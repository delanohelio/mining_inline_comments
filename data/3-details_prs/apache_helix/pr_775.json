{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NDUyNjk0", "number": 775, "title": "Add HttpRoutingDataReader", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nResolves #774\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nHttpRoutingDataReader is a component used by new ZkClient APIs to make an HTTP read request to the metadata store directory service to retrieve routing data. ZkClient APIs will construct an internal MetadataStoreRoutingData instance based on the raw routing data retrieved from MSDS.\nNote: this change contains modifications to MockMSDS because the actual endpoint names changed. The methods and http server contexts have been updated.\nTests\n\n The following tests are written for this issue:\n\nTestHttpRoutingDataReader\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nzookeeper-api\n\n[INFO]  T E S T S\n[INFO] -------------------------------------------------------\n[INFO] Running TestSuite\n[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.429 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  7.497 s\n[INFO] Finished at: 2020-02-22T17:59:33-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-18T07:09:51Z", "url": "https://github.com/apache/helix/pull/775", "merged": true, "mergeCommit": {"oid": "33e7ad3f2ee76de8803cf17b7e071057aa9cf786"}, "closed": true, "closedAt": "2020-02-25T22:45:29Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFram2gFqTM2MDc2MTU5NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcH4EwjAH2gAyMzc2NDUyNjk0OmJlMTc4NjlkOWU2YTkxNzgxODhkYmY3ZjhjYzk2MTE5NzI0NTNhNDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzYxNTk0", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-360761594", "createdAt": "2020-02-19T00:05:17Z", "commit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMDowNToxN1rOFrW4hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMDozMDowN1rOFrXTMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwODAwNg==", "bodyText": "Nit, wrap long line.", "url": "https://github.com/apache/helix/pull/775#discussion_r381008006", "createdAt": "2020-02-19T00:05:17Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of \"metadata store sharding keys\", where the sharding keys in a value list all route to the realm address in the key disallows a meaningful mapping to be returned", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxNDgzMg==", "bodyText": "Since this is a blocking IO, my thought is it may add more time for zkclient init/creation. Would it help if the request is async while creating a new zkclient?\nDo we need to consider timeout for this request?", "url": "https://github.com/apache/helix/pull/775#discussion_r381014832", "createdAt": "2020-02-19T00:30:07Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of \"metadata store sharding keys\", where the sharding keys in a value list all route to the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRoutingData(String msdsEndpoint) {\n+\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+\n+    HttpGet requestAllRealmNames =\n+        new HttpGet(msdsEndpoint); //TODO: construct an endpoint once REST endpoint is finalized\n+    try (CloseableHttpClient httpClient = HttpClients.createDefault();\n+        CloseableHttpResponse response = httpClient.execute(requestAllRealmNames)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjc1MDk4", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-362275098", "createdAt": "2020-02-20T22:17:51Z", "commit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxNzo1MVrOFslGUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxNzo1MVrOFslGUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4OTQ4OA==", "bodyText": "Is that possible to have comment module to hold these http related functions in general? I do see these kind of operations here and there in different modules.", "url": "https://github.com/apache/helix/pull/775#discussion_r382289488", "createdAt": "2020-02-20T22:17:51Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzEyNDg4", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-362312488", "createdAt": "2020-02-20T23:37:23Z", "commit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNzoyM1rOFsm9Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNzoyM1rOFsm9Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTg5MA==", "bodyText": "The application config should provide (via system property) the namespace of endpoint. This is the input to construct msdsEndpoint.\nThis construction logic should be outside this class?  Or we want to put it inside this class?", "url": "https://github.com/apache/helix/pull/775#discussion_r382319890", "createdAt": "2020-02-20T23:37:23Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of \"metadata store sharding keys\", where the sharding keys in a value list all route to the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRoutingData(String msdsEndpoint) {\n+\n+    Map<String, List<String>> rawRoutingData = new HashMap<>();\n+\n+    HttpGet requestAllRealmNames =\n+        new HttpGet(msdsEndpoint); //TODO: construct an endpoint once REST endpoint is finalized", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f"}, "originalPosition": 55}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ef735e462755a38b5f2ca53416e6dd3abd1935f", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/6ef735e462755a38b5f2ca53416e6dd3abd1935f", "committedDate": "2020-02-18T07:07:39Z", "message": "WIP: Add HttpRoutingDataReader\n\nHttpRoutingDataReader is a component used by new ZkClient APIs to make an HTTP read request to the metadata store directory service to retrieve routing data. ZkClient APIs will construct an internal MetadataStoreRoutingData instance based on the raw routing data retrieved from MSDS."}, "afterCommit": {"oid": "0da52012d34b651e48df98e9b68b204a5266bf90", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/0da52012d34b651e48df98e9b68b204a5266bf90", "committedDate": "2020-02-21T01:33:45Z", "message": "sadf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "137f163f2e312858b7d4f145831a9221d32e8121", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/137f163f2e312858b7d4f145831a9221d32e8121", "committedDate": "2020-02-24T02:24:26Z", "message": "WIP: Add HttpRoutingDataReader\n\nHttpRoutingDataReader is a component used by new ZkClient APIs to make an HTTP read request to the metadata store directory service to retrieve routing data. ZkClient APIs will construct an internal MetadataStoreRoutingData instance based on the raw routing data retrieved from MSDS."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34be4ac2b66daa0e77326a2ab0d1fee7a489ee2c", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/34be4ac2b66daa0e77326a2ab0d1fee7a489ee2c", "committedDate": "2020-02-24T02:26:08Z", "message": "sadf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163e0d6b0c7eebe01e9f4789b5777f8589585b8a", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/163e0d6b0c7eebe01e9f4789b5777f8589585b8a", "committedDate": "2020-02-24T02:26:08Z", "message": "asdf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fcb234be227687656bbbee3ab7af683be89b5e9", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/3fcb234be227687656bbbee3ab7af683be89b5e9", "committedDate": "2020-02-24T02:26:08Z", "message": "finish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50bd3537673a4e9233c12e19dd9652d6cef18eac", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/50bd3537673a4e9233c12e19dd9652d6cef18eac", "committedDate": "2020-02-24T02:26:08Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f759d6366cdb267b85a5c8ed421c9ddd89fac3", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/17f759d6366cdb267b85a5c8ed421c9ddd89fac3", "committedDate": "2020-02-24T02:26:08Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb7364cb4365289c5de9b3866ca73dc6eeb961ad", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/fb7364cb4365289c5de9b3866ca73dc6eeb961ad", "committedDate": "2020-02-24T02:26:08Z", "message": "javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c8bf71db4b8b314cf0d235c04a34a5f4c74d848", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/8c8bf71db4b8b314cf0d235c04a34a5f4c74d848", "committedDate": "2020-02-24T02:26:08Z", "message": "FSAD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "535d328d2b6bccbf6bf4e8620cbf7e2a9cdf5dbe", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/535d328d2b6bccbf6bf4e8620cbf7e2a9cdf5dbe", "committedDate": "2020-02-24T02:26:08Z", "message": "SADf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d551119f141662b751cdf8e3abb9a5c0f6724fc4", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/d551119f141662b751cdf8e3abb9a5c0f6724fc4", "committedDate": "2020-02-24T06:08:37Z", "message": "Change endpoint"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d9602485e4d17499ed4fa8483c11573ae22e9b79", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/d9602485e4d17499ed4fa8483c11573ae22e9b79", "committedDate": "2020-02-23T02:05:27Z", "message": "SADf"}, "afterCommit": {"oid": "d551119f141662b751cdf8e3abb9a5c0f6724fc4", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/d551119f141662b751cdf8e3abb9a5c0f6724fc4", "committedDate": "2020-02-24T06:08:37Z", "message": "Change endpoint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjAwMTQ3", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363200147", "createdAt": "2020-02-24T07:27:11Z", "commit": {"oid": "d551119f141662b751cdf8e3abb9a5c0f6724fc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNzoyNzoxMVrOFtXSrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNzoyNzoxMVrOFtXSrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzExMTg1Mw==", "bodyText": "Endpoint path is incorrect. You may want \u201crouting-data\u201d", "url": "https://github.com/apache/helix/pull/775#discussion_r383111853", "createdAt": "2020-02-24T07:27:11Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @param httpClient\n+   * @param msdsEndpoint\n+   * @return\n+   * @throws IOException\n+   */\n+  private static Map<String, List<String>> getAllRoutingData(CloseableHttpClient httpClient,\n+      String msdsEndpoint)\n+      throws IOException {\n+    HttpGet requestAllData =\n+        new HttpGet(msdsEndpoint + \"/\" + MetadataStoreRoutingConstants.ROUTING_DATA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d551119f141662b751cdf8e3abb9a5c0f6724fc4"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/0780818b1c0a28e595523373e7bae249f6a7c900", "committedDate": "2020-02-24T16:44:09Z", "message": "update endpoint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjAyMDEx", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363602011", "createdAt": "2020-02-24T18:24:40Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoyNDo0MFrOFtq_Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoyNDo0MFrOFtq_Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNDU4Ng==", "bodyText": "What is this RetryOnFailture notation? My understanding of this part is kind of weak. More important, what does this buy for us?", "url": "https://github.com/apache/helix/pull/775#discussion_r383434586", "createdAt": "2020-02-24T18:24:40Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjA1Njgx", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363605681", "createdAt": "2020-02-24T18:30:23Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozMDoyM1rOFtrLEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozMDoyM1rOFtrLEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNzU4Ng==", "bodyText": "will httpCient.execute throw other exceptions aside from IOException?", "url": "https://github.com/apache/helix/pull/775#discussion_r383437586", "createdAt": "2020-02-24T18:30:23Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @param httpClient\n+   * @param msdsEndpoint\n+   * @return\n+   * @throws IOException\n+   */\n+  private static Map<String, List<String>> getAllRoutingData(CloseableHttpClient httpClient,\n+      String msdsEndpoint)\n+      throws IOException {\n+    HttpGet requestAllData = new HttpGet(\n+        msdsEndpoint + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    CloseableHttpResponse response = httpClient.execute(requestAllData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjA3MzQ4", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363607348", "createdAt": "2020-02-24T18:33:02Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozMzowMlrOFtrQdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozMzowMlrOFtrQdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzODk2NA==", "bodyText": "Why this is a public API? Do we intend to provide this one outside users? Is there such a case?", "url": "https://github.com/apache/helix/pull/775#discussion_r383438964", "createdAt": "2020-02-24T18:33:02Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjExMDgw", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363611080", "createdAt": "2020-02-24T18:39:00Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozOTowMFrOFtrcNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozOTowMFrOFtrcNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTk3Mg==", "bodyText": "Here, getRawRoutingData would throw illegalStateException which is unchecked. Think you are a user, how do you plan to handle this one? Also, IOException, and InvalidRoutingDataException?\nOr do we really want user to handle these exceptions?\nIt seems to me the user only need to understand that 1/ configuration issue 2/ MSDS for some reason not working.\nSo they can either change the code or trouble shoot for communication issues to MSDS", "url": "https://github.com/apache/helix/pull/775#discussion_r383441972", "createdAt": "2020-02-24T18:39:00Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjExOTI4", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363611928", "createdAt": "2020-02-24T18:40:23Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODo0MDoyM1rOFtre9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODo0MDoyM1rOFtre9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjY3OA==", "bodyText": "This close can be leaked. use try, catch? so simply let getAllRoutingData handle this httpclient creation.", "url": "https://github.com/apache/helix/pull/775#discussion_r383442678", "createdAt": "2020-02-24T18:40:23Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjIwNTY5", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363620569", "createdAt": "2020-02-24T18:54:04Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODo1NDowNFrOFtr6gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODo1NDowNFrOFtr6gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0OTcyOQ==", "bodyText": "Suggest you add a comment as why use volatile here. https://en.wikipedia.org/wiki/Double-checked_locking. Otherwise, later people changing the code may remove them.", "url": "https://github.com/apache/helix/pull/775#discussion_r383449729", "createdAt": "2020-02-24T18:54:04Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjAxODE0", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363601814", "createdAt": "2020-02-24T18:24:21Z", "commit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoyNDoyMVrOFtq-rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODo1ODoyMFrOFtsDEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNDQxMw==", "bodyText": "What is the benefit of introducing new lib: jcabi. I think HttpClients' already provides retry mechanism: HttpRequestInterceptor or setRetryHandler(new DefaultHttpRequestRetryHandler())", "url": "https://github.com/apache/helix/pull/775#discussion_r383434413", "createdAt": "2020-02-24T18:24:21Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTk2OA==", "bodyText": "I am considering setting this in constructor. At least we can move it out of synchronized block.", "url": "https://github.com/apache/helix/pull/775#discussion_r383441968", "createdAt": "2020-02-24T18:39:00Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MzA3Mg==", "bodyText": "@RetryOnFailure is applied to this whole method. It seems we are going to call this reader each time we create a RealmAwareZkClient? The heavy work is one the first time we call to get routing data.\nI would use HttpClients' retry so we don't have to acquire lock and create HttpClient 3 times (a bit heavier) if attempting. Instead, http client could just retry on exception within the locking block, which I think is easier.\nAnd one more benefit is we could use try-with-resource and auto close httpClient.\nWhat do you think?\nWhen is reader supposed to be created, each time when creating zkClient, or a singleton is maintained ?", "url": "https://github.com/apache/helix/pull/775#discussion_r383443072", "createdAt": "2020-02-24T18:41:09Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MTkyMw==", "bodyText": "Maybe I would decouple fetch http json response and parse json to map:\n\nresponse = httpClient.execute(routing-data-endpoint) // Easier to just retry and timeout http request.\nMap<String, List<>> parseRoutingData(response) {}", "url": "https://github.com/apache/helix/pull/775#discussion_r383451923", "createdAt": "2020-02-24T18:58:20Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import com.jcabi.aspects.RetryOnFailure;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+import org.codehaus.jackson.map.ObjectMapper;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  @RetryOnFailure(attempts = 3, delay = 1, unit = TimeUnit.SECONDS)\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          String msdsEndpoint =\n+              System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+          if (msdsEndpoint == null || msdsEndpoint.isEmpty()) {\n+            throw new IllegalStateException(\n+                \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+          }\n+\n+          // Note: HttpClient's timeout settings are system timeout settings by default\n+          CloseableHttpClient httpClient = HttpClients.createDefault();\n+          // Update the reference\n+          _rawRoutingData = getAllRoutingData(httpClient, msdsEndpoint);\n+          // Close any open resources\n+          httpClient.close();\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @param httpClient\n+   * @param msdsEndpoint\n+   * @return\n+   * @throws IOException\n+   */\n+  private static Map<String, List<String>> getAllRoutingData(CloseableHttpClient httpClient,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0780818b1c0a28e595523373e7bae249f6a7c900"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c130620a404292554d67a989bca47736f67278f0", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/c130620a404292554d67a989bca47736f67278f0", "committedDate": "2020-02-25T03:21:25Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODY0NDkw", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363864490", "createdAt": "2020-02-25T04:31:25Z", "commit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNDozMToyNVrOFt4V6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNTo0Mjo0N1rOFt5SqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MzM1Mg==", "bodyText": "Can we make the versions consistent and most recent if possible?", "url": "https://github.com/apache/helix/pull/775#discussion_r383653352", "createdAt": "2020-02-25T04:31:25Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/pom.xml", "diffHunk": "@@ -59,6 +59,11 @@ under the License.\n         </exclusion>\n       </exclusions>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.11</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Mzg3NQ==", "bodyText": "Nit, we had a change for helix style IntelliJ. With the new change, this line should not be wrapped. Can you update your style and format it?", "url": "https://github.com/apache/helix/pull/775#discussion_r383653875", "createdAt": "2020-02-25T04:34:01Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass()\n+      throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData()\n+      throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MzkyNQ==", "bodyText": "Consistent version.", "url": "https://github.com/apache/helix/pull/775#discussion_r383653925", "createdAt": "2020-02-25T04:34:19Z", "author": {"login": "huizhilu"}, "path": "metadata-store-directory-common/pom.xml", "diffHunk": "@@ -43,6 +43,11 @@ under the License.\n   </properties>\n \n   <dependencies>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.8</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Njg0Nw==", "bodyText": "Just a question: Do we need to set encoding like UTF-8 ? As jersey uses UTF-8 by default, while EntityUtils.toString uses \"ISO-8859-1\" if encoding is not set is header. Maybe just need to confirm at least our rest server includes \"UTF-8\" in header.", "url": "https://github.com/apache/helix/pull/775#discussion_r383656847", "createdAt": "2020-02-25T04:48:14Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData()\n+      throws IOException {\n+    // Retry count is 3 by default\n+    HttpGet requestAllData = new HttpGet(\n+        MSDS_ENDPOINT + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    try (CloseableHttpClient httpClient = HttpClients.custom()\n+        .setConnectionBackoffStrategy(new DefaultBackoffStrategy())\n+        .setRetryHandler(new DefaultHttpRequestRetryHandler()).build()) {\n+      return httpClient.execute(requestAllData);\n+    }\n+  }\n+\n+  /**\n+   * Returns the raw routing data in a Map< ZkRealm, List of shardingKeys > format.\n+   * @param routingDataResponse\n+   * @return\n+   */\n+  private static Map<String, List<String>> parseRoutingData(\n+      CloseableHttpResponse routingDataResponse)\n+      throws IOException {\n+    HttpEntity entity = routingDataResponse.getEntity();\n+    if (entity != null) {\n+      String resultStr = EntityUtils.toString(entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODkwNA==", "bodyText": "I don't see a timeout setting. If we don't set timeout, it may use system defined timeout or infinite timeout. To make the system responsive and stable, are we considering timeout: connectTimeout, socketTimeout, etc.?", "url": "https://github.com/apache/helix/pull/775#discussion_r383668904", "createdAt": "2020-02-25T05:42:47Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData()\n+      throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData()\n+      throws IOException {\n+    // Retry count is 3 by default\n+    HttpGet requestAllData = new HttpGet(\n+        MSDS_ENDPOINT + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+    try (CloseableHttpClient httpClient = HttpClients.custom()\n+        .setConnectionBackoffStrategy(new DefaultBackoffStrategy())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzOTE4NTc3", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-363918577", "createdAt": "2020-02-25T07:31:09Z", "commit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNzozMToxMFrOFt7KtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNzozMToxMFrOFt7KtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5OTYzNw==", "bodyText": "Minor as it is a test: maybe we would use try...finally to close the server and client, in case exception or assertion fails and server is still running?", "url": "https://github.com/apache/helix/pull/775#discussion_r383699637", "createdAt": "2020-02-25T07:31:10Z", "author": {"login": "huizhilu"}, "path": "metadata-store-directory-common/src/test/java/org/apache/helix/msdcommon/mock/TestMockMetadataStoreDirectoryServer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.msdcommon.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.junit.Test;\n+import org.testng.Assert;\n+\n+\n+public class TestMockMetadataStoreDirectoryServer {\n+  @Test\n+  public void testMockMetadataStoreDirectoryServer()\n+      throws IOException {\n+    // Create fake routing data\n+    Map<String, Collection<String>> routingData = new HashMap<>();\n+    routingData.put(\"zk-0\", ImmutableList.of(\"sharding-key-0\", \"sharding-key-1\", \"sharding-key-2\"));\n+    routingData.put(\"zk-1\", ImmutableList.of(\"sharding-key-3\", \"sharding-key-4\", \"sharding-key-5\"));\n+    routingData.put(\"zk-2\", ImmutableList.of(\"sharding-key-6\", \"sharding-key-7\", \"sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    String host = \"localhost\";\n+    int port = 11000;\n+    String endpoint = \"http://\" + host + \":\" + port;\n+    String namespace = \"MY-HELIX-NAMESPACE\";\n+    MockMetadataStoreDirectoryServer server =\n+        new MockMetadataStoreDirectoryServer(host, port, namespace, routingData);\n+    server.startServer();\n+    CloseableHttpClient httpClient = HttpClients.createDefault();\n+\n+    // Send a GET request for all routing data\n+    HttpGet getRequest = new HttpGet(\n+        endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+            + MetadataStoreRoutingConstants.MSDS_GET_ALL_ROUTING_DATA_ENDPOINT);\n+\n+    CloseableHttpResponse getResponse = httpClient.execute(getRequest);\n+    Map<String, Object> resultMap = MockMetadataStoreDirectoryServer.OBJECT_MAPPER\n+        .readValue(getResponse.getEntity().getContent(), Map.class);\n+    List<Map<String, Object>> routingDataList =\n+        (List<Map<String, Object>>) resultMap.get(MetadataStoreRoutingConstants.ROUTING_DATA);\n+    Collection<String> allRealms = routingDataList.stream().map(mapEntry -> (String) mapEntry\n+        .get(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM))\n+        .collect(Collectors.toSet());\n+    Assert.assertEquals(allRealms, routingData.keySet());\n+    Map<String, List<String>> retrievedRoutingData = routingDataList.stream().collect(Collectors\n+        .toMap(mapEntry -> (String) mapEntry\n+                .get(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM),\n+            mapEntry -> (List<String>) mapEntry.get(MetadataStoreRoutingConstants.SHARDING_KEYS)));\n+    Assert.assertEquals(retrievedRoutingData, routingData);\n+\n+    // Send a GET request for all realms\n+    getRequest = new HttpGet(endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+        + MockMetadataStoreDirectoryServer.ZK_REALM_ENDPOINT);\n+    getResponse = httpClient.execute(getRequest);\n+    Map<String, Collection<String>> allRealmsMap = MockMetadataStoreDirectoryServer.OBJECT_MAPPER\n+        .readValue(getResponse.getEntity().getContent(), Map.class);\n+    Assert\n+        .assertTrue(allRealmsMap.containsKey(MetadataStoreRoutingConstants.METADATA_STORE_REALMS));\n+    allRealms = allRealmsMap.get(MetadataStoreRoutingConstants.METADATA_STORE_REALMS);\n+    Assert.assertEquals(allRealms, routingData.keySet());\n+\n+    // Send a GET request for testZkRealm\n+    String testZkRealm = \"zk-0\";\n+    getRequest = new HttpGet(endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+        + MockMetadataStoreDirectoryServer.ZK_REALM_ENDPOINT + \"/\" + testZkRealm);\n+    getResponse = httpClient.execute(getRequest);\n+    Map<String, Object> shardingKeysMap = MockMetadataStoreDirectoryServer.OBJECT_MAPPER\n+        .readValue(getResponse.getEntity().getContent(), Map.class);\n+    Assert.assertTrue(\n+        shardingKeysMap.containsKey(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM));\n+    Assert.assertTrue(shardingKeysMap.containsKey(MetadataStoreRoutingConstants.SHARDING_KEYS));\n+    String zkRealm =\n+        (String) shardingKeysMap.get(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM);\n+    Collection<String> shardingKeyList =\n+        (Collection) shardingKeysMap.get(MetadataStoreRoutingConstants.SHARDING_KEYS);\n+    Assert.assertEquals(zkRealm, testZkRealm);\n+    Assert.assertEquals(shardingKeyList, routingData.get(testZkRealm));\n+\n+    // Try sending a POST request (not supported)\n+    HttpPost postRequest = new HttpPost(\n+        endpoint + MockMetadataStoreDirectoryServer.REST_PREFIX + namespace\n+            + MockMetadataStoreDirectoryServer.ZK_REALM_ENDPOINT + \"/\" + testZkRealm);\n+    CloseableHttpResponse postResponse = httpClient.execute(postRequest);\n+\n+    // Shutdown\n+    server.stopServer();\n+    httpClient.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c130620a404292554d67a989bca47736f67278f0"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/c09373c36acec7044b9a378d230e6a44e828582b", "committedDate": "2020-02-25T08:22:54Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzI2MjQz", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-364326243", "createdAt": "2020-02-25T17:42:50Z", "commit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNzo0Mjo1MVrOFuPNbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1NzoxMVrOFuRMBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyODAxNA==", "bodyText": "Nit, maybe start server before try?", "url": "https://github.com/apache/helix/pull/775#discussion_r384028014", "createdAt": "2020-02-25T17:42:51Z", "author": {"login": "huizhilu"}, "path": "metadata-store-directory-common/src/test/java/org/apache/helix/msdcommon/mock/TestMockMetadataStoreDirectoryServer.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package org.apache.helix.msdcommon.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.junit.Test;\n+import org.testng.Assert;\n+\n+\n+public class TestMockMetadataStoreDirectoryServer {\n+  @Test\n+  public void testMockMetadataStoreDirectoryServer() throws IOException {\n+    // Create fake routing data\n+    Map<String, Collection<String>> routingData = new HashMap<>();\n+    routingData.put(\"zk-0\", ImmutableList.of(\"sharding-key-0\", \"sharding-key-1\", \"sharding-key-2\"));\n+    routingData.put(\"zk-1\", ImmutableList.of(\"sharding-key-3\", \"sharding-key-4\", \"sharding-key-5\"));\n+    routingData.put(\"zk-2\", ImmutableList.of(\"sharding-key-6\", \"sharding-key-7\", \"sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    String host = \"localhost\";\n+    int port = 11000;\n+    String endpoint = \"http://\" + host + \":\" + port;\n+    String namespace = \"MY-HELIX-NAMESPACE\";\n+\n+    MockMetadataStoreDirectoryServer server =\n+        new MockMetadataStoreDirectoryServer(host, port, namespace, routingData);\n+    try (CloseableHttpClient httpClient = HttpClients.createDefault()) {\n+      server.startServer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MjkzOA==", "bodyText": "Can Assert correctly check a list and a collection (a set instance) ? I doubt it.", "url": "https://github.com/apache/helix/pull/775#discussion_r384042938", "createdAt": "2020-02-25T18:25:56Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass() throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData() throws IOException {\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    _testRawRoutingData\n+        .forEach((realm, keys) -> Assert.assertEquals(rawRoutingData.get(realm), keys));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NzUzMg==", "bodyText": "What do you mean here? My understanding is, if neither set is null, Assert could check them, regardless ordering of elements: set[\"a\", \"b\", \"c\"], set[\"c\", \"b\", \"a\"] should be equal. What is the case they are not equal: \"if the ordering of elements is not equal\"?", "url": "https://github.com/apache/helix/pull/775#discussion_r384047532", "createdAt": "2020-02-25T18:34:17Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass() throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData() throws IOException {\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    _testRawRoutingData\n+        .forEach((realm, keys) -> Assert.assertEquals(rawRoutingData.get(realm), keys));\n+  }\n+\n+  @Test(dependsOnMethods = \"testGetRawRoutingData\")\n+  public void testGetMetadataStoreRoutingData() throws IOException, InvalidRoutingDataException {\n+    MetadataStoreRoutingData data = HttpRoutingDataReader.getMetadataStoreRoutingData();\n+    Map<String, String> allMappings = data.getAllMappingUnderPath(\"/\");\n+    Map<String, Set<String>> groupedMappings = allMappings.entrySet().stream().collect(Collectors\n+        .groupingBy(Map.Entry::getValue,\n+            Collectors.mapping(Map.Entry::getKey, Collectors.toSet())));\n+    _testRawRoutingData.forEach((realm, keys) -> {\n+      // Two way containsAll because AssertEquals on two set collections is buggy in that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MDQyMQ==", "bodyText": "If you say \"should still return old data because it's static\", I think it is important to check we could still check the old data is actually returned. assert rawRoutingData equals to _rawRoutingData?", "url": "https://github.com/apache/helix/pull/775#discussion_r384060421", "createdAt": "2020-02-25T18:57:11Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/util/TestHttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.ImmutableSet;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.impl.ZkTestBase;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestHttpRoutingDataReader extends ZkTestBase {\n+  private MockMetadataStoreDirectoryServer _msdsServer;\n+  private Map<String, Collection<String>> _testRawRoutingData;\n+  private final String _host = \"localhost\";\n+  private final int _port = 1991;\n+  private final String _namespace = \"TestHttpRoutingDataReader\";\n+\n+  @BeforeClass\n+  public void beforeClass() throws IOException {\n+    // Create fake routing data\n+    _testRawRoutingData = new HashMap<>();\n+    _testRawRoutingData\n+        .put(\"zk-0\", ImmutableSet.of(\"/sharding-key-0\", \"/sharding-key-1\", \"/sharding-key-2\"));\n+    _testRawRoutingData\n+        .put(\"zk-1\", ImmutableSet.of(\"/sharding-key-3\", \"/sharding-key-4\", \"/sharding-key-5\"));\n+    _testRawRoutingData\n+        .put(\"zk-2\", ImmutableSet.of(\"/sharding-key-6\", \"/sharding-key-7\", \"/sharding-key-8\"));\n+\n+    // Start MockMSDS\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // Register the endpoint as a System property\n+    String msdsEndpoint = \"http://\" + _host + \":\" + _port + \"/admin/v2/namespaces/\" + _namespace;\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY, msdsEndpoint);\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _msdsServer.stopServer();\n+  }\n+\n+  @Test\n+  public void testGetRawRoutingData() throws IOException {\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    _testRawRoutingData\n+        .forEach((realm, keys) -> Assert.assertEquals(rawRoutingData.get(realm), keys));\n+  }\n+\n+  @Test(dependsOnMethods = \"testGetRawRoutingData\")\n+  public void testGetMetadataStoreRoutingData() throws IOException, InvalidRoutingDataException {\n+    MetadataStoreRoutingData data = HttpRoutingDataReader.getMetadataStoreRoutingData();\n+    Map<String, String> allMappings = data.getAllMappingUnderPath(\"/\");\n+    Map<String, Set<String>> groupedMappings = allMappings.entrySet().stream().collect(Collectors\n+        .groupingBy(Map.Entry::getValue,\n+            Collectors.mapping(Map.Entry::getKey, Collectors.toSet())));\n+    _testRawRoutingData.forEach((realm, keys) -> {\n+      // Two way containsAll because AssertEquals on two set collections is buggy in that\n+      // it will fail if the ordering of elements is not equal (we just want to compare contents)\n+      Assert.assertTrue(groupedMappings.get(realm).containsAll(keys));\n+      Assert.assertTrue(keys.containsAll(groupedMappings.get(realm)));\n+    });\n+  }\n+\n+  /**\n+   * Test that the static methods in HttpRoutingDataReader returns consistent results even though MSDS's data have been updated.\n+   */\n+  @Test(dependsOnMethods = \"testGetMetadataStoreRoutingData\")\n+  public void testStaticMapping() throws IOException, InvalidRoutingDataException {\n+    // Modify routing data\n+    String newRealm = \"newRealm\";\n+    _testRawRoutingData.put(newRealm, ImmutableSet.of(\"/newKey\"));\n+\n+    // Kill MSDS and restart with a new mapping\n+    _msdsServer.stopServer();\n+    _msdsServer =\n+        new MockMetadataStoreDirectoryServer(_host, _port, _namespace, _testRawRoutingData);\n+    _msdsServer.startServer();\n+\n+    // HttpRoutingDataReader should still return old data because it's static\n+    // Make sure the results don't contain the new realm\n+    Map<String, List<String>> rawRoutingData = HttpRoutingDataReader.getRawRoutingData();\n+    Assert.assertFalse(rawRoutingData.containsKey(newRealm));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzY4MDM2", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-364368036", "createdAt": "2020-02-25T18:59:22Z", "commit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1OToyMlrOFuRQ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1OToyMlrOFuRQ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MTY2MA==", "bodyText": "Where is retry count set? Also, shall we make the retry count configurable? I think configurable can be good idea. 3 still seems to me not very safe. If this part not working well, the whole cluster may not bootup.", "url": "https://github.com/apache/helix/pull/775#discussion_r384061660", "createdAt": "2020-02-25T18:59:22Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData() throws IOException {\n+    // Retry count is 3 by default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzcxNDU3", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-364371457", "createdAt": "2020-02-25T19:04:21Z", "commit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowNDoyMVrOFuRbuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowNDoyMVrOFuRbuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDQ0MA==", "bodyText": "_parseRoutingData can return an empty map. Then the empty map can be return to user.  This is basically telling user we find nothing. This is error condition.\nIf we make this method public, we should let user know this error condition by throwing exception.", "url": "https://github.com/apache/helix/pull/775#discussion_r384064440", "createdAt": "2020-02-25T19:04:21Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzczMDgz", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-364373083", "createdAt": "2020-02-25T19:06:46Z", "commit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowNjo0NlrOFuRgiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTowNjo0NlrOFuRgiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTY3Mw==", "bodyText": "I did not examine the TrieRoutingData implementation. Can we make sure _metaDataStoreRoutingData will not be empty map after this line?\nThis is important. Otherwise, with empty map, you are not going to retry getRawRoutingData. The result is disaster then.", "url": "https://github.com/apache/helix/pull/775#discussion_r384065673", "createdAt": "2020-02-25T19:06:46Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0Mzc2ODQy", "url": "https://github.com/apache/helix/pull/775#pullrequestreview-364376842", "createdAt": "2020-02-25T19:12:29Z", "commit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxMjozMFrOFuRr8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxMjozMFrOFuRr8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2ODU5NQ==", "bodyText": "Let us add a comment here.\nWe avoid this point to be SPOF by relying on VIP LB and retry mechanism. This dependency is important. We may revisit this dependency assumption later.", "url": "https://github.com/apache/helix/pull/775#discussion_r384068595", "createdAt": "2020-02-25T19:12:30Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/util/HttpRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.apache.helix.zookeeper.util;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultBackoffStrategy;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.util.EntityUtils;\n+\n+\n+public class HttpRoutingDataReader {\n+  private static final String MSDS_ENDPOINT =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+  private static final int HTTP_TIMEOUT_IN_MS = 5000;\n+\n+  /** Double-checked locking requires that the following fields be volatile */\n+  private static volatile Map<String, List<String>> _rawRoutingData;\n+  private static volatile MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private HttpRoutingDataReader() {\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned\n+   */\n+  public static Map<String, List<String>> getRawRoutingData() throws IOException {\n+    if (MSDS_ENDPOINT == null || MSDS_ENDPOINT.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System Properties!\");\n+    }\n+    if (_rawRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_rawRoutingData == null) {\n+          CloseableHttpResponse routingDataResponse = getAllRoutingData();\n+          // Update the reference if reading routingData over HTTP is successful\n+          _rawRoutingData = parseRoutingData(routingDataResponse);\n+        }\n+      }\n+    }\n+    return _rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format.\n+   * @return\n+   * @throws IOException if there is an issue connecting to MSDS\n+   * @throws InvalidRoutingDataException if the raw routing data is not valid\n+   */\n+  public static MetadataStoreRoutingData getMetadataStoreRoutingData()\n+      throws IOException, InvalidRoutingDataException {\n+    if (_metadataStoreRoutingData == null) {\n+      synchronized (HttpRoutingDataReader.class) {\n+        if (_metadataStoreRoutingData == null) {\n+          _metadataStoreRoutingData = new TrieRoutingData(getRawRoutingData());\n+        }\n+      }\n+    }\n+    return _metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Makes an HTTP call to fetch all routing data.\n+   * @return\n+   * @throws IOException\n+   */\n+  private static CloseableHttpResponse getAllRoutingData() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09373c36acec7044b9a378d230e6a44e828582b"}, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "540ca738c0474772d74c5e9c0c568a1f5c82d50c", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/540ca738c0474772d74c5e9c0c568a1f5c82d50c", "committedDate": "2020-02-25T19:39:53Z", "message": "asdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e348f4ce3efc1e8d2d9d10fd10f498cb321ea0b", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/0e348f4ce3efc1e8d2d9d10fd10f498cb321ea0b", "committedDate": "2020-02-25T20:14:32Z", "message": "update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be17869d9e6a9178188dbf7f8cc9611972453a40", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/be17869d9e6a9178188dbf7f8cc9611972453a40", "committedDate": "2020-02-25T20:23:26Z", "message": "up"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4980, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}