{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMTQ5ODE0", "number": 1489, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMzowOFrOEy-6cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMToxNzo1OVrOEzD2_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODk1MDI2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxMzowOFrOHp7p-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxNToxNVrOHp7uvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMTA2NQ==", "bodyText": "All the above changes seems to be non-essential change, right?", "url": "https://github.com/apache/helix/pull/1489#discussion_r513731065", "createdAt": "2020-10-28T20:13:08Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -192,43 +191,38 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n   @Override\n   public void registerMessageHandlerFactory(String type, MessageHandlerFactory factory,\n       int threadpoolSize) {\n-    if (factory instanceof  MultiTypeMessageHandlerFactory) {\n+    if (factory instanceof MultiTypeMessageHandlerFactory) {\n       if (!((MultiTypeMessageHandlerFactory) factory).getMessageTypes().contains(type)) {\n         throw new HelixException(\"Message factory type mismatch. Type: \" + type + \", factory: \"\n             + ((MultiTypeMessageHandlerFactory) factory).getMessageTypes());\n       }\n     } else {\n       if (!factory.getMessageType().equals(type)) {\n         throw new HelixException(\n-            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory.getMessageType());\n+            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory\n+                .getMessageType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMjI4Nw==", "bodyText": "This PR is all about non-essential changes that are the preparation for the real business logic changes later.\nNon-essential does not mean we are not going to do it.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513732287", "createdAt": "2020-10-28T20:15:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -192,43 +191,38 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n   @Override\n   public void registerMessageHandlerFactory(String type, MessageHandlerFactory factory,\n       int threadpoolSize) {\n-    if (factory instanceof  MultiTypeMessageHandlerFactory) {\n+    if (factory instanceof MultiTypeMessageHandlerFactory) {\n       if (!((MultiTypeMessageHandlerFactory) factory).getMessageTypes().contains(type)) {\n         throw new HelixException(\"Message factory type mismatch. Type: \" + type + \", factory: \"\n             + ((MultiTypeMessageHandlerFactory) factory).getMessageTypes());\n       }\n     } else {\n       if (!factory.getMessageType().equals(type)) {\n         throw new HelixException(\n-            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory.getMessageType());\n+            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory\n+                .getMessageType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMTA2NQ=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTI4ODM1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTo1MDowNlrOHp-1AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjo1NDo1MVrOHqAcVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4MzA0MA==", "bodyText": "We can use putIfAbsent since we are not using the return value anymore here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513783040", "createdAt": "2020-10-28T21:50:06Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -192,43 +191,38 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n   @Override\n   public void registerMessageHandlerFactory(String type, MessageHandlerFactory factory,\n       int threadpoolSize) {\n-    if (factory instanceof  MultiTypeMessageHandlerFactory) {\n+    if (factory instanceof MultiTypeMessageHandlerFactory) {\n       if (!((MultiTypeMessageHandlerFactory) factory).getMessageTypes().contains(type)) {\n         throw new HelixException(\"Message factory type mismatch. Type: \" + type + \", factory: \"\n             + ((MultiTypeMessageHandlerFactory) factory).getMessageTypes());\n       }\n     } else {\n       if (!factory.getMessageType().equals(type)) {\n         throw new HelixException(\n-            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory.getMessageType());\n+            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory\n+                .getMessageType());\n       }\n     }\n \n     _isShuttingDown = false;\n \n-    MsgHandlerFactoryRegistryItem newItem = new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n+    MsgHandlerFactoryRegistryItem newItem =\n+        new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n     MsgHandlerFactoryRegistryItem prevItem = _hdlrFtyRegistry.putIfAbsent(type, newItem);\n     if (prevItem == null) {\n-      ExecutorService newPool = Executors.newFixedThreadPool(threadpoolSize, new ThreadFactory() {\n-        @Override public Thread newThread(Runnable r) {\n-          return new Thread(r, \"HelixTaskExecutor-message_handle_thread_\" + thread_uid.getAndIncrement());\n-        }\n-      });\n-      ExecutorService prevExecutor = _executorMap.putIfAbsent(type, newPool);\n-      if (prevExecutor != null) {\n-        LOG.warn(\"Skip creating a new thread pool for type: \" + type + \", already existing pool: \"\n-            + prevExecutor + \", isShutdown: \" + prevExecutor.isShutdown());\n-        newPool.shutdown();\n-        newPool = null;\n-      } else {\n+      _executorMap.computeIfAbsent(type, msgType -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwOTQ5NA==", "bodyText": "putIfAbsent is not good since you will need to create the new pool, check, then close the new pool if there is already an existing one.\nThis is what I optimized here.\ncomputeIfAbsent won't trigger the compute callback if the key already exists.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513809494", "createdAt": "2020-10-28T22:54:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -192,43 +191,38 @@ public void registerMessageHandlerFactory(String type, MessageHandlerFactory fac\n   @Override\n   public void registerMessageHandlerFactory(String type, MessageHandlerFactory factory,\n       int threadpoolSize) {\n-    if (factory instanceof  MultiTypeMessageHandlerFactory) {\n+    if (factory instanceof MultiTypeMessageHandlerFactory) {\n       if (!((MultiTypeMessageHandlerFactory) factory).getMessageTypes().contains(type)) {\n         throw new HelixException(\"Message factory type mismatch. Type: \" + type + \", factory: \"\n             + ((MultiTypeMessageHandlerFactory) factory).getMessageTypes());\n       }\n     } else {\n       if (!factory.getMessageType().equals(type)) {\n         throw new HelixException(\n-            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory.getMessageType());\n+            \"Message factory type mismatch. Type: \" + type + \", factory: \" + factory\n+                .getMessageType());\n       }\n     }\n \n     _isShuttingDown = false;\n \n-    MsgHandlerFactoryRegistryItem newItem = new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n+    MsgHandlerFactoryRegistryItem newItem =\n+        new MsgHandlerFactoryRegistryItem(factory, threadpoolSize);\n     MsgHandlerFactoryRegistryItem prevItem = _hdlrFtyRegistry.putIfAbsent(type, newItem);\n     if (prevItem == null) {\n-      ExecutorService newPool = Executors.newFixedThreadPool(threadpoolSize, new ThreadFactory() {\n-        @Override public Thread newThread(Runnable r) {\n-          return new Thread(r, \"HelixTaskExecutor-message_handle_thread_\" + thread_uid.getAndIncrement());\n-        }\n-      });\n-      ExecutorService prevExecutor = _executorMap.putIfAbsent(type, newPool);\n-      if (prevExecutor != null) {\n-        LOG.warn(\"Skip creating a new thread pool for type: \" + type + \", already existing pool: \"\n-            + prevExecutor + \", isShutdown: \" + prevExecutor.isShutdown());\n-        newPool.shutdown();\n-        newPool = null;\n-      } else {\n+      _executorMap.computeIfAbsent(type, msgType -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4MzA0MA=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTMwMDY3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTo1NDoxMFrOHp-8sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMzowODozMFrOHqAveg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTAwOQ==", "bodyText": "nit: better to name it as isNoOpMessage? The word check could be confusing here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513785009", "createdAt": "2020-10-28T21:54:10Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwOTc5NA==", "bodyText": "This method is now also cleaning up the message, and it is not easy to move the logic out. So I prefer not calling it as an isXXXX method.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513809794", "createdAt": "2020-10-28T22:55:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTAwOQ=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNDM5NA==", "bodyText": "Changed to checkAndProcessNoOpMessage", "url": "https://github.com/apache/helix/pull/1489#discussion_r513814394", "createdAt": "2020-10-28T23:08:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTAwOQ=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTM2MDc3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxNToxOFrOHp_gmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwNDowMjozM1rOHqIf8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDIwMA==", "bodyText": "This is not just check noOp, it also has other functionalities, check message expired or cancellation logic. Shall we change the name of this one?\nMore importantly, any exception thrown out here without statemodel marked as ERROR can cause controller sending another message repeatedly. Can you this invariant to the comment? So later if someone not familiar with this code can understand the intention here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513794200", "createdAt": "2020-10-28T22:15:18Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxMDc5Nw==", "bodyText": "Any suggestion regarding the name? I feel \"checkAndProcessNoOpMessage\" is too long. But maybe that's what we need.\nRegarding your 2nd comment, could you please point out the potential code that throws Exception? I will take care of that in the following PR. We won't change any business logic in this one.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513810797", "createdAt": "2020-10-28T22:58:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDIwMA=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0MjAzMg==", "bodyText": "Right now, the code is actually within a big try{} block. the catch block would remove message. I know in the next diff you will do more magic to make sure when this method exit, they must be a statemodel with some state. Currently, there is no logic error (probably the only thing is the first line of getHelixDataAcessor() is one is super picky). However, state this variant would help later developers to understand the reasoning here. So I think it would be a good idea to have a comment here.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513842032", "createdAt": "2020-10-29T00:37:12Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDIwMA=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk0MTQ5MQ==", "bodyText": "Depends on the solution, we might need to comment on this logic from a different perspective. I'm not convinced by now that we shall return the statemodel. And the logic here is not only for state transition messages only. So comment here will introduce more confusion.\nI prefer to make the existing logic clean enough first. I will add a comment if necessary when on the real fix.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513941491", "createdAt": "2020-10-29T04:02:33Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkForNoOpMessage(Message message, String instanceName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDIwMA=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 532}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTM2MzQxOnYy", "diffSide": "LEFT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxNjoxOVrOHp_iSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjo1OTowMFrOHqAiZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDYzMg==", "bodyText": "why remove these two lines?", "url": "https://github.com/apache/helix/pull/1489#discussion_r513794632", "createdAt": "2020-10-28T22:16:19Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -810,164 +799,52 @@ public void onMessage(String instanceName, List<Message> messages,\n     Set<String> createCurStateNames = new HashSet<>();\n \n     for (Message message : messages) {\n-      try {\n-        // nop messages are simply removed. It is used to trigger onMessage() in\n-        // situations such as register a new message handler factory\n-        if (message.getMsgType().equalsIgnoreCase(MessageType.NO_OP.toString())) {\n-          LOG.info(\n-              \"Dropping NO-OP message. mid: \" + message.getId() + \", from: \" + message.getMsgSrc());\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          continue;\n-        }\n-\n-        String tgtSessionId = message.getTgtSessionId();\n-        // sessionId mismatch normally means message comes from expired session, just remove it\n-        if (!sessionId.equals(tgtSessionId) && !tgtSessionId.equals(\"*\")) {\n-          String warningMessage =\n-              \"SessionId does NOT match. expected sessionId: \" + sessionId\n-                  + \", tgtSessionId in message: \" + tgtSessionId + \", messageId: \"\n-                  + message.getMsgId();\n-          LOG.warn(warningMessage);\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          _statusUpdateUtil.logWarning(message, HelixStateMachineEngine.class, warningMessage, manager);\n-\n-          // Proactively send a session sync message from participant to controller\n-          // upon session mismatch after a new session is established\n-          if (manager.getInstanceType() == InstanceType.PARTICIPANT\n-              || manager.getInstanceType() == InstanceType.CONTROLLER_PARTICIPANT) {\n-            if (message.getCreateTimeStamp() > manager.getSessionStartTime()) {\n-              syncSessionToController(manager);\n-            }\n-          }\n-          continue;\n-        }\n-\n-        if ((manager.getInstanceType() == InstanceType.CONTROLLER\n-            || manager.getInstanceType() == InstanceType.CONTROLLER_PARTICIPANT)\n-            && MessageType.PARTICIPANT_SESSION_CHANGE.name().equals(message.getMsgType())) {\n-          LOG.info(String.format(\"Controller received PARTICIPANT_SESSION_CHANGE msg from src: %s\",\n-              message.getMsgSrc()));\n-          PropertyKey key = new Builder(manager.getClusterName()).liveInstances();\n-          List<LiveInstance> liveInstances =\n-              manager.getHelixDataAccessor().getChildValues(key, true);\n-          _controller.onLiveInstanceChange(liveInstances, changeContext);\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.COMPLETED);\n-          continue;\n-        }\n-\n-        // don't process message that is of READ or UNPROCESSABLE state\n-        if (MessageState.NEW != message.getMsgState()) {\n-          // It happens because we don't delete message right after\n-          // read. Instead we keep it until the current state is updated.\n-          // We will read the message again if there is a new message but we\n-          // check for the status and ignore if its already read\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Message already read. msgId: \" + message.getMsgId());\n-          }\n-          continue;\n-        }\n-\n-        if (message.isExpired()) {\n-          LOG.info(\n-              \"Dropping expired message. mid: \" + message.getId() + \", from: \" + message.getMsgSrc()\n-                  + \" relayed from: \" + message.getRelaySrcHost());\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          continue;\n-        }\n-\n-        // State Transition Cancellation\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          boolean success = cancelNotStartedStateTransition(message, stateTransitionHandlers, accessor, instanceName);\n-          if (success) {\n-            continue;\n-          }\n-        }\n-\n-        _monitor.reportReceivedMessage(message);\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to process the message {}. Deleting the message from ZK. Exception: {}\",\n-            message, e);\n-        removeMessageFromTaskAndFutureMap(message);\n-        removeMessageFromZK(accessor, message, instanceName);\n+      if (checkForNoOpMessage(message, instanceName, changeContext, manager, sessionId,\n+          stateTransitionHandlers)) {\n+        // skip the following operations for the no-op messages.\n         continue;\n       }\n-\n       // create message handlers, if handlers not found, leave its state as NEW\n       NotificationContext msgWorkingContext = changeContext.clone();\n       try {\n-        MessageHandler createHandler = createMessageHandler(message, msgWorkingContext);\n-        if (createHandler == null) {\n+        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n+        if (msgHandler == null) {\n+          // Failed to create message handler, skip processing this message in this callback.\n+          // The same message process will be retried in the next round.\n           continue;\n         }\n         if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n             .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          String messageTarget =\n-              getMessageTarget(message.getResourceName(), message.getPartitionName());\n-\n-          if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-              && isStateTransitionInProgress(messageTarget)) {\n-\n-            String taskId = _messageTaskMap.get(messageTarget);\n-            Message msg = _taskMap.get(taskId).getTask().getMessage();\n-\n-            // If there is another state transition for same partition is going on,\n-            // discard the message. Controller will resend if this is a valid message\n-            String errMsg = String.format(\n-                \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-                message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-                String.valueOf(msg.isRelayMessage()), msg.getReadTimeStamp(),\n-                System.currentTimeMillis(), message.getFromState(), message.getToState());\n-            handleUnprocessableMessage(message, null /* exception */, errMsg, accessor,\n-                instanceName, manager);\n-            continue;\n-          }\n-          if (createHandler instanceof HelixStateTransitionHandler) {\n-            // We only check to state if there is no ST task scheduled/executing.\n-            HelixStateTransitionHandler.StaleMessageValidateResult result =\n-                ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-            if (!result.isValid) {\n-              handleUnprocessableMessage(message, null /* exception */,\n-                  result.exception.getMessage(), accessor, instanceName, manager);\n-              continue;\n-            }\n-          }\n-          if (stateTransitionHandlers.containsKey(messageTarget)) {\n-            // If there are 2 messages in same batch about same partition's state transition,\n-            // the later one is discarded\n-            Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n-            String errMsg = String.format(\n-                \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n-                message.getMsgId(), duplicatedMessage.getFromState(),\n-                duplicatedMessage.getToState(), message.getFromState(), message.getToState());\n-            handleUnprocessableMessage(message, null /* exception */, errMsg, accessor,\n-                instanceName, manager);\n+          if (validateStateTransitionMessage(message, instanceName, manager,\n+              stateTransitionHandlers, msgHandler)) {\n+            // Need future process by triggering state transition\n+            String msgTarget =\n+                getMessageTarget(message.getResourceName(), message.getPartitionName());\n+            stateTransitionHandlers.put(msgTarget, msgHandler);\n+            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n+          } else {\n+            // skip the following operations for the invalid/expired state transition messages.\n             continue;\n           }\n-\n-          stateTransitionHandlers\n-              .put(getMessageTarget(message.getResourceName(), message.getPartitionName()),\n-                  createHandler);\n-          stateTransitionContexts\n-              .put(getMessageTarget(message.getResourceName(), message.getPartitionName()),\n-                  msgWorkingContext);\n         } else {\n-          nonStateTransitionHandlers.add(createHandler);\n+          // Need future process non state transition messages by triggering the handler\n+          nonStateTransitionHandlers.add(msgHandler);\n           nonStateTransitionContexts.add(msgWorkingContext);\n         }\n       } catch (Exception e) {\n         handleUnprocessableMessage(message, e, e.getMessage(), accessor, instanceName, manager);\n         continue;\n       }\n \n-      markReadMessage(message, msgWorkingContext, manager);\n-      readMsgs.add(message);\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 465}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxMTA0NQ==", "bodyText": "Nothing being removed.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513811045", "createdAt": "2020-10-28T22:59:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -810,164 +799,52 @@ public void onMessage(String instanceName, List<Message> messages,\n     Set<String> createCurStateNames = new HashSet<>();\n \n     for (Message message : messages) {\n-      try {\n-        // nop messages are simply removed. It is used to trigger onMessage() in\n-        // situations such as register a new message handler factory\n-        if (message.getMsgType().equalsIgnoreCase(MessageType.NO_OP.toString())) {\n-          LOG.info(\n-              \"Dropping NO-OP message. mid: \" + message.getId() + \", from: \" + message.getMsgSrc());\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          continue;\n-        }\n-\n-        String tgtSessionId = message.getTgtSessionId();\n-        // sessionId mismatch normally means message comes from expired session, just remove it\n-        if (!sessionId.equals(tgtSessionId) && !tgtSessionId.equals(\"*\")) {\n-          String warningMessage =\n-              \"SessionId does NOT match. expected sessionId: \" + sessionId\n-                  + \", tgtSessionId in message: \" + tgtSessionId + \", messageId: \"\n-                  + message.getMsgId();\n-          LOG.warn(warningMessage);\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          _statusUpdateUtil.logWarning(message, HelixStateMachineEngine.class, warningMessage, manager);\n-\n-          // Proactively send a session sync message from participant to controller\n-          // upon session mismatch after a new session is established\n-          if (manager.getInstanceType() == InstanceType.PARTICIPANT\n-              || manager.getInstanceType() == InstanceType.CONTROLLER_PARTICIPANT) {\n-            if (message.getCreateTimeStamp() > manager.getSessionStartTime()) {\n-              syncSessionToController(manager);\n-            }\n-          }\n-          continue;\n-        }\n-\n-        if ((manager.getInstanceType() == InstanceType.CONTROLLER\n-            || manager.getInstanceType() == InstanceType.CONTROLLER_PARTICIPANT)\n-            && MessageType.PARTICIPANT_SESSION_CHANGE.name().equals(message.getMsgType())) {\n-          LOG.info(String.format(\"Controller received PARTICIPANT_SESSION_CHANGE msg from src: %s\",\n-              message.getMsgSrc()));\n-          PropertyKey key = new Builder(manager.getClusterName()).liveInstances();\n-          List<LiveInstance> liveInstances =\n-              manager.getHelixDataAccessor().getChildValues(key, true);\n-          _controller.onLiveInstanceChange(liveInstances, changeContext);\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.COMPLETED);\n-          continue;\n-        }\n-\n-        // don't process message that is of READ or UNPROCESSABLE state\n-        if (MessageState.NEW != message.getMsgState()) {\n-          // It happens because we don't delete message right after\n-          // read. Instead we keep it until the current state is updated.\n-          // We will read the message again if there is a new message but we\n-          // check for the status and ignore if its already read\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(\"Message already read. msgId: \" + message.getMsgId());\n-          }\n-          continue;\n-        }\n-\n-        if (message.isExpired()) {\n-          LOG.info(\n-              \"Dropping expired message. mid: \" + message.getId() + \", from: \" + message.getMsgSrc()\n-                  + \" relayed from: \" + message.getRelaySrcHost());\n-          reportAndRemoveMessage(message, accessor, instanceName, ProcessedMessageState.DISCARDED);\n-          continue;\n-        }\n-\n-        // State Transition Cancellation\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          boolean success = cancelNotStartedStateTransition(message, stateTransitionHandlers, accessor, instanceName);\n-          if (success) {\n-            continue;\n-          }\n-        }\n-\n-        _monitor.reportReceivedMessage(message);\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to process the message {}. Deleting the message from ZK. Exception: {}\",\n-            message, e);\n-        removeMessageFromTaskAndFutureMap(message);\n-        removeMessageFromZK(accessor, message, instanceName);\n+      if (checkForNoOpMessage(message, instanceName, changeContext, manager, sessionId,\n+          stateTransitionHandlers)) {\n+        // skip the following operations for the no-op messages.\n         continue;\n       }\n-\n       // create message handlers, if handlers not found, leave its state as NEW\n       NotificationContext msgWorkingContext = changeContext.clone();\n       try {\n-        MessageHandler createHandler = createMessageHandler(message, msgWorkingContext);\n-        if (createHandler == null) {\n+        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n+        if (msgHandler == null) {\n+          // Failed to create message handler, skip processing this message in this callback.\n+          // The same message process will be retried in the next round.\n           continue;\n         }\n         if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n             .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          String messageTarget =\n-              getMessageTarget(message.getResourceName(), message.getPartitionName());\n-\n-          if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-              && isStateTransitionInProgress(messageTarget)) {\n-\n-            String taskId = _messageTaskMap.get(messageTarget);\n-            Message msg = _taskMap.get(taskId).getTask().getMessage();\n-\n-            // If there is another state transition for same partition is going on,\n-            // discard the message. Controller will resend if this is a valid message\n-            String errMsg = String.format(\n-                \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-                message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-                String.valueOf(msg.isRelayMessage()), msg.getReadTimeStamp(),\n-                System.currentTimeMillis(), message.getFromState(), message.getToState());\n-            handleUnprocessableMessage(message, null /* exception */, errMsg, accessor,\n-                instanceName, manager);\n-            continue;\n-          }\n-          if (createHandler instanceof HelixStateTransitionHandler) {\n-            // We only check to state if there is no ST task scheduled/executing.\n-            HelixStateTransitionHandler.StaleMessageValidateResult result =\n-                ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-            if (!result.isValid) {\n-              handleUnprocessableMessage(message, null /* exception */,\n-                  result.exception.getMessage(), accessor, instanceName, manager);\n-              continue;\n-            }\n-          }\n-          if (stateTransitionHandlers.containsKey(messageTarget)) {\n-            // If there are 2 messages in same batch about same partition's state transition,\n-            // the later one is discarded\n-            Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n-            String errMsg = String.format(\n-                \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n-                message.getMsgId(), duplicatedMessage.getFromState(),\n-                duplicatedMessage.getToState(), message.getFromState(), message.getToState());\n-            handleUnprocessableMessage(message, null /* exception */, errMsg, accessor,\n-                instanceName, manager);\n+          if (validateStateTransitionMessage(message, instanceName, manager,\n+              stateTransitionHandlers, msgHandler)) {\n+            // Need future process by triggering state transition\n+            String msgTarget =\n+                getMessageTarget(message.getResourceName(), message.getPartitionName());\n+            stateTransitionHandlers.put(msgTarget, msgHandler);\n+            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n+          } else {\n+            // skip the following operations for the invalid/expired state transition messages.\n             continue;\n           }\n-\n-          stateTransitionHandlers\n-              .put(getMessageTarget(message.getResourceName(), message.getPartitionName()),\n-                  createHandler);\n-          stateTransitionContexts\n-              .put(getMessageTarget(message.getResourceName(), message.getPartitionName()),\n-                  msgWorkingContext);\n         } else {\n-          nonStateTransitionHandlers.add(createHandler);\n+          // Need future process non state transition messages by triggering the handler\n+          nonStateTransitionHandlers.add(msgHandler);\n           nonStateTransitionContexts.add(msgWorkingContext);\n         }\n       } catch (Exception e) {\n         handleUnprocessableMessage(message, e, e.getMessage(), accessor, instanceName, manager);\n         continue;\n       }\n \n-      markReadMessage(message, msgWorkingContext, manager);\n-      readMsgs.add(message);\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDYzMg=="}, "originalCommit": {"oid": "0777cd369d48fba480ac9ffb7e0b309fda7540ee"}, "originalPosition": 465}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTc2MDYxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMToxNzo1OVrOHqDKVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDozOTo1OVrOHqtyyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NDAzOA==", "bodyText": "nit, put this line also into try{} block.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513854038", "createdAt": "2020-10-29T01:17:59Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n+      NotificationContext changeContext, HelixManager manager, String sessionId,\n+      Map<String, MessageHandler> stateTransitionHandlers) {\n+    HelixDataAccessor accessor = manager.getHelixDataAccessor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "originalPosition": 535}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkzNTQ3Mg==", "bodyText": "If this fails, meaning we lost ZK connection and the wait is timed out. In this case, I think it would be better to throw the exception instead of proceeding. The handleUnprocessableMessage will fail too due to ZK connection breaks.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513935472", "createdAt": "2020-10-29T03:52:59Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n+      NotificationContext changeContext, HelixManager manager, String sessionId,\n+      Map<String, MessageHandler> stateTransitionHandlers) {\n+    HelixDataAccessor accessor = manager.getHelixDataAccessor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NDAzOA=="}, "originalCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "originalPosition": 535}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk0MjE4Mw==", "bodyText": "One more point why we should not change it, moving this line into the try-catch block changes the business logic.", "url": "https://github.com/apache/helix/pull/1489#discussion_r513942183", "createdAt": "2020-10-29T04:03:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n+      NotificationContext changeContext, HelixManager manager, String sessionId,\n+      Map<String, MessageHandler> stateTransitionHandlers) {\n+    HelixDataAccessor accessor = manager.getHelixDataAccessor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NDAzOA=="}, "originalCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "originalPosition": 535}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0NzMwMw==", "bodyText": "public HelixDataAccessor getHelixDataAccessor() {\n    checkConnected(_waitForConnectedTimeout);\n    return _dataAccessor;\n  }\n\nif somehow the _zkClient is closed, the above code would throw exception, which would cause the same issue of repeatedly controller sending messages.\nNote, with new change to statusUpdateUtil, we won't really use _zkClient from ZKHelixManager to write to Zookeeper.\nIn sum, I think the core idea (invariant) is that don't throw anything out from this method. Anyway, up to you.", "url": "https://github.com/apache/helix/pull/1489#discussion_r514547303", "createdAt": "2020-10-29T20:30:17Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n+      NotificationContext changeContext, HelixManager manager, String sessionId,\n+      Map<String, MessageHandler> stateTransitionHandlers) {\n+    HelixDataAccessor accessor = manager.getHelixDataAccessor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NDAzOA=="}, "originalCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "originalPosition": 535}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1MjUyMQ==", "bodyText": "This specific case won't cause retry, since the message won't be removed when zkclient is down.\nstatusUpdateUtil is a different story. It should be considered in different PRs.\nBased on what we discussed today with @dasahcc and @lei-xia , we agreed that it is not ideal or applicable for us to eliminate all potential Exceptions. And leave the message in any of the Exception cases is dangerous, IMO.\nSo we will take this case by case.\nIn the following PRs, we will ensure all the Exceptions of application code (behind the interfaces) will be handled gracefully. But our internal logic exceptions will be evaluated one by one in other PRs, if necessary.", "url": "https://github.com/apache/helix/pull/1489#discussion_r514552521", "createdAt": "2020-10-29T20:39:59Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -997,30 +873,186 @@ public void onMessage(String instanceName, List<Message> messages,\n       }\n     }\n \n-    // update message state to READ in batch and schedule all read messages\n+    // update message state to READ in batch and schedule tasks for all read messages\n     if (readMsgs.size() > 0) {\n       updateMessageState(readMsgs, accessor, instanceName);\n \n-      // Remove message if schedule tasks are failed.\n       for (Map.Entry<String, MessageHandler> handlerEntry : stateTransitionHandlers.entrySet()) {\n         MessageHandler handler = handlerEntry.getValue();\n         NotificationContext context = stateTransitionContexts.get(handlerEntry.getKey());\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n-        }\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n       }\n \n       for (int i = 0; i < nonStateTransitionHandlers.size(); i++) {\n         MessageHandler handler = nonStateTransitionHandlers.get(i);\n         NotificationContext context = nonStateTransitionContexts.get(i);\n-        Message msg = handler._message;\n-        if (!scheduleTask(new HelixTask(msg, context, handler, this))) {\n-          removeMessageFromTaskAndFutureMap(msg);\n-          removeMessageFromZK(accessor, msg, instanceName);\n+        scheduleTaskForMessage(instanceName, accessor, handler, context);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Inspect the message. Report and remove it if no operation needs to be done.\n+   * @param message\n+   * @param instanceName\n+   * @param changeContext\n+   * @param manager\n+   * @param sessionId\n+   * @param stateTransitionHandlers\n+   * @return True if the message is no-op message and no other process step is required.\n+   */\n+  private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n+      NotificationContext changeContext, HelixManager manager, String sessionId,\n+      Map<String, MessageHandler> stateTransitionHandlers) {\n+    HelixDataAccessor accessor = manager.getHelixDataAccessor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NDAzOA=="}, "originalCommit": {"oid": "78fb311b83fcc0e6365fc9212711795d62cc3e2c"}, "originalPosition": 535}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1055, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}