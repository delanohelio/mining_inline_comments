{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0ODU1NDcw", "number": 1165, "title": "Quota calculation based on CurrentState", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR title:\nFixes #1164\n\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nIn this PR, the new methods have been added to AssignableInstanceManager which allow controller to calculate quota based on CurrentState and pending messages. The previous quota calculation has been removed from the cache refresh. The new one is added in the TaskSchedulingStage after currentState being computed.\nTests\n\n\n The following tests are written for this issue:\nTestStuckTaskQuota\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\nhelix-core:\n[INFO] Tests run: 1151, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4,797.423 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 1151, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:20 h\n[INFO] Finished at: 2020-07-21T18:34:47-07:00\n[INFO] ------------------------------------------------------------------------\n\nhelix-rest:\n[INFO] Tests run: 159, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 43.449 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 159, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  49.027 s\n[INFO] Finished at: 2020-07-21T20:18:57-07:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-07-22T03:20:52Z", "url": "https://github.com/apache/helix/pull/1165", "merged": true, "mergeCommit": {"oid": "f8da1e2f155129cd2075aa46e35e075b618bf233"}, "closed": true, "closedAt": "2020-07-24T18:12:29Z", "author": {"login": "alirezazamani"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3MCS0gH2gAyNDU0ODU1NDcwOmNhNmY4YjAwYzhiZTVkMjE1ZmI0OTRhYmZiMjlkMDEyNTM4NDQwYzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc32mANAH2gAyNDU0ODU1NDcwOjYxYTk2YjVhYjk3ZDk1OWUzOTA3NTEyYTA1MzVkNzhhYzUyZmIyZjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ca6f8b00c8be5d215fb494abfb29d012538440c3", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/ca6f8b00c8be5d215fb494abfb29d012538440c3", "committedDate": "2020-07-21T20:13:17Z", "message": "Use CurrentState to calculate quota\n\nIn this commit, the new methods has been added to\nAssignableInstanceManager which allow controller\nto calculate quota based on CurrentState and\npending messages."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf", "committedDate": "2020-07-22T03:12:59Z", "message": "Add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDc5MTk4", "url": "https://github.com/apache/helix/pull/1165#pullrequestreview-454479198", "createdAt": "2020-07-23T20:40:39Z", "commit": {"oid": "6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0MDozOVrOG2azDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0MDozOVrOG2azDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTM0Mg==", "bodyText": "Let's combine it:\nif (jobConfig == null || jobConfig.getJobType() == null) {\nreturn AssignableInstance.DEFAULT_QUOTA_TYPE;\n}\nreturn jobConfig.getJobType();", "url": "https://github.com/apache/helix/pull/1165#discussion_r459715342", "createdAt": "2020-07-23T20:40:39Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/task/AssignableInstanceManager.java", "diffHunk": "@@ -176,6 +181,178 @@ public void buildAssignableInstances(ClusterConfig clusterConfig, TaskDataCache\n     computeGlobalThreadBasedCapacity();\n   }\n \n+  /**\n+   * Builds AssignableInstances and restores TaskAssignResults from scratch by reading from\n+   * CurrentState. It re-computes current quota profile for each AssignableInstance.\n+   * If a task current state is INIT or RUNNING or if there is a pending message which it's ToState\n+   * is RUNNING, the task/partition will be assigned to AssignableInstances of the instance.\n+   * @param clusterConfig\n+   * @param taskDataCache\n+   * @param liveInstances\n+   * @param instanceConfigs\n+   * @param currentStateOutput\n+   * @param resourceMap\n+   */\n+  public void buildAssignableInstancesFromCurrentState(ClusterConfig clusterConfig,\n+      TaskDataCache taskDataCache, Map<String, LiveInstance> liveInstances,\n+      Map<String, InstanceConfig> instanceConfigs, CurrentStateOutput currentStateOutput,\n+      Map<String, Resource> resourceMap) {\n+    _assignableInstanceMap.clear();\n+    _taskAssignResultMap.clear();\n+\n+    // Create all AssignableInstance objects based on what's in liveInstances\n+    for (Map.Entry<String, LiveInstance> liveInstanceEntry : liveInstances.entrySet()) {\n+      // Prepare instance-specific metadata\n+      String instanceName = liveInstanceEntry.getKey();\n+      LiveInstance liveInstance = liveInstanceEntry.getValue();\n+      if (!instanceConfigs.containsKey(instanceName)) {\n+        continue; // Ill-formatted input; skip over this instance\n+      }\n+      InstanceConfig instanceConfig = instanceConfigs.get(instanceName);\n+\n+      // Create an AssignableInstance\n+      AssignableInstance assignableInstance =\n+          new AssignableInstance(clusterConfig, instanceConfig, liveInstance);\n+      _assignableInstanceMap.put(instanceConfig.getInstanceName(), assignableInstance);\n+      LOG.debug(\"AssignableInstance created for instance: {}\", instanceName);\n+    }\n+\n+    Map<String, JobConfig> jobConfigMap = taskDataCache.getJobConfigMap();\n+\n+    // Update task profiles by traversing all CurrentStates\n+    for (Map.Entry<String, Resource> resourceEntry : resourceMap.entrySet()) {\n+      String resourceName = resourceEntry.getKey();\n+      if (resourceEntry.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n+        JobConfig jobConfig = jobConfigMap.get(resourceName);\n+        JobContext jobContext = taskDataCache.getJobContext(resourceName);\n+        String quotaType = getQuotaType(jobConfig);\n+        Map<Partition, Map<String, String>> currentStateMap =\n+            currentStateOutput.getCurrentStateMap(resourceName);\n+        for (Map.Entry<Partition, Map<String, String>> currentStateMapEntry : currentStateMap\n+            .entrySet()) {\n+          Partition partition = currentStateMapEntry.getKey();\n+          String taskId = getTaskID(jobConfig, jobContext, partition);\n+          for (Map.Entry<String, String> instanceCurrentStateEntry : currentStateMapEntry.getValue()\n+              .entrySet()) {\n+            String assignedInstance = instanceCurrentStateEntry.getKey();\n+            String taskState = instanceCurrentStateEntry.getValue();\n+            // If a task in in INIT or RUNNING state on the instance, this task should occupy one\n+            // quota from this instance.\n+            if (taskState.equals(TaskPartitionState.INIT.name())\n+                || taskState.equals(TaskPartitionState.RUNNING.name())) {\n+              assignTaskToInstance(assignedInstance, jobConfig, taskId, quotaType);\n+            }\n+          }\n+        }\n+        Map<Partition, Map<String, Message>> pendingMessageMap =\n+            currentStateOutput.getPendingMessageMap(resourceName);\n+        for (Map.Entry<Partition, Map<String, Message>> pendingMessageMapEntry : pendingMessageMap\n+            .entrySet()) {\n+          Partition partition = pendingMessageMapEntry.getKey();\n+          String taskId = getTaskID(jobConfig, jobContext, partition);\n+          for (Map.Entry<String, Message> instancePendingMessageEntry : pendingMessageMapEntry\n+              .getValue().entrySet()) {\n+            String assignedInstance = instancePendingMessageEntry.getKey();\n+            String messageToState = instancePendingMessageEntry.getValue().getToState();\n+            // If there is a pending message on the instance which has ToState of RUNNING, the task\n+            // will run on the instance soon. So the task needs to occupy one quota on this instance.\n+            if (messageToState.equals(TaskPartitionState.RUNNING.name())\n+                && !TaskPartitionState.INIT.name().equals(\n+                    currentStateOutput.getCurrentState(resourceName, partition, assignedInstance))\n+                && !TaskPartitionState.RUNNING.name().equals(currentStateOutput\n+                    .getCurrentState(resourceName, partition, assignedInstance))) {\n+              assignTaskToInstance(assignedInstance, jobConfig, taskId, quotaType);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    LOG.info(\n+        \"AssignableInstanceManager built AssignableInstances from scratch based on contexts in TaskDataCache due to Controller switch or ClusterConfig change.\");\n+    computeGlobalThreadBasedCapacity();\n+  }\n+\n+  /**\n+   * Assign the task to the instance's Assignable Instance\n+   * @param instance\n+   * @param jobConfig\n+   * @param taskId\n+   * @param quotaType\n+   */\n+  private void assignTaskToInstance(String instance, JobConfig jobConfig, String taskId,\n+      String quotaType) {\n+    if (_assignableInstanceMap.containsKey(instance)) {\n+      TaskConfig taskConfig = getTaskConfig(jobConfig, taskId);\n+      AssignableInstance assignableInstance = _assignableInstanceMap.get(instance);\n+      TaskAssignResult taskAssignResult =\n+          assignableInstance.restoreTaskAssignResult(taskId, taskConfig, quotaType);\n+      if (taskAssignResult.isSuccessful()) {\n+        _taskAssignResultMap.put(taskId, taskAssignResult);\n+        LOG.debug(\"TaskAssignResult restored for taskId: {}, assigned on instance: {}\", taskId,\n+            instance);\n+      }\n+    } else {\n+      LOG.debug(\n+          \"While building AssignableInstance map, discovered that the instance a task is assigned to is no \"\n+              + \"longer a LiveInstance! TaskAssignResult will not be created and no resource will be taken \"\n+              + \"up for this task. TaskId: {}, Instance: {}\",\n+          taskId, instance);\n+    }\n+  }\n+\n+  /**\n+   * Extract the quota type information of the Job\n+   * @param jobConfig\n+   * @return\n+   */\n+  private String getQuotaType(JobConfig jobConfig) {\n+    // If jobConfig is null (job has been deleted but participant has not dropped the task yet), use\n+    // default quota for the task\n+    if (jobConfig == null) {\n+      return AssignableInstance.DEFAULT_QUOTA_TYPE;\n+    }\n+    String quotaType = jobConfig.getJobType();\n+    if (quotaType == null) {\n+      quotaType = AssignableInstance.DEFAULT_QUOTA_TYPE;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a93aa2f39d193f10b83ca6bc6764b171d2bb5cf"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f162822274b16e9aac5de0b35d034caf21d1d3c", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/3f162822274b16e9aac5de0b35d034caf21d1d3c", "committedDate": "2020-07-23T21:40:28Z", "message": "Address the comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61a96b5ab97d959e3907512a0535d78ac52fb2f3", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/61a96b5ab97d959e3907512a0535d78ac52fb2f3", "committedDate": "2020-07-23T21:48:18Z", "message": "Remove unused import"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4571, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}