{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNzc3NjQz", "number": 908, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzoyMjoxMVrODq5OtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoxNjo0OFrODq_dNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzA0NDM3OnYy", "diffSide": "LEFT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzoyMjoxMVrOF67GgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxMToxNFrOF6_P_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMDA0OA==", "bodyText": "Why is this section removed? In a scenario where ZkRoutingDataReader is instantiated by itself, subscribeRoutingDataChanges might encounter NoNodeException if we don't ensure that ROUTING_DATA_PATH exists in ZK.", "url": "https://github.com/apache/helix/pull/908#discussion_r397330048", "createdAt": "2020-03-24T17:22:11Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "diffHunk": "@@ -58,25 +58,9 @@ public ZkRoutingDataReader(String namespace, String zkAddress,\n     _zkClient = DedicatedZkClientFactory.getInstance()\n         .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n             new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-\n-    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n-    // create() semantic will fail if it already exists\n-    try {\n-      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n-    } catch (ZkNodeExistsException e) {\n-      // This is okay\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5ODAxNQ==", "bodyText": "Adding it back.", "url": "https://github.com/apache/helix/pull/908#discussion_r397398015", "createdAt": "2020-03-24T19:11:14Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "diffHunk": "@@ -58,25 +58,9 @@ public ZkRoutingDataReader(String namespace, String zkAddress,\n     _zkClient = DedicatedZkClientFactory.getInstance()\n         .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n             new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-\n-    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n-    // create() semantic will fail if it already exists\n-    try {\n-      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n-    } catch (ZkNodeExistsException e) {\n-      // This is okay\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMDA0OA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzA2NDA0OnYy", "diffSide": "LEFT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzoyNjo1NlrOF67TOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxMTowMlrOF6_PiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMzMwNQ==", "bodyText": "Likewise, without this section, some ZNode creation might fail if they didn't create the parent (ROUTING_DATA_PATH) and the parent doesn't exist.", "url": "https://github.com/apache/helix/pull/908#discussion_r397333305", "createdAt": "2020-03-24T17:26:56Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -82,20 +82,14 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n         .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n             new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n \n-    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n-    // create() semantic will fail if it already exists\n-    try {\n-      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n-    } catch (ZkNodeExistsException e) {\n-      // This is okay\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5Nzg5Nw==", "bodyText": "I'll re-add.", "url": "https://github.com/apache/helix/pull/908#discussion_r397397897", "createdAt": "2020-03-24T19:11:02Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -82,20 +82,14 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n         .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n             new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n \n-    // Ensure that ROUTING_DATA_PATH exists in ZK. If not, create\n-    // create() semantic will fail if it already exists\n-    try {\n-      _zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n-    } catch (ZkNodeExistsException e) {\n-      // This is okay\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMzMwNQ=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzEyNDg1OnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzo0MjowNVrOF6760g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxMDo1NFrOF6_PLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MzQ0Mg==", "bodyText": "Is it possible to reduce duplication among the handle functions?", "url": "https://github.com/apache/helix/pull/908#discussion_r397343442", "createdAt": "2020-03-24T17:42:05Z", "author": {"login": "NealSun96"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -165,5 +238,93 @@ public void close() {\n     if (_zkMetadataStoreDirectory != null) {\n       _zkMetadataStoreDirectory.close();\n     }\n+    if (_zkClientForListener != null) {\n+      _zkClientForListener.close();\n+    }\n+  }\n+\n+  @Override\n+  public void handleChildChange(String parentPath, List<String> currentChilds) {\n+    if (_zkClientForListener == null || _zkClientForListener.isClosed()) {\n+      return;\n+    }\n+    // Resubscribe\n+    _zkClientForListener.unsubscribeAll();\n+    ZkRoutingDataReader.subscribeRoutingDataChanges(_zkClientForListener, this, this);\n+    resetZkResources();\n+  }\n+\n+  @Override\n+  public void handleDataChange(String dataPath, Object data) {\n+    if (_zkClientForListener == null || _zkClientForListener.isClosed()) {\n+      return;\n+    }\n+    resetZkResources();\n+  }\n+\n+  @Override\n+  public void handleDataDeleted(String dataPath) {\n+    if (_zkClientForListener == null || _zkClientForListener.isClosed()) {\n+      return;\n+    }\n+    // Resubscribe\n+    _zkClientForListener.unsubscribeAll();\n+    ZkRoutingDataReader.subscribeRoutingDataChanges(_zkClientForListener, this, this);\n+    resetZkResources();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5NzgwNg==", "bodyText": "Updated. It's hard to reduce duplication further because we need to sneak in unsubscribe/resubscribe for some callback functions.", "url": "https://github.com/apache/helix/pull/908#discussion_r397397806", "createdAt": "2020-03-24T19:10:54Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -165,5 +238,93 @@ public void close() {\n     if (_zkMetadataStoreDirectory != null) {\n       _zkMetadataStoreDirectory.close();\n     }\n+    if (_zkClientForListener != null) {\n+      _zkClientForListener.close();\n+    }\n+  }\n+\n+  @Override\n+  public void handleChildChange(String parentPath, List<String> currentChilds) {\n+    if (_zkClientForListener == null || _zkClientForListener.isClosed()) {\n+      return;\n+    }\n+    // Resubscribe\n+    _zkClientForListener.unsubscribeAll();\n+    ZkRoutingDataReader.subscribeRoutingDataChanges(_zkClientForListener, this, this);\n+    resetZkResources();\n+  }\n+\n+  @Override\n+  public void handleDataChange(String dataPath, Object data) {\n+    if (_zkClientForListener == null || _zkClientForListener.isClosed()) {\n+      return;\n+    }\n+    resetZkResources();\n+  }\n+\n+  @Override\n+  public void handleDataDeleted(String dataPath) {\n+    if (_zkClientForListener == null || _zkClientForListener.isClosed()) {\n+      return;\n+    }\n+    // Resubscribe\n+    _zkClientForListener.unsubscribeAll();\n+    ZkRoutingDataReader.subscribeRoutingDataChanges(_zkClientForListener, this, this);\n+    resetZkResources();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MzQ0Mg=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDAzOTgyOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowODoyNVrOF7E82A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMDowMTowOFrOF7HhkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MTQxNg==", "bodyText": "The path contains\"/\" symbol. Would that be OK?", "url": "https://github.com/apache/helix/pull/908#discussion_r397491416", "createdAt": "2020-03-24T22:08:25Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -339,4 +348,22 @@ public synchronized void close() {\n     _routingDataMap.clear();\n     _zkMetadataStoreDirectoryInstance = null;\n   }\n+\n+  /**\n+   * Make sure the root routing data path exists. Also, register the routing ZK address.\n+   * @param zkClient\n+   */\n+  private void createRoutingDataPath(HelixZkClient zkClient, String zkAddress) {\n+    try {\n+      zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n+    } catch (ZkNodeExistsException e) {\n+      // The node already exists and it's okay\n+    }\n+    // Make sure ROUTING_DATA_PATH is mapped to the routing ZK so that FederatedZkClient used\n+    // in Helix REST can subscribe to the routing data path\n+    ZNRecord znRecord = new ZNRecord(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxOTkzMA==", "bodyText": "That's okay. This is just an ID - it's for display purposes only.", "url": "https://github.com/apache/helix/pull/908#discussion_r397519930", "createdAt": "2020-03-24T23:20:57Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -339,4 +348,22 @@ public synchronized void close() {\n     _routingDataMap.clear();\n     _zkMetadataStoreDirectoryInstance = null;\n   }\n+\n+  /**\n+   * Make sure the root routing data path exists. Also, register the routing ZK address.\n+   * @param zkClient\n+   */\n+  private void createRoutingDataPath(HelixZkClient zkClient, String zkAddress) {\n+    try {\n+      zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n+    } catch (ZkNodeExistsException e) {\n+      // The node already exists and it's okay\n+    }\n+    // Make sure ROUTING_DATA_PATH is mapped to the routing ZK so that FederatedZkClient used\n+    // in Helix REST can subscribe to the routing data path\n+    ZNRecord znRecord = new ZNRecord(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MTQxNg=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzMzU4NA==", "bodyText": "That was confusing user. In our convention, the path to a certain will be \"/ID of ZNode1/ID of ZNode2\".  Usually we dont have folder name is one thing and id of ZNRecord is another thing. Suggest to make it consisnt.", "url": "https://github.com/apache/helix/pull/908#discussion_r397533584", "createdAt": "2020-03-25T00:01:08Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -339,4 +348,22 @@ public synchronized void close() {\n     _routingDataMap.clear();\n     _zkMetadataStoreDirectoryInstance = null;\n   }\n+\n+  /**\n+   * Make sure the root routing data path exists. Also, register the routing ZK address.\n+   * @param zkClient\n+   */\n+  private void createRoutingDataPath(HelixZkClient zkClient, String zkAddress) {\n+    try {\n+      zkClient.createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, true);\n+    } catch (ZkNodeExistsException e) {\n+      // The node already exists and it's okay\n+    }\n+    // Make sure ROUTING_DATA_PATH is mapped to the routing ZK so that FederatedZkClient used\n+    // in Helix REST can subscribe to the routing data path\n+    ZNRecord znRecord = new ZNRecord(MetadataStoreRoutingConstants.ROUTING_DATA_PATH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MTQxNg=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDA0NTgxOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoxMDozMFrOF7FAfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMDoxN1rOF7G5Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MjM0OA==", "bodyText": "Would you like to make it as public util function? If yes, then move it to some util class, otherwise, I think we have internal member of _zkClient, does not need to make the zkclient is passing in.", "url": "https://github.com/apache/helix/pull/908#discussion_r397492348", "createdAt": "2020-03-24T22:10:30Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "diffHunk": "@@ -138,40 +122,51 @@ public synchronized void handleChildChange(String s, List<String> list) {\n \n   @Override\n   public synchronized void handleStateChanged(Watcher.Event.KeeperState state) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleNewSession(String sessionId) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleSessionEstablishmentError(Throwable error) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n+  /**\n+   * Subscribes to the routing data paths using the provided ZkClient.\n+   * @param zkClient\n+   * @param childListener\n+   * @param dataListener\n+   */\n+  public static void subscribeRoutingDataChanges(RealmAwareZkClient zkClient,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMzI3OA==", "bodyText": "As suggested, I moved it to RealmAwareZkClient.", "url": "https://github.com/apache/helix/pull/908#discussion_r397523278", "createdAt": "2020-03-24T23:30:17Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "diffHunk": "@@ -138,40 +122,51 @@ public synchronized void handleChildChange(String s, List<String> list) {\n \n   @Override\n   public synchronized void handleStateChanged(Watcher.Event.KeeperState state) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleNewSession(String sessionId) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleSessionEstablishmentError(Throwable error) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n+  /**\n+   * Subscribes to the routing data paths using the provided ZkClient.\n+   * @param zkClient\n+   * @param childListener\n+   * @param dataListener\n+   */\n+  public static void subscribeRoutingDataChanges(RealmAwareZkClient zkClient,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MjM0OA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDA0NzUyOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoxMToxMVrOF7FBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMDozNlrOF7G50w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MjYzMw==", "bodyText": "Let's make a util class for this purpose.", "url": "https://github.com/apache/helix/pull/908#discussion_r397492633", "createdAt": "2020-03-24T22:11:11Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "diffHunk": "@@ -138,40 +122,51 @@ public synchronized void handleChildChange(String s, List<String> list) {\n \n   @Override\n   public synchronized void handleStateChanged(Watcher.Event.KeeperState state) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleNewSession(String sessionId) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleSessionEstablishmentError(Throwable error) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n+  /**\n+   * Subscribes to the routing data paths using the provided ZkClient.\n+   * @param zkClient\n+   * @param childListener\n+   * @param dataListener\n+   */\n+  public static void subscribeRoutingDataChanges(RealmAwareZkClient zkClient,\n+      IZkChildListener childListener, IZkDataListener dataListener) {\n+    zkClient.subscribeChildChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, childListener);\n+    for (String child : zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+      zkClient.subscribeDataChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child,\n+          dataListener);\n+    }\n+  }\n+\n   private void handleResubscription() {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n \n     // Renew subscription\n     _zkClient.unsubscribeAll();\n-    _zkClient.subscribeChildChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, this);\n-    for (String child : _zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n-      _zkClient.subscribeDataChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child,\n-          this);\n-    }\n+    ZkRoutingDataReader.subscribeRoutingDataChanges(_zkClient, this, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMzQxMQ==", "bodyText": "Moved to RealmAwareZkClient interface.", "url": "https://github.com/apache/helix/pull/908#discussion_r397523411", "createdAt": "2020-03-24T23:30:36Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataReader.java", "diffHunk": "@@ -138,40 +122,51 @@ public synchronized void handleChildChange(String s, List<String> list) {\n \n   @Override\n   public synchronized void handleStateChanged(Watcher.Event.KeeperState state) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleNewSession(String sessionId) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n   @Override\n   public synchronized void handleSessionEstablishmentError(Throwable error) {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n     _routingDataListener.refreshRoutingData(_namespace);\n   }\n \n+  /**\n+   * Subscribes to the routing data paths using the provided ZkClient.\n+   * @param zkClient\n+   * @param childListener\n+   * @param dataListener\n+   */\n+  public static void subscribeRoutingDataChanges(RealmAwareZkClient zkClient,\n+      IZkChildListener childListener, IZkDataListener dataListener) {\n+    zkClient.subscribeChildChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, childListener);\n+    for (String child : zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+      zkClient.subscribeDataChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child,\n+          dataListener);\n+    }\n+  }\n+\n   private void handleResubscription() {\n-    if (_zkClient.isClosed()) {\n+    if (_zkClient == null || _zkClient.isClosed()) {\n       return;\n     }\n \n     // Renew subscription\n     _zkClient.unsubscribeAll();\n-    _zkClient.subscribeChildChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, this);\n-    for (String child : _zkClient.getChildren(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n-      _zkClient.subscribeDataChanges(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + child,\n-          this);\n-    }\n+    ZkRoutingDataReader.subscribeRoutingDataChanges(_zkClient, this, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5MjYzMw=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDA1NTM0OnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoxMzo0MlrOF7FGHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMjowMVrOF7G71g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5Mzc5MQ==", "bodyText": "The volatile keyword is trying to make variable sharing between threads. Do we have many threads for using these variables, which are not able to get the instance?", "url": "https://github.com/apache/helix/pull/908#discussion_r397493791", "createdAt": "2020-03-24T22:13:42Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMzkyNg==", "bodyText": "Yes. Jersey spins up a thread to serve each incoming request.\nAlso volatile is used to as a double-checked locking idiom. So it is needed here for lazy initialization.", "url": "https://github.com/apache/helix/pull/908#discussion_r397523926", "createdAt": "2020-03-24T23:32:01Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5Mzc5MQ=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDA2NDUzOnYy", "diffSide": "RIGHT", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoxNjo0OFrOF7FLjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowOTozMFrOF7oB-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5NTE4MA==", "bodyText": "Why we need a pool? Since you already make the task driver could accept the RealmAzreZkClient, we can pass in the FederatedZkClient as input, right? And TaskDriver does not have any session aware operations. So we can use FederatedZkClient for multiple cluster accessing purpose.", "url": "https://github.com/apache/helix/pull/908#discussion_r397495180", "createdAt": "2020-03-24T22:16:48Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;\n+\n+  private volatile ZKHelixAdmin _zkHelixAdmin;\n+  private volatile ClusterSetup _clusterSetup;\n+  private volatile ConfigAccessor _configAccessor;\n   // A lazily-initialized base data accessor that reads/writes byte array to ZK\n   // TODO: Only read (deserialize) is supported at this time. This baseDataAccessor should support write (serialize) as needs arise\n   private volatile ZkBaseDataAccessor<byte[]> _byteArrayZkBaseDataAccessor;\n   // 1 Cluster name will correspond to 1 helix data accessor\n   private final Map<String, HelixDataAccessor> _helixDataAccessorPool;\n   // 1 Cluster name will correspond to 1 task driver\n   private final Map<String, TaskDriver> _taskDriverPool;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDQ4Ng==", "bodyText": "Your line of thinking is correct, but if we made that change here, Helix REST will no longer be backward-compatible. We leave it here so that for users that use Helix REST in a single ZK mode will be able to use it the way they were able to use before (1 TaskDriver per cluster)", "url": "https://github.com/apache/helix/pull/908#discussion_r397524486", "createdAt": "2020-03-24T23:33:36Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;\n+\n+  private volatile ZKHelixAdmin _zkHelixAdmin;\n+  private volatile ClusterSetup _clusterSetup;\n+  private volatile ConfigAccessor _configAccessor;\n   // A lazily-initialized base data accessor that reads/writes byte array to ZK\n   // TODO: Only read (deserialize) is supported at this time. This baseDataAccessor should support write (serialize) as needs arise\n   private volatile ZkBaseDataAccessor<byte[]> _byteArrayZkBaseDataAccessor;\n   // 1 Cluster name will correspond to 1 helix data accessor\n   private final Map<String, HelixDataAccessor> _helixDataAccessorPool;\n   // 1 Cluster name will correspond to 1 task driver\n   private final Map<String, TaskDriver> _taskDriverPool;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5NTE4MA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzNDYxMw==", "bodyText": "Can you elaborate why it is not backward compatible? I think FederatedZKClient can support single ZK access, right? We can make it accept single ZK while combining with multi ZK access. Otherwise, we already started multiple Servlet for different ZK works fine and I did not get the idea of making REST realm-aware.", "url": "https://github.com/apache/helix/pull/908#discussion_r397534613", "createdAt": "2020-03-25T00:04:22Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;\n+\n+  private volatile ZKHelixAdmin _zkHelixAdmin;\n+  private volatile ClusterSetup _clusterSetup;\n+  private volatile ConfigAccessor _configAccessor;\n   // A lazily-initialized base data accessor that reads/writes byte array to ZK\n   // TODO: Only read (deserialize) is supported at this time. This baseDataAccessor should support write (serialize) as needs arise\n   private volatile ZkBaseDataAccessor<byte[]> _byteArrayZkBaseDataAccessor;\n   // 1 Cluster name will correspond to 1 helix data accessor\n   private final Map<String, HelixDataAccessor> _helixDataAccessorPool;\n   // 1 Cluster name will correspond to 1 task driver\n   private final Map<String, TaskDriver> _taskDriverPool;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5NTE4MA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU4NDIwMQ==", "bodyText": "If multiZk system config is not set and MSDS routing data is not available (which is the case for a single-zk realm user), you cannot create a FederatedZkClient. Does that make sense? So we need to preserve the behavior if the user is not using the multi-zk feature.", "url": "https://github.com/apache/helix/pull/908#discussion_r397584201", "createdAt": "2020-03-25T03:05:37Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;\n+\n+  private volatile ZKHelixAdmin _zkHelixAdmin;\n+  private volatile ClusterSetup _clusterSetup;\n+  private volatile ConfigAccessor _configAccessor;\n   // A lazily-initialized base data accessor that reads/writes byte array to ZK\n   // TODO: Only read (deserialize) is supported at this time. This baseDataAccessor should support write (serialize) as needs arise\n   private volatile ZkBaseDataAccessor<byte[]> _byteArrayZkBaseDataAccessor;\n   // 1 Cluster name will correspond to 1 helix data accessor\n   private final Map<String, HelixDataAccessor> _helixDataAccessorPool;\n   // 1 Cluster name will correspond to 1 task driver\n   private final Map<String, TaskDriver> _taskDriverPool;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5NTE4MA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA1NTU1NQ==", "bodyText": "I agree with that. But the routing logic should not be at service layer. Otherwise, each service using TaskDriver or ConfigAccessor will have their own routing logic.\nTaskDriver / Config Accessor is instantiated from RealmAwareZKClient. Then can we make some smart things underneath for sharding key routing?", "url": "https://github.com/apache/helix/pull/908#discussion_r398055555", "createdAt": "2020-03-25T17:53:57Z", "author": {"login": "junkaixue"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;\n+\n+  private volatile ZKHelixAdmin _zkHelixAdmin;\n+  private volatile ClusterSetup _clusterSetup;\n+  private volatile ConfigAccessor _configAccessor;\n   // A lazily-initialized base data accessor that reads/writes byte array to ZK\n   // TODO: Only read (deserialize) is supported at this time. This baseDataAccessor should support write (serialize) as needs arise\n   private volatile ZkBaseDataAccessor<byte[]> _byteArrayZkBaseDataAccessor;\n   // 1 Cluster name will correspond to 1 helix data accessor\n   private final Map<String, HelixDataAccessor> _helixDataAccessorPool;\n   // 1 Cluster name will correspond to 1 task driver\n   private final Map<String, TaskDriver> _taskDriverPool;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5NTE4MA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NjE2OA==", "bodyText": "I understand your concern and where you're coming from.  But it's still difficult. TaskDriver and ConfigAccessor are different APIs by design.\n\nTaskDriver/HelixManager/HelixDataAccessor -> only serve 1 single Helix cluster\nConfigAccessor/ClusterSetup/etc.. -> can serve many Helix clusters\nSo we need to keep a pool regardless.\nTo help you understand:\n\n  public TaskDriver(HelixManager manager) {\n  }\n  @Deprecated\n  public TaskDriver(RealmAwareZkClient client, String clusterName) {\n  }\n  @Deprecated\n  public TaskDriver(RealmAwareZkClient client, ZkBaseDataAccessor<ZNRecord> baseAccessor,\n      String clusterName) {}\n  @Deprecated\n  public TaskDriver(HelixAdmin admin, HelixDataAccessor accessor, ConfigAccessor cfgAccessor,\n      HelixPropertyStore<ZNRecord> propertyStore, String clusterName) {\n    this(admin, accessor, propertyStore, clusterName);\n  }\n\nYou see that every constructor of TaskDriver takes in a cluster name.\nAlthough TaskDriver does not support any ephemeral operations, by design it's meant to be a single cluster API.\nI think what you wanted to see was to pass in some FederatedZkClient into TaskDriver and use one TaskDriver for all clusters, but 1) that does not work, and 2) if we wanted to make that work, that's going to require a lot of code change in TaskDriver.", "url": "https://github.com/apache/helix/pull/908#discussion_r398066168", "createdAt": "2020-03-25T18:09:30Z", "author": {"login": "narendly"}, "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -20,42 +20,67 @@\n  * under the License.\n  */\n \n-import java.util.HashMap;\n+import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixAdmin;\n import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n import org.apache.helix.InstanceType;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.SystemPropertyKeys;\n import org.apache.helix.manager.zk.ZKHelixAdmin;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n-import org.apache.helix.manager.zk.ZNRecordSerializer;\n import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n import org.apache.helix.task.TaskDriver;\n import org.apache.helix.tools.ClusterSetup;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.IZkStateListener;\n import org.apache.helix.zookeeper.zkclient.exception.ZkMarshallingError;\n import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.Watcher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n-public class ServerContext {\n+public class ServerContext implements IZkDataListener, IZkChildListener, IZkStateListener {\n+  private static final Logger LOG = LoggerFactory.getLogger(ServerContext.class);\n+\n   private final String _zkAddr;\n-  private HelixZkClient _zkClient;\n-  private ZKHelixAdmin _zkHelixAdmin;\n-  private ClusterSetup _clusterSetup;\n-  private ConfigAccessor _configAccessor;\n+  private volatile RealmAwareZkClient _zkClient;\n+\n+  private volatile ZKHelixAdmin _zkHelixAdmin;\n+  private volatile ClusterSetup _clusterSetup;\n+  private volatile ConfigAccessor _configAccessor;\n   // A lazily-initialized base data accessor that reads/writes byte array to ZK\n   // TODO: Only read (deserialize) is supported at this time. This baseDataAccessor should support write (serialize) as needs arise\n   private volatile ZkBaseDataAccessor<byte[]> _byteArrayZkBaseDataAccessor;\n   // 1 Cluster name will correspond to 1 helix data accessor\n   private final Map<String, HelixDataAccessor> _helixDataAccessorPool;\n   // 1 Cluster name will correspond to 1 task driver\n   private final Map<String, TaskDriver> _taskDriverPool;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5NTE4MA=="}, "originalCommit": {"oid": "5389a84dccb40ff5d760851e617b201f0d2b8a28"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1408, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}