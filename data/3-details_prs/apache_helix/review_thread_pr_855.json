{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMzk0MjIy", "number": 855, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxNzozMVrODlOSKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1NDoyNFrODnR9vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzU3OTI5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxNzozMVrOFx_tOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxNzozMVrOFx_tOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2ODMxMg==", "bodyText": "ZkBaseDataAccessor needs to be able to take in Connection and Client configs. Instead of a constructor that takes in 0 parameters, could we use the builder pattern to achieve this? See the example for ConfigAccessor.", "url": "https://github.com/apache/helix/pull/855#discussion_r387968312", "createdAt": "2020-03-04T22:17:31Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,14 +107,31 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private static final String EMPTY_ZK_ADDRESS = \"\";\n+\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * This default constructor attempts to connect to ZK on multi-realm mode.\n+   *\n+   * @exception IllegalStateException if connecting to ZK on multi-realm mode fails\n+   */\n+  public ZkBaseDataAccessor() {\n+    this(EMPTY_ZK_ADDRESS);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "383fbd3bdfc6a7eda0791600e097fa1ed245e2b9"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzU4MjA5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxODozMVrOFx_u3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxODozMVrOFx_u3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2ODczNQ==", "bodyText": "Under what circumstances will IllegalArgumentException be thrown?", "url": "https://github.com/apache/helix/pull/855#discussion_r387968735", "createdAt": "2020-03-04T22:18:31Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1251,41 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    RealmAwareZkClient zkClient;\n+\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IllegalArgumentException | IOException | InvalidRoutingDataException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "383fbd3bdfc6a7eda0791600e097fa1ed245e2b9"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDI5NTE0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTowMzozNlrOFyGgPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTowMzozNlrOFyGgPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3OTY3Nw==", "bodyText": "Could we move up this constructor so it's with other public constructors?", "url": "https://github.com/apache/helix/pull/855#discussion_r388079677", "createdAt": "2020-03-05T05:03:36Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private ZkBaseDataAccessor(Builder builder) throws IOException, InvalidRoutingDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c250acf155da2f6d20df98f82a108f16031d71df"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDI5NTg3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTowNDoyM1rOFyGgvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjo0NDozOFrOFyrjyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3OTgwNQ==", "bodyText": "We'd need ZkBaseDataAccessor-specific parameters here as well such as ZkClientType (See #863 for reference)", "url": "https://github.com/apache/helix/pull/855#discussion_r388079805", "createdAt": "2020-03-05T05:04:23Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c250acf155da2f6d20df98f82a108f16031d71df"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY4Njc5Mg==", "bodyText": "Got it.", "url": "https://github.com/apache/helix/pull/855#discussion_r388686792", "createdAt": "2020-03-06T02:44:38Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3OTgwNQ=="}, "originalCommit": {"oid": "c250acf155da2f6d20df98f82a108f16031d71df"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDI5NzQzOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTowNTozNVrOFyGhpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNTowNTozNVrOFyGhpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4MDAzNg==", "bodyText": "Ideally, validation logic should also resolve things like ZkClientType (if it's not set), so that the constructor should only worry about \"constructing\", not figuring out what's set or not. Let's try to separate logic as much as we can - this will help future development much easier in my opinion.", "url": "https://github.com/apache/helix/pull/855#discussion_r388080036", "createdAt": "2020-03-05T05:05:35Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c250acf155da2f6d20df98f82a108f16031d71df"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTUxNDIxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozNTowN1rOFzLOqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzowNzowM1rOFzSI4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTY3NA==", "bodyText": "Do we have a PR for HelixDataAccessor as well?", "url": "https://github.com/apache/helix/pull/855#discussion_r389205674", "createdAt": "2020-03-07T00:35:07Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,21 +108,75 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODg4Mg==", "bodyText": "As we discussed offline, we decided not to add a builder constructor for HelixDataAccessor.\nThe reason is: Underneath it is using a BaseDataAccessor, which could an instance of ZkBaseDataAccessor/ZkCacheBaseDataAccessor/HelixPropertyStore, etc.. If we offer a builder constructor, we have to determine which instance of BaseDataAccessor. If we just offer a builder constructor like this Builder().setBaseDataAccessor(), I don\u2019t think we need it.", "url": "https://github.com/apache/helix/pull/855#discussion_r389318882", "createdAt": "2020-03-07T23:07:03Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,21 +108,75 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTY3NA=="}, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTUxNTM1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozNjowNFrOFzLPXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMzowNzoyMFrOFzSI5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTg1NA==", "bodyText": "As discussed offline, please make sure you're throwing a HelixException and propagating the Exception.\nNote that we shouldn't fall back to single-realm mode. We should fail here.", "url": "https://github.com/apache/helix/pull/855#discussion_r389205854", "createdAt": "2020-03-07T00:36:04Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,21 +108,75 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    RealmAwareZkClient zkClient;\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+              builder.realmAwareZkClientConfig);\n+          // Break here to exit.\n+          break;\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          if (builder.zkAddress == null || builder.zkAddress.isEmpty()) {\n+            throw new IllegalStateException(\"Not able to connect on multi-realm mode.\", e);\n+          }\n+          LOG.info(\"Not able to connect on multi-realm mode. \"\n+              + \"Connecting on single-realm mode to ZK: {}\", builder.zkAddress);\n+          builder.setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM);\n+        }\n+        // No break here. If connecting on multi-realm fails and ZK address is valid, connecting\n+        // on single-realm is allowed.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODg4NQ==", "bodyText": "Done.", "url": "https://github.com/apache/helix/pull/855#discussion_r389318885", "createdAt": "2020-03-07T23:07:20Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,21 +108,75 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    RealmAwareZkClient zkClient;\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+              builder.realmAwareZkClientConfig);\n+          // Break here to exit.\n+          break;\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          if (builder.zkAddress == null || builder.zkAddress.isEmpty()) {\n+            throw new IllegalStateException(\"Not able to connect on multi-realm mode.\", e);\n+          }\n+          LOG.info(\"Not able to connect on multi-realm mode. \"\n+              + \"Connecting on single-realm mode to ZK: {}\", builder.zkAddress);\n+          builder.setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM);\n+        }\n+        // No break here. If connecting on multi-realm fails and ZK address is valid, connecting\n+        // on single-realm is allowed.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTg1NA=="}, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTUxNjA2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozNjozN1rOFzLPxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QyMjozMTowNlrOFzSBkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTk1OA==", "bodyText": "Is this break necessary?", "url": "https://github.com/apache/helix/pull/855#discussion_r389205958", "createdAt": "2020-03-07T00:36:37Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    try {\n+      return new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      // Fall back to connect on single-realm mode if failed to connect on multi-realm mode and\n+      // ZK address is not empty.\n+      LOG.info(\"Not able to connect on multi-realm mode, caused by: {}. \"\n+          + \"Connecting on single-realm mode to ZK: {}.\", e.getMessage(), zkAddress);\n+    }\n+\n+    RealmAwareZkClient zkClient;\n+\n+    switch (zkClientType) {\n+      case DEDICATED:\n+        zkClient = DedicatedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                clientConfig.createHelixZkClientConfig());\n+        break;\n+      case SHARED:\n+      default:\n+        zkClient = SharedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                clientConfig.createHelixZkClientConfig());\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzAwOA==", "bodyText": "It is just my habit: As a matter of good form, put a break after the last case (the default here) even though it's logically unnecessary. Some day when another case gets added at the end, this bit of defensive programming will save you.", "url": "https://github.com/apache/helix/pull/855#discussion_r389317008", "createdAt": "2020-03-07T22:31:06Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    try {\n+      return new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      // Fall back to connect on single-realm mode if failed to connect on multi-realm mode and\n+      // ZK address is not empty.\n+      LOG.info(\"Not able to connect on multi-realm mode, caused by: {}. \"\n+          + \"Connecting on single-realm mode to ZK: {}.\", e.getMessage(), zkAddress);\n+    }\n+\n+    RealmAwareZkClient zkClient;\n+\n+    switch (zkClientType) {\n+      case DEDICATED:\n+        zkClient = DedicatedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                clientConfig.createHelixZkClientConfig());\n+        break;\n+      case SHARED:\n+      default:\n+        zkClient = SharedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                clientConfig.createHelixZkClientConfig());\n+        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTk1OA=="}, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTUxODMxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozODozOFrOFzLRGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozODozOFrOFzLRGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNjI5OQ==", "bodyText": "Let's clearly note that this private method is only to be used for constructors that do not take a Builder in as a parameter because of the fallback behavior.", "url": "https://github.com/apache/helix/pull/855#discussion_r389206299", "createdAt": "2020-03-07T00:38:38Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTUxOTIyOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozOToyM1rOFzLRoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozOToyM1rOFzLRoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNjQzMw==", "bodyText": "Great use of logging, but let's also note here that this is for backward-compatibility for constructors that take in zkaddress or zkclient.", "url": "https://github.com/apache/helix/pull/855#discussion_r389206433", "createdAt": "2020-03-07T00:39:23Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    try {\n+      return new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      // Fall back to connect on single-realm mode if failed to connect on multi-realm mode and\n+      // ZK address is not empty.\n+      LOG.info(\"Not able to connect on multi-realm mode, caused by: {}. \"\n+          + \"Connecting on single-realm mode to ZK: {}.\", e.getMessage(), zkAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTcyODE0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1ODo1MVrOFzxIKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1ODo1MVrOFzxIKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNjYwMQ==", "bodyText": "Change comment.", "url": "https://github.com/apache/helix/pull/855#discussion_r389826601", "createdAt": "2020-03-09T16:58:51Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1280,127 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f756761cf722e33fb0ca8862ed71ee394a9ee65d"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTczNTk3OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzowMDo1OFrOFzxNMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1MjowNFrOF0obeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzg4OA==", "bodyText": "I think we should make the behavior description in the Java doc.", "url": "https://github.com/apache/helix/pull/855#discussion_r389827888", "createdAt": "2020-03-09T17:00:58Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -199,20 +238,13 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  public ZkBaseDataAccessor(String zkAddress,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f756761cf722e33fb0ca8862ed71ee394a9ee65d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMjY2NQ==", "bodyText": "As discussed offline, we don't want the fallback behavior and also make these old constructors deprecated.", "url": "https://github.com/apache/helix/pull/855#discussion_r390732665", "createdAt": "2020-03-11T03:52:04Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -199,20 +238,13 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  public ZkBaseDataAccessor(String zkAddress,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzg4OA=="}, "originalCommit": {"oid": "f756761cf722e33fb0ca8862ed71ee394a9ee65d"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTg4MTI1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1NjoxNlrOF0sO5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1NjoxNlrOF0sO5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NDk4MQ==", "bodyText": "Nit: This is already inside ZkBaseDataAccessor, so no need to qualify ZkClientTypes using ZkBaseDataAccessor. Did you copy the code from the other PRs? IDE automatically puts these things.", "url": "https://github.com/apache/helix/pull/855#discussion_r390794981", "createdAt": "2020-03-11T07:56:16Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,28 +118,85 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          if (builder.zkClientType == ZkBaseDataAccessor.ZkClientType.DEDICATED) {\n+            // Use a realm-aware dedicated zk client\n+            _zkClient = DedicatedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else if (builder.zkClientType == ZkBaseDataAccessor.ZkClientType.SHARED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faf74392d9f83a619d1aeeb85abf6709cfab6fbf"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTg4NDMxOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1NzoyM1rOF0sQuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDo0NTo0OVrOF1N84w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NTQ0OA==", "bodyText": "why do we need the long package name for this serializer?", "url": "https://github.com/apache/helix/pull/855#discussion_r390795448", "createdAt": "2020-03-11T07:57:23Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -198,21 +271,17 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param zkAddress\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n+   *\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  @Deprecated\n+  public ZkBaseDataAccessor(String zkAddress,\n+      org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer pathBasedZkSerializer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faf74392d9f83a619d1aeeb85abf6709cfab6fbf"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0NTU5NQ==", "bodyText": "It is to reduce duplicate code for 2 constructors that have serializer parameters. BasicZkSerializer implements the long path PathBasedZkSerializer interface in zookeeper module. So we need this long path zookeeper PathBasedZkSerializer.\npublic ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer, ZkClientType zkClientType) {\n  this(zkAddress, new BasicZkSerializer(zkSerializer), zkClientType);\n}\n\nCons: new BasicZkSerializer(zkSerializer) just follows the behavior in ZkClientConfig. If it is changed in ZkClientConfig to use another instance other than BasicZkSerializer, the one here would not follow that change.\nWell, if we don't want to reduce the duplicate code, we can just keep the original code.", "url": "https://github.com/apache/helix/pull/855#discussion_r391045595", "createdAt": "2020-03-11T15:14:27Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -198,21 +271,17 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param zkAddress\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n+   *\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  @Deprecated\n+  public ZkBaseDataAccessor(String zkAddress,\n+      org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer pathBasedZkSerializer,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NTQ0OA=="}, "originalCommit": {"oid": "faf74392d9f83a619d1aeeb85abf6709cfab6fbf"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NzQyNw==", "bodyText": "I'd prefer to leave it as is and tackle this later. This sort of refactoring doesn't have to be in the scope of this PR. Having 2 constructors is fine for now.", "url": "https://github.com/apache/helix/pull/855#discussion_r391347427", "createdAt": "2020-03-12T00:45:49Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -198,21 +271,17 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param zkAddress\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n+   *\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  @Deprecated\n+  public ZkBaseDataAccessor(String zkAddress,\n+      org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer pathBasedZkSerializer,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NTQ0OA=="}, "originalCommit": {"oid": "faf74392d9f83a619d1aeeb85abf6709cfab6fbf"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE1MzkwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1NDoyNFrOF1MBBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzozMToxNVrOF1MupQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTcxNg==", "bodyText": "So we do agree to support shared zkclient while in multi realm mode?", "url": "https://github.com/apache/helix/pull/855#discussion_r391315716", "createdAt": "2020-03-11T22:54:24Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,28 +118,85 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+            // Use a realm-aware dedicated zk client\n+            _zkClient = DedicatedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else if (builder.zkClientType == ZkClientType.SHARED) {\n+            // Use a realm-aware shared zk client\n+            _zkClient = SharedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b83c779d6638e56676d253c502a494044ee951c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNDcxMg==", "bodyText": "This is a realm aware shared Zk client. If the user wants to use it this way, then they can", "url": "https://github.com/apache/helix/pull/855#discussion_r391324712", "createdAt": "2020-03-11T23:22:26Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,28 +118,85 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+            // Use a realm-aware dedicated zk client\n+            _zkClient = DedicatedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else if (builder.zkClientType == ZkClientType.SHARED) {\n+            // Use a realm-aware shared zk client\n+            _zkClient = SharedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTcxNg=="}, "originalCommit": {"oid": "5b83c779d6638e56676d253c502a494044ee951c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNzM5Nw==", "bodyText": "@dasahcc This is a realm-aware shared ZkClient. Users could construct the client with the sharding key on multi-realm mode.", "url": "https://github.com/apache/helix/pull/855#discussion_r391327397", "createdAt": "2020-03-11T23:31:15Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,28 +118,85 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+            // Use a realm-aware dedicated zk client\n+            _zkClient = DedicatedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else if (builder.zkClientType == ZkClientType.SHARED) {\n+            // Use a realm-aware shared zk client\n+            _zkClient = SharedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTcxNg=="}, "originalCommit": {"oid": "5b83c779d6638e56676d253c502a494044ee951c"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1332, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}