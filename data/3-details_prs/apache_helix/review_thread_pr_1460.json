{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxODg2MjQx", "number": 1460, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNzowOTowMVrOEtJCqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0MToyNVrOEvg9Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NzY5NTE0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNzowOTowMVrOHgxJIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMTo1NDozOFrOHg63LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA==", "bodyText": "A question regarding the description, if the error is just logged here, meaning the users won't really know there is a mismatch. If the callback is not done, they won't be able to distinguish between this error and other errors. Is this the expected behavior?", "url": "https://github.com/apache/helix/pull/1460#discussion_r504121634", "createdAt": "2020-10-13T17:09:01Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyODMwNQ==", "bodyText": "You mean they wouldn't be able to distinguish \"stale messages\" vs \"messages that don't have callbacks set up correctly\"? I think these cases are logically the same and can't be easily distinguished code-level. If we are loosening up on one case, it's going to affect the other.\nOn the other hand, callback registration is done in our code and naturally there should be a callback before sending messages that require replies. I imagine the previous check was there for cautionary purpose, not that messages are commonly created with incorrect correlation ids.", "url": "https://github.com/apache/helix/pull/1460#discussion_r504128305", "createdAt": "2020-10-13T17:19:33Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE1Mjc5Mg==", "bodyText": "Actually I meant this missing ID exception and exceptions in the later functions in onReply. Do we need to consider distinguishing between them? like in your test Assert.assertFalse(callback.isDone()). Any other errors may happen in middle?", "url": "https://github.com/apache/helix/pull/1460#discussion_r504152792", "createdAt": "2020-10-13T18:01:41Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3MTQyOA==", "bodyText": "I'm not sure I follow: this is not a \"try\" block, this is an \"if\" block. There's no exception handling here.", "url": "https://github.com/apache/helix/pull/1460#discussion_r504171428", "createdAt": "2020-10-13T18:29:37Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3Mjk0Mg==", "bodyText": "All i would like to ask is whether removing the previous thrown exception will cause any information lost. If it's ok, then I'm fine.", "url": "https://github.com/apache/helix/pull/1460#discussion_r504172942", "createdAt": "2020-10-13T18:32:24Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI3OTc3NQ==", "bodyText": "I see what you mean now: you're saying in both cases, callback.isDone() == false, and it can't be distinguished whether the callback failed or there's no callback registered.\nIf the callback fails due to some exception like you said, the task result will reflect that (setException(e), setInterrupted(true)). It's more difficult to tell the \"callback not registered\" case, but since customers don't want exceptions raised, there isn't any better way here.", "url": "https://github.com/apache/helix/pull/1460#discussion_r504279775", "createdAt": "2020-10-13T21:52:14Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI4MDg3Ng==", "bodyText": "Yep, that's what I meant. I think it's not a big concern.", "url": "https://github.com/apache/helix/pull/1460#discussion_r504280876", "createdAt": "2020-10-13T21:54:38Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -113,12 +104,19 @@ public HelixTaskResult handleMessage() throws InterruptedException {\n           + _correlationId);\n \n       AsyncCallback callback = _callbackMap.get(_correlationId);\n-      synchronized (callback) {\n-        callback.onReply(_message);\n-        if (callback.isDone()) {\n-          _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n-          _callbackMap.remove(_correlationId);\n+      if (callback != null) {\n+        synchronized (callback) {\n+          callback.onReply(_message);\n+          if (callback.isDone()) {\n+            _logger.info(\"Removing finished callback, correlationid:\" + _correlationId);\n+            _callbackMap.remove(_correlationId);\n+          }\n         }\n+      } else {\n+        String msg = \"Message \" + _message.getMsgId()\n+            + \" does not have correponding callback. Probably timed out already. Correlation id: \"\n+            + _correlationId;\n+        _logger.warn(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMTYzNA=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTEzMDE2OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMToxMToyM1rOHg-r8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxODoyNjo1NlrOHhfuyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MzUzOQ==", "bodyText": "Alternatively, if the exception is not graceful, we can return null when createHandler() is triggered. This is much better than returning a handler that does nothing (but still consume system resources).\nOf course, the callers of createHandler() need to be improved to tolerate the null return value.", "url": "https://github.com/apache/helix/pull/1460#discussion_r504343539", "createdAt": "2020-10-14T01:11:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -62,15 +62,6 @@ void verifyMessage(Message message) {\n       throw new HelixException(errorMsg);\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg4NDkzNw==", "bodyText": "You brought up a very good point, although for our scenario, ZK read probably fails before an effective DOS. I understand this reminds you of some TCP DOS. :)\nIf you could check out HelixTaskExecutor, at around line 900, you can see how we handle null return value for createHandler(). The current approach is to skip the message without cleaning it up. I could explore on changing this current approach (because we need to clean up those reply messages), but such a change will impact other message handlings as well (such as state transition messages).", "url": "https://github.com/apache/helix/pull/1460#discussion_r504884937", "createdAt": "2020-10-14T18:26:56Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/AsyncCallbackService.java", "diffHunk": "@@ -62,15 +62,6 @@ void verifyMessage(Message message) {\n       throw new HelixException(errorMsg);\n     }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MzUzOQ=="}, "originalCommit": {"oid": "f602d70367538594a22f79d20e4b5c5520a7b3f2"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjU4NDg3OnYy", "diffSide": "RIGHT", "path": "helix-common/src/main/java/org/apache/helix/HelixException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0MToyNVrOHkispA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNTowN1rOHkkEjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3OTI2OA==", "bodyText": "So RuntimeException can be configured not to have stack trace out.", "url": "https://github.com/apache/helix/pull/1460#discussion_r508079268", "createdAt": "2020-10-19T21:41:25Z", "author": {"login": "kaisun2000"}, "path": "helix-common/src/main/java/org/apache/helix/HelixException.java", "diffHunk": "@@ -30,6 +30,16 @@ public HelixException(String message) {\n     super(message);\n   }\n \n+  /**\n+   * Create a HelixException that can optionally turn off stack trace. Its other characteristics are\n+   * the same as a HelixException with a message.\n+   * @param message the detail message\n+   * @param writableStackTrace whether or not the stack trace should be writable\n+   */\n+  public HelixException(String message, boolean writableStackTrace) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a19533b1e091bc75872ebcd62000cad13aee5dc"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTc3Mg==", "bodyText": "Yes sir", "url": "https://github.com/apache/helix/pull/1460#discussion_r508101772", "createdAt": "2020-10-19T22:35:07Z", "author": {"login": "NealSun96"}, "path": "helix-common/src/main/java/org/apache/helix/HelixException.java", "diffHunk": "@@ -30,6 +30,16 @@ public HelixException(String message) {\n     super(message);\n   }\n \n+  /**\n+   * Create a HelixException that can optionally turn off stack trace. Its other characteristics are\n+   * the same as a HelixException with a message.\n+   * @param message the detail message\n+   * @param writableStackTrace whether or not the stack trace should be writable\n+   */\n+  public HelixException(String message, boolean writableStackTrace) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3OTI2OA=="}, "originalCommit": {"oid": "9a19533b1e091bc75872ebcd62000cad13aee5dc"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1022, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}