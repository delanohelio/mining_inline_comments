{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NTY0MzMx", "number": 899, "title": "Use Java Generics and inheritance to reduce duplicate code in Helix API Builders", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nResolves #873\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR removes duplicate logic and refactors the ZK helix API Builder logic into one single public abstract class so that other Builders can inherit from it. It makes use of Builder inheritance and Java Generics. This PR promotes code reuse and better craftsmanship.\nTests\n\n The following tests are written for this issue:\n\nTest coverage already exists for this functionality.\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Results:\n[INFO] \n[ERROR] Failures: \n[ERROR]   TestEnableCompression.testEnableCompressionResource:117 expected:<true> but was:<false>\n[ERROR]   TestControllerLeadershipChange.testMissingTopStateDurationMonitoring:262 expected:<true> but was:<false>\n[INFO] \n[ERROR] Tests run: 1097, Failures: 2, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:11 h\n[INFO] Finished at: 2020-03-19T19:01:09-07:00\n[INFO] ------------------------------------------------------------------------\n\nTests run for failed tests:\n[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 31.62 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:12 min\n[INFO] Finished at: 2020-03-19T20:35:31-07:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-03-17T00:52:40Z", "url": "https://github.com/apache/helix/pull/899", "merged": true, "mergeCommit": {"oid": "30ea659a654f796fbabb96a978b9b49abc8d8406"}, "closed": true, "closedAt": "2020-03-21T04:28:39Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOmJQ6AFqTM3NjIyNDU0OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPtWZKAH2gAyMzg5NTY0MzMxOmE4NWRmZWNlNGNhOGNmNjRkZWI3N2ZiN2NlNjM0NTE3ZGU0NWY2MmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MjI0NTQ4", "url": "https://github.com/apache/helix/pull/899#pullrequestreview-376224548", "createdAt": "2020-03-17T16:54:55Z", "commit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjo1NDo1NlrOF3lUCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNzoyNjowNlrOF3miFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNzMzOQ==", "bodyText": "nit, this is more a question, I think you have thought about this. Shall we call it GenericHelixZkApiBuilder?", "url": "https://github.com/apache/helix/pull/899#discussion_r393827339", "createdAt": "2020-03-17T16:54:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -932,73 +933,13 @@ public void close() {\n     }\n   }\n \n-  public static class Builder {\n-    private String _zkAddress;\n-    private RealmAwareZkClient.RealmMode _realmMode;\n-    private RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n-    private RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n-\n+  public static class Builder extends GenericZkHelixApiBuilder<Builder> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NDQ5Mw==", "bodyText": "The following logic looks generic enough to put in GenericZkHelixApiBuilder. And this ZkBaseDataAccessor constructor can directly get a zkclient instance as the input.", "url": "https://github.com/apache/helix/pull/899#discussion_r393844493", "createdAt": "2020-03-17T17:21:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -142,22 +142,22 @@ public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n   }\n \n   private ZkBaseDataAccessor(Builder<T> builder) {\n-    switch (builder.realmMode) {\n+    switch (builder.getRealmMode()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA==", "bodyText": "Following the previous comment, I can see this zkClientType is an exception which is not common for all the GenericZkHelixApiBuilder child classes' logic. In this case, we can let the ZkBaseDataAccessor builder extends my proposed GenericZkHelixApiBuilder method which creates a ZkClient, and in this extended method, we read and apply this _zkClientType.", "url": "https://github.com/apache/helix/pull/899#discussion_r393846480", "createdAt": "2020-03-17T17:24:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -142,22 +142,22 @@ public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n   }\n \n   private ZkBaseDataAccessor(Builder<T> builder) {\n-    switch (builder.realmMode) {\n+    switch (builder.getRealmMode()) {\n       case MULTI_REALM:\n         try {\n-          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+          if (builder._zkClientType == ZkClientType.DEDICATED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NzMxNw==", "bodyText": "Or, if there are more than one builders require zkClientType, we can have another generic builder which includes the zkClientType logic and let it to extend GenericZkHelixApiBuilder.", "url": "https://github.com/apache/helix/pull/899#discussion_r393847317", "createdAt": "2020-03-17T17:26:06Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -142,22 +142,22 @@ public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n   }\n \n   private ZkBaseDataAccessor(Builder<T> builder) {\n-    switch (builder.realmMode) {\n+    switch (builder.getRealmMode()) {\n       case MULTI_REALM:\n         try {\n-          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+          if (builder._zkClientType == ZkClientType.DEDICATED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}, "originalCommit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a35b2cec65d18f1b5442a4210b3264e3d5c4b64", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/9a35b2cec65d18f1b5442a4210b3264e3d5c4b64", "committedDate": "2020-03-17T17:49:42Z", "message": "asdfsfa"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0447fb2dde8c60566c2ea32c948728e0dfce5bf", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/f0447fb2dde8c60566c2ea32c948728e0dfce5bf", "committedDate": "2020-03-17T17:49:42Z", "message": "Refactor Builders into GenericZkHelixApiBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63dce2cf5d177664f2f4533fd33c8db5357faecd", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/63dce2cf5d177664f2f4533fd33c8db5357faecd", "committedDate": "2020-03-17T17:49:42Z", "message": "fix stackoverflow"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/988e67768cc04ca8853cb76815aa2f926f97072f", "committedDate": "2020-03-17T02:53:05Z", "message": "fix stackoverflow"}, "afterCommit": {"oid": "63dce2cf5d177664f2f4533fd33c8db5357faecd", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/63dce2cf5d177664f2f4533fd33c8db5357faecd", "committedDate": "2020-03-17T17:49:42Z", "message": "fix stackoverflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb764b1e6403d0c983c6882d0488e82a84c5df64", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/bb764b1e6403d0c983c6882d0488e82a84c5df64", "committedDate": "2020-03-17T17:55:57Z", "message": "Remove multizkenvironment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44fb4ca71771eeff1776eb5fd4244af089c20a47", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/44fb4ca71771eeff1776eb5fd4244af089c20a47", "committedDate": "2020-03-17T19:32:01Z", "message": "Refactor further"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MjcxODM1", "url": "https://github.com/apache/helix/pull/899#pullrequestreview-377271835", "createdAt": "2020-03-18T22:12:20Z", "commit": {"oid": "44fb4ca71771eeff1776eb5fd4244af089c20a47"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMjoxMjoyMFrOF4YsDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMjoxNjo0OVrOF4Yy5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2OTA3MQ==", "bodyText": "Isn't this switch block identical to the ones in ZKHelixAdmin and ClusterSetup? IMO, let the builder have a method for creating a ZkClient is simpler and easier to maintain.", "url": "https://github.com/apache/helix/pull/899#discussion_r394669071", "createdAt": "2020-03-18T22:12:20Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -87,11 +88,11 @@\n    * @param builder\n    */\n   private ConfigAccessor(Builder builder) {\n-    switch (builder._realmMode) {\n+    switch (builder.getRealmMode()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44fb4ca71771eeff1776eb5fd4244af089c20a47"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MDgyMg==", "bodyText": "I would prefer 2. Once a class is designed with a builder, the builder should contain most of the complicated building logic. IMHO, including which client to use. Then the real private constructor of the Accessor just takes whatever client it is given. Although both ways avoid duplicate code, method 2 encapsulates the logic more closely.\nActually, it is an option that you put this logic into the generic builder. For the other accessors, this type can be fixed in the implemented builder class.", "url": "https://github.com/apache/helix/pull/899#discussion_r394670822", "createdAt": "2020-03-18T22:16:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -142,22 +142,22 @@ public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n   }\n \n   private ZkBaseDataAccessor(Builder<T> builder) {\n-    switch (builder.realmMode) {\n+    switch (builder.getRealmMode()) {\n       case MULTI_REALM:\n         try {\n-          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+          if (builder._zkClientType == ZkClientType.DEDICATED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0NjQ4MA=="}, "originalCommit": {"oid": "988e67768cc04ca8853cb76815aa2f926f97072f"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3Mjg0MTEw", "url": "https://github.com/apache/helix/pull/899#pullrequestreview-377284110", "createdAt": "2020-03-18T22:34:11Z", "commit": {"oid": "44fb4ca71771eeff1776eb5fd4244af089c20a47"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "836c112b3e9a7b49709ec5c3a72afdf18d46de71", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/836c112b3e9a7b49709ec5c3a72afdf18d46de71", "committedDate": "2020-03-19T04:48:13Z", "message": "move construction logic to builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/5c12189b59ba442c3ee88fdfadab0a3e38b8f399", "committedDate": "2020-03-19T04:52:15Z", "message": "asdf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTIyNDk4", "url": "https://github.com/apache/helix/pull/899#pullrequestreview-378122498", "createdAt": "2020-03-19T21:57:50Z", "commit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo1Nzo1MFrOF5BzHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoyOTozMVrOF5CkDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MjYyMw==", "bodyText": "Is it intended to be done with a different name in the parent class? Note in the child builder it is called createRealmAwareZkClientFromBuilder().\nOne of the reasons that I want to use the same name is avoiding the caller to be confused when they have more than one method to call when they try to get a ZkClient instance from the builder.", "url": "https://github.com/apache/helix/pull/899#discussion_r395342623", "createdAt": "2020-03-19T21:57:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {\n+  protected String _zkAddress;\n+  protected RealmAwareZkClient.RealmMode _realmMode;\n+  protected RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+  protected RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+  public B setZkAddress(String zkAddress) {\n+    _zkAddress = zkAddress;\n+    return self();\n+  }\n+\n+  public B setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+    _realmMode = realmMode;\n+    return self();\n+  }\n+\n+  public B setRealmAwareZkConnectionConfig(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+    _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+    return self();\n+  }\n+\n+  public RealmAwareZkClient.RealmAwareZkConnectionConfig getRealmAwareZkConnectionConfig() {\n+    return _realmAwareZkConnectionConfig;\n+  }\n+\n+  public B setRealmAwareZkClientConfig(\n+      RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+    _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+    return self();\n+  }\n+\n+  /**\n+   * Validates the given Builder parameters using a generic validation logic.\n+   */\n+  protected void validate() {\n+    // Resolve RealmMode based on whether ZK address has been set\n+    boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+    if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+      throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+    }\n+    if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n+      throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n+    }\n+    if (_realmMode == null) {\n+      _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+          : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+    }\n+\n+    initializeConfigsIfNull();\n+  }\n+\n+  /**\n+   * Initializes Realm-aware ZkConnection and ZkClient configs if they haven't been set.\n+   */\n+  protected void initializeConfigsIfNull() {\n+    // Resolve all default values\n+    if (_realmAwareZkConnectionConfig == null) {\n+      _realmAwareZkConnectionConfig =\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+    }\n+\n+    // For Helix APIs, ZNRecord should be the default data model\n+    if (_realmAwareZkClientConfig == null) {\n+      _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n+          .setZkSerializer(new ZNRecordSerializer());\n+    }\n+  }\n+\n+  /**\n+   * Creates a RealmAwareZkClient based on the parameters set.\n+   * To be used in Helix ZK APIs' constructors: ConfigAccessor, ClusterSetup, ZKHelixAdmin\n+   * @return\n+   */\n+  public RealmAwareZkClient createZkClientFromBuilder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzY5NQ==", "bodyText": "I would prefer to leverage builder here as well. So we can merge the logic of buildRealmAwareZkClientWithDefaultConfigs into the builder.\nNot sure if there are any conflicts. If there are, I don't have a strong preference that we have to do this change.", "url": "https://github.com/apache/helix/pull/899#discussion_r395343695", "createdAt": "2020-03-19T22:00:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -260,10 +217,9 @@ public ZkBaseDataAccessor(String zkAddress, ZkClientType zkClientType) {\n   @Deprecated\n   public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n       ZkClientType zkClientType) {\n-    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n-        new RealmAwareZkClient.RealmAwareZkClientConfig().setZkSerializer(zkSerializer);\n-\n-    _zkClient = buildRealmAwareZkClient(clientConfig, zkAddress, zkClientType);\n+    _zkClient = buildRealmAwareZkClientWithDefaultConfigs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDAwMA==", "bodyText": "Not sure if we can merge it to the builder logic? If not possible for now, let's have a TODO here.", "url": "https://github.com/apache/helix/pull/899#discussion_r395344000", "createdAt": "2020-03-19T22:01:03Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1390,65 +1311,23 @@ public Builder() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n-\n-    /*\n-     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n-     */\n-    private void validate() {\n-      // Resolve RealmMode based on other parameters\n-      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n-      boolean isZkClientTypeSet = zkClientType != null;\n-\n-      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n-      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n-        throw new HelixException(\"ZkClientType cannot be set on multi-realm mode!\");\n-      }\n-      // If ZkClientType is not set and realmMode is single-realm, default to SHARED\n-      if (!isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM) {\n-        zkClientType = ZkClientType.SHARED;\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n-        throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM\n-          && zkClientType == ZkClientType.FEDERATED) {\n-        throw new HelixException(\"FederatedZkClient cannot be set on single-realm mode!\");\n-      }\n-\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n-      // Resolve RealmAwareZkClientConfig\n-      if (realmAwareZkClientConfig == null) {\n-        realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n-            .setZkSerializer(new ZNRecordSerializer());\n-      }\n-\n-      // Resolve RealmAwareZkConnectionConfig\n-      if (realmAwareZkConnectionConfig == null) {\n-        // If not set, create a default one\n-        realmAwareZkConnectionConfig =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n-      }\n-    }\n   }\n \n-  /*\n-   * This is used for constructors that do not take a Builder in as a parameter because of\n-   * keeping backward-compatibility.\n+  /**\n+   * This method is used for constructors that are not based on the Builder for\n+   * backward-compatibility.\n+   * It checks if there is a System Property config set for Multi-ZK mode and determines if a\n+   * FederatedZkClient should be created.\n+   * @param clientConfig default RealmAwareZkClientConfig with ZK serializer set\n+   * @param zkAddress\n+   * @param zkClientType\n+   * @return\n    */\n-  private RealmAwareZkClient buildRealmAwareZkClient(\n+  static RealmAwareZkClient buildRealmAwareZkClientWithDefaultConfigs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDE0Mw==", "bodyText": "Same here.", "url": "https://github.com/apache/helix/pull/899#discussion_r395344143", "createdAt": "2020-03-19T22:01:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -126,41 +117,9 @@ public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths, String monitorType, String monitorkey,\n       ZkBaseDataAccessor.ZkClientType zkClientType) {\n-\n-    // If the multi ZK config is enabled, use multi-realm mode with FederatedZkClient\n-    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {\n-      try {\n-        RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder connectionConfigBuilder =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder();\n-        RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n-            new RealmAwareZkClient.RealmAwareZkClientConfig();\n-        clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n-            .setMonitorKey(monitorkey);\n-        // Use a federated zk client\n-        _zkClient = new FederatedZkClient(connectionConfigBuilder.build(), clientConfig);\n-      } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-        // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be\n-        // found\n-        throw new HelixException(\"Failed to create ZkCacheBaseDataAccessor!\", e);\n-      }\n-    } else {\n-      HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-      clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n-          .setMonitorKey(monitorkey);\n-      switch (zkClientType) {\n-        case DEDICATED:\n-          _zkClient = DedicatedZkClientFactory.getInstance()\n-              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n-                  new HelixZkClient.ZkClientConfig().setZkSerializer(serializer));\n-          break;\n-        case SHARED:\n-        default:\n-          _zkClient = SharedZkClientFactory.getInstance()\n-              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-      }\n-      _zkClient.waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n-    }\n-\n+    _zkClient = ZkBaseDataAccessor.buildRealmAwareZkClientWithDefaultConfigs(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NjE1OQ==", "bodyText": "The reason we call the path as \"shardingkey\" is to make it more generic. If we assign it to the clusterName, it means we set a strong assumption here that for Helix, the shardingkey == clusterName. Although this assumption is valid, the code is confusing.\nSo shall we add an additional method builder.getClusterName() to avoid confusion? The internal logic is the same. Note that both builder classes are in Helix-core. So we should reduce exposing Realm concept if not necessary.", "url": "https://github.com/apache/helix/pull/899#discussion_r395346159", "createdAt": "2020-03-19T22:06:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java", "diffHunk": "@@ -144,23 +145,11 @@ public ZkHelixClusterVerifier(String zkAddr, String clusterName) {\n     _keyBuilder = _accessor.keyBuilder();\n   }\n \n-  protected ZkHelixClusterVerifier(Builder builder) {\n-    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {\n-      try {\n-        // First, try to create a RealmAwareZkClient that's a DedicatedZkClient\n-        _zkClient = DedicatedZkClientFactory.getInstance()\n-            .buildZkClient(builder._realmAwareZkConnectionConfig,\n-                builder._realmAwareZkClientConfig);\n-      } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-        throw new HelixException(\"ZkHelixClusterVerifier: failed to create ZkClient!\", e);\n-      }\n-    } else {\n-      _zkClient = DedicatedZkClientFactory.getInstance()\n-          .buildZkClient(new HelixZkClient.ZkConnectionConfig(builder._zkAddress));\n-    }\n-    _usesExternalZkClient = false;\n+  protected <B extends Builder<B>> ZkHelixClusterVerifier(Builder<B> builder) {\n+    _zkClient = builder.createZkClientFromBuilderForVerifier();\n     _zkClient.setZkSerializer(new ZNRecordSerializer());\n-    _clusterName = builder._realmAwareZkConnectionConfig.getZkRealmShardingKey();\n+    _usesExternalZkClient = false;\n+    _clusterName = builder.getRealmAwareZkConnectionConfig().getZkRealmShardingKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NjUzOA==", "bodyText": "More java doc to specify what's the difference between types, please.", "url": "https://github.com/apache/helix/pull/899#discussion_r395346538", "createdAt": "2020-03-19T22:07:25Z", "author": {"login": "jiajunwang"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ZkClientType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package org.apache.helix.zookeeper.api.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+public enum ZkClientType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NzM1OA==", "bodyText": "nit, return setZkClientType(Enum.valueOf(ZkClientType.class, zkClientType.name()));", "url": "https://github.com/apache/helix/pull/899#discussion_r395347358", "createdAt": "2020-03-19T22:09:27Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.api.client.ZkClientType;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericBaseDataAccessorBuilder serves as the abstract parent class for Builders used by\n+ * BaseDataAccessor APIs that create ZK connections. By having this class, we promote code-reuse.\n+ * @param <B>\n+ */\n+public class GenericBaseDataAccessorBuilder<B extends GenericBaseDataAccessorBuilder<B>> extends GenericZkHelixApiBuilder<B> {\n+  /** ZK-based BaseDataAccessor-specific parameter **/\n+  private ZkClientType _zkClientType;\n+\n+  /**\n+   * Sets the ZkClientType.\n+   * If this is set to either DEDICATED or SHARED, this accessor will be created on\n+   * single-realm mode.\n+   * If this is set to FEDERATED, multi-realm mode will be used.\n+   * @param zkClientType\n+   * @return\n+   */\n+  public B setZkClientType(ZkBaseDataAccessor.ZkClientType zkClientType) {\n+    _zkClientType = Enum.valueOf(ZkClientType.class, zkClientType.name());\n+    return self();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODE0OQ==", "bodyText": "Shall we include the target class as a template T in addition to B here? So you can define the abstract build() method to make this class more complete.", "url": "https://github.com/apache/helix/pull/899#discussion_r395348149", "createdAt": "2020-03-19T22:11:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODM0Nw==", "bodyText": "This looks nice : )", "url": "https://github.com/apache/helix/pull/899#discussion_r395348347", "createdAt": "2020-03-19T22:12:03Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {\n+  protected String _zkAddress;\n+  protected RealmAwareZkClient.RealmMode _realmMode;\n+  protected RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+  protected RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+  public B setZkAddress(String zkAddress) {\n+    _zkAddress = zkAddress;\n+    return self();\n+  }\n+\n+  public B setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+    _realmMode = realmMode;\n+    return self();\n+  }\n+\n+  public B setRealmAwareZkConnectionConfig(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+    _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+    return self();\n+  }\n+\n+  public RealmAwareZkClient.RealmAwareZkConnectionConfig getRealmAwareZkConnectionConfig() {\n+    return _realmAwareZkConnectionConfig;\n+  }\n+\n+  public B setRealmAwareZkClientConfig(\n+      RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+    _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+    return self();\n+  }\n+\n+  /**\n+   * Validates the given Builder parameters using a generic validation logic.\n+   */\n+  protected void validate() {\n+    // Resolve RealmMode based on whether ZK address has been set\n+    boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+    if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+      throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+    }\n+    if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n+      throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n+    }\n+    if (_realmMode == null) {\n+      _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+          : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+    }\n+\n+    initializeConfigsIfNull();\n+  }\n+\n+  /**\n+   * Initializes Realm-aware ZkConnection and ZkClient configs if they haven't been set.\n+   */\n+  protected void initializeConfigsIfNull() {\n+    // Resolve all default values\n+    if (_realmAwareZkConnectionConfig == null) {\n+      _realmAwareZkConnectionConfig =\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+    }\n+\n+    // For Helix APIs, ZNRecord should be the default data model\n+    if (_realmAwareZkClientConfig == null) {\n+      _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n+          .setZkSerializer(new ZNRecordSerializer());\n+    }\n+  }\n+\n+  /**\n+   * Creates a RealmAwareZkClient based on the parameters set.\n+   * To be used in Helix ZK APIs' constructors: ConfigAccessor, ClusterSetup, ZKHelixAdmin\n+   * @return\n+   */\n+  public RealmAwareZkClient createZkClientFromBuilder() {\n+    switch (_realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          return new FederatedZkClient(_realmAwareZkConnectionConfig,\n+              _realmAwareZkClientConfig.setZkSerializer(new ZNRecordSerializer()));\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          throw new HelixException(\"Failed to create FederatedZkClient!\", e);\n+        }\n+      case SINGLE_REALM:\n+        // Create a HelixZkClient: Use a SharedZkClient because ClusterSetup does not need to do\n+        // ephemeral operations\n+        return SharedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddress),\n+                _realmAwareZkClientConfig.createHelixZkClientConfig()\n+                    .setZkSerializer(new ZNRecordSerializer()));\n+      default:\n+        throw new HelixException(\"Invalid RealmMode given: \" + _realmMode);\n+    }\n+  }\n+\n+  /**\n+   * Returns an instance of a subclass-Builder in order to reduce duplicate code.\n+   * SuppressWarnings is used to rid of IDE warnings.\n+   * @return an instance of a subclass-Builder. E.g.) ConfigAccessor.Builder\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  final B self() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1MTA3Ng==", "bodyText": "I think just call it createZkClient() or createRealmAwareZkClient would be good enough.", "url": "https://github.com/apache/helix/pull/899#discussion_r395351076", "createdAt": "2020-03-19T22:18:45Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericZkHelixApiBuilder.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.helix.HelixException;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.client.FederatedZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+\n+\n+/**\n+ * GenericZkHelixApiBuilder serves as the abstract parent class for Builders used by Helix Java APIs\n+ * that create ZK connections. By having this class, we reduce duplicate code as much as possible.\n+ * @param <B>\n+ */\n+public abstract class GenericZkHelixApiBuilder<B extends GenericZkHelixApiBuilder<B>> {\n+  protected String _zkAddress;\n+  protected RealmAwareZkClient.RealmMode _realmMode;\n+  protected RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+  protected RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+  public B setZkAddress(String zkAddress) {\n+    _zkAddress = zkAddress;\n+    return self();\n+  }\n+\n+  public B setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+    _realmMode = realmMode;\n+    return self();\n+  }\n+\n+  public B setRealmAwareZkConnectionConfig(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+    _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+    return self();\n+  }\n+\n+  public RealmAwareZkClient.RealmAwareZkConnectionConfig getRealmAwareZkConnectionConfig() {\n+    return _realmAwareZkConnectionConfig;\n+  }\n+\n+  public B setRealmAwareZkClientConfig(\n+      RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+    _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+    return self();\n+  }\n+\n+  /**\n+   * Validates the given Builder parameters using a generic validation logic.\n+   */\n+  protected void validate() {\n+    // Resolve RealmMode based on whether ZK address has been set\n+    boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+    if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+      throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+    }\n+    if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n+      throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n+    }\n+    if (_realmMode == null) {\n+      _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+          : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+    }\n+\n+    initializeConfigsIfNull();\n+  }\n+\n+  /**\n+   * Initializes Realm-aware ZkConnection and ZkClient configs if they haven't been set.\n+   */\n+  protected void initializeConfigsIfNull() {\n+    // Resolve all default values\n+    if (_realmAwareZkConnectionConfig == null) {\n+      _realmAwareZkConnectionConfig =\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+    }\n+\n+    // For Helix APIs, ZNRecord should be the default data model\n+    if (_realmAwareZkClientConfig == null) {\n+      _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n+          .setZkSerializer(new ZNRecordSerializer());\n+    }\n+  }\n+\n+  /**\n+   * Creates a RealmAwareZkClient based on the parameters set.\n+   * To be used in Helix ZK APIs' constructors: ConfigAccessor, ClusterSetup, ZKHelixAdmin\n+   * @return\n+   */\n+  public RealmAwareZkClient createZkClientFromBuilder() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MjYyMw=="}, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NTE0OA==", "bodyText": "I tried to compare this solution with the other method, a private constructor accepts all parameters including the ZkClient.\nPros: less parameter.\nCons: you have to make createZkClient() method public.\nSince the constructor is private and easy to update, will the option B be better? Moreover, many classes have it's defined constructors so you don't need to define a new one.\nIn this way, the builder will be very clean. Basically, the only public methods are setXXX() and build(). All the other methods are not required to be public. What do you think?", "url": "https://github.com/apache/helix/pull/899#discussion_r395355148", "createdAt": "2020-03-19T22:29:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -87,26 +88,7 @@\n    * @param builder\n    */\n   private ConfigAccessor(Builder builder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73a5d99f859af82b3f9afd2b9f3b8a251dd73cef", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/73a5d99f859af82b3f9afd2b9f3b8a251dd73cef", "committedDate": "2020-03-20T00:46:16Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b465ba80457f7ba4d125a86d7432adcc3499cb4", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/4b465ba80457f7ba4d125a86d7432adcc3499cb4", "committedDate": "2020-03-20T00:49:01Z", "message": "fdsa"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MjQ5MzIy", "url": "https://github.com/apache/helix/pull/899#pullrequestreview-378249322", "createdAt": "2020-03-20T06:12:29Z", "commit": {"oid": "4b465ba80457f7ba4d125a86d7432adcc3499cb4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNjoxMjoyOVrOF5Igvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNjoyMDo1MlrOF5InCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MjYwNg==", "bodyText": "There is no need to deprecate, we can directly remove it. I checked, it is not in the master branch yet.\nSame for the other usages. I think we should just remove it instead of introducing a new but deprecated method to the master branch.\nIf you are worried about the backward compatibility, then we can just leave the very old code that creates either DEDICATED or SHARED client. Those constructors are deprecated anyway.\nWe don't need to change the logic of the deprecated methods to return RealmAware ZkClient. As you said, this will just mix the new logic with the old/deprecated ones.", "url": "https://github.com/apache/helix/pull/899#discussion_r395452606", "createdAt": "2020-03-20T06:12:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1390,65 +1311,23 @@ public Builder() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n-\n-    /*\n-     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n-     */\n-    private void validate() {\n-      // Resolve RealmMode based on other parameters\n-      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n-      boolean isZkClientTypeSet = zkClientType != null;\n-\n-      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n-      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n-        throw new HelixException(\"ZkClientType cannot be set on multi-realm mode!\");\n-      }\n-      // If ZkClientType is not set and realmMode is single-realm, default to SHARED\n-      if (!isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM) {\n-        zkClientType = ZkClientType.SHARED;\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n-        throw new HelixException(\"ZkAddress cannot be set on multi-realm mode!\");\n-      }\n-\n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM\n-          && zkClientType == ZkClientType.FEDERATED) {\n-        throw new HelixException(\"FederatedZkClient cannot be set on single-realm mode!\");\n-      }\n-\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n-      // Resolve RealmAwareZkClientConfig\n-      if (realmAwareZkClientConfig == null) {\n-        realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig()\n-            .setZkSerializer(new ZNRecordSerializer());\n-      }\n-\n-      // Resolve RealmAwareZkConnectionConfig\n-      if (realmAwareZkConnectionConfig == null) {\n-        // If not set, create a default one\n-        realmAwareZkConnectionConfig =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n-      }\n-    }\n   }\n \n-  /*\n-   * This is used for constructors that do not take a Builder in as a parameter because of\n-   * keeping backward-compatibility.\n+  /**\n+   * This method is used for constructors that are not based on the Builder for\n+   * backward-compatibility.\n+   * It checks if there is a System Property config set for Multi-ZK mode and determines if a\n+   * FederatedZkClient should be created.\n+   * @param clientConfig default RealmAwareZkClientConfig with ZK serializer set\n+   * @param zkAddress\n+   * @param zkClientType\n+   * @return\n    */\n-  private RealmAwareZkClient buildRealmAwareZkClient(\n+  static RealmAwareZkClient buildRealmAwareZkClientWithDefaultConfigs(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDAwMA=="}, "originalCommit": {"oid": "5c12189b59ba442c3ee88fdfadab0a3e38b8f399"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1MzUzMA==", "bodyText": "This one shall be deprecated as well. And I would suggest keeping the very original behavior. Only return realmaware client through the new builder method.", "url": "https://github.com/apache/helix/pull/899#discussion_r395453530", "createdAt": "2020-03-20T06:17:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -126,41 +117,9 @@ public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b465ba80457f7ba4d125a86d7432adcc3499cb4"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ1NDIxNw==", "bodyText": "Why not override createZkClient() here?", "url": "https://github.com/apache/helix/pull/899#discussion_r395454217", "createdAt": "2020-03-20T06:20:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java", "diffHunk": "@@ -384,14 +373,26 @@ protected void validate() {\n                   + _zkAddress + \" RealmAwareZkConnectionConfig: \" + _realmAwareZkConnectionConfig);\n         }\n       }\n+      initializeConfigsIfNull();\n+    }\n \n-      // Resolve all default values\n-      if (_realmAwareZkConnectionConfig == null) {\n-        _realmAwareZkConnectionConfig =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n-      }\n-      if (_realmAwareZkClientConfig == null) {\n-        _realmAwareZkClientConfig = new RealmAwareZkClient.RealmAwareZkClientConfig();\n+    /**\n+     * Creates a RealmAwareZkClient for ZkHelixClusterVerifiers.\n+     * Note that DedicatedZkClient is used whether it's multi-realm or single-realm.\n+     * @return\n+     */\n+    private RealmAwareZkClient createZkClientFromBuilderForVerifier() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b465ba80457f7ba4d125a86d7432adcc3499cb4"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "063089b581d1bb47bcc80e03a7d3cb8ee0ed8736", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/063089b581d1bb47bcc80e03a7d3cb8ee0ed8736", "committedDate": "2020-03-20T18:23:46Z", "message": "adsf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cee717658e48018e4f69e9e51035b2711619d7a7", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/cee717658e48018e4f69e9e51035b2711619d7a7", "committedDate": "2020-03-20T20:34:55Z", "message": "f"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODQ4OTAx", "url": "https://github.com/apache/helix/pull/899#pullrequestreview-378848901", "createdAt": "2020-03-20T22:40:47Z", "commit": {"oid": "cee717658e48018e4f69e9e51035b2711619d7a7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a85dfece4ca8cf64deb77fb7ce634517de45f62c", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/a85dfece4ca8cf64deb77fb7ce634517de45f62c", "committedDate": "2020-03-21T04:25:08Z", "message": "sadf"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4712, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}