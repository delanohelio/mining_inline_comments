{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNzIzNDE4", "number": 838, "title": "Make ConfigAccessor and ZkUtil realm-aware", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nResolves #839\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nTo make Helix Java APIs realm-aware, we first make ConfigAccessor and ZkUtil realm-aware by instrumenting these APIs with a Builder and RealmAwareZkClients.\nThe Builder pattern is chosen because it is a scalable option when there are a lot of configurable parameters. It makes it easy to validate the given parameters as well.\nTests\n\n The following tests are written for this issue:\n\nConfigAccessor is already covered by TestConfigAccessor.\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO]\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestEnableCompression.testEnableCompressionResource:108 expected: but was:\n[INFO]\n[ERROR] Tests run: 1083, Failures: 1, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  01:08 h\n[INFO] Finished at: 2020-02-29T20:46:35-08:00\nTestCompression passes when run individually\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-02-29T03:55:01Z", "url": "https://github.com/apache/helix/pull/838", "merged": true, "mergeCommit": {"oid": "08f5ec7ec88eb8db95cf63c89d6062a4d19c31f1"}, "closed": true, "closedAt": "2020-03-03T04:48:10Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcI7Ya-gH2gAyMzgxNzIzNDE4OjFmNWExMGFkOWFkNmUwOTUxYjYwNzI2MWVjMzJhNDJkZDRkM2FlZDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJ6w7MAFqTM2NzY5ODQ3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1f5a10ad9ad6e0951b607261ec32a42dd4d3aed1", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/1f5a10ad9ad6e0951b607261ec32a42dd4d3aed1", "committedDate": "2020-02-29T02:48:33Z", "message": "Make ConfigAccessor realm-aware"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca33ae14af1eb56a3aa5e8af6b65e21e4f50b1b6", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/ca33ae14af1eb56a3aa5e8af6b65e21e4f50b1b6", "committedDate": "2020-02-29T03:53:09Z", "message": "Implement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e60815332bccc622806b3bb30014895d3690a685", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/e60815332bccc622806b3bb30014895d3690a685", "committedDate": "2020-03-01T03:27:49Z", "message": "Implement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abe1efef7de4969064d34904361b952f4591143a", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/abe1efef7de4969064d34904361b952f4591143a", "committedDate": "2020-03-01T03:30:58Z", "message": "format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDE4MDMx", "url": "https://github.com/apache/helix/pull/838#pullrequestreview-367418031", "createdAt": "2020-03-02T18:16:56Z", "commit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxODoxNjo1NlrOFwp88w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxODoxNjo1NlrOFwp88w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MzMxNQ==", "bodyText": "It seems by default you set realmMode as multi realm. Why not set it multi realm by default in constructor ?\nAnd if sharding key is set only, are we going to just allow it to have single realm by default?\nIt seems easier to use and to check the code logic?\nBy default:\n\nNo sharding key or realm mode set, by default it is multi realm\nOnly sharding key is set, single realm\nSharding key and multi realm set, illegal", "url": "https://github.com/apache/helix/pull/838#discussion_r386563315", "createdAt": "2020-03-02T18:16:56Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -373,6 +379,91 @@ public String getZkRealmShardingKey() {\n     public int getSessionTimeout() {\n       return _sessionTimeout;\n     }\n+\n+    public String getMsdsEndpoint() {\n+      return _msdsEndpoint;\n+    }\n+\n+    public HelixZkClient.ZkConnectionConfig createZkConnectionConfig()\n+        throws IOException, InvalidRoutingDataException {\n+      // Convert to a single-realm HelixZkClient's ZkConnectionConfig\n+      if (_zkRealmShardingKey == null || _zkRealmShardingKey.isEmpty()) {\n+        throw new ZkClientException(\n+            \"Cannot create ZkConnectionConfig because ZK realm sharding key is either null or empty!\");\n+      }\n+\n+      String zkAddress;\n+      // Look up the ZK address for the given ZK realm sharding key\n+      if (_msdsEndpoint == null || _msdsEndpoint.isEmpty()) {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData()\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      } else {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData(_msdsEndpoint)\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      }\n+\n+      return new HelixZkClient.ZkConnectionConfig(zkAddress).setSessionTimeout(_sessionTimeout);\n+    }\n+\n+    public static class Builder {\n+      private RealmMode _realmMode;\n+      private String _zkRealmShardingKey;\n+      private String _msdsEndpoint;\n+      private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+\n+      public Builder() {\n+      }\n+\n+      public Builder setRealmMode(RealmMode mode) {\n+        _realmMode = mode;\n+        return this;\n+      }\n+\n+      public Builder setZkRealmShardingKey(String shardingKey) {\n+        _zkRealmShardingKey = shardingKey;\n+        return this;\n+      }\n+\n+      public Builder setMsdsEndpoint(String msdsEndpoint) {\n+        _msdsEndpoint = msdsEndpoint;\n+        return this;\n+      }\n+\n+      public Builder setSessionTimeout(int sessionTimeout) {\n+        _sessionTimeout = sessionTimeout;\n+        return this;\n+      }\n+\n+      public RealmAwareZkConnectionConfig build() {\n+        validate();\n+        return new RealmAwareZkConnectionConfig(this);\n+      }\n+\n+      /**\n+       * Validate the internal fields of the builder before creating an instance.\n+       */\n+      private void validate() {\n+        boolean isRealmModeSet = _realmMode != null;\n+        boolean isShardingKeySet = _zkRealmShardingKey != null && !_zkRealmShardingKey.isEmpty();\n+        switch (isRealmModeSet ? _realmMode : RealmMode.MULTI_REALM) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTkxNjg3", "url": "https://github.com/apache/helix/pull/838#pullrequestreview-367591687", "createdAt": "2020-03-02T22:57:49Z", "commit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjo1Nzo0OVrOFwybRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjo1Nzo0OVrOFwybRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMjE0OA==", "bodyText": "It seems this could be simplified a bit to make it easier to read?\nif (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n throw new HelixException(\n     \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n}\n\nif (_realmMode == null) {\n _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n             : RealmAwareZkClient.RealmMode.MULTI_REALM;\n}", "url": "https://github.com/apache/helix/pull/838#discussion_r386702148", "createdAt": "2020-03-02T22:57:49Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -830,4 +857,75 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String _zkAddress;\n+    private RealmAwareZkClient.RealmMode _realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public Builder setZkAddress(String zkAddress) {\n+      _zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      _realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ConfigAccessor build() throws Exception {\n+      validate();\n+      return new ConfigAccessor(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isRealmModeSet = _realmMode != null;\n+      boolean isZkAddressSet = _zkAddress != null && !_zkAddress.isEmpty();\n+      if (isRealmModeSet) {\n+        if (_realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+          throw new HelixException(\n+              \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+        }\n+        // If realm mode is set to multi-realm, we simply ignore the given ZK address\n+      } else {\n+        // If zkAddress is set, that implies single-realm mode. Otherwise, multi-realm mode.\n+        _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 197}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTkzNjI1", "url": "https://github.com/apache/helix/pull/838#pullrequestreview-367593625", "createdAt": "2020-03-02T23:01:44Z", "commit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMzowMTo0NVrOFwyiDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMzoyMzoxMFrOFwzAIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwMzg4Nw==", "bodyText": "Do we want ZkClientException?", "url": "https://github.com/apache/helix/pull/838#discussion_r386703887", "createdAt": "2020-03-02T23:01:45Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -373,6 +379,91 @@ public String getZkRealmShardingKey() {\n     public int getSessionTimeout() {\n       return _sessionTimeout;\n     }\n+\n+    public String getMsdsEndpoint() {\n+      return _msdsEndpoint;\n+    }\n+\n+    public HelixZkClient.ZkConnectionConfig createZkConnectionConfig()\n+        throws IOException, InvalidRoutingDataException {\n+      // Convert to a single-realm HelixZkClient's ZkConnectionConfig\n+      if (_zkRealmShardingKey == null || _zkRealmShardingKey.isEmpty()) {\n+        throw new ZkClientException(\n+            \"Cannot create ZkConnectionConfig because ZK realm sharding key is either null or empty!\");\n+      }\n+\n+      String zkAddress;\n+      // Look up the ZK address for the given ZK realm sharding key\n+      if (_msdsEndpoint == null || _msdsEndpoint.isEmpty()) {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData()\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      } else {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData(_msdsEndpoint)\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      }\n+\n+      return new HelixZkClient.ZkConnectionConfig(zkAddress).setSessionTimeout(_sessionTimeout);\n+    }\n+\n+    public static class Builder {\n+      private RealmMode _realmMode;\n+      private String _zkRealmShardingKey;\n+      private String _msdsEndpoint;\n+      private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+\n+      public Builder() {\n+      }\n+\n+      public Builder setRealmMode(RealmMode mode) {\n+        _realmMode = mode;\n+        return this;\n+      }\n+\n+      public Builder setZkRealmShardingKey(String shardingKey) {\n+        _zkRealmShardingKey = shardingKey;\n+        return this;\n+      }\n+\n+      public Builder setMsdsEndpoint(String msdsEndpoint) {\n+        _msdsEndpoint = msdsEndpoint;\n+        return this;\n+      }\n+\n+      public Builder setSessionTimeout(int sessionTimeout) {\n+        _sessionTimeout = sessionTimeout;\n+        return this;\n+      }\n+\n+      public RealmAwareZkConnectionConfig build() {\n+        validate();\n+        return new RealmAwareZkConnectionConfig(this);\n+      }\n+\n+      /**\n+       * Validate the internal fields of the builder before creating an instance.\n+       */\n+      private void validate() {\n+        boolean isRealmModeSet = _realmMode != null;\n+        boolean isShardingKeySet = _zkRealmShardingKey != null && !_zkRealmShardingKey.isEmpty();\n+        switch (isRealmModeSet ? _realmMode : RealmMode.MULTI_REALM) {\n+          case MULTI_REALM:\n+            if (isShardingKeySet && isRealmModeSet) {\n+              throw new IllegalArgumentException(\n+                  \"ZK sharding key cannot be set on multi-realm mode! Sharding key: \"\n+                      + _zkRealmShardingKey);\n+            }\n+            break;\n+          case SINGLE_REALM:\n+            if (!isShardingKeySet) {\n+              throw new IllegalArgumentException(\n+                  \"ZK sharding key must be set on single-realm mode!\");\n+            }\n+            break;\n+          default:\n+            throw new ZkClientException(\"RealmAwareZkConnectionConfig: Unknown mode!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNTYzOQ==", "bodyText": "Nit, shall we declare type List<> ?", "url": "https://github.com/apache/helix/pull/838#discussion_r386705639", "createdAt": "2020-03-02T23:06:32Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -75,7 +80,7 @@ public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient)\n       logger.info(\"Fail to check cluster setup : zookeeper client is null!\");\n       return false;\n     }\n-    ArrayList<String> requiredPaths = new ArrayList<String>();\n+    ArrayList<String> requiredPaths = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNzkyNA==", "bodyText": "It seems this changes the original behavior. baseAccessor.exits is actually an async call using asyncExists() in the bottom implementation. I think it is better to keep the original behavior.", "url": "https://github.com/apache/helix/pull/838#discussion_r386707924", "createdAt": "2020-03-02T23:12:33Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -92,15 +97,17 @@ public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient)\n     requiredPaths.add(PropertyPathBuilder.controllerHistory(clusterName));\n     boolean isValid = true;\n \n-    BaseDataAccessor<Object> baseAccessor = new ZkBaseDataAccessor<Object>(zkClient);\n-    boolean[] ret = baseAccessor.exists(requiredPaths, 0);\n+    boolean[] ret = new boolean[requiredPaths.size()];\n+    for (int i = 0; i < requiredPaths.size(); i++) {\n+      ret[i] = zkClient.exists(requiredPaths.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwODgwNg==", "bodyText": "Nit: Maybe we can modify a bit for the error message to combine the error paths together like below to avoid the extra duplicate strings Invalid cluster setup, missing znode path for each path.\nInvalid cluster setup, missing znode paths: [path1, path2]", "url": "https://github.com/apache/helix/pull/838#discussion_r386708806", "createdAt": "2020-03-02T23:15:14Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -92,15 +97,17 @@ public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient)\n     requiredPaths.add(PropertyPathBuilder.controllerHistory(clusterName));\n     boolean isValid = true;\n \n-    BaseDataAccessor<Object> baseAccessor = new ZkBaseDataAccessor<Object>(zkClient);\n-    boolean[] ret = baseAccessor.exists(requiredPaths, 0);\n+    boolean[] ret = new boolean[requiredPaths.size()];\n+    for (int i = 0; i < requiredPaths.size(); i++) {\n+      ret[i] = zkClient.exists(requiredPaths.get(i));\n+    }\n     StringBuilder errorMsg = new StringBuilder();\n \n     for (int i = 0; i < ret.length; i++) {\n       if (!ret[i]) {\n         isValid = false;\n-        errorMsg\n-            .append((\"Invalid cluster setup, missing znode path: \" + requiredPaths.get(i)) + \"\\n\");\n+        errorMsg.append(\"Invalid cluster setup, missing znode path: \").append(requiredPaths.get(i))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTIzMw==", "bodyText": "If we have public static boolean isClusterSetup(String clusterName, RealmAwareZkClient zkClient), it seems keeping this old API public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient) is redundant, because HelixZkClient is a subclass of RealmAwareZkClient?", "url": "https://github.com/apache/helix/pull/838#discussion_r386711233", "createdAt": "2020-03-02T23:22:08Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -66,6 +67,10 @@ public static boolean isClusterSetup(String clusterName, String zkAddress) {\n   }\n \n   public static boolean isClusterSetup(String clusterName, HelixZkClient zkClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxMTU4NA==", "bodyText": "I think we can move this old API as HelixZkClient can automatically fit into RealmAwareZkClient.", "url": "https://github.com/apache/helix/pull/838#discussion_r386711584", "createdAt": "2020-03-02T23:23:10Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java", "diffHunk": "@@ -132,7 +139,12 @@ public static boolean isInstanceSetup(String zkAddress, String clusterName, Stri\n     return result;\n   }\n \n-  public static boolean isInstanceSetup(HelixZkClient zkclient, String clusterName,\n+  public static boolean isInstanceSetup(HelixZkClient zkClient, String clusterName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe1efef7de4969064d34904361b952f4591143a"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59b39dd50cd8e786ea514156a7666f5c7e6f9507", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/59b39dd50cd8e786ea514156a7666f5c7e6f9507", "committedDate": "2020-03-03T02:45:27Z", "message": "update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjkyMjAx", "url": "https://github.com/apache/helix/pull/838#pullrequestreview-367692201", "createdAt": "2020-03-03T04:11:40Z", "commit": {"oid": "59b39dd50cd8e786ea514156a7666f5c7e6f9507"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNDoxMTo0MFrOFw3yZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNDoxNDo0MlrOFw30mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4OTk4OQ==", "bodyText": "This \u201c._\u201d is a bit annoying and we may not have setters in builder...\nThis is one of the reasons I don\u2019t like this leading underscore naming convention. May be in this case I would just ignore this convention and instead use a convention without leading underscore.", "url": "https://github.com/apache/helix/pull/838#discussion_r386789989", "createdAt": "2020-03-03T04:11:40Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -325,16 +328,18 @@ public int hashCode() {\n    * ZkConnection-related configs for creating an instance of RealmAwareZkClient.\n    */\n   class RealmAwareZkConnectionConfig {\n-\n     /**\n      * zkRealmShardingKey: used to deduce which ZK realm this RealmAwareZkClientConfig should connect to.\n-     * NOTE: this field will be ignored if MODE is MULTI_REALM!\n+     * NOTE: this field will be ignored if RealmMode is MULTI_REALM!\n      */\n-    private final String _zkRealmShardingKey;\n-    private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n-\n-    public RealmAwareZkConnectionConfig(String zkRealmShardingKey) {\n-      _zkRealmShardingKey = zkRealmShardingKey;\n+    private String _zkRealmShardingKey;\n+    private String _msdsEndpoint;\n+    private int _sessionTimeout;\n+\n+    private RealmAwareZkConnectionConfig(Builder builder) {\n+      _zkRealmShardingKey = builder._zkRealmShardingKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b39dd50cd8e786ea514156a7666f5c7e6f9507"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5MDU1Mw==", "bodyText": "It seems if realm mode is not set by caller, we don\u2019t set it here by default. Shall we set a default value based on sharding key being set or not?", "url": "https://github.com/apache/helix/pull/838#discussion_r386790553", "createdAt": "2020-03-03T04:14:42Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -373,6 +378,81 @@ public String getZkRealmShardingKey() {\n     public int getSessionTimeout() {\n       return _sessionTimeout;\n     }\n+\n+    public String getMsdsEndpoint() {\n+      return _msdsEndpoint;\n+    }\n+\n+    public HelixZkClient.ZkConnectionConfig createZkConnectionConfig()\n+        throws IOException, InvalidRoutingDataException {\n+      // Convert to a single-realm HelixZkClient's ZkConnectionConfig\n+      if (_zkRealmShardingKey == null || _zkRealmShardingKey.isEmpty()) {\n+        throw new ZkClientException(\n+            \"Cannot create ZkConnectionConfig because ZK realm sharding key is either null or empty!\");\n+      }\n+\n+      String zkAddress;\n+      // Look up the ZK address for the given ZK realm sharding key\n+      if (_msdsEndpoint == null || _msdsEndpoint.isEmpty()) {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData()\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      } else {\n+        zkAddress = HttpRoutingDataReader.getMetadataStoreRoutingData(_msdsEndpoint)\n+            .getMetadataStoreRealm(_zkRealmShardingKey);\n+      }\n+\n+      return new HelixZkClient.ZkConnectionConfig(zkAddress).setSessionTimeout(_sessionTimeout);\n+    }\n+\n+    public static class Builder {\n+      private RealmMode _realmMode;\n+      private String _zkRealmShardingKey;\n+      private String _msdsEndpoint;\n+      private int _sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n+\n+      public Builder() {\n+      }\n+\n+      public Builder setRealmMode(RealmMode mode) {\n+        _realmMode = mode;\n+        return this;\n+      }\n+\n+      public Builder setZkRealmShardingKey(String shardingKey) {\n+        _zkRealmShardingKey = shardingKey;\n+        return this;\n+      }\n+\n+      public Builder setMsdsEndpoint(String msdsEndpoint) {\n+        _msdsEndpoint = msdsEndpoint;\n+        return this;\n+      }\n+\n+      public Builder setSessionTimeout(int sessionTimeout) {\n+        _sessionTimeout = sessionTimeout;\n+        return this;\n+      }\n+\n+      public RealmAwareZkConnectionConfig build() {\n+        validate();\n+        return new RealmAwareZkConnectionConfig(this);\n+      }\n+\n+      /**\n+       * Validate the internal fields of the builder before creating an instance.\n+       */\n+      private void validate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b39dd50cd8e786ea514156a7666f5c7e6f9507"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3Njk4NDc4", "url": "https://github.com/apache/helix/pull/838#pullrequestreview-367698478", "createdAt": "2020-03-03T04:39:20Z", "commit": {"oid": "59b39dd50cd8e786ea514156a7666f5c7e6f9507"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4998, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}