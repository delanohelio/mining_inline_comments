{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MzQ2MTI0", "number": 1040, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjoyOToyMlrOEBDpRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMTowNDozNlrOEBONdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTQzNzQ5OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjoyOToyMlrOGcuA-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjo0NToxNVrOGcuRtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2NzIyNA==", "bodyText": "Could this cause problem? If there is a cancel message, so the toState is not RUNNING, it should INIT? Then are we cancelling the CANCEL message?", "url": "https://github.com/apache/helix/pull/1040#discussion_r432767224", "createdAt": "2020-05-29T22:29:22Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -449,43 +448,31 @@ private void updatePartitionInformationInJobContext(CurrentStateOutput currentSt\n    * @param paMap\n    * @param assignedPartitions\n    */\n-  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId,\n-      String pName, String instance, Message pendingMessage, TaskState jobState,\n-      TaskPartitionState currState, Map<Integer, PartitionAssignment> paMap,\n-      Map<String, Set<Integer>> assignedPartitions) {\n-\n-    // stateMap is a mapping of Instance -> TaskPartitionState (String)\n-    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));\n-    if (stateMap != null) {\n-      String prevState = stateMap.get(instance);\n-      if (!pendingMessage.getToState().equals(prevState)) {\n-        LOG.warn(String.format(\n-            \"Task pending to-state is %s while previous assigned state is %s. This should not\"\n-                + \"happen.\",\n-            pendingMessage.getToState(), prevState));\n+  private void processTaskWithPendingMessage(Integer pId, String pName, String instance,\n+      Message pendingMessage, TaskState jobState, TaskPartitionState currState,\n+      Map<Integer, PartitionAssignment> paMap, Map<String, Set<Integer>> assignedPartitions) {\n+\n+    if (jobState == TaskState.TIMING_OUT && currState == TaskPartitionState.INIT\n+        && pendingMessage.getToState().equals(TaskPartitionState.RUNNING.name())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73437572adef7278512145de0f3c5018ca450ee6"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3MTUwOQ==", "bodyText": "This part of the code is to issue ST cancellation message. Right? If there is a pending message which its toState is  INIT then this if statement will not be satisfied and we will not cancel the cancel message.\nAlso, this part is basically similar to the previous version of the code (So I don't think there is a logic change in this PR)\nFrom the comments and the code: If there is a pending message for this task and this pending message is INIT->RUNNING, if the job goes to TIMING_OUT state, we need to cancel this state transition. Hence we would set the task back to INIT state in this case. Then if Helix can cancel the ST (if enabled) this ST will be cancelled by controller.\nAlso without this change we are in the same situation: We decided to send INIT->RUNNING message for this task (hence in previous pipeline we set previousAssignment to RUNNING and send INIT-> RUNNING message), in next pipelines while the message has not been processed yet, job goes to TIMING_OUT state, hence this message is not needed we can cancel it (if enabled). In this case we set the paMap back to INIT.", "url": "https://github.com/apache/helix/pull/1040#discussion_r432771509", "createdAt": "2020-05-29T22:45:15Z", "author": {"login": "alirezazamani"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -449,43 +448,31 @@ private void updatePartitionInformationInJobContext(CurrentStateOutput currentSt\n    * @param paMap\n    * @param assignedPartitions\n    */\n-  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId,\n-      String pName, String instance, Message pendingMessage, TaskState jobState,\n-      TaskPartitionState currState, Map<Integer, PartitionAssignment> paMap,\n-      Map<String, Set<Integer>> assignedPartitions) {\n-\n-    // stateMap is a mapping of Instance -> TaskPartitionState (String)\n-    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));\n-    if (stateMap != null) {\n-      String prevState = stateMap.get(instance);\n-      if (!pendingMessage.getToState().equals(prevState)) {\n-        LOG.warn(String.format(\n-            \"Task pending to-state is %s while previous assigned state is %s. This should not\"\n-                + \"happen.\",\n-            pendingMessage.getToState(), prevState));\n+  private void processTaskWithPendingMessage(Integer pId, String pName, String instance,\n+      Message pendingMessage, TaskState jobState, TaskPartitionState currState,\n+      Map<Integer, PartitionAssignment> paMap, Map<String, Set<Integer>> assignedPartitions) {\n+\n+    if (jobState == TaskState.TIMING_OUT && currState == TaskPartitionState.INIT\n+        && pendingMessage.getToState().equals(TaskPartitionState.RUNNING.name())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2NzIyNA=="}, "originalCommit": {"oid": "73437572adef7278512145de0f3c5018ca450ee6"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzE2ODU1OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMTowNDozNlrOGc8hig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMDoxMzoyNlrOGdYiWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNDkzOA==", "bodyText": "I think a better state to assign here might be DROPPED? Previously, we would send things to INIT but that would be a long-winded way to cause this to be dropped. And I'm not sure with the recent changes, the tasks that are timing out that are in INIT state will indeed be dropped eventually.\nIf they don't, then there's a problem - init state takes up a quota in the quota calculation, and we might end up seeing quota leaks.\nHave you tried to drop here directly? We can try to run some tests to see what the consequences are for dropping directly here.", "url": "https://github.com/apache/helix/pull/1040#discussion_r433004938", "createdAt": "2020-06-01T01:04:36Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -449,43 +448,31 @@ private void updatePartitionInformationInJobContext(CurrentStateOutput currentSt\n    * @param paMap\n    * @param assignedPartitions\n    */\n-  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId,\n-      String pName, String instance, Message pendingMessage, TaskState jobState,\n-      TaskPartitionState currState, Map<Integer, PartitionAssignment> paMap,\n-      Map<String, Set<Integer>> assignedPartitions) {\n-\n-    // stateMap is a mapping of Instance -> TaskPartitionState (String)\n-    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));\n-    if (stateMap != null) {\n-      String prevState = stateMap.get(instance);\n-      if (!pendingMessage.getToState().equals(prevState)) {\n-        LOG.warn(String.format(\n-            \"Task pending to-state is %s while previous assigned state is %s. This should not\"\n-                + \"happen.\",\n-            pendingMessage.getToState(), prevState));\n+  private void processTaskWithPendingMessage(Integer pId, String pName, String instance,\n+      Message pendingMessage, TaskState jobState, TaskPartitionState currState,\n+      Map<Integer, PartitionAssignment> paMap, Map<String, Set<Integer>> assignedPartitions) {\n+\n+    if (jobState == TaskState.TIMING_OUT && currState == TaskPartitionState.INIT\n+        && pendingMessage.getToState().equals(TaskPartitionState.RUNNING.name())) {\n+      // While job is timing out, if the task is pending on INIT->RUNNING, set it back to INIT,\n+      // so that Helix will cancel the transition.\n+      paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73437572adef7278512145de0f3c5018ca450ee6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Mzg5Ng==", "bodyText": "@narendly Thank you for the suggestion. I think what you are suggesting would also work. However, I think the logic behind this part of code should be untouched as much as possible. If we want to do send DROPPED here (although I think it would work), we need to release the quota and do further logic changes. The reason is once we DROP the the task from instance, we will miss currentState and we will not see that task in other methods in order to release quota. Hence, I prefer to send DROPPED for the task using two level approach (i.e. first send it to INIT and then DROP it).\nAlso since there is a pending INIT->RUNNING message existed, it is not very safe to release the quota here. Because the task might go to RUNNING state and before we cancel it, the quota information will be mismatched with the actual scenario. So if we first let the task to go to INIT state and then releasing the quota and sending it to DROPPED will be better option in my opinion.\nTo answer your question, we will actually handle this case for releasing the quota in updatePreviousAssignedTasksStatus method. Here the code that would do that:\n        case INIT: {\n          // INIT is a temporary state for tasks\n          // Two possible scenarios for INIT:\n          // 1. Task is getting scheduled for the first time. In this case, Task's state will go\n          // from null->INIT->RUNNING, and this INIT state will be transient and very short-lived\n          // 2. Task is getting scheduled for the first time, but in this case, job is timed out or\n          // timing out. In this case, it will be sent back to INIT state to be removed. Here we\n          // ensure that this task then goes from INIT to DROPPED so that it will be released from\n          // AssignableInstance to prevent resource leak\n          if (jobState == TaskState.TIMED_OUT || jobState == TaskState.TIMING_OUT\n              || jobTgtState == TargetState.DELETE) {\n            // Job is timed out or timing out or targetState is to be deleted, so its tasks will be\n            // sent back to INIT\n            // In this case, tasks' IdealState will be removed, and they will be sent to DROPPED\n            partitionsToDropFromIs.add(pId);\n            \n            assignedPartitions.get(instance).add(pId);\n            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));\n\n            // Also release resources for these tasks\n            assignableInstanceManager.release(instance, taskConfig, quotaType);\n            break;\n          } \n\nYour comment actually guided me to add another safety check for INIT case. I added two lines to make sure we DROP the task if job is TIMED_OUT or TIMING_OUT and the task is in INIT state. Thanks for the comments and careful review.", "url": "https://github.com/apache/helix/pull/1040#discussion_r433463896", "createdAt": "2020-06-01T20:13:26Z", "author": {"login": "alirezazamani"}, "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -449,43 +448,31 @@ private void updatePartitionInformationInJobContext(CurrentStateOutput currentSt\n    * @param paMap\n    * @param assignedPartitions\n    */\n-  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId,\n-      String pName, String instance, Message pendingMessage, TaskState jobState,\n-      TaskPartitionState currState, Map<Integer, PartitionAssignment> paMap,\n-      Map<String, Set<Integer>> assignedPartitions) {\n-\n-    // stateMap is a mapping of Instance -> TaskPartitionState (String)\n-    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));\n-    if (stateMap != null) {\n-      String prevState = stateMap.get(instance);\n-      if (!pendingMessage.getToState().equals(prevState)) {\n-        LOG.warn(String.format(\n-            \"Task pending to-state is %s while previous assigned state is %s. This should not\"\n-                + \"happen.\",\n-            pendingMessage.getToState(), prevState));\n+  private void processTaskWithPendingMessage(Integer pId, String pName, String instance,\n+      Message pendingMessage, TaskState jobState, TaskPartitionState currState,\n+      Map<Integer, PartitionAssignment> paMap, Map<String, Set<Integer>> assignedPartitions) {\n+\n+    if (jobState == TaskState.TIMING_OUT && currState == TaskPartitionState.INIT\n+        && pendingMessage.getToState().equals(TaskPartitionState.RUNNING.name())) {\n+      // While job is timing out, if the task is pending on INIT->RUNNING, set it back to INIT,\n+      // so that Helix will cancel the transition.\n+      paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNDkzOA=="}, "originalCommit": {"oid": "73437572adef7278512145de0f3c5018ca450ee6"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1096, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}