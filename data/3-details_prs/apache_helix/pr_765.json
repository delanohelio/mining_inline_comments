{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NTg0NTg1", "number": 765, "title": "Add DedicatedZkClient and update DedicatedZkClientFactory", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #766\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nAs part of ZkClient API enhancement, we wish to add DedicatedZkClient, which is a wrapper of the raw ZkClient, that provides realm-aware access to ZooKeeper.\nRealm-aware in that it only performs requests whose path's Zk path sharding key belongs to the ZK realm it's connected to.\nAlso, we need to modify DedicatedZkClientFactory so that users could use this factory to generate instances of DedicatedZkClient.\nTests\n\n The following tests are written for this issue:\n\nRealmAwareZkClientTestBase\nTestDedicatedZkClient\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  5.256 s\n[INFO] Finished at: 2020-02-20T16:00:28-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-14T21:42:12Z", "url": "https://github.com/apache/helix/pull/765", "merged": true, "mergeCommit": {"oid": "9b4acde89f423b1d71ee4227de4fd2fb8823473d"}, "closed": true, "closedAt": "2020-02-21T00:17:04Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFmWW5gFqTM2MDU3NDM3Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHoLAzgFqTM2MzgyMzMwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNTc0Mzc2", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-360574376", "createdAt": "2020-02-18T18:32:53Z", "commit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODozMjo1M1rOFrNroA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODozNDo1NlrOFrNvvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzI0OA==", "bodyText": "This is PR for dedicated zkclient factory, right?", "url": "https://github.com/apache/helix/pull/765#discussion_r380857248", "createdAt": "2020-02-18T18:32:53Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -44,15 +44,17 @@ protected SharedZkClientFactory() {\n   @Override\n   public RealmAwareZkClient buildZkClient(\n       RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n-      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1ODMwMA==", "bodyText": "Is this new code or refactor? If refactor, we should remove the old code in REST module, right?", "url": "https://github.com/apache/helix/pull/765#discussion_r380858300", "createdAt": "2020-02-18T18:34:56Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,277 @@\n+package org.apache.helix.zookeeper.impl.factory;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * TODO: remove when there's a separate module.\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzA4MDE1", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-360708015", "createdAt": "2020-02-18T22:05:32Z", "commit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjowNTozMlrOFrULLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjowNTozMlrOFrULLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzYzMQ==", "bodyText": "If we don't want users to directly use this class, shall we consider refactoring the code structure so we can make this class protected? I think that may be better than just commenting not to use it directly.", "url": "https://github.com/apache/helix/pull/765#discussion_r380963631", "createdAt": "2020-02-18T22:05:32Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,592 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzE0NTE4", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-360714518", "createdAt": "2020-02-18T22:16:39Z", "commit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjoxNjozOVrOFrUfIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjoxNjozOVrOFrUfIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2ODczOA==", "bodyText": "It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method.\nUpdate: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()", "url": "https://github.com/apache/helix/pull/765#discussion_r380968738", "createdAt": "2020-02-18T22:16:39Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,592 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    create(path, null, acl, CreateMode.EPHEMERAL, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    return create(path, datat, acl, mode, null);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    create(path, data, acl, CreateMode.EPHEMERAL, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,\n+        sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _rawZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _rawZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "originalPosition": 476}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzk2NDMz", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-360796433", "createdAt": "2020-02-19T01:55:20Z", "commit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwMTo1NToyMVrOFrYtPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODozMDo1NFrOFryrng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNzg4Nw==", "bodyText": "@narendly, as discussed offline. I don't think we need this as the connectionConfig have all the information to construct a rest call to MSDS.\nThe checking of a dedicated ZKCLient and dedicated ShareZKClient should all limit to path underlying the sharding key.\nYes, two different sharding keys (cluster) can reside on the same shareded Zookeeper server. But the zkClient constructed with sharding key one should not really be able to access zk path underlying the second sharding key (space). The reason is that later we may need to reshard the keys to different zookeeper servers,  that would be a problem then.  \"future backward compatibility problem\".", "url": "https://github.com/apache/helix/pull/765#discussion_r381037887", "createdAt": "2020-02-19T01:55:21Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -44,15 +44,17 @@ protected SharedZkClientFactory() {\n   @Override\n   public RealmAwareZkClient buildZkClient(\n       RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n-      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig) {\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n     // TODO: Implement the logic\n     // Return an instance of SharedZkClient\n     return null;\n   }\n \n   @Override\n   public RealmAwareZkClient buildZkClient(\n-      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig) {\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2MzQ1NA==", "bodyText": "Why change this access modifier in ZkClient? This is interface change.", "url": "https://github.com/apache/helix/pull/765#discussion_r381463454", "createdAt": "2020-02-19T18:30:54Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -636,7 +636,7 @@ public String create(final String path, Object datat, final List<ACL> acl, final\n    * @throws IllegalArgumentException if called from anything else except the ZooKeeper event thread\n    * @throws ZkException if any zookeeper exception occurs\n    */\n-  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+   public String create(final String path, final Object dataObject, final List<ACL> acl,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e97970fc1ef2a3faba48d1a94c57712bdcc4bb1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzY1NzI3", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361365727", "createdAt": "2020-02-19T19:16:35Z", "commit": {"oid": "b03e0da4c4e096a0e81de640f50bc7a1938e589c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxNjozNlrOFr0N0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOTozMjowNVrOFr0uww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODU5NQ==", "bodyText": "Nit: could assign to _zkRealmAddress first and then perform the check", "url": "https://github.com/apache/helix/pull/765#discussion_r381488595", "createdAt": "2020-02-19T19:16:36Z", "author": {"login": "NealSun96"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,488 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b03e0da4c4e096a0e81de640f50bc7a1938e589c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5NzAyNw==", "bodyText": "This is no longer the latest TrieRoutingdata after the changes introduced in: 8c050b3 .", "url": "https://github.com/apache/helix/pull/765#discussion_r381497027", "createdAt": "2020-02-19T19:32:05Z", "author": {"login": "NealSun96"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/TrieRoutingData.java", "diffHunk": "@@ -0,0 +1,277 @@\n+package org.apache.helix.zookeeper.impl.factory;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * TODO: remove when there's a separate module.\n+ * This is a class that uses a data structure similar to trie to represent metadata store routing\n+ * data. It is not exactly a trie because it in essence stores a mapping (from sharding keys to\n+ * realm addresses) instead of pure text information; also, only the terminal nodes store meaningful\n+ * information (realm addresses).\n+ */\n+public class TrieRoutingData implements MetadataStoreRoutingData {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDAzODEx", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361403811", "createdAt": "2020-02-19T20:13:19Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDoxMzoyMFrOFr2CEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDoxMzoyMFrOFr2CEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxODM1Mw==", "bodyText": "It seems IllegalArgumentException will be thrown for createPersistent(), and there is no check for writeData(). If we want to test writeData() as well, shall we have another validation for writeData() to be more accurate?", "url": "https://github.com/apache/helix/pull/765#discussion_r381518353", "createdAt": "2020-02-19T20:13:20Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {\n+  private static final String ZK_SHARDING_KEY_PREFIX = \"/TEST_SHARDING_KEY_\";\n+  private static final String TEST_VALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_\" + 0 + \"/a/b/c\";\n+  private static final String TEST_INVALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_invalid\" + \"/a/b/c\";\n+\n+  // <Realm, List of sharding keys> Mapping\n+  private static final Map<String, List<String>> RAW_ROUTING_DATA = new HashMap<>();\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  private MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    // Populate RAW_ROUTING_DATA\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = new ArrayList<>();\n+      shardingKeyList.add(ZK_SHARDING_KEY_PREFIX + \"_\" + i);\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      RAW_ROUTING_DATA.put(realmName, shardingKeyList);\n+    }\n+\n+    // Feed the raw routing data into TrieRoutingData to construct an in-memory representation of routing information\n+    _metadataStoreRoutingData = new TrieRoutingData(RAW_ROUTING_DATA);\n+  }\n+\n+  /**\n+   * 1. Create a DedicatedZkClient with a non-existing sharding key (for which there is no valid ZK realm)\n+   * -> This should fail with an exception\n+   * 2. Create a DedicatedZkClient with a valid sharding key\n+   * -> This should pass\n+   */\n+  @Test\n+  public void testDedicatedZkClientCreation() {\n+    // Create a DedicatedZkClient\n+    String invalidShardingKey = \"InvalidShardingKey\";\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    // Create a connection config with the invalid sharding key\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig(invalidShardingKey);\n+\n+    try {\n+      _realmAwareZkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(connectionConfig, clientConfig, _metadataStoreRoutingData);\n+      Assert.fail(\"Should not succeed with an invalid sharding key!\");\n+    } catch (IllegalArgumentException e) {\n+      // Expected\n+    }\n+\n+    // Use a valid sharding key this time around\n+    String validShardingKey = ZK_SHARDING_KEY_PREFIX + \"_\" + 0; // Use TEST_SHARDING_KEY_0\n+    connectionConfig = new RealmAwareZkClient.RealmAwareZkConnectionConfig(validShardingKey);\n+    _realmAwareZkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(connectionConfig, clientConfig, _metadataStoreRoutingData);\n+  }\n+\n+  /**\n+   * Test the persistent create() call against a valid path and an invalid path.\n+   * Valid path is one that belongs to the realm designated by the sharding key.\n+   * Invalid path is one that does not belong to the realm designated by the sharding key.\n+   */\n+  @Test(dependsOnMethods = \"testDedicatedZkClientCreation\")\n+  public void testDedicatedZkClientCreatePersistent() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // Test writing and reading against the validPath\n+    _realmAwareZkClient.createPersistent(TEST_VALID_PATH, true);\n+    _realmAwareZkClient.writeData(TEST_VALID_PATH, znRecord);\n+    Assert.assertEquals(_realmAwareZkClient.readData(TEST_VALID_PATH), znRecord);\n+\n+    // Test writing and reading against the invalid path\n+    try {\n+      _realmAwareZkClient.createPersistent(TEST_INVALID_PATH, true);\n+      _realmAwareZkClient.writeData(TEST_INVALID_PATH, znRecord);\n+      Assert.fail(\"Create() should not succeed on an invalid path!\");\n+    } catch (IllegalArgumentException e) {\n+      // Okay - expected", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTM4Njgz", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361538683", "createdAt": "2020-02-20T00:35:50Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMDozNTo1MFrOFr8sfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMDozODoyN1rOFr8vmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNzUxOA==", "bodyText": "Shall we just call _rawZkClient.readData(path, returnNullIfPathNotExists), so it is easier to maintain the code because it relies on raw ZkClient, which is our initial purpose?", "url": "https://github.com/apache/helix/pull/765#discussion_r381627518", "createdAt": "2020-02-20T00:35:50Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNzY1OQ==", "bodyText": "Same, to call raw zkClient?", "url": "https://github.com/apache/helix/pull/765#discussion_r381627659", "createdAt": "2020-02-20T00:36:18Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n+      }\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyODMxNA==", "bodyText": "Typo? _rawZkClient.countChildren() Otherwise, a stack overflow :)", "url": "https://github.com/apache/helix/pull/765#discussion_r381628314", "createdAt": "2020-02-20T00:38:27Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return countChildren(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 258}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTc3ODgw", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361577880", "createdAt": "2020-02-20T01:24:25Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMToyNDoyNVrOFr9uEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMToyNzowNVrOFr90QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NDMwNA==", "bodyText": "create(path, null, acl, CreateMode.EPHEMERAL, sessionId); to re-use the code and minimize the code branches to reduce duplicate code and maintenance effort? For example, if we want to change the behavior, we just need to change create().\nUpdate: I didn't realize that you wanted to keep zkclient's create() private until seeing the change you made to revert public -> private. I think there are 2 options then: 1. make that private to public. 2. call its own  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId)", "url": "https://github.com/apache/helix/pull/765#discussion_r381644304", "createdAt": "2020-02-20T01:24:25Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTc0MQ==", "bodyText": "Same: call its owncreate()?", "url": "https://github.com/apache/helix/pull/765#discussion_r381645741", "createdAt": "2020-02-20T01:26:49Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0NTg4OQ==", "bodyText": "Same: call its owncreate()?", "url": "https://github.com/apache/helix/pull/765#discussion_r381645889", "createdAt": "2020-02-20T01:27:05Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,480 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTk5Njc4", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361599678", "createdAt": "2020-02-20T02:39:45Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMjozOTo0NVrOFsASHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMjozOTo0NVrOFsASHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY4NjMwMg==", "bodyText": "Nit, it seems each time concatenating the path, underscore is added and so the paths would be /TEST_SHARDING_KEY__0/a/b, which does not affect the results but it may not be what you wanted to have in comment?\nString validShardingKey = ZK_SHARDING_KEY_PREFIX + \"_\" + 0; // Use TEST_SHARDING_KEY_0", "url": "https://github.com/apache/helix/pull/765#discussion_r381686302", "createdAt": "2020-02-20T02:39:45Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {\n+  private static final String ZK_SHARDING_KEY_PREFIX = \"/TEST_SHARDING_KEY_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjA2MDg1", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361606085", "createdAt": "2020-02-20T03:03:55Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMzowMzo1NVrOFsBC_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMzowMzo1NVrOFsBC_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY5ODgxMg==", "bodyText": "Current ZkTestBase in helix-core is occupying this port. If we run the tests in the whole project and port 2183 is already occupied by ZK started by helix-core, can we still start a ZK at this port 2183? If not, we may want to use another port.", "url": "https://github.com/apache/helix/pull/765#discussion_r381698812", "createdAt": "2020-02-20T03:03:55Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/ZkTestBase.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.zookeeper.zkclient.IDefaultNameSpace;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+\n+\n+/**\n+ * Test base class for various integration tests with an in-memory ZooKeeper.\n+ */\n+public class ZkTestBase {\n+  private static final Logger LOG = LoggerFactory.getLogger(ZkTestBase.class);\n+  private static final MBeanServerConnection MBEAN_SERVER =\n+      ManagementFactory.getPlatformMBeanServer();\n+\n+  // maven surefire-plugin's multiple ZK config keys\n+  private static final String MULTI_ZK_PROPERTY_KEY = \"multiZk\";\n+  private static final String NUM_ZK_PROPERTY_KEY = \"numZk\";\n+\n+  protected static final String ZK_PREFIX = \"localhost:\";\n+  protected static final int ZK_START_PORT = 2183;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjA3MDM5", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361607039", "createdAt": "2020-02-20T03:07:39Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMzowNzozOVrOFsBKRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMzowNzozOVrOFsBKRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwMDY3Ng==", "bodyText": "Nit, Do you want it to be public or private? If private, no need to add the space.", "url": "https://github.com/apache/helix/pull/765#discussion_r381700676", "createdAt": "2020-02-20T03:07:39Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -636,7 +636,7 @@ public String create(final String path, Object datat, final List<ACL> acl, final\n    * @throws IllegalArgumentException if called from anything else except the ZooKeeper event thread\n    * @throws ZkException if any zookeeper exception occurs\n    */\n-  private String create(final String path, final Object dataObject, final List<ACL> acl,\n+   private String create(final String path, final Object dataObject, final List<ACL> acl,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjEwNzU1", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361610755", "createdAt": "2020-02-20T03:22:21Z", "commit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMzoyMjoyMVrOFsBnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwMzoyMjoyMVrOFsBnRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTcwODEwMw==", "bodyText": "Is this client supposed to be close after class?", "url": "https://github.com/apache/helix/pull/765#discussion_r381708103", "createdAt": "2020-02-20T03:22:21Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {\n+  private static final String ZK_SHARDING_KEY_PREFIX = \"/TEST_SHARDING_KEY_\";\n+  private static final String TEST_VALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_\" + 0 + \"/a/b/c\";\n+  private static final String TEST_INVALID_PATH = ZK_SHARDING_KEY_PREFIX + \"_invalid\" + \"/a/b/c\";\n+\n+  // <Realm, List of sharding keys> Mapping\n+  private static final Map<String, List<String>> RAW_ROUTING_DATA = new HashMap<>();\n+\n+  private RealmAwareZkClient _realmAwareZkClient;\n+  private MetadataStoreRoutingData _metadataStoreRoutingData;\n+\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    // Populate RAW_ROUTING_DATA\n+    for (int i = 0; i < _numZk; i++) {\n+      List<String> shardingKeyList = new ArrayList<>();\n+      shardingKeyList.add(ZK_SHARDING_KEY_PREFIX + \"_\" + i);\n+      String realmName = ZK_PREFIX + (ZK_START_PORT + i);\n+      RAW_ROUTING_DATA.put(realmName, shardingKeyList);\n+    }\n+\n+    // Feed the raw routing data into TrieRoutingData to construct an in-memory representation of routing information\n+    _metadataStoreRoutingData = new TrieRoutingData(RAW_ROUTING_DATA);\n+  }\n+\n+  /**\n+   * 1. Create a DedicatedZkClient with a non-existing sharding key (for which there is no valid ZK realm)\n+   * -> This should fail with an exception\n+   * 2. Create a DedicatedZkClient with a valid sharding key\n+   * -> This should pass\n+   */\n+  @Test\n+  public void testDedicatedZkClientCreation() {\n+    // Create a DedicatedZkClient\n+    String invalidShardingKey = \"InvalidShardingKey\";\n+    RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+        new RealmAwareZkClient.RealmAwareZkClientConfig();\n+\n+    // Create a connection config with the invalid sharding key\n+    RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig =\n+        new RealmAwareZkClient.RealmAwareZkConnectionConfig(invalidShardingKey);\n+\n+    try {\n+      _realmAwareZkClient = DedicatedZkClientFactory.getInstance()\n+          .buildZkClient(connectionConfig, clientConfig, _metadataStoreRoutingData);\n+      Assert.fail(\"Should not succeed with an invalid sharding key!\");\n+    } catch (IllegalArgumentException e) {\n+      // Expected\n+    }\n+\n+    // Use a valid sharding key this time around\n+    String validShardingKey = ZK_SHARDING_KEY_PREFIX + \"_\" + 0; // Use TEST_SHARDING_KEY_0\n+    connectionConfig = new RealmAwareZkClient.RealmAwareZkConnectionConfig(validShardingKey);\n+    _realmAwareZkClient = DedicatedZkClientFactory.getInstance()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b80fec1b63590eae1d1d262d27249e7d959e488"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjkyNDM1", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-361692435", "createdAt": "2020-02-20T07:57:20Z", "commit": {"oid": "2f01c9937c2133af6b6bb57bc1bae1cc66308465"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNzo1NzoyMFrOFsJSNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNzo1OTozOFrOFsJV2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzMzc4MA==", "bodyText": "Since checkIfPathContainsShardingKey() is critical, can we add a test to cover this: valid path and all invalid path cases?", "url": "https://github.com/apache/helix/pull/765#discussion_r381833780", "createdAt": "2020-02-20T07:57:20Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestDedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.impl.factory.TrieRoutingData;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDedicatedZkClient extends ZkTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f01c9937c2133af6b6bb57bc1bae1cc66308465"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNDcxMw==", "bodyText": "If sharding key is /abcde, are these paths expected to pass this check and supposed to use this zkclient:\n\n/abcde_0/xxx\n/abcde/abcde-0/xxx", "url": "https://github.com/apache/helix/pull/765#discussion_r381834713", "createdAt": "2020-02-20T07:59:38Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    create(path, null, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    createEphemeral(path, null, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    create(path, null, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    create(path, data, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.EPHEMERAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.createEphemeral(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    return create(path, data, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.EPHEMERAL_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, sessionId);\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.createEphemeralSequential(path, data, acl, sessionId);\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, returnNullIfPathNotExists);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.readDataAndStat(path, stat, returnNullIfPathNotExists);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.getCreationTime(path);\n+  }\n+\n+  @Override\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _rawZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _rawZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _rawZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _rawZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _rawZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _rawZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.serialize(data, path);\n+  }\n+\n+  @Override\n+  public <T> T deserialize(byte[] data, String path) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.deserialize(data, path);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _rawZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _rawZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _rawZkClient.getZkSerializer();\n+  }\n+\n+  /**\n+   * Checks whether the given path belongs matches the ZK path sharding key this DedicatedZkClient is designated to at initialization.\n+   * @param path\n+   * @return\n+   */\n+  private void checkIfPathContainsShardingKey(String path) {\n+    if (!path.startsWith(_zkRealmShardingKey)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f01c9937c2133af6b6bb57bc1bae1cc66308465"}, "originalPosition": 459}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMTcyNDE0", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-362172414", "createdAt": "2020-02-20T19:27:58Z", "commit": {"oid": "2221562ffc5eb4742e91c584f887661461ffb7c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOToyNzo1OFrOFsgQRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOToyNzo1OFrOFsgQRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxMDExOQ==", "bodyText": "Nit. We can provide a default implementation of this one. The default implementation would call the above one by constructing an default  RealmAwareZkClient.RealmAwareZkClientConfig.", "url": "https://github.com/apache/helix/pull/765#discussion_r382210119", "createdAt": "2020-02-20T19:27:58Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/factory/RealmAwareZkClientFactory.java", "diffHunk": "@@ -30,16 +31,21 @@\n    * Build a RealmAwareZkClient using specified connection config and client config.\n    * @param connectionConfig\n    * @param clientConfig\n+   * @param metadataStoreRoutingData\n    * @return HelixZkClient\n    */\n+  // TODO: remove MetadataStoreRoutingData\n   RealmAwareZkClient buildZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n-      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig);\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData);\n \n   /**\n    * Builds a RealmAwareZkClient using specified connection config and default client config.\n    * @param connectionConfig\n+   * @param metadataStoreRoutingData\n    * @return RealmAwareZkClient\n    */\n-  RealmAwareZkClient buildZkClient(\n-      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig);\n+  // TODO: remove MetadataStoreRoutingData\n+  RealmAwareZkClient buildZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2221562ffc5eb4742e91c584f887661461ffb7c0"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMTgyMzQ3", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-362182347", "createdAt": "2020-02-20T19:43:01Z", "commit": {"oid": "2221562ffc5eb4742e91c584f887661461ffb7c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOTo0MzowMVrOFsgvog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOTo0MzowMVrOFsgvog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxODE0Ng==", "bodyText": "There is ZkTestBase in Helix common before. So what is the strategy here.\n1/ Are we going to remove that ZkTestBase from Helix common and associated test?\n2/ Move ZkTestBase in Helix common and associated test here?\n3/ Have two ZKTestBase s and their related test in parallel?", "url": "https://github.com/apache/helix/pull/765#discussion_r382218146", "createdAt": "2020-02-20T19:43:01Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/ZkTestBase.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.apache.helix.zookeeper.impl;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2221562ffc5eb4742e91c584f887661461ffb7c0"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjc2MzQ3", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-362276347", "createdAt": "2020-02-20T22:20:10Z", "commit": {"oid": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyMDoxMFrOFslKVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyMDoxMFrOFslKVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MDUxOQ==", "bodyText": "As a general comment. As we took the approach to composition (aka create new class DedicatedZkClient), theoretically, it would be ideal to test the new method even it is a thin wrapper.\nIf we choose the approach of modifying the ZKClient, since the code is not change, we can reason that limiting our testing to only the modified part, namely the checkingPath validity part would be enough.\nConsidering composition is only a thin wrapper, I don't see the necessity to do it right now. However, later if we change the code of DedicatedZkClient implementation more, we should add more test then.", "url": "https://github.com/apache/helix/pull/765#discussion_r382290519", "createdAt": "2020-02-20T22:20:10Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/RealmAwareZkClientTestBase.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.zookeeper.impl.client;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjc5NjY1", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-362279665", "createdAt": "2020-02-20T22:26:38Z", "commit": {"oid": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyNjozOFrOFslU5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyNjozOFrOFslU5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MzIyMQ==", "bodyText": "This is same class as helix-core, right? Since helix-core refers this module, can we remove the test base in the core?", "url": "https://github.com/apache/helix/pull/765#discussion_r382293221", "createdAt": "2020-02-20T22:26:38Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/ZkTestBase.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.apache.helix.zookeeper.impl;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.management.MBeanServerConnection;\n+import javax.management.ObjectName;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.helix.zookeeper.zkclient.IDefaultNameSpace;\n+import org.apache.helix.zookeeper.zkclient.ZkServer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterSuite;\n+import org.testng.annotations.BeforeSuite;\n+\n+\n+/**\n+ * Test base class for various integration tests with an in-memory ZooKeeper.\n+ */\n+public class ZkTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjg3Njg5", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-362287689", "createdAt": "2020-02-20T22:42:29Z", "commit": {"oid": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2661825aa94cd1465763201eaf6172bf4bbd5e6", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/b2661825aa94cd1465763201eaf6172bf4bbd5e6", "committedDate": "2020-02-21T00:07:15Z", "message": "WIP: Add DedicatedZkClient and update DedicatedZkClientFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c86d1d148d4a45c250915756de6cb7c53e6366b", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/9c86d1d148d4a45c250915756de6cb7c53e6366b", "committedDate": "2020-02-21T00:07:15Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "673a9754d05d61387b3b9f880f22282f924ed375", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/673a9754d05d61387b3b9f880f22282f924ed375", "committedDate": "2020-02-21T00:07:15Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcff9fc8e903227ce548951e82f551d8c9a55dba", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/bcff9fc8e903227ce548951e82f551d8c9a55dba", "committedDate": "2020-02-21T00:07:15Z", "message": "Add MetadataStoreRoutingData temporarily"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b132cf30a6c804a90d53d70aec40707c43021fc8", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/b132cf30a6c804a90d53d70aec40707c43021fc8", "committedDate": "2020-02-21T00:07:15Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19326d32ee50faac686e4e4d3b24ade3a2d23d31", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/19326d32ee50faac686e4e4d3b24ade3a2d23d31", "committedDate": "2020-02-21T00:07:15Z", "message": "Just do a sharding key check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2195260328d7afb018c75658ef88debe35e95eb", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/c2195260328d7afb018c75658ef88debe35e95eb", "committedDate": "2020-02-21T00:07:15Z", "message": "Update and address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29a16eb34f0a4ec45b65b4cf7acdff8756153c88", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/29a16eb34f0a4ec45b65b4cf7acdff8756153c88", "committedDate": "2020-02-21T00:07:15Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9629737e60e5f2f2a710747db082bf8b76dca29b", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/9629737e60e5f2f2a710747db082bf8b76dca29b", "committedDate": "2020-02-21T00:07:15Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad1d251de83a66072cd9cd87ea2b5c2606a155df", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/ad1d251de83a66072cd9cd87ea2b5c2606a155df", "committedDate": "2020-02-21T00:07:15Z", "message": "Update tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7345f8a3a243ec3bf2019c706c6dbccef92de801", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/7345f8a3a243ec3bf2019c706c6dbccef92de801", "committedDate": "2020-02-21T00:07:15Z", "message": "Update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4535ed69f491816efe4997110cdfc4a26178317", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/c4535ed69f491816efe4997110cdfc4a26178317", "committedDate": "2020-02-21T00:07:15Z", "message": "asdf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16940e2c0adcee53f8d1e9dc03b68db65afd8d65", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/16940e2c0adcee53f8d1e9dc03b68db65afd8d65", "committedDate": "2020-02-21T00:07:15Z", "message": "Fix'\ngit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "committedDate": "2020-02-21T00:13:16Z", "message": "Rebase onto apache zooscalability"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6b6a6ec2b1ee8d961c857e8fcbfeea888611236", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/b6b6a6ec2b1ee8d961c857e8fcbfeea888611236", "committedDate": "2020-02-20T21:21:11Z", "message": "Fix'\ngit"}, "afterCommit": {"oid": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/f8ed4a63d927f3859a99cef3126c6ae5e9403c9c", "committedDate": "2020-02-21T00:13:16Z", "message": "Rebase onto apache zooscalability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODIzMzAz", "url": "https://github.com/apache/helix/pull/765#pullrequestreview-363823303", "createdAt": "2020-02-25T01:51:47Z", "commit": {"oid": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMTo1MTo0N1rOFt2IyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMTo1MTo0N1rOFt2IyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxNzIyNQ==", "bodyText": "checkIfPathContainsShardingKey(path); _rawZkClient.createPersistent(path, createParents); \nDelegate to other public API is anti-pattern of composition and delegation or sometime called PIMPL in C++ world. It make harder to reason if this is keeping the _rawZkClient's behavior or not. In fact, if later _rawZkClient implementation is changed, you may have unexpected behavior.\nThere are other places like this.", "url": "https://github.com/apache/helix/pull/765#discussion_r383617225", "createdAt": "2020-02-25T01:51:47Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/DedicatedZkClient.java", "diffHunk": "@@ -0,0 +1,473 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkConnection;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;\n+import org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer;\n+import org.apache.helix.zookeeper.zkclient.serialize.ZkSerializer;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.OpResult;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * NOTE: DO NOT USE THIS CLASS DIRECTLY. Use DedicatedZkClientFactory to create instances of DedicatedZkClient.\n+ *\n+ * An implementation of the RealmAwareZkClient interface.\n+ * Supports CRUD, data change subscription, and ephemeral mode operations.\n+ */\n+public class DedicatedZkClient implements RealmAwareZkClient {\n+  private static Logger LOG = LoggerFactory.getLogger(DedicatedZkClient.class);\n+\n+  private final ZkClient _rawZkClient;\n+  private final MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmShardingKey;\n+  private final String _zkRealmAddress;\n+\n+  // TODO: Remove MetadataStoreRoutingData from constructor\n+  public DedicatedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: Get it from static map/singleton (HttpRoutingDataReader)\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create a ZK connection\n+    IZkConnection zkConnection =\n+        new ZkConnection(zkRealmAddress, connectionConfig.getSessionTimeout());\n+\n+    // Create a ZkClient\n+    _rawZkClient = new ZkClient(zkConnection, (int) clientConfig.getConnectInitTimeout(),\n+        clientConfig.getOperationRetryTimeout(), clientConfig.getZkSerializer(),\n+        clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n+        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n+  }\n+\n+  @Override\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    return _rawZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkIfPathContainsShardingKey(path);\n+    _rawZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _rawZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _rawZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ed4a63d927f3859a99cef3126c6ae5e9403c9c"}, "originalPosition": 143}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4968, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}