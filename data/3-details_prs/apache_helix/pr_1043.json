{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Mzg2Njk5", "number": 1043, "title": "Code clean up Topology.java", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n#1042 Validate instance topology configuration before let it comes online\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nWe need sanity check for topology definition in InstanceConfig in multiple places. Since we already have sanity check logic in controller/rebalancer/topology/Topology.java and controller/rebalancer/waged/model/AssignableNode.java, it's better to extract the logic into an single util function first and use the same logic to do sanity check in multiple places.\nThis PR is the first PR for issue #1042. It extracts the sanity check logic in multiple functions into one single function in Topology.java to align with the topology verification logic in AssignableNode.java.\nIt also changes the implementation for InstanceConfig.getDomainAsMap since to resolve CPU usage hotspot showed in CPU profiler.\nTests\n\n The following tests are written for this issue:\n\nNo new test is added since this PR is code clean up.\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[ERROR] Failures: \n[ERROR]   TestWagedRebalance.testChangeIdealState:271->validate:614 expected:<true> but was:<false>                                                      \n[ERROR]   TestDeleteJobFromJobQueue.testForceDeleteJobFromJobQueue:75 \u00bb Helix Failed to ...                                                              \n[ERROR]   TestWorkflowTermination.testWorkflowRunningTimeout:126 \u00bb Helix Workflow \"testW...                                                              \n[INFO]\n[ERROR] Tests run: 1145, Failures: 3, Errors: 0, Skipped: 1\n\n\n[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 40.747 s - in org.apache.helix.integration.rebalancer.WagedRebalancer.TestWagedRebalance\n[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 9.246 s - in org.apache.helix.integration.task.TestDeleteJobFromJobQueue\n[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 32.675 s - in org.apache.helix.integration.task.TestWorkflowTermination\n\n\n\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-05-30T00:36:49Z", "url": "https://github.com/apache/helix/pull/1043", "merged": true, "mergeCommit": {"oid": "5fd37e98be5ec941370392df51c118e60f203421"}, "closed": true, "closedAt": "2020-06-22T20:56:33Z", "author": {"login": "xyuanlu"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmSOKhAFqTQyMTM4NDg3Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABctARbxgFqTQzNDQwMzAxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzg0ODc3", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-421384877", "createdAt": "2020-05-30T07:10:23Z", "commit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzoxMDoyM1rOGcxHTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNzo0ODoyM1rOGcxQeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ==", "bodyText": "LinkedHashMap implements Map interface. I suggest keeping Map.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432817999", "createdAt": "2020-05-30T07:10:23Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxODE3MQ==", "bodyText": "I suggest using Map interface as type.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432818171", "createdAt": "2020-05-30T07:13:35Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxODM0Nw==", "bodyText": "Instead of String.format, I suggest parameterized logging: logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\nString.format is slower. And parameterized logging eliminates string concatenation if WARN level logging is not enabled.\nSame for the other logging you changed in this PR.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432818347", "createdAt": "2020-05-30T07:16:53Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDIwOA==", "bodyText": "In what case the IllegalArgumentException is thrown from getDomainAsMap? Is this same behavior with the old condition check?", "url": "https://github.com/apache/helix/pull/1043#discussion_r432820208", "createdAt": "2020-05-30T07:46:08Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyMDM0NQ==", "bodyText": "I suggest making \"Helix_default_\" a constant because the constant eliminates redundant string objects: constant is only one string object but this would create one string each time.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432820345", "createdAt": "2020-05-30T07:48:23Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 264}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19c39e9f31bd6427402fa1de772f1ba7e3a5eef0", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/19c39e9f31bd6427402fa1de772f1ba7e3a5eef0", "committedDate": "2020-05-30T23:11:10Z", "message": "Address comments"}, "afterCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/98a3dd81fd188e410f67ba353350462a89bb4306", "committedDate": "2020-05-30T23:20:03Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTQxNTE4", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-421541518", "createdAt": "2020-06-01T00:12:25Z", "commit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDoxMjoyNVrOGc8KLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDoxMjoyNVrOGc8KLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5ODk1OQ==", "bodyText": "I'd like to know the rationale of setting default value. Basically if the \"domain\" field is not set, we throw an exception, but if the \"domain\" is set with a random value, we think it is fine and give it a default zone value. How do we know it doesn't cause problem for rebalance.", "url": "https://github.com/apache/helix/pull/1043#discussion_r432998959", "createdAt": "2020-06-01T00:12:25Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length()==0) {\n+              value = _defaultPathPrefix + key;\n+            }\n+            instanceTopologyMap.put(key, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 268}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTQ0NTYy", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-421544562", "createdAt": "2020-06-01T00:37:22Z", "commit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDozNzoyMlrOGc8Uyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDozNzoyMlrOGc8Uyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMTY3NQ==", "bodyText": "Please review the convention for defining constant Strings in Java.\nhttps://stackoverflow.com/questions/9639007/defining-constant-string-in-java\nWith that said, is this prefix necessary?", "url": "https://github.com/apache/helix/pull/1043#discussion_r433001675", "createdAt": "2020-06-01T00:37:22Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private final String _defaultPathPrefix = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTQ1NjYz", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-421545663", "createdAt": "2020-06-01T00:45:38Z", "commit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDo0NTozOFrOGc8Ywg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDo0NTozOFrOGc8Ywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjY5MA==", "bodyText": "@xyuanlu\nLet's use a Map to declare?\nAnd what you said about LinkedHashMap is true, but Map is a higher-level construct (interface) and LinkedHashMap is an implementation. Even if you wanted a LinkedHashMap instance, how do you guarantee that the map has the right order? If you want to be 100% sure about the order, you have two options:\n\nMake it crystal clear that the user must pass in ordered map (TreeMap or LinkedHashMap)\ndo your own sorting internally.\n\nWith that said, what you said about using LinkedHashMap for declaration implies that maybe we should review the difference between declaration and implementation. Here's a helpful explanation: https://stackoverflow.com/questions/11715485/what-is-the-difference-between-declaration-and-definition-in-java", "url": "https://github.com/apache/helix/pull/1043#discussion_r433002690", "createdAt": "2020-06-01T00:45:38Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTQ1NzIw", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-421545720", "createdAt": "2020-06-01T00:46:06Z", "commit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDo0NjowNlrOGc8Y_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMDo0NjowNlrOGc8Y_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjc1MA==", "bodyText": "Let's use Map instead...", "url": "https://github.com/apache/helix/pull/1043#discussion_r433002750", "createdAt": "2020-06-01T00:46:06Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +186,106 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306"}, "originalPosition": 147}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "98a3dd81fd188e410f67ba353350462a89bb4306", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/98a3dd81fd188e410f67ba353350462a89bb4306", "committedDate": "2020-05-30T23:20:03Z", "message": "Address comments"}, "afterCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/11f71b1dc05a7fd895b2fb4ddf1c248c01652a71", "committedDate": "2020-06-02T21:44:49Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDg1OTQ3", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-424085947", "createdAt": "2020-06-04T04:01:10Z", "commit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDowMToxMFrOGe1CIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDowMjo0NlrOGe1DkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTM2Mw==", "bodyText": "Helix usually have all capitalized strings as our naming convention. Is this newly introduced or exists before?", "url": "https://github.com/apache/helix/pull/1043#discussion_r434979363", "createdAt": "2020-06-04T04:01:10Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private static final String DEFAULT_PATH_PREFIX = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTcyOA==", "bodyText": "Why not change this to be while clause since this already lost advantage of for loop for instantiation.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434979728", "createdAt": "2020-06-04T04:02:46Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,42 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        for (; lastValidTypeIdx >= 0; --lastValidTypeIdx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/11f71b1dc05a7fd895b2fb4ddf1c248c01652a71", "committedDate": "2020-06-02T21:44:49Z", "message": "Address comments"}, "afterCommit": {"oid": "7e3ccbb87c78e2177b65dbbf3f7251b0d7089761", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/7e3ccbb87c78e2177b65dbbf3f7251b0d7089761", "committedDate": "2020-06-04T18:11:51Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e3ccbb87c78e2177b65dbbf3f7251b0d7089761", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/7e3ccbb87c78e2177b65dbbf3f7251b0d7089761", "committedDate": "2020-06-04T18:11:51Z", "message": "Address comments"}, "afterCommit": {"oid": "a034e9ad92b038e3eb11dc490bbeb7966455ea3b", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/a034e9ad92b038e3eb11dc490bbeb7966455ea3b", "committedDate": "2020-06-05T00:00:02Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a034e9ad92b038e3eb11dc490bbeb7966455ea3b", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/a034e9ad92b038e3eb11dc490bbeb7966455ea3b", "committedDate": "2020-06-05T00:00:02Z", "message": "Address comments"}, "afterCommit": {"oid": "056b52ce125e2d08e0bdcca58b53c9c4fffe2bd4", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/056b52ce125e2d08e0bdcca58b53c9c4fffe2bd4", "committedDate": "2020-06-05T00:20:05Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "056b52ce125e2d08e0bdcca58b53c9c4fffe2bd4", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/056b52ce125e2d08e0bdcca58b53c9c4fffe2bd4", "committedDate": "2020-06-05T00:20:05Z", "message": "Address comments"}, "afterCommit": {"oid": "0b9edc39040f096207819f11f7310e49374e20c9", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/0b9edc39040f096207819f11f7310e49374e20c9", "committedDate": "2020-06-05T20:55:12Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b9edc39040f096207819f11f7310e49374e20c9", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/0b9edc39040f096207819f11f7310e49374e20c9", "committedDate": "2020-06-05T20:55:12Z", "message": "Address comments"}, "afterCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/5beceaa88043afd696067a081a6fbc404888c709", "committedDate": "2020-06-08T22:06:12Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTAyNjkx", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-424102691", "createdAt": "2020-06-04T04:58:48Z", "commit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNDo1ODo0OFrOGe13HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowNToxNFrOGiLKAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk5MjkyNQ==", "bodyText": "Why it is PATH_PREFIX, I think it should be the VALUE_PREFIX. Of course, the value prefix is not a good name either. Let's call it DEFAULT_DOMAIN_PREFIX. And add some comments to indicate what's the usage.", "url": "https://github.com/apache/helix/pull/1043#discussion_r434992925", "createdAt": "2020-06-04T04:58:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -55,16 +55,10 @@\n   private final List<String> _liveInstances;\n   private final Map<String, InstanceConfig> _instanceConfigMap;\n   private final ClusterConfig _clusterConfig;\n-  private final boolean _topologyAwareEnabled;\n+  private static final String DEFAULT_PATH_PREFIX = \"Helix_default_\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3OTM2Mw=="}, "originalCommit": {"oid": "11f71b1dc05a7fd895b2fb4ddf1c248c01652a71"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MDcxNA==", "bodyText": "This logic cannot handle the following case correctly,\n\"/domain/rack///node/\"", "url": "https://github.com/apache/helix/pull/1043#discussion_r438470714", "createdAt": "2020-06-11T00:00:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ==", "bodyText": "This operation is more expansive than the original code. What's the purpose of modifying this part? It does not seem to be simpler.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438481995", "createdAt": "2020-06-11T00:43:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MjE1Mw==", "bodyText": "Note this operation is called many times during the rebalance, so any incremental delay is impactful. Must be very careful, or the rebalance latency will be increased.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438482153", "createdAt": "2020-06-11T00:44:10Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyStr = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = topologyStr.length - 1;\n+        while(lastValidTypeIdx >= 0) {\n+          if (topologyStr[lastValidTypeIdx].length() != 0) {\n+            break;\n           }\n+          --lastValidTypeIdx;\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (lastValidTypeIdx < 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyStr[lastValidTypeIdx];\n+        _faultZoneType = clusterConfig.getFaultZoneType();\n+        if (_faultZoneType == null) {\n+          _faultZoneType = _endNodeType;\n+        }\n+        if (Arrays.stream(topologyStr).noneMatch(type -> type.equals(_faultZoneType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTk5NQ=="}, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MzA0Mg==", "bodyText": "In this case, please convert the pathNameMap to be a LinkedHashMap input.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438483042", "createdAt": "2020-06-11T00:47:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int numOfmatchedKeys = 0;\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length() == 0) {\n+              value = DEFAULT_PATH_PREFIX + key;\n+            } else {\n+              numOfmatchedKeys++;\n+            }\n+            instanceTopologyMap.put(key, value);\n+          }\n+        }\n+        if (numOfmatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology {}\",\n+              domain, topologyKeys.toString());\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return instanceTopologyMap;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n+   * Input param 'pathNameMap' must have a certain order where the order of the keys should be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4Mzk3Nw==", "bodyText": "This should be LinkedHashMap", "url": "https://github.com/apache/helix/pull/1043#discussion_r438483977", "createdAt": "2020-06-11T00:51:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTE1OQ==", "bodyText": "This is duplicate code, let's have a private method to check if the node is enabled or not.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438485159", "createdAt": "2020-06-11T00:55:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTI5Mg==", "bodyText": "This comment is not right.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438485292", "createdAt": "2020-06-11T00:56:04Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NTc5OQ==", "bodyText": "Why not directly call domainAsMap = instanceConfig.getDomainAsMap();?", "url": "https://github.com/apache/helix/pull/1043#discussion_r438485799", "createdAt": "2020-06-11T00:58:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NjM4Mg==", "bodyText": "I would prefer to keep it. A LinkedHashSet or ArrayList would be much easier to handle compared with array.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438486382", "createdAt": "2020-06-11T01:00:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +75,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NjU4Mg==", "bodyText": "Could you just input the String[] topologyStr (or a LinkedHashSet which I would recommend) to this method so you don't do the calculation again?", "url": "https://github.com/apache/helix/pull/1043#discussion_r438486582", "createdAt": "2020-06-11T01:01:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NzI4Ng==", "bodyText": "Mention here that the default domain value has been used. Otherwise, this warning looks like a major problem.", "url": "https://github.com/apache/helix/pull/1043#discussion_r438487286", "createdAt": "2020-06-11T01:04:09Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          // we have the hierarchy style of domain id for instance.\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing ZONE_ID information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing ZONE setting, ignore it should be fine.\n+            logger.warn(\"ZONE_ID for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fail the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\"Domain for instance {} is not set, ignore the instance!\", instance);\n+            return null;\n+          }\n+        }\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int numOfmatchedKeys = 0;\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            String value = domainAsMap.get(key);\n+            if (value == null || value.length() == 0) {\n+              value = DEFAULT_PATH_PREFIX + key;\n+            } else {\n+              numOfmatchedKeys++;\n+            }\n+            instanceTopologyMap.put(key, value);\n+          }\n+        }\n+        if (numOfmatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4NzU1NA==", "bodyText": "instance -> instanceName", "url": "https://github.com/apache/helix/pull/1043#discussion_r438487554", "createdAt": "2020-06-11T01:05:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +187,129 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      Map<String, String> instanceTopologyMap =\n+          computeInstanceTopologyMap(_clusterConfig, instance, insConfig);\n+      if (instanceTopologyMap != null) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n       }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig    clusterConfig of the cluster.\n+   * @param instance         Name of the given instance.\n+   * @param instanceConfig   instanceConfig of the instance.\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(ClusterConfig clusterConfig,\n+      String instance, InstanceConfig instanceConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709"}, "originalPosition": 207}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5beceaa88043afd696067a081a6fbc404888c709", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/5beceaa88043afd696067a081a6fbc404888c709", "committedDate": "2020-06-08T22:06:12Z", "message": "Address comments"}, "afterCommit": {"oid": "9bf4c5f0089ef9079537d2714af6e8f622e1692a", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/9bf4c5f0089ef9079537d2714af6e8f622e1692a", "committedDate": "2020-06-12T06:33:34Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9bf4c5f0089ef9079537d2714af6e8f622e1692a", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/9bf4c5f0089ef9079537d2714af6e8f622e1692a", "committedDate": "2020-06-12T06:33:34Z", "message": "address comments"}, "afterCommit": {"oid": "f592493c87fec60f060580eb40c98b2cfc73fa88", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/f592493c87fec60f060580eb40c98b2cfc73fa88", "committedDate": "2020-06-12T19:51:48Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f592493c87fec60f060580eb40c98b2cfc73fa88", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/f592493c87fec60f060580eb40c98b2cfc73fa88", "committedDate": "2020-06-12T19:51:48Z", "message": "address comments"}, "afterCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/c93fc1398b740546d79039926777df32078c314c", "committedDate": "2020-06-12T21:31:27Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDg5MDE0", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-430089014", "createdAt": "2020-06-13T00:01:49Z", "commit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowMTo0OVrOGjUNBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDoyNjo0NFrOGjUbGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDM1OQ==", "bodyText": "Does \"_clusterTopologyKeys.get(_clusterTopologyKeys.size() - 1)\"  works the same? But you won't need lastValidTypeIdx in that way.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439684359", "createdAt": "2020-06-13T00:01:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +78,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n+    _clusterTopologyKeys = new LinkedHashSet<>();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            _clusterTopologyKeys.add(topologyKeys[i]);\n+            lastValidTypeIdx = i;\n           }\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (_clusterTopologyKeys.size() == 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);\n-            lastType = type;\n-          }\n-          _endNodeType = lastType;\n-          _faultZoneType = clusterConfig.getFaultZoneType();\n-          if (_faultZoneType == null) {\n-            _faultZoneType = _endNodeType;\n-          }\n-          if (!_types.contains(_faultZoneType)) {\n-            throw new HelixException(String\n-                .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n-                    _faultZoneType, topologyDef));\n-          }\n-          _useDefaultTopologyDef = false;\n+        }\n+        _endNodeType = topologyKeys[lastValidTypeIdx];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTk3Mg==", "bodyText": "nit, just put in the try block. It is not used outside.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439685972", "createdAt": "2020-06-13T00:12:40Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjE1Nw==", "bodyText": "Where do you update this map? I didn't see in your latest version.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439686157", "createdAt": "2020-06-13T00:14:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -81,62 +78,43 @@ public Topology(final List<String> allNodes, final List<String> liveNodes,\n       throw new HelixException(String.format(\"Config for instances %s is not found!\",\n           _allInstances.removeAll(_instanceConfigMap.keySet())));\n     }\n-\n     _clusterConfig = clusterConfig;\n-    _types = new LinkedHashSet<>();\n-    _topologyAwareEnabled = clusterConfig.isTopologyAwareEnabled();\n+    _clusterTopologyKeys = new LinkedHashSet<>();\n \n-    if (_topologyAwareEnabled) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n       String topologyDef = _clusterConfig.getTopology();\n       if (topologyDef != null) {\n         // Customized cluster topology definition is configured.\n-        String[] types = topologyDef.trim().split(\"/\");\n-        for (int i = 0; i < types.length; i++) {\n-          if (types[i].length() != 0) {\n-            _types.add(types[i]);\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            _clusterTopologyKeys.add(topologyKeys[i]);\n+            lastValidTypeIdx = i;\n           }\n         }\n-        if (_types.size() == 0) {\n-          logger.error(\"Invalid cluster topology definition \" + topologyDef);\n+        if (_clusterTopologyKeys.size() == 0) {\n           throw new HelixException(\"Invalid cluster topology definition \" + topologyDef);\n-        } else {\n-          String lastType = null;\n-          for (String type : _types) {\n-            _defaultDomainPathValues.put(type, \"Helix_default_\" + type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc0OA==", "bodyText": "It won't be null, I guess. Don't overprotect the code, it may hide issues.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439686748", "createdAt": "2020-06-13T00:18:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc2Nw==", "bodyText": "It won't be null. Don't overprotect the code, it may hide issues.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439686767", "createdAt": "2020-06-13T00:18:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzUwMw==", "bodyText": "I see you want a lazy initialization. It's good design.\nBut since you are modifying the input parameter implicitly, it might be clearer to just refer to _defaultDomainPathValues. Otherwise, there is an implicit assumption that the caller needs to pass the same map for all the calls.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439687503", "createdAt": "2020-06-13T00:23:42Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n+        }\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value =\n+                defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzY0NA==", "bodyText": "Add the corresponding comment as you did for the other 2 conditions above.", "url": "https://github.com/apache/helix/pull/1043#discussion_r439687644", "createdAt": "2020-06-13T00:24:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +190,124 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      LinkedHashMap<String, String> instanceTopologyMap;\n+      try {\n+        instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys, _defaultDomainPathValues);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys,\n+      Map<String, String> defaultDomainPathValuesCache) throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys == null || clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+                  instanceConfig.getDomainAsString(), instanceName), e);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        if (domainAsMap == null || domainAsMap.isEmpty()) {\n+          throw new IllegalArgumentException(String\n+              .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n+        }\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value =\n+                defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));\n+          } else {\n+            numOfMatchedKeys++;\n+          }\n+          instanceTopologyMap.put(key, value);\n+        }\n+        if (numOfMatchedKeys != domainAsMap.size()) {\n+          logger.warn(\n+              \"Key-value pairs in InstanceConfig.Domain {} do not align with keys in ClusterConfig.Topology \"\n+                  + \"{}, using default domain value instead\", instanceConfig.getDomainAsString(),\n+              clusterTopologyKeys.toString());\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Nzk2MA==", "bodyText": "I talked with Xiaoyuan, since the method logic requires the input map has a fixed iterate order, I suggest her to use the explicit type. Please note that if you input a Map instantiate by HashMap, then the method won't work as expected!", "url": "https://github.com/apache/helix/pull/1043#discussion_r439687960", "createdAt": "2020-06-13T00:26:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +185,104 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n+    for (String instance : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instance);\n+      LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+      if (computeInstanceTopologyMap(_clusterConfig, instance, insConfig, instanceTopologyMap)) {\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instance, instanceTopologyMap, weight, _liveInstances);\n+      }\n+    }\n+    return root;\n+  }\n+\n+  private boolean computeInstanceTopologyMap(ClusterConfig clusterConfig, String instance,\n+      InstanceConfig instanceConfig, LinkedHashMap<String, String> instanceTopologyMap) {\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef == null) {\n+        // Return a map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n         if (zone == null) {\n           // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n             // if enabled instance missing ZONE_ID information, fails the rebalance.\n             throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n+                .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n           } else {\n             // if the disabled instance missing ZONE setting, ignore it should be fine.\n             logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n+                .format(\"ZONE_ID for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n           }\n-\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n-      }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n-    }\n-    return root;\n-  }\n-\n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n+      } else {\n+        /*\n+         * Return a map representing the cluster structure using cluster topology defined in\n+         * TOPOLOGY in ClusterConfig.\n+         */\n+        String domain = instanceConfig.getDomainAsString();\n+        if (domain == null || domain.isEmpty()) {\n+          if (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+              || !clusterConfig.getDisabledInstances().containsKey(instance))) {\n+            // if enabled instance missing domain information, fails the rebalance.\n+            throw new HelixException(String\n+                .format(\"Domain for instance %s is not set, fail the topology-aware placement!\",\n+                    instance));\n+          } else {\n+            // if the disabled instance missing domain setting, ignore it should be fine.\n+            logger.warn(\n+                String.format(\"Domain for instance %s is not set, ignore the instance!\", instance));\n+            return false;\n+          }\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        Map<String, String> domainAsMap;\n+        try {\n+          domainAsMap = instanceConfig.getDomainAsMap();\n+        } catch (IllegalArgumentException e) {\n           throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+              \"Domain %s for instance %s is not valid, fail the topology-aware placement!\",\n+              domain, instance));\n         }\n-        String type = values[0];\n-        String value = values[1];\n-\n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        for (String key : topologyKeys) {\n+          if (!key.isEmpty()) {\n+            // if a key does not exist in the instance domain config, apply the default domain value.\n+            instanceTopologyMap.put(key, domainAsMap.getOrDefault(key, \"Helix_default_\" + key));\n+          }\n         }\n-        pathValueMap.put(type, value);\n-      }\n-\n-      int weight = insConfig.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n+    } else {\n+      instanceTopologyMap.put(Types.INSTANCE.name(), instance);\n     }\n-    return root;\n+    return true;\n   }\n \n-\n   /**\n    * Add an end node to the tree, create all the paths to the leaf node if not present.\n    */\n-  private Node addEndNode(Node root, String instanceName, Map<String, String> pathNameMap,\n+  private void addEndNode(Node root, String instanceName, LinkedHashMap<String, String> pathNameMap,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNzk5OQ=="}, "originalCommit": {"oid": "461e843d21212b985e00d9a152b9d1dc553b05f1"}, "originalPosition": 287}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c93fc1398b740546d79039926777df32078c314c", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/c93fc1398b740546d79039926777df32078c314c", "committedDate": "2020-06-12T21:31:27Z", "message": "address comments"}, "afterCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/482e8f22150c39205c742a1b8de7c4de9d28d3f4", "committedDate": "2020-06-13T04:40:35Z", "message": "address hotspot in CPU usage profiler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODcwODcz", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-432870873", "createdAt": "2020-06-18T00:57:53Z", "commit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1Nzo1M1rOGlcFzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1OTo1MlrOGlcHoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDczMg==", "bodyText": "Isn't this block the same logic as getDomainAsMap()?", "url": "https://github.com/apache/helix/pull/1043#discussion_r441910732", "createdAt": "2020-06-18T00:57:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMTIwMQ==", "bodyText": "Remove", "url": "https://github.com/apache/helix/pull/1043#discussion_r441911201", "createdAt": "2020-06-18T00:59:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -212,123 +191,122 @@ private static Node cloneTree(Node root, Map<Node, Integer> newNodeWeight, Set<N\n     return newRoot;\n   }\n \n-  /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n-   */\n-  private Node createClusterTreeWithDefaultTopologyDef() {\n+  private Node createClusterTree() {\n     // root\n     Node root = new Node();\n     root.setName(\"root\");\n     root.setId(computeId(\"root\"));\n     root.setType(Types.ROOT.name());\n \n-    for (String ins : _allInstances) {\n-      InstanceConfig config = _instanceConfigMap.get(ins);\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      if (_topologyAwareEnabled) {\n-        String zone = config.getZoneId();\n-        if (zone == null) {\n-          // we have the hierarchy style of domain id for instance.\n-          if (config.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-              || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-            // if enabled instance missing ZONE_ID information, fails the rebalance.\n-            throw new HelixException(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-          } else {\n-            // if the disabled instance missing ZONE setting, ignore it should be fine.\n-            logger.warn(String\n-                .format(\"ZONE_ID for instance %s is not set, failed the topology-aware placement!\",\n-                    ins));\n-            continue;\n-          }\n-\n+    // TODO: Currently we add disabled instance to the topology tree. Since they are not considered\n+    // TODO: in relabalnce, maybe we should skip adding them to the tree for consistence.\n+    for (String instanceName : _allInstances) {\n+      InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n+      try {\n+        LinkedHashMap<String, String> instanceTopologyMap =\n+            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n+                insConfig, _clusterTopologyKeys);\n+        int weight = insConfig.getWeight();\n+        if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n+          weight = DEFAULT_NODE_WEIGHT;\n+        }\n+        addEndNode(root, instanceName, instanceTopologyMap, weight, _liveInstances);\n+      } catch (IllegalArgumentException e) {\n+        if (isInstanceEnabled(_clusterConfig, instanceName, insConfig)) {\n+          throw e;\n+        } else {\n+          logger\n+              .warn(\"Topology setting {} for instance {} is unset or invalid, ignore the instance!\",\n+                  insConfig.getDomainAsString(), instanceName);\n         }\n-        pathValueMap.put(Types.ZONE.name(), zone);\n-      }\n-      pathValueMap.put(Types.INSTANCE.name(), ins);\n-      int weight = config.getWeight();\n-      if (weight < 0 || weight == InstanceConfig.WEIGHT_NOT_SET) {\n-        weight = DEFAULT_NODE_WEIGHT;\n       }\n-      root = addEndNode(root, ins, pathValueMap, weight, _liveInstances);\n     }\n     return root;\n   }\n \n+  private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceName,\n+      InstanceConfig instanceConfig) {\n+    return (instanceConfig.getInstanceEnabled() && (clusterConfig.getDisabledInstances() == null\n+        || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n+  }\n+\n   /**\n-   * Creates a tree representing the cluster structure using default cluster topology definition\n-   * (i,e no topology definition given and no domain id set).\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n    */\n-  private Node createClusterTreeWithCustomizedTopology() {\n-    // root\n-    Node root = new Node();\n-    root.setName(\"root\");\n-    root.setId(computeId(\"root\"));\n-    root.setType(Types.ROOT.name());\n-\n-    for (String ins : _allInstances) {\n-      InstanceConfig insConfig = _instanceConfigMap.get(ins);\n-      String domain = insConfig.getDomainAsString();\n-      if (domain == null) {\n-        if (insConfig.getInstanceEnabled() && (_clusterConfig.getDisabledInstances() == null\n-            || !_clusterConfig.getDisabledInstances().containsKey(ins))) {\n-          // if enabled instance missing domain information, fails the rebalance.\n-          throw new HelixException(String\n-              .format(\"Domain for instance %s is not set, failed the topology-aware placement!\",\n-                  ins));\n-        } else {\n-          // if the disabled instance missing domain setting, ignore it should be fine.\n-          logger\n-              .warn(String.format(\"Domain for instance %s is not set, ignore the instance!\", ins));\n-          continue;\n+  private LinkedHashMap<String, String> computeInstanceTopologyMap(boolean isTopologyAwareEnabled,\n+      String instanceName, InstanceConfig instanceConfig, LinkedHashSet<String> clusterTopologyKeys)\n+      throws IllegalArgumentException {\n+    LinkedHashMap<String, String> instanceTopologyMap = new LinkedHashMap<>();\n+    if (isTopologyAwareEnabled) {\n+      if (clusterTopologyKeys.size() == 0) {\n+        // Return a ordered map using default cluster topology definition, i,e. /root/zone/instance\n+        String zone = instanceConfig.getZoneId();\n+        if (zone == null) {\n+          throw new IllegalArgumentException(String\n+              .format(\"ZONE_ID for instance %s is not set, fail the topology-aware placement!\",\n+                  instanceName));\n         }\n-      }\n-\n-      String[] pathPairs = domain.trim().split(\",\");\n-      Map<String, String> pathValueMap = new HashMap<>();\n-      for (String pair : pathPairs) {\n-        String[] values = pair.trim().split(\"=\");\n-        if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n-          throw new HelixException(String.format(\n-              \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n-              pair, ins));\n+        instanceTopologyMap.put(Types.ZONE.name(), zone);\n+        instanceTopologyMap.put(Types.INSTANCE.name(), instanceName);\n+      } else {\n+        /*\n+         * Return a ordered map representing the instance path. The topology order is defined in\n+         * ClusterConfig.topology.\n+         */\n+        Map<String, String> domainAsMap = new HashMap<>();\n+        String[] pathPairs = instanceConfig.getDomainAsString().trim().split(\",\");\n+        for (String pair : pathPairs) {\n+          String[] values = pair.trim().split(\"=\");\n+          if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+            throw new IllegalArgumentException(String.format(\n+                \"Domain-Value pair %s for instance %s is not valid, failed the topology-aware placement!\",\n+                pair, instanceName));\n+          }\n+          domainAsMap.put(values[0], values[1]);\n         }\n-        String type = values[0];\n-        String value = values[1];\n \n-        if (!_types.contains(type)) {\n-          logger.warn(String\n-              .format(\"Path %s defined in domain of instance %s not recognized, ignored!\", pair,\n-                  ins));\n-          continue;\n+        int numOfMatchedKeys = 0;\n+        for (String key : clusterTopologyKeys) {\n+          // if a key does not exist in the instance domain config, using the default domain value.\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            value = _defaultDomainPathValues.get(key);\n+                //defaultDomainPathValuesCache.computeIfAbsent(key, k -> (DEFAULT_DOMAIN_PREFIX + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4"}, "originalPosition": 272}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "482e8f22150c39205c742a1b8de7c4de9d28d3f4", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/482e8f22150c39205c742a1b8de7c4de9d28d3f4", "committedDate": "2020-06-13T04:40:35Z", "message": "address hotspot in CPU usage profiler"}, "afterCommit": {"oid": "e5240646303291e85618bf2da3c090ebf7de8173", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/e5240646303291e85618bf2da3c090ebf7de8173", "committedDate": "2020-06-18T17:56:39Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5240646303291e85618bf2da3c090ebf7de8173", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/e5240646303291e85618bf2da3c090ebf7de8173", "committedDate": "2020-06-18T17:56:39Z", "message": "address comments"}, "afterCommit": {"oid": "b45cd77c209b7973be0250ec724b1032f8d77274", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/b45cd77c209b7973be0250ec724b1032f8d77274", "committedDate": "2020-06-18T23:11:19Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9efb3bdc8ab4ee90e76a56104f679630f6698ffc", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/9efb3bdc8ab4ee90e76a56104f679630f6698ffc", "committedDate": "2020-06-19T18:38:57Z", "message": "code clean up  Topology.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fc211d84140e426ff4bc2fe0cce8002b6b9d206", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/0fc211d84140e426ff4bc2fe0cce8002b6b9d206", "committedDate": "2020-06-19T18:38:57Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6908e3daaf35bc54e427c569c31ebc28a46fd17b", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/6908e3daaf35bc54e427c569c31ebc28a46fd17b", "committedDate": "2020-06-19T18:38:57Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a28b38232c7f0b5e6ed3fe7f30bb7108341d87a9", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/a28b38232c7f0b5e6ed3fe7f30bb7108341d87a9", "committedDate": "2020-06-19T18:38:57Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a316f7098eff7f4ab6174e6c201d99f8904e1d3a", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/a316f7098eff7f4ab6174e6c201d99f8904e1d3a", "committedDate": "2020-06-19T18:38:57Z", "message": "address hotspot in CPU usage profiler"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b45cd77c209b7973be0250ec724b1032f8d77274", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/b45cd77c209b7973be0250ec724b1032f8d77274", "committedDate": "2020-06-18T23:11:19Z", "message": "address comments"}, "afterCommit": {"oid": "528400efa8bddb5d6e79c287c9d01b41a29944a6", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/528400efa8bddb5d6e79c287c9d01b41a29944a6", "committedDate": "2020-06-19T18:38:57Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "528400efa8bddb5d6e79c287c9d01b41a29944a6", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/528400efa8bddb5d6e79c287c9d01b41a29944a6", "committedDate": "2020-06-19T18:38:57Z", "message": "address comments"}, "afterCommit": {"oid": "836e752c484a82c0342c02bb4b0a015a1230fd4a", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/836e752c484a82c0342c02bb4b0a015a1230fd4a", "committedDate": "2020-06-19T18:52:57Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/e496ec67055f6068250dc6912c4550bbecc128f3", "committedDate": "2020-06-19T22:17:45Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "836e752c484a82c0342c02bb4b0a015a1230fd4a", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/836e752c484a82c0342c02bb4b0a015a1230fd4a", "committedDate": "2020-06-19T18:52:57Z", "message": "address comments"}, "afterCommit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/e496ec67055f6068250dc6912c4550bbecc128f3", "committedDate": "2020-06-19T22:17:45Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzkzMzAz", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-434393303", "createdAt": "2020-06-20T01:38:58Z", "commit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwMTozODo1OVrOGmkGXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQwMTozODo1OVrOGmkGXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MDUyNA==", "bodyText": "We shall trim at the final values level but not the above layers. What do you think?", "url": "https://github.com/apache/helix/pull/1043#discussion_r443090524", "createdAt": "2020-06-20T01:38:59Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -150,12 +150,22 @@ public String getDomainAsString() {\n    */\n   public Map<String, String> getDomainAsMap() {\n     String domain = getDomainAsString();\n+    Map<String, String> domainAsMap = new HashMap<>();\n     if (domain == null || domain.isEmpty()) {\n-      return Collections.emptyMap();\n+      return domainAsMap;\n+    }\n+\n+    String[] pathPairs = domain.trim().split(\",\");\n+    for (String pair : pathPairs) {\n+      String[] values = pair.trim().split(\"=\");\n+      if (values.length != 2 || values[0].isEmpty() || values[1].isEmpty()) {\n+        throw new IllegalArgumentException(\n+            String.format(\"Domain-Value pair %s is not valid.\", pair));\n+      }\n+      domainAsMap.put(values[0], values[1]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e496ec67055f6068250dc6912c4550bbecc128f3"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ad96ac7f1dbc28dd368dfbfe9e2184d1e006cfd", "author": {"user": {"login": "xyuanlu", "name": null}}, "url": "https://github.com/apache/helix/commit/4ad96ac7f1dbc28dd368dfbfe9e2184d1e006cfd", "committedDate": "2020-06-20T02:08:22Z", "message": "address comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDAzMDEw", "url": "https://github.com/apache/helix/pull/1043#pullrequestreview-434403010", "createdAt": "2020-06-20T04:51:43Z", "commit": {"oid": "4ad96ac7f1dbc28dd368dfbfe9e2184d1e006cfd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4423, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}