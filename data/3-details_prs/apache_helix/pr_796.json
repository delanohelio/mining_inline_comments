{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDU5ODE1", "number": 796, "title": "Add SharedZkClient/InnerSharedZkClient implementation", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nfix #762\nDescription\n\n\n Here are some details about my PR\nRefactor the original SharedZkClient to InnerSharedZkClient. Add\nSharedZkClient implementation. The implementation use composition\npattern. It would check the ZkPath validity and delegate the\nimplementation to InnerSharedZkClient. In sum, InnerSharedZkClient\nis shared ZkClient but not realm aware. SharedZkClient is truely\nrealm aware ZkClient.\n\n\nTests\n\n The following tests are written for this issue:\n\nTestSharedZkClient\n\n The following is the result of the \"mvn test\" command on the appropriate module [zookeeper-api]:\n[INFO]\n[INFO] -------------------------------------------------------\n[INFO]  T E S T S\n[INFO] -------------------------------------------------------\n[INFO] Running TestSuite\n[WARNING] Tests run: 12, Failures: 0, Errors: 0, Skipped: 5, Time elapsed: 1.662 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[WARNING] Tests run: 12, Failures: 0, Errors: 0, Skipped: 5\n[INFO]\n[INFO]\n[INFO] --- maven-surefire-plugin:3.0.0-M3:test (multi-zk) @ zookeeper-api ---\n[INFO]\n[INFO] -------------------------------------------------------\n[INFO]  T E S T S\n[INFO] -------------------------------------------------------\n[INFO] Running TestSuite\n[WARNING] Tests run: 12, Failures: 0, Errors: 0, Skipped: 5, Time elapsed: 1.703 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[WARNING] Tests run: 12, Failures: 0, Errors: 0, Skipped: 5\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  7.828 s\n[INFO] Finished at: 2020-02-27T14:36:07-08:00\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-21T01:29:02Z", "url": "https://github.com/apache/helix/pull/796", "merged": true, "mergeCommit": {"oid": "5fc6305d7b8df8f668d38ab6be3bf0ba59b8d2bd"}, "closed": true, "closedAt": "2020-02-27T22:55:42Z", "author": {"login": "kaisun2000"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGWcuhgBqjMwNTkwNTIyMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIjS7tAFqTM2NjA1MzUzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05b8814e216e06796f6f03d20cfc6ff2a3ab5e8c", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/05b8814e216e06796f6f03d20cfc6ff2a3ab5e8c", "committedDate": "2020-02-21T01:06:30Z", "message": "WIP: add SharedZkClient/InnerSharedZkClient implementation\n\nRefactor the original SharedZkClient to InnerSharedZkClient. Add\nSharedZkClient implementation. The implementation use composition\npattern. It would check the ZkPath validity and delegate the\nimplementation to InnerSharedZkClient. In sum, InnerSharedZkClient\nis shared ZkClient but not realm aware. SharedZkClient is truely\nrealm aware ZkClient."}, "afterCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a", "committedDate": "2020-02-21T02:34:43Z", "message": "WIP: add SharedZkClient/InnerSharedZkClient implementation\n\nRefactor the original SharedZkClient to InnerSharedZkClient. Add\nSharedZkClient implementation. The implementation use composition\npattern. It would check the ZkPath validity and delegate the\nimplementation to InnerSharedZkClient. In sum, InnerSharedZkClient\nis shared ZkClient but not realm aware. SharedZkClient is truely\nrealm aware ZkClient."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzc0Nzkz", "url": "https://github.com/apache/helix/pull/796#pullrequestreview-362374793", "createdAt": "2020-02-21T03:05:03Z", "commit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNTowNFrOFsqVOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzoxMToxOFrOFsqauw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTIyNA==", "bodyText": "Duplicate code. Please create a private method for this.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375224", "createdAt": "2020-02-21T03:05:04Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTQzMg==", "bodyText": "Call its own method like ZkClient to reduce maintenance effort.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375432", "createdAt": "2020-02-21T03:05:57Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTYzNQ==", "bodyText": "Don't forget _innerSharedZkClient. otherwise stack overflow.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375635", "createdAt": "2020-02-21T03:06:49Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTgzMw==", "bodyText": "Wrap it into a single private method to check path.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375833", "createdAt": "2020-02-21T03:07:41Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTk2Mg==", "bodyText": "Please call _innerSharedZkClient.readData()", "url": "https://github.com/apache/helix/pull/796#discussion_r382375962", "createdAt": "2020-02-21T03:08:18Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjI1Mw==", "bodyText": "Why not assign value when declaring: one line ?", "url": "https://github.com/apache/helix/pull/796#discussion_r382376253", "createdAt": "2020-02-21T03:09:38Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjQ2NA==", "bodyText": "It seems HelixZkClient is deprecated. Shall we use RealmawareZkClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r382376464", "createdAt": "2020-02-21T03:10:39Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjYzNQ==", "bodyText": "Should not import this deprecated IZkStateListener.", "url": "https://github.com/apache/helix/pull/796#discussion_r382376635", "createdAt": "2020-02-21T03:11:18Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -20,13 +20,27 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.ZkConnectionManager;\n-import org.apache.helix.zookeeper.zkclient.IZkConnection;\n-import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDQ1NTQy", "url": "https://github.com/apache/helix/pull/796#pullrequestreview-363045542", "createdAt": "2020-02-22T19:11:53Z", "commit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToxMTo1NFrOFtMdWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOTozMToxMVrOFtMh7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDM2Mg==", "bodyText": "Why is this necessary? Could we remove this?", "url": "https://github.com/apache/helix/pull/796#discussion_r382934362", "createdAt": "2020-02-22T19:11:54Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/HelixZkClient.java", "diffHunk": "@@ -89,32 +89,28 @@ public int getSessionTimeout() {\n    * Deprecated - please use RealmAwareZkClient and RealmAwareZkClientConfig instead.\n    *\n    * Configuration for creating a new HelixZkClient with serializer and monitor.\n-   *\n-   * TODO: If possible, try to merge with RealmAwareZkClient's RealmAwareZkClientConfig to reduce duplicate logic/code (without breaking backward-compatibility).\n-   * Simply making this a subclass of RealmAwareZkClientConfig will break backward-compatiblity.\n    */\n   @Deprecated\n-  class ZkClientConfig {\n-    // For client to init the connection\n-    private long _connectInitTimeout = DEFAULT_CONNECTION_TIMEOUT;\n-\n-    // Data access configs\n-    private long _operationRetryTimeout = DEFAULT_OPERATION_TIMEOUT;\n-\n-    // Others\n-    private PathBasedZkSerializer _zkSerializer;\n-\n-    // Monitoring\n-    private String _monitorType;\n-    private String _monitorKey;\n-    private String _monitorInstanceName = null;\n-    private boolean _monitorRootPathOnly = true;\n+  class ZkClientConfig extends RealmAwareZkClientConfig {\n+    /*\n+    public ZkClientConfig(RealmAwareZkClientConfig rConfig) {\n+      this._zkSerializer = rConfig.getZkSerializer();\n+      this._connectInitTimeout = rConfig.getConnectInitTimeout();\n+      this._operationRetryTimeout = rConfig.getOperationRetryTimeout();\n+      this._monitorInstanceName = rConfig.getMonitorInstanceName();\n+      this._monitorKey = rConfig.getMonitorKey();\n+      this._monitorType = rConfig.getMonitorType();\n+      this._monitorRootPathOnly = rConfig.isMonitorRootPathOnly();\n+    }\n+    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDQ0MA==", "bodyText": "Why is this necessary? Since we already have a TODO, we don't need to leave this here as a block comment.\nIn general, our coding standards are such that we avoid code that's blocked out like this. Please consider removing this as you revise this PR :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382934440", "createdAt": "2020-02-22T19:13:33Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/factory/RealmAwareZkClientFactory.java", "diffHunk": "@@ -45,11 +45,17 @@ RealmAwareZkClient buildZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig\n    * @param metadataStoreRoutingData\n    * @return RealmAwareZkClient\n    */\n+\n   // TODO: remove MetadataStoreRoutingData\n   default RealmAwareZkClient buildZkClient(\n       RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n       MetadataStoreRoutingData metadataStoreRoutingData) {\n     return buildZkClient(connectionConfig, new RealmAwareZkClient.RealmAwareZkClientConfig(),\n         metadataStoreRoutingData);\n+    /*\n+  default RealmAwareZkClient buildZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig) {\n+    return buildZkClient(connectionConfig, new RealmAwareZkClient.RealmAwareZkClientConfig());\n+  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDU1OQ==", "bodyText": "If this is going to build without this import, then we should remove it. If this doesn't build, let us leave this here for the time being, and let's use #783 to track this work.\nHow does this sound @pkuwm ? This will be much easier because we could establish a clear action plan as a whole as to how we should remove these deprecated classes altogether throughout the codebase.", "url": "https://github.com/apache/helix/pull/796#discussion_r382934559", "createdAt": "2020-02-22T19:15:43Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -20,13 +20,27 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.ZkConnectionManager;\n-import org.apache.helix.zookeeper.zkclient.IZkConnection;\n-import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjYzNQ=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDgxMg==", "bodyText": "@kaisun2000\nAs I demonstrated in the PR that you got the diff for this PR from, there's a way to do this in a much simpler manner. You do not have to call all setters when you create an instance of ZkClientConfig.\nCould you please see https://github.com/apache/helix/pull/770/files#diff-74feb4babccc9de65b296f5a79178548R84 and revise this piece of code accordingly?", "url": "https://github.com/apache/helix/pull/796#discussion_r382934812", "createdAt": "2020-02-22T19:20:00Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTAwNw==", "bodyText": "This check is necessary here, but there is a way to make this much simpler by refactoring the block that throws the exception into the check() function. This was done in the following PR: https://github.com/apache/helix/pull/765/files#diff-851efd495ff678457258d26f3c9f854aR99\nCould you please review this PR and make the changes to cut down on duplicate code/logic? Thank you!", "url": "https://github.com/apache/helix/pull/796#discussion_r382935007", "createdAt": "2020-02-22T19:23:05Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA1MA==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935050", "createdAt": "2020-02-22T19:23:48Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA2Mg==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935062", "createdAt": "2020-02-22T19:24:03Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA3Mg==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935072", "createdAt": "2020-02-22T19:24:09Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA4MQ==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935081", "createdAt": "2020-02-22T19:24:15Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTE5NA==", "bodyText": "+1. There are a lot of overloaded methods here for creating ephemeral nodes.\nMy suggestion is that you could have the bottom-most method throw this UnsupportedOperationException, and have all of the other overloaded methods call the bottom-most method (the method with the most comprehensive list of parameters).\nThat way, we could cut down on a lot of duplication.", "url": "https://github.com/apache/helix/pull/796#discussion_r382935194", "createdAt": "2020-02-22T19:26:15Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTIyNA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTI4Ng==", "bodyText": "+1. This was an error in a previous PR. Please make sure we properly delegate the method to _innerSharedZkClient and not call itself recursively :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935286", "createdAt": "2020-02-22T19:27:23Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTYzNQ=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTMzNA==", "bodyText": "As @pkuwm said, please follow the pattern used here:\nhttps://github.com/apache/helix/pull/765/files#diff-851efd495ff678457258d26f3c9f854aR297", "url": "https://github.com/apache/helix/pull/796#discussion_r382935334", "createdAt": "2020-02-22T19:28:08Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTQwOA==", "bodyText": "As seen here: https://github.com/apache/helix/pull/765/files#diff-851efd495ff678457258d26f3c9f854aR459,\nwe could enhance this method to cut down on duplication:\n    try {\n      String zkRealmForPath = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n      if (!_zkRealmAddress.equals(zkRealmForPath)) {\n        throw new IllegalArgumentException(\"Given path: \" + path + \"'s ZK realm: \" + zkRealmForPath\n            + \" does not match the ZK realm: \" + _zkRealmAddress + \" and sharding key: \"\n            + _zkRealmShardingKey + \" for this DedicatedZkClient!\");\n      }\n    } catch (NoSuchElementException e) {\n      throw new IllegalArgumentException(\n          \"Given path: \" + path + \" does not have a valid sharding key!\");\n    }\n  }", "url": "https://github.com/apache/helix/pull/796#discussion_r382935408", "createdAt": "2020-02-22T19:29:16Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n     }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getCreationTime(path);\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _innerSharedZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _innerSharedZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _innerSharedZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _innerSharedZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _innerSharedZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _innerSharedZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.getConnection();\n+    return _innerSharedZkClient.serialize(data, path);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n+  public <T> T deserialize(byte[] data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.create(path, datat, acl, mode);\n+    return _innerSharedZkClient.deserialize(data, path);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _innerSharedZkClient.getZkSerializer();\n+  }\n+\n+  private boolean checkIfPathBelongsToZkRealm(String path) {\n+    // TODO: Check if the path's sharding key equals the sharding key\n+    // TODO: Implement this with TrieRoutingData\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 634}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTUzNA==", "bodyText": "@kaisun2000\nAs we discussed, there are a few more test cases we need to add to this test class.\nCould you please add more comprehensive test cases that cover ephemeral node operations for SharedZkClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r382935534", "createdAt": "2020-02-22T19:31:11Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.testng.annotations.BeforeClass;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODU1ODE3", "url": "https://github.com/apache/helix/pull/796#pullrequestreview-363855817", "createdAt": "2020-02-25T03:53:49Z", "commit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1Mzo0OVrOFt35Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNDowMToyM1rOFt3_IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NjAxMA==", "bodyText": "nit: consider renaming this method to checkIfPathContainsShardingKey and move it to the end of file to make it even with DedicatedZkClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r383646010", "createdAt": "2020-02-25T03:53:49Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,467 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+  private final  MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmAddress;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n-  @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n-      }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+  private void checkPathAndThrow(String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NjYyMw==", "bodyText": "@kaisun2000\nI see. In that case, I don't think\nclass ZkClientConfig extends RealmAwareZkClientConfig { is necessary. Could we remove that and all the overriding of the setter methods?", "url": "https://github.com/apache/helix/pull/796#discussion_r383646623", "createdAt": "2020-02-25T03:56:45Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDgxMg=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0Njg2NA==", "bodyText": "Nit: \"Creating ephemeral nodes...\"", "url": "https://github.com/apache/helix/pull/796#discussion_r383646864", "createdAt": "2020-02-25T03:58:01Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,467 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+  private final  MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmAddress;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n-  @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n-      }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+  private void checkPathAndThrow(String path) {\n+    // TODO: replace with the singleton MetadataStoreRoutingData\n+    try {\n+      String zkRealmForPath = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+      if (!_zkRealmAddress.equals(zkRealmForPath)) {\n+        throw new IllegalArgumentException(\"Given path: \" + path + \"'s ZK realm: \" + zkRealmForPath\n+            + \" does not match the ZK realm: \" + _zkRealmAddress + \" and sharding key: \"\n+            + _zkRealmShardingKey + \" for this DedicatedZkClient!\");\n       }\n+    } catch (NoSuchElementException e) {\n+      throw new IllegalArgumentException(\n+          \"Given path: \" + path + \" does not have a valid sharding key!\");\n     }\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n-    }\n-    return super.getConnection();\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkPathAndThrow(path);\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n-    }\n-    return super.create(path, datat, acl, mode);\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, createParents);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, data);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, data, acl);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    checkPathAndThrow(path);\n+    return _innerSharedZkClient.createPersistentSequential(path, data);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    checkPathAndThrow(path);\n+    return _innerSharedZkClient.createPersistentSequential(path, data, acl);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzAzOQ==", "bodyText": "@kaisun2000\nYou created another method called checkAndThrow. Could you consolidate that method into this one?", "url": "https://github.com/apache/helix/pull/796#discussion_r383647039", "createdAt": "2020-02-25T03:58:51Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n     }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getCreationTime(path);\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _innerSharedZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _innerSharedZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _innerSharedZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _innerSharedZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _innerSharedZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _innerSharedZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.getConnection();\n+    return _innerSharedZkClient.serialize(data, path);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n+  public <T> T deserialize(byte[] data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.create(path, datat, acl, mode);\n+    return _innerSharedZkClient.deserialize(data, path);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _innerSharedZkClient.getZkSerializer();\n+  }\n+\n+  private boolean checkIfPathBelongsToZkRealm(String path) {\n+    // TODO: Check if the path's sharding key equals the sharding key\n+    // TODO: Implement this with TrieRoutingData\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTQwOA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 634}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzEzOA==", "bodyText": "Nit: \"Creating\"", "url": "https://github.com/apache/helix/pull/796#discussion_r383647138", "createdAt": "2020-02-25T03:59:27Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -128,4 +139,78 @@ public int getActiveConnectionCount() {\n     }\n     return count;\n   }\n+\n+  public interface OnCloseCallback {\n+    /**\n+     * Triggered after the SharedZkClient is closed.\n+     */\n+    void onClose();\n+  }\n+\n+  /**\n+   * NOTE: do NOT use this class directly. Please use SharedZkClientFactory to create an instance of SharedZkClient.\n+   * InnerSharedZkClient is a ZkClient used by SharedZkClient to power ZK operations against a single ZK realm.\n+   *\n+   * NOTE2: current InnerSharedZkClient replace the original SharedZKClient. We intend to keep the behavior of original\n+   * SharedZkClient intact. (Think of rename the original SharedZkClient as InnerSharedZkClient. This would maintain\n+   * backward compatibility.\n+   */\n+  public static class InnerSharedZkClient extends ZkClient implements HelixZkClient {\n+\n+    private final OnCloseCallback _onCloseCallback;\n+    private final ZkConnectionManager _connectionManager;\n+\n+    public InnerSharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n+        OnCloseCallback callback) {\n+      super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n+          clientConfig.getZkSerializer(), clientConfig.getMonitorType(),\n+          clientConfig.getMonitorKey(), clientConfig.getMonitorInstanceName(),\n+          clientConfig.isMonitorRootPathOnly());\n+      _connectionManager = connectionManager;\n+      // Register to the base dedicated RealmAwareZkClient\n+      _connectionManager.registerWatcher(this);\n+      _onCloseCallback = callback;\n+    }\n+\n+    @Override\n+    public void close() {\n+      super.close();\n+      if (isClosed()) {\n+        // Note that if register is not done while constructing, these private fields may not be init yet.\n+        if (_connectionManager != null) {\n+          _connectionManager.unregisterWatcher(this);\n+        }\n+        if (_onCloseCallback != null) {\n+          _onCloseCallback.onClose();\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public IZkConnection getConnection() {\n+      if (isClosed()) {\n+        return IDLE_CONNECTION;\n+      }\n+      return super.getConnection();\n+    }\n+\n+    /**\n+     * Since ZkConnection session is shared in this HelixZkClient, do not create ephemeral node using a SharedZKClient.\n+     */\n+    @Override\n+    public String create(final String path, Object datat, final List<ACL> acl,\n+        final CreateMode mode) {\n+      if (mode.isEphemeral()) {\n+        throw new UnsupportedOperationException(\n+            \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzIxOQ==", "bodyText": "Fix the comment here?", "url": "https://github.com/apache/helix/pull/796#discussion_r383647219", "createdAt": "2020-02-25T03:59:57Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    super.beforeClass();\n+    // Set the factory to DedicatedZkClientFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzUyMA==", "bodyText": "Remove empty line?", "url": "https://github.com/apache/helix/pull/796#discussion_r383647520", "createdAt": "2020-02-25T04:01:23Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    super.beforeClass();\n+    // Set the factory to DedicatedZkClientFactory\n+    _realmAwareZkClientFactory = SharedZkClientFactory.getInstance();\n+  }\n+\n+  @Test\n+  public void testCreateEphemeralFailure() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // test createEphemeral should fail\n+    try {\n+      _realmAwareZkClient.createEphemeral(TEST_VALID_PATH);\n+      Assert.fail(\"sharedReamlAwareZkClient is not expected to be able to create ephemeral node via createEphemeral\");\n+    } catch (UnsupportedOperationException e){\n+      // this is expected\n+    }\n+\n+    // test creating Ephemeral via creat would also fail\n+    try {\n+      _realmAwareZkClient.create(TEST_VALID_PATH, znRecord, CreateMode.EPHEMERAL);\n+      Assert.fail(\"sharedRealmAwareZkClient is not expected to be able to create ephmeral node via create\");\n+    } catch (UnsupportedOperationException e) {\n+      // this is expected.\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDcyOTUx", "url": "https://github.com/apache/helix/pull/796#pullrequestreview-364472951", "createdAt": "2020-02-25T21:47:24Z", "commit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo0NzoyNFrOFuWaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo0NzoyNFrOFuWaaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NjAyNw==", "bodyText": "Remove empty line here?", "url": "https://github.com/apache/helix/pull/796#discussion_r384146027", "createdAt": "2020-02-25T21:47:24Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    super.beforeClass();\n+    // Set the factory to SharedZkClientFactory\n+    _realmAwareZkClientFactory = SharedZkClientFactory.getInstance();\n+  }\n+\n+  @Test\n+  public void testCreateEphemeralFailure() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // test createEphemeral should fail\n+    try {\n+      _realmAwareZkClient.createEphemeral(TEST_VALID_PATH);\n+      Assert.fail(\"sharedReamlAwareZkClient is not expected to be able to create ephemeral node via createEphemeral\");\n+    } catch (UnsupportedOperationException e){\n+      // this is expected\n+    }\n+\n+    // test creating Ephemeral via creat would also fail\n+    try {\n+      _realmAwareZkClient.create(TEST_VALID_PATH, znRecord, CreateMode.EPHEMERAL);\n+      Assert.fail(\"sharedRealmAwareZkClient is not expected to be able to create ephmeral node via create\");\n+    } catch (UnsupportedOperationException e) {\n+      // this is expected.\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTAwMzIx", "url": "https://github.com/apache/helix/pull/796#pullrequestreview-364500321", "createdAt": "2020-02-25T22:35:16Z", "commit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNToxN1rOFuXxHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNToxN1rOFuXxHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODIyMA==", "bodyText": "Is this moved from original SharedZKClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r384168220", "createdAt": "2020-02-25T22:35:17Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -128,4 +139,78 @@ public int getActiveConnectionCount() {\n     }\n     return count;\n   }\n+\n+  public interface OnCloseCallback {\n+    /**\n+     * Triggered after the SharedZkClient is closed.\n+     */\n+    void onClose();\n+  }\n+\n+  /**\n+   * NOTE: do NOT use this class directly. Please use SharedZkClientFactory to create an instance of SharedZkClient.\n+   * InnerSharedZkClient is a ZkClient used by SharedZkClient to power ZK operations against a single ZK realm.\n+   *\n+   * NOTE2: current InnerSharedZkClient replace the original SharedZKClient. We intend to keep the behavior of original\n+   * SharedZkClient intact. (Think of rename the original SharedZkClient as InnerSharedZkClient. This would maintain\n+   * backward compatibility.\n+   */\n+  public static class InnerSharedZkClient extends ZkClient implements HelixZkClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "958641db63118c2bf5ac7df3b2853b56b01fde04", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/958641db63118c2bf5ac7df3b2853b56b01fde04", "committedDate": "2020-02-27T19:31:05Z", "message": "Fix'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f018651dd5256a498405c4aa0f86a8dc43b93798", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/f018651dd5256a498405c4aa0f86a8dc43b93798", "committedDate": "2020-02-27T19:31:05Z", "message": "Remove import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c1365640981f4f7d08a3fb4732c2b6feff6119a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/9c1365640981f4f7d08a3fb4732c2b6feff6119a", "committedDate": "2020-02-27T19:31:05Z", "message": "WIP: add SharedZkClient/InnerSharedZkClient implementation\n\nRefactor the original SharedZkClient to InnerSharedZkClient. Add\nSharedZkClient implementation. The implementation use composition\npattern. It would check the ZkPath validity and delegate the\nimplementation to InnerSharedZkClient. In sum, InnerSharedZkClient\nis shared ZkClient but not realm aware. SharedZkClient is truely\nrealm aware ZkClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cef19cbdbae4d8ba3a3c804421e0fb6a6b4f1f6a", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/cef19cbdbae4d8ba3a3c804421e0fb6a6b4f1f6a", "committedDate": "2020-02-27T19:31:05Z", "message": "WIP: add sharedZkClient/InnerSharedZkClient implementation\n\n(continued) strictly follow the delegation pattern in sharedZkClient\nimplementation. Add test for testing createEphemeralNode failure\ncase."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb52281e0f6df77de1b58f3954c63c461aad17dd", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/fb52281e0f6df77de1b58f3954c63c461aad17dd", "committedDate": "2020-02-27T19:31:05Z", "message": "Addresses all the comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c576030930ea86b15eec60fd96a179e29cdac999", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/c576030930ea86b15eec60fd96a179e29cdac999", "committedDate": "2020-02-27T19:31:05Z", "message": "fixed some naming and nits comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcb8ae7b58cfceb74f88597d03f2d7167f7dbfee", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/fcb8ae7b58cfceb74f88597d03f2d7167f7dbfee", "committedDate": "2020-02-27T19:31:05Z", "message": "resolve some nit comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "202308f088d757d702fe505bb6529cca3227a2d4", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/202308f088d757d702fe505bb6529cca3227a2d4", "committedDate": "2020-02-27T22:22:47Z", "message": "rebase, applying coding style format schema, one more round of testing."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20761968595e399a679545ee7b8de48f0b506d11", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/20761968595e399a679545ee7b8de48f0b506d11", "committedDate": "2020-02-25T22:50:29Z", "message": "resolve some nit comment."}, "afterCommit": {"oid": "202308f088d757d702fe505bb6529cca3227a2d4", "author": {"user": null}, "url": "https://github.com/apache/helix/commit/202308f088d757d702fe505bb6529cca3227a2d4", "committedDate": "2020-02-27T22:22:47Z", "message": "rebase, applying coding style format schema, one more round of testing."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDUzNTMy", "url": "https://github.com/apache/helix/pull/796#pullrequestreview-366053532", "createdAt": "2020-02-27T22:44:50Z", "commit": {"oid": "202308f088d757d702fe505bb6529cca3227a2d4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4959, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}