{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MTYyODU0", "number": 1438, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODoyNToyMFrOEq3lAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODoyNToyMFrOEq3lAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzg2MjQzOnYy", "diffSide": "LEFT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/TaskGarbageCollectionStage.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODoyNToyMFrOHdUlTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToxODozNFrOHdaT1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNzk4MQ==", "bodyText": "why the previous way has a bug?", "url": "https://github.com/apache/helix/pull/1438#discussion_r500507981", "createdAt": "2020-10-06T18:25:20Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/TaskGarbageCollectionStage.java", "diffHunk": "@@ -73,9 +73,12 @@ public void process(ClusterEvent event) throws Exception {\n           continue;\n         }\n         long purgeInterval = workflowConfig.getJobPurgeInterval();\n+        if (purgeInterval <= 0) {\n+          continue;\n+        }\n         long currentTime = System.currentTimeMillis();\n         long nextPurgeTime = workflowContext.getLastJobPurgeTime() + purgeInterval;\n-        if (purgeInterval > 0 && nextPurgeTime <= currentTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6be1faec80cf057dec64e44cdc49a4797041322"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMzQzNQ==", "bodyText": "Since we allow negative delay in scheduleRebalance, which leads to immediate rebalance (on-demand), the current logic is incorrect. When job purge interval is non-positive, a rebalance is always triggered immediately.\nSee after this if statement for the rebalance scheduling line. That line is always triggered in the previous version.", "url": "https://github.com/apache/helix/pull/1438#discussion_r500513435", "createdAt": "2020-10-06T18:33:44Z", "author": {"login": "NealSun96"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/TaskGarbageCollectionStage.java", "diffHunk": "@@ -73,9 +73,12 @@ public void process(ClusterEvent event) throws Exception {\n           continue;\n         }\n         long purgeInterval = workflowConfig.getJobPurgeInterval();\n+        if (purgeInterval <= 0) {\n+          continue;\n+        }\n         long currentTime = System.currentTimeMillis();\n         long nextPurgeTime = workflowContext.getLastJobPurgeTime() + purgeInterval;\n-        if (purgeInterval > 0 && nextPurgeTime <= currentTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNzk4MQ=="}, "originalCommit": {"oid": "e6be1faec80cf057dec64e44cdc49a4797041322"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwMTgxNQ==", "bodyText": "I see due to this line:\n        scheduleNextJobPurge(workflowConfig.getWorkflowId(), nextPurgeTime, _rebalanceScheduler,\n            manager);\n\npreviously it always schedule the purge.\nHelp me to understand the impact of this a little bit more. With this change, event this is not always scheduled. From the perspective of flaky test, it does not matter, right? I mean with this pull change, we will still see the flaky test to be flaky.", "url": "https://github.com/apache/helix/pull/1438#discussion_r500601815", "createdAt": "2020-10-06T21:18:34Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/TaskGarbageCollectionStage.java", "diffHunk": "@@ -73,9 +73,12 @@ public void process(ClusterEvent event) throws Exception {\n           continue;\n         }\n         long purgeInterval = workflowConfig.getJobPurgeInterval();\n+        if (purgeInterval <= 0) {\n+          continue;\n+        }\n         long currentTime = System.currentTimeMillis();\n         long nextPurgeTime = workflowContext.getLastJobPurgeTime() + purgeInterval;\n-        if (purgeInterval > 0 && nextPurgeTime <= currentTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNzk4MQ=="}, "originalCommit": {"oid": "e6be1faec80cf057dec64e44cdc49a4797041322"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 991, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}