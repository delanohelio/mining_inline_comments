{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDU5ODE1", "number": 796, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNTowNFrODhwEqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNToxN1rODi4IXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE3MjI0OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNTowNFrOFsqVOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDozMzoyM1rOFtu5TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTIyNA==", "bodyText": "Duplicate code. Please create a private method for this.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375224", "createdAt": "2020-02-21T03:05:04Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTE5NA==", "bodyText": "+1. There are a lot of overloaded methods here for creating ephemeral nodes.\nMy suggestion is that you could have the bottom-most method throw this UnsupportedOperationException, and have all of the other overloaded methods call the bottom-most method (the method with the most comprehensive list of parameters).\nThat way, we could cut down on a lot of duplication.", "url": "https://github.com/apache/helix/pull/796#discussion_r382935194", "createdAt": "2020-02-22T19:26:15Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTIyNA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5ODU3Mg==", "bodyText": "We can do it in the final non public create() etc as my other proposal did.\nI thought it before. If you using composition, doing it in the wrapper method seems to have its merit. The reasoning is that you explicitly express that this is not supported for the interface you extends. Instead of relying on a underlying non public create to support it.\nIn fact, I adopt the strategy to strictly delegate to _inner for all implementation other than this one which we explicitly state not going to support. This is very easy to reason we are doing the right thing, namely delegation/composition.", "url": "https://github.com/apache/helix/pull/796#discussion_r383498572", "createdAt": "2020-02-24T20:33:23Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTIyNA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE3MzcxOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNTo1N1rOFsqWCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNTo1N1rOFsqWCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTQzMg==", "bodyText": "Call its own method like ZkClient to reduce maintenance effort.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375432", "createdAt": "2020-02-21T03:05:57Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE3NTAyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNjo0OVrOFsqW0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNzoyM1rOFtMg9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTYzNQ==", "bodyText": "Don't forget _innerSharedZkClient. otherwise stack overflow.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375635", "createdAt": "2020-02-21T03:06:49Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTI4Ng==", "bodyText": "+1. This was an error in a previous PR. Please make sure we properly delegate the method to _innerSharedZkClient and not call itself recursively :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935286", "createdAt": "2020-02-22T19:27:23Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTYzNQ=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE3NjM3OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNzo0MVrOFsqXmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowNzo0MVrOFsqXmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTgzMw==", "bodyText": "Wrap it into a single private method to check path.", "url": "https://github.com/apache/helix/pull/796#discussion_r382375833", "createdAt": "2020-02-21T03:07:41Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE3NzIwOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowODoxOFrOFsqYGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzoyMjoyNlrOFtzeBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTk2Mg==", "bodyText": "Please call _innerSharedZkClient.readData()", "url": "https://github.com/apache/helix/pull/796#discussion_r382375962", "createdAt": "2020-02-21T03:08:18Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3MzUwOA==", "bodyText": "This is a tip of iceberg. I will delegate public API impl to _innerSharedZkClient as much as possible.", "url": "https://github.com/apache/helix/pull/796#discussion_r383573508", "createdAt": "2020-02-24T23:22:26Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NTk2Mg=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE3OTI1OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowOTozOFrOFsqZPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowOTo1MVrOFtzM4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjI1Mw==", "bodyText": "Why not assign value when declaring: one line ?", "url": "https://github.com/apache/helix/pull/796#discussion_r382376253", "createdAt": "2020-02-21T03:09:38Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2OTEyMw==", "bodyText": "This would be changed to use to #775 HttpRoutingDataReader next. Will change them by then.", "url": "https://github.com/apache/helix/pull/796#discussion_r383569123", "createdAt": "2020-02-24T23:09:51Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjI1Mw=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE4MDY3OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzoxMDozOVrOFsqaEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowODowNVrOFtzKfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjQ2NA==", "bodyText": "It seems HelixZkClient is deprecated. Shall we use RealmawareZkClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r382376464", "createdAt": "2020-02-21T03:10:39Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2ODUxMQ==", "bodyText": "Here the design from @narendly is to reuse the existing (implementation) of HelixZkClient and specifically the shared builder method. This is intentionally.\nSince it is hides in the implementation part. It is not a big deal. This can potentially subject to change later if there is such need.", "url": "https://github.com/apache/helix/pull/796#discussion_r383568511", "createdAt": "2020-02-24T23:08:05Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjQ2NA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzE4MTg2OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzoxMToxOFrOFsqauw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjozMTo0NlrOFtySfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjYzNQ==", "bodyText": "Should not import this deprecated IZkStateListener.", "url": "https://github.com/apache/helix/pull/796#discussion_r382376635", "createdAt": "2020-02-21T03:11:18Z", "author": {"login": "huizhilu"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -20,13 +20,27 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.ZkConnectionManager;\n-import org.apache.helix.zookeeper.zkclient.IZkConnection;\n-import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDU1OQ==", "bodyText": "If this is going to build without this import, then we should remove it. If this doesn't build, let us leave this here for the time being, and let's use #783 to track this work.\nHow does this sound @pkuwm ? This will be much easier because we could establish a clear action plan as a whole as to how we should remove these deprecated classes altogether throughout the codebase.", "url": "https://github.com/apache/helix/pull/796#discussion_r382934559", "createdAt": "2020-02-22T19:15:43Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -20,13 +20,27 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.ZkConnectionManager;\n-import org.apache.helix.zookeeper.zkclient.IZkConnection;\n-import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjYzNQ=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1NDE3NQ==", "bodyText": "Actually we need them for subscribeStateChange.", "url": "https://github.com/apache/helix/pull/796#discussion_r383554175", "createdAt": "2020-02-24T22:31:46Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -20,13 +20,27 @@\n  */\n \n import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.ZkConnectionManager;\n-import org.apache.helix.zookeeper.zkclient.IZkConnection;\n-import org.apache.helix.zookeeper.zkclient.ZkConnection;\n+import org.apache.helix.zookeeper.api.client.RealmAwareZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.helix.zookeeper.zkclient.DataUpdater;\n+import org.apache.helix.zookeeper.zkclient.IZkChildListener;\n+import org.apache.helix.zookeeper.zkclient.IZkDataListener;\n+import org.apache.helix.zookeeper.zkclient.callback.ZkAsyncCallbacks;\n+import org.apache.helix.zookeeper.zkclient.deprecated.IZkStateListener;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjYzNQ=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDgzNDQ1OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/HelixZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToxMTo1NFrOFtMdWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToxMTo1NFrOFtMdWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDM2Mg==", "bodyText": "Why is this necessary? Could we remove this?", "url": "https://github.com/apache/helix/pull/796#discussion_r382934362", "createdAt": "2020-02-22T19:11:54Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/HelixZkClient.java", "diffHunk": "@@ -89,32 +89,28 @@ public int getSessionTimeout() {\n    * Deprecated - please use RealmAwareZkClient and RealmAwareZkClientConfig instead.\n    *\n    * Configuration for creating a new HelixZkClient with serializer and monitor.\n-   *\n-   * TODO: If possible, try to merge with RealmAwareZkClient's RealmAwareZkClientConfig to reduce duplicate logic/code (without breaking backward-compatibility).\n-   * Simply making this a subclass of RealmAwareZkClientConfig will break backward-compatiblity.\n    */\n   @Deprecated\n-  class ZkClientConfig {\n-    // For client to init the connection\n-    private long _connectInitTimeout = DEFAULT_CONNECTION_TIMEOUT;\n-\n-    // Data access configs\n-    private long _operationRetryTimeout = DEFAULT_OPERATION_TIMEOUT;\n-\n-    // Others\n-    private PathBasedZkSerializer _zkSerializer;\n-\n-    // Monitoring\n-    private String _monitorType;\n-    private String _monitorKey;\n-    private String _monitorInstanceName = null;\n-    private boolean _monitorRootPathOnly = true;\n+  class ZkClientConfig extends RealmAwareZkClientConfig {\n+    /*\n+    public ZkClientConfig(RealmAwareZkClientConfig rConfig) {\n+      this._zkSerializer = rConfig.getZkSerializer();\n+      this._connectInitTimeout = rConfig.getConnectInitTimeout();\n+      this._operationRetryTimeout = rConfig.getOperationRetryTimeout();\n+      this._monitorInstanceName = rConfig.getMonitorInstanceName();\n+      this._monitorKey = rConfig.getMonitorKey();\n+      this._monitorType = rConfig.getMonitorType();\n+      this._monitorRootPathOnly = rConfig.isMonitorRootPathOnly();\n+    }\n+    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDgzNDk3OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/factory/RealmAwareZkClientFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToxMzozM1rOFtMdqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToxMzozM1rOFtMdqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDQ0MA==", "bodyText": "Why is this necessary? Since we already have a TODO, we don't need to leave this here as a block comment.\nIn general, our coding standards are such that we avoid code that's blocked out like this. Please consider removing this as you revise this PR :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382934440", "createdAt": "2020-02-22T19:13:33Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/factory/RealmAwareZkClientFactory.java", "diffHunk": "@@ -45,11 +45,17 @@ RealmAwareZkClient buildZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig\n    * @param metadataStoreRoutingData\n    * @return RealmAwareZkClient\n    */\n+\n   // TODO: remove MetadataStoreRoutingData\n   default RealmAwareZkClient buildZkClient(\n       RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n       MetadataStoreRoutingData metadataStoreRoutingData) {\n     return buildZkClient(connectionConfig, new RealmAwareZkClient.RealmAwareZkClientConfig(),\n         metadataStoreRoutingData);\n+    /*\n+  default RealmAwareZkClient buildZkClient(\n+      RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig) {\n+    return buildZkClient(connectionConfig, new RealmAwareZkClient.RealmAwareZkClientConfig());\n+  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDgzODAzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyMDowMFrOFtMfHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1Njo0NVrOFt37nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDgxMg==", "bodyText": "@kaisun2000\nAs I demonstrated in the PR that you got the diff for this PR from, there's a way to do this in a much simpler manner. You do not have to call all setters when you create an instance of ZkClientConfig.\nCould you please see https://github.com/apache/helix/pull/770/files#diff-74feb4babccc9de65b296f5a79178548R84 and revise this piece of code accordingly?", "url": "https://github.com/apache/helix/pull/796#discussion_r382934812", "createdAt": "2020-02-22T19:20:00Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxMjQ5MQ==", "bodyText": "The code you wrote before does not work. If compiles but throw run time exception due to down-casting.", "url": "https://github.com/apache/helix/pull/796#discussion_r383612491", "createdAt": "2020-02-25T01:32:37Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDgxMg=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NjYyMw==", "bodyText": "@kaisun2000\nI see. In that case, I don't think\nclass ZkClientConfig extends RealmAwareZkClientConfig { is necessary. Could we remove that and all the overriding of the setter methods?", "url": "https://github.com/apache/helix/pull/796#discussion_r383646623", "createdAt": "2020-02-25T03:56:45Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNDgxMg=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDgzOTYzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyMzowNVrOFtMf3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyMzowNVrOFtMf3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTAwNw==", "bodyText": "This check is necessary here, but there is a way to make this much simpler by refactoring the block that throws the exception into the check() function. This was done in the following PR: https://github.com/apache/helix/pull/765/files#diff-851efd495ff678457258d26f3c9f854aR99\nCould you please review this PR and make the changes to cut down on duplicate code/logic? Thank you!", "url": "https://github.com/apache/helix/pull/796#discussion_r382935007", "createdAt": "2020-02-22T19:23:05Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0MDAwOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyMzo0OFrOFtMgCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyMzo0OFrOFtMgCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA1MA==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935050", "createdAt": "2020-02-22T19:23:48Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0MDA5OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNDowM1rOFtMgFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNDowM1rOFtMgFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA2Mg==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935062", "createdAt": "2020-02-22T19:24:03Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0MDE4OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNDowOVrOFtMgIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNDowOVrOFtMgIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA3Mg==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935072", "createdAt": "2020-02-22T19:24:09Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0MDI1OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNDoxNVrOFtMgKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyNDoxNVrOFtMgKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTA4MQ==", "bodyText": "Please review my comment above on making the check simpler and apply them to all methods overriden in SharedZkClient. Thanks :)", "url": "https://github.com/apache/helix/pull/796#discussion_r382935081", "createdAt": "2020-02-22T19:24:15Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0MjI5OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyODowOFrOFtMhJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMToxOTo1M1rOFt1pAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTMzNA==", "bodyText": "As @pkuwm said, please follow the pattern used here:\nhttps://github.com/apache/helix/pull/765/files#diff-851efd495ff678457258d26f3c9f854aR297", "url": "https://github.com/apache/helix/pull/796#discussion_r382935334", "createdAt": "2020-02-22T19:28:08Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwOTA5MQ==", "bodyText": "done.", "url": "https://github.com/apache/helix/pull/796#discussion_r383609091", "createdAt": "2020-02-25T01:19:53Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTMzNA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0Mjg3OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOToyOToxNlrOFtMhcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNDozOFrOFuRwRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTQwOA==", "bodyText": "As seen here: https://github.com/apache/helix/pull/765/files#diff-851efd495ff678457258d26f3c9f854aR459,\nwe could enhance this method to cut down on duplication:\n    try {\n      String zkRealmForPath = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n      if (!_zkRealmAddress.equals(zkRealmForPath)) {\n        throw new IllegalArgumentException(\"Given path: \" + path + \"'s ZK realm: \" + zkRealmForPath\n            + \" does not match the ZK realm: \" + _zkRealmAddress + \" and sharding key: \"\n            + _zkRealmShardingKey + \" for this DedicatedZkClient!\");\n      }\n    } catch (NoSuchElementException e) {\n      throw new IllegalArgumentException(\n          \"Given path: \" + path + \" does not have a valid sharding key!\");\n    }\n  }", "url": "https://github.com/apache/helix/pull/796#discussion_r382935408", "createdAt": "2020-02-22T19:29:16Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n     }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getCreationTime(path);\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _innerSharedZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _innerSharedZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _innerSharedZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _innerSharedZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _innerSharedZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _innerSharedZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.getConnection();\n+    return _innerSharedZkClient.serialize(data, path);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n+  public <T> T deserialize(byte[] data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.create(path, datat, acl, mode);\n+    return _innerSharedZkClient.deserialize(data, path);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _innerSharedZkClient.getZkSerializer();\n+  }\n+\n+  private boolean checkIfPathBelongsToZkRealm(String path) {\n+    // TODO: Check if the path's sharding key equals the sharding key\n+    // TODO: Implement this with TrieRoutingData\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 634}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwOTAyOA==", "bodyText": "done.", "url": "https://github.com/apache/helix/pull/796#discussion_r383609028", "createdAt": "2020-02-25T01:19:37Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n     }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getCreationTime(path);\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _innerSharedZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _innerSharedZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _innerSharedZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _innerSharedZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _innerSharedZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _innerSharedZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.getConnection();\n+    return _innerSharedZkClient.serialize(data, path);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n+  public <T> T deserialize(byte[] data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.create(path, datat, acl, mode);\n+    return _innerSharedZkClient.deserialize(data, path);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _innerSharedZkClient.getZkSerializer();\n+  }\n+\n+  private boolean checkIfPathBelongsToZkRealm(String path) {\n+    // TODO: Check if the path's sharding key equals the sharding key\n+    // TODO: Implement this with TrieRoutingData\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTQwOA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 634}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzAzOQ==", "bodyText": "@kaisun2000\nYou created another method called checkAndThrow. Could you consolidate that method into this one?", "url": "https://github.com/apache/helix/pull/796#discussion_r383647039", "createdAt": "2020-02-25T03:58:51Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n     }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getCreationTime(path);\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _innerSharedZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _innerSharedZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _innerSharedZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _innerSharedZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _innerSharedZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _innerSharedZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.getConnection();\n+    return _innerSharedZkClient.serialize(data, path);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n+  public <T> T deserialize(byte[] data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.create(path, datat, acl, mode);\n+    return _innerSharedZkClient.deserialize(data, path);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _innerSharedZkClient.getZkSerializer();\n+  }\n+\n+  private boolean checkIfPathBelongsToZkRealm(String path) {\n+    // TODO: Check if the path's sharding key equals the sharding key\n+    // TODO: Implement this with TrieRoutingData\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTQwOA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 634}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2OTcwMw==", "bodyText": "checkIfPathContainsShardingKey, will do.", "url": "https://github.com/apache/helix/pull/796#discussion_r384069703", "createdAt": "2020-02-25T19:14:38Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,549 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = null;\n+    zkRealmAddress = metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n   @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    createPersistent(path, false);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    createPersistent(path, createParents, ZooDefs.Ids.OPEN_ACL_UNSAFE);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    create(path, data, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    create(path, data, acl, CreateMode.PERSISTENT);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    return create(path, data, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    return create(path, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String create(String path, Object data, CreateMode mode) {\n+    return create(path, data, mode);\n+  }\n+\n+  @Override\n+  public String create(String path, Object datat, List<ACL> acl, CreateMode mode) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.create(path, datat, acl, mode);\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public void createEphemeral(String path, Object data, List<ACL> acl, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public String createEphemeralSequential(String path, Object data, List<ACL> acl,\n+      String sessionId) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()\n+            + \" is not supported.\");\n+  }\n+\n+  @Override\n+  public List<String> getChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getChildren(path);\n+  }\n+\n+  @Override\n+  public int countChildren(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return countChildren(path);\n+  }\n+\n+  @Override\n+  public boolean exists(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.exists(path);\n+  }\n+\n+  @Override\n+  public Stat getStat(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getStat(path);\n+  }\n+\n+  @Override\n+  public boolean waitUntilExists(String path, TimeUnit timeUnit, long time) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.waitUntilExists(path, timeUnit, time);\n+  }\n+\n+  @Override\n+  public void deleteRecursively(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.deleteRecursively(path);\n+  }\n+\n+  @Override\n+  public boolean delete(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.delete(path);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path) {\n+    return readData(path, false);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      return readData(path, null);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+    }\n+    return data;\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat);\n+  }\n+\n+  @Override\n+  public <T> T readData(String path, Stat stat, boolean watch) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.readData(path, stat, watch);\n+  }\n+\n+  @Override\n+  public <T> T readDataAndStat(String path, Stat stat, boolean returnNullIfPathNotExists) {\n+    T data = null;\n+    try {\n+      data = readData(path, stat);\n+    } catch (ZkNoNodeException e) {\n+      if (!returnNullIfPathNotExists) {\n+        throw e;\n       }\n     }\n+    return data;\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object object) {\n+    writeData(path, object, -1);\n+  }\n+\n+  @Override\n+  public <T> void updateDataSerialized(String path, DataUpdater<T> updater) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.updateDataSerialized(path, updater);\n+  }\n+\n+  @Override\n+  public void writeData(String path, Object datat, int expectedVersion) {\n+    writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataReturnStat(String path, Object datat, int expectedVersion) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public Stat writeDataGetStat(String path, Object datat, int expectedVersion) {\n+    return writeDataReturnStat(path, datat, expectedVersion);\n+  }\n+\n+  @Override\n+  public void asyncCreate(String path, Object datat, CreateMode mode,\n+      ZkAsyncCallbacks.CreateCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncCreate(path, datat, mode, cb);\n+  }\n+\n+  @Override\n+  public void asyncSetData(String path, Object datat, int version,\n+      ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncSetData(path, datat, version, cb);\n+  }\n+\n+  @Override\n+  public void asyncGetData(String path, ZkAsyncCallbacks.GetDataCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncGetData(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncExists(String path, ZkAsyncCallbacks.ExistsCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncExists(path, cb);\n+  }\n+\n+  @Override\n+  public void asyncDelete(String path, ZkAsyncCallbacks.DeleteCallbackHandler cb) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.asyncDelete(path, cb);\n+  }\n+\n+  @Override\n+  public void watchForData(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _innerSharedZkClient.watchForData(path);\n+  }\n+\n+  @Override\n+  public List<String> watchForChilds(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.watchForChilds(path);\n+  }\n+\n+  @Override\n+  public long getCreationTime(String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    return _innerSharedZkClient.getCreationTime(path);\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n+  public List<OpResult> multi(Iterable<Op> ops) {\n+    return _innerSharedZkClient.multi(ops);\n+  }\n+\n+  @Override\n+  public boolean waitUntilConnected(long time, TimeUnit timeUnit) {\n+    return _innerSharedZkClient.waitUntilConnected(time, timeUnit);\n+  }\n+\n+  @Override\n+  public String getServers() {\n+    return _innerSharedZkClient.getServers();\n+  }\n+\n+  @Override\n+  public long getSessionId() {\n+    return _innerSharedZkClient.getSessionId();\n+  }\n+\n+  @Override\n+  public void close() {\n+    _innerSharedZkClient.close();\n+  }\n+\n+  @Override\n+  public boolean isClosed() {\n+    return _innerSharedZkClient.isClosed();\n+  }\n+\n+  @Override\n+  public byte[] serialize(Object data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.getConnection();\n+    return _innerSharedZkClient.serialize(data, path);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n+  public <T> T deserialize(byte[] data, String path) {\n+    if (!checkIfPathBelongsToZkRealm(path)) {\n+      throw new IllegalArgumentException(\n+          \"The given path does not map to the ZK realm for this DedicatedZkClient! Path: \" + path\n+              + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n     }\n-    return super.create(path, datat, acl, mode);\n+    return _innerSharedZkClient.deserialize(data, path);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void setZkSerializer(ZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public void setZkSerializer(PathBasedZkSerializer zkSerializer) {\n+    _innerSharedZkClient.setZkSerializer(zkSerializer);\n+  }\n+\n+  @Override\n+  public PathBasedZkSerializer getZkSerializer() {\n+    return _innerSharedZkClient.getZkSerializer();\n+  }\n+\n+  private boolean checkIfPathBelongsToZkRealm(String path) {\n+    // TODO: Check if the path's sharding key equals the sharding key\n+    // TODO: Implement this with TrieRoutingData\n+    return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTQwOA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 634}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg0MzgzOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQxOTozMToxMVrOFtMh7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMTowOTo1NVrOFt1efg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTUzNA==", "bodyText": "@kaisun2000\nAs we discussed, there are a few more test cases we need to add to this test class.\nCould you please add more comprehensive test cases that cover ephemeral node operations for SharedZkClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r382935534", "createdAt": "2020-02-22T19:31:11Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.testng.annotations.BeforeClass;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNjM5OA==", "bodyText": "done.", "url": "https://github.com/apache/helix/pull/796#discussion_r383606398", "createdAt": "2020-02-25T01:09:55Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.testng.annotations.BeforeClass;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzNTUzNA=="}, "originalCommit": {"oid": "20ebaea9ac3e82f3c7a3ad7d871b3e46a8ec226a"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTYzMDMyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1Mzo0OVrOFt35Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNDoyM1rOFuRvvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NjAxMA==", "bodyText": "nit: consider renaming this method to checkIfPathContainsShardingKey and move it to the end of file to make it even with DedicatedZkClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r383646010", "createdAt": "2020-02-25T03:53:49Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,467 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+  private final  MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmAddress;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n-  @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n-      }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+  private void checkPathAndThrow(String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2OTU2NQ==", "bodyText": "sure.", "url": "https://github.com/apache/helix/pull/796#discussion_r384069565", "createdAt": "2020-02-25T19:14:23Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,467 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+  private final  MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmAddress;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n-  @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n-      }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+  private void checkPathAndThrow(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NjAxMA=="}, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTYzNTc3OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1ODowMVrOFt38kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1ODowMVrOFt38kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0Njg2NA==", "bodyText": "Nit: \"Creating ephemeral nodes...\"", "url": "https://github.com/apache/helix/pull/796#discussion_r383646864", "createdAt": "2020-02-25T03:58:01Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/SharedZkClient.java", "diffHunk": "@@ -37,79 +51,467 @@\n  * HelixZkClient that uses shared ZkConnection.\n  * A SharedZkClient won't manipulate the shared ZkConnection directly.\n  */\n-public class SharedZkClient extends ZkClient implements HelixZkClient {\n+public class SharedZkClient implements RealmAwareZkClient {\n   private static Logger LOG = LoggerFactory.getLogger(SharedZkClient.class);\n-  /*\n-   * Since we cannot really disconnect the ZkConnection, we need a dummy ZkConnection placeholder.\n-   * This is to ensure connection field is never null even the shared RealmAwareZkClient instance is closed so as to avoid NPE.\n-   */\n-  private final static ZkConnection IDLE_CONNECTION = new ZkConnection(\"Dummy_ZkServers\");\n-  private final OnCloseCallback _onCloseCallback;\n-  private final ZkConnectionManager _connectionManager;\n-\n-  public interface OnCloseCallback {\n-    /**\n-     * Triggered after the RealmAwareZkClient is closed.\n-     */\n-    void onClose();\n-  }\n-\n-  /**\n-   * Construct a shared RealmAwareZkClient that uses a shared ZkConnection.\n-   *\n-   * @param connectionManager     The manager of the shared ZkConnection.\n-   * @param clientConfig          ZkClientConfig details to create the shared RealmAwareZkClient.\n-   * @param callback              Clean up logic when the shared RealmAwareZkClient is closed.\n-   */\n-  public SharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n-      OnCloseCallback callback) {\n-    super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n-        clientConfig.getZkSerializer(), clientConfig.getMonitorType(), clientConfig.getMonitorKey(),\n-        clientConfig.getMonitorInstanceName(), clientConfig.isMonitorRootPathOnly());\n-    _connectionManager = connectionManager;\n-    // Register to the base dedicated RealmAwareZkClient\n-    _connectionManager.registerWatcher(this);\n-    _onCloseCallback = callback;\n+\n+  private final HelixZkClient _innerSharedZkClient;\n+  private final String _zkRealmShardingKey;\n+  private final  MetadataStoreRoutingData _metadataStoreRoutingData;\n+  private final String _zkRealmAddress;\n+\n+  public SharedZkClient(RealmAwareZkClient.RealmAwareZkConnectionConfig connectionConfig,\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig,\n+      MetadataStoreRoutingData metadataStoreRoutingData) {\n+\n+    if (connectionConfig == null) {\n+      throw new IllegalArgumentException(\"RealmAwareZkConnectionConfig cannot be null!\");\n+    }\n+    _zkRealmShardingKey = connectionConfig.getZkRealmShardingKey();\n+\n+    if (metadataStoreRoutingData == null) {\n+      throw new IllegalArgumentException(\"MetadataStoreRoutingData cannot be null!\");\n+    }\n+    _metadataStoreRoutingData = metadataStoreRoutingData;\n+\n+    // TODO: use _zkRealmShardingKey to generate zkRealmAddress. This can done the same way of pull 765 once @hunter check it in.\n+    // Get the ZkRealm address based on the ZK path sharding key\n+    String zkRealmAddress = _metadataStoreRoutingData.getMetadataStoreRealm(_zkRealmShardingKey);\n+    if (zkRealmAddress == null || zkRealmAddress.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"ZK realm address for the given ZK realm sharding key is invalid! ZK realm address: \"\n+              + zkRealmAddress + \" ZK realm sharding key: \" + _zkRealmShardingKey);\n+    }\n+    _zkRealmAddress = zkRealmAddress;\n+\n+    // Create an InnerSharedZkClient to actually serve ZK requests\n+    // TODO: Rename HelixZkClient in the future or remove it entirely - this will be a backward-compatibility breaking change because HelixZkClient is being used by Helix users.\n+\n+    // Note, here delegate _innerSharedZkClient would share the same connectionManager. Once the close() API of\n+    // SharedZkClient is invoked, we can just call the close() API of delegate _innerSharedZkClient. This would follow\n+    // exactly the pattern of innerSharedZkClient closing logic, which would close the connectionManager when the last\n+    // sharedInnerZkClient is closed.\n+    HelixZkClient.ZkConnectionConfig zkConnectionConfig =\n+        new HelixZkClient.ZkConnectionConfig(zkRealmAddress)\n+            .setSessionTimeout(connectionConfig.getSessionTimeout());\n+    HelixZkClient.ZkClientConfig zkClientConfig = new HelixZkClient.ZkClientConfig();\n+    zkClientConfig.setZkSerializer(clientConfig.getZkSerializer())\n+        .setConnectInitTimeout(clientConfig.getConnectInitTimeout())\n+        .setOperationRetryTimeout(clientConfig.getOperationRetryTimeout())\n+        .setMonitorInstanceName(clientConfig.getMonitorInstanceName())\n+        .setMonitorKey(clientConfig.getMonitorKey())\n+        .setMonitorType(clientConfig.getMonitorType())\n+        .setMonitorRootPathOnly(clientConfig.isMonitorRootPathOnly());\n+    _innerSharedZkClient = SharedZkClientFactory.getInstance()\n+        .buildZkClient(zkConnectionConfig, zkClientConfig);\n   }\n \n-  @Override\n-  public void close() {\n-    super.close();\n-    if (isClosed()) {\n-      // Note that if register is not done while constructing, these private fields may not be init yet.\n-      if (_connectionManager != null) {\n-        _connectionManager.unregisterWatcher(this);\n-      }\n-      if (_onCloseCallback != null) {\n-        _onCloseCallback.onClose();\n+  private void checkPathAndThrow(String path) {\n+    // TODO: replace with the singleton MetadataStoreRoutingData\n+    try {\n+      String zkRealmForPath = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+      if (!_zkRealmAddress.equals(zkRealmForPath)) {\n+        throw new IllegalArgumentException(\"Given path: \" + path + \"'s ZK realm: \" + zkRealmForPath\n+            + \" does not match the ZK realm: \" + _zkRealmAddress + \" and sharding key: \"\n+            + _zkRealmShardingKey + \" for this DedicatedZkClient!\");\n       }\n+    } catch (NoSuchElementException e) {\n+      throw new IllegalArgumentException(\n+          \"Given path: \" + path + \" does not have a valid sharding key!\");\n     }\n   }\n \n   @Override\n-  public IZkConnection getConnection() {\n-    if (isClosed()) {\n-      return IDLE_CONNECTION;\n-    }\n-    return super.getConnection();\n+  public List<String> subscribeChildChanges(String path, IZkChildListener listener) {\n+    checkPathAndThrow(path);\n+    return _innerSharedZkClient.subscribeChildChanges(path, listener);\n   }\n \n-  /**\n-   * Since ZkConnection session is shared in this RealmAwareZkClient, do not create ephemeral node using a SharedZKClient.\n-   */\n   @Override\n-  public String create(final String path, Object datat, final List<ACL> acl,\n-      final CreateMode mode) {\n-    if (mode.isEphemeral()) {\n-      throw new UnsupportedOperationException(\n-          \"Create ephemeral nodes using a \" + SharedZkClient.class.getSimpleName()\n-              + \" is not supported.\");\n-    }\n-    return super.create(path, datat, acl, mode);\n+  public void unsubscribeChildChanges(String path, IZkChildListener listener) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.unsubscribeChildChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeDataChanges(String path, IZkDataListener listener) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.subscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeDataChanges(String path, IZkDataListener listener) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.unsubscribeDataChanges(path, listener);\n+  }\n+\n+  @Override\n+  public void subscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.subscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeStateChanges(IZkStateListener listener) {\n+    _innerSharedZkClient.unsubscribeStateChanges(listener);\n+  }\n+\n+  @Override\n+  public void unsubscribeAll() {\n+    _innerSharedZkClient.unsubscribeAll();\n+  }\n+\n+  @Override\n+  public void createPersistent(String path) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, createParents);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, boolean createParents, List<ACL> acl) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, createParents, acl);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, data);\n+  }\n+\n+  @Override\n+  public void createPersistent(String path, Object data, List<ACL> acl) {\n+    checkPathAndThrow(path);\n+    _innerSharedZkClient.createPersistent(path, data, acl);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data) {\n+    checkPathAndThrow(path);\n+    return _innerSharedZkClient.createPersistentSequential(path, data);\n+  }\n+\n+  @Override\n+  public String createPersistentSequential(String path, Object data, List<ACL> acl) {\n+    checkPathAndThrow(path);\n+    return _innerSharedZkClient.createPersistentSequential(path, data, acl);\n   }\n \n   @Override\n-  protected boolean isManagingZkConnection() {\n-    return false;\n+  public void createEphemeral(String path) {\n+    throw new UnsupportedOperationException(\n+        \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTYzNzQ2OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1OToyN1rOFt39og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToyMjo1OVrOFuSBoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzEzOA==", "bodyText": "Nit: \"Creating\"", "url": "https://github.com/apache/helix/pull/796#discussion_r383647138", "createdAt": "2020-02-25T03:59:27Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -128,4 +139,78 @@ public int getActiveConnectionCount() {\n     }\n     return count;\n   }\n+\n+  public interface OnCloseCallback {\n+    /**\n+     * Triggered after the SharedZkClient is closed.\n+     */\n+    void onClose();\n+  }\n+\n+  /**\n+   * NOTE: do NOT use this class directly. Please use SharedZkClientFactory to create an instance of SharedZkClient.\n+   * InnerSharedZkClient is a ZkClient used by SharedZkClient to power ZK operations against a single ZK realm.\n+   *\n+   * NOTE2: current InnerSharedZkClient replace the original SharedZKClient. We intend to keep the behavior of original\n+   * SharedZkClient intact. (Think of rename the original SharedZkClient as InnerSharedZkClient. This would maintain\n+   * backward compatibility.\n+   */\n+  public static class InnerSharedZkClient extends ZkClient implements HelixZkClient {\n+\n+    private final OnCloseCallback _onCloseCallback;\n+    private final ZkConnectionManager _connectionManager;\n+\n+    public InnerSharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n+        OnCloseCallback callback) {\n+      super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n+          clientConfig.getZkSerializer(), clientConfig.getMonitorType(),\n+          clientConfig.getMonitorKey(), clientConfig.getMonitorInstanceName(),\n+          clientConfig.isMonitorRootPathOnly());\n+      _connectionManager = connectionManager;\n+      // Register to the base dedicated RealmAwareZkClient\n+      _connectionManager.registerWatcher(this);\n+      _onCloseCallback = callback;\n+    }\n+\n+    @Override\n+    public void close() {\n+      super.close();\n+      if (isClosed()) {\n+        // Note that if register is not done while constructing, these private fields may not be init yet.\n+        if (_connectionManager != null) {\n+          _connectionManager.unregisterWatcher(this);\n+        }\n+        if (_onCloseCallback != null) {\n+          _onCloseCallback.onClose();\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public IZkConnection getConnection() {\n+      if (isClosed()) {\n+        return IDLE_CONNECTION;\n+      }\n+      return super.getConnection();\n+    }\n+\n+    /**\n+     * Since ZkConnection session is shared in this HelixZkClient, do not create ephemeral node using a SharedZKClient.\n+     */\n+    @Override\n+    public String create(final String path, Object datat, final List<ACL> acl,\n+        final CreateMode mode) {\n+      if (mode.isEphemeral()) {\n+        throw new UnsupportedOperationException(\n+            \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3NDE0NQ==", "bodyText": "fixed all", "url": "https://github.com/apache/helix/pull/796#discussion_r384074145", "createdAt": "2020-02-25T19:22:59Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -128,4 +139,78 @@ public int getActiveConnectionCount() {\n     }\n     return count;\n   }\n+\n+  public interface OnCloseCallback {\n+    /**\n+     * Triggered after the SharedZkClient is closed.\n+     */\n+    void onClose();\n+  }\n+\n+  /**\n+   * NOTE: do NOT use this class directly. Please use SharedZkClientFactory to create an instance of SharedZkClient.\n+   * InnerSharedZkClient is a ZkClient used by SharedZkClient to power ZK operations against a single ZK realm.\n+   *\n+   * NOTE2: current InnerSharedZkClient replace the original SharedZKClient. We intend to keep the behavior of original\n+   * SharedZkClient intact. (Think of rename the original SharedZkClient as InnerSharedZkClient. This would maintain\n+   * backward compatibility.\n+   */\n+  public static class InnerSharedZkClient extends ZkClient implements HelixZkClient {\n+\n+    private final OnCloseCallback _onCloseCallback;\n+    private final ZkConnectionManager _connectionManager;\n+\n+    public InnerSharedZkClient(ZkConnectionManager connectionManager, ZkClientConfig clientConfig,\n+        OnCloseCallback callback) {\n+      super(connectionManager.getConnection(), 0, clientConfig.getOperationRetryTimeout(),\n+          clientConfig.getZkSerializer(), clientConfig.getMonitorType(),\n+          clientConfig.getMonitorKey(), clientConfig.getMonitorInstanceName(),\n+          clientConfig.isMonitorRootPathOnly());\n+      _connectionManager = connectionManager;\n+      // Register to the base dedicated RealmAwareZkClient\n+      _connectionManager.registerWatcher(this);\n+      _onCloseCallback = callback;\n+    }\n+\n+    @Override\n+    public void close() {\n+      super.close();\n+      if (isClosed()) {\n+        // Note that if register is not done while constructing, these private fields may not be init yet.\n+        if (_connectionManager != null) {\n+          _connectionManager.unregisterWatcher(this);\n+        }\n+        if (_onCloseCallback != null) {\n+          _onCloseCallback.onClose();\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public IZkConnection getConnection() {\n+      if (isClosed()) {\n+        return IDLE_CONNECTION;\n+      }\n+      return super.getConnection();\n+    }\n+\n+    /**\n+     * Since ZkConnection session is shared in this HelixZkClient, do not create ephemeral node using a SharedZKClient.\n+     */\n+    @Override\n+    public String create(final String path, Object datat, final List<ACL> acl,\n+        final CreateMode mode) {\n+      if (mode.isEphemeral()) {\n+        throw new UnsupportedOperationException(\n+            \"Create ephemeral nodes using \" + SharedZkClient.class.getSimpleName()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzEzOA=="}, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTYzNzk4OnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1OTo1N1rOFt398w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMzo1OTo1N1rOFt398w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzIxOQ==", "bodyText": "Fix the comment here?", "url": "https://github.com/apache/helix/pull/796#discussion_r383647219", "createdAt": "2020-02-25T03:59:57Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    super.beforeClass();\n+    // Set the factory to DedicatedZkClientFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTYzOTkyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNDowMToyM1rOFt3_IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNDowMToyM1rOFt3_IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY0NzUyMA==", "bodyText": "Remove empty line?", "url": "https://github.com/apache/helix/pull/796#discussion_r383647520", "createdAt": "2020-02-25T04:01:23Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    super.beforeClass();\n+    // Set the factory to DedicatedZkClientFactory\n+    _realmAwareZkClientFactory = SharedZkClientFactory.getInstance();\n+  }\n+\n+  @Test\n+  public void testCreateEphemeralFailure() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // test createEphemeral should fail\n+    try {\n+      _realmAwareZkClient.createEphemeral(TEST_VALID_PATH);\n+      Assert.fail(\"sharedReamlAwareZkClient is not expected to be able to create ephemeral node via createEphemeral\");\n+    } catch (UnsupportedOperationException e){\n+      // this is expected\n+    }\n+\n+    // test creating Ephemeral via creat would also fail\n+    try {\n+      _realmAwareZkClient.create(TEST_VALID_PATH, znRecord, CreateMode.EPHEMERAL);\n+      Assert.fail(\"sharedRealmAwareZkClient is not expected to be able to create ephmeral node via create\");\n+    } catch (UnsupportedOperationException e) {\n+      // this is expected.\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95970f8ad9982910cbf7fad55da1d9b05a55d456"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODgzOTcxOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo0NzoyNFrOFuWaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo0NzoyNFrOFuWaaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NjAyNw==", "bodyText": "Remove empty line here?", "url": "https://github.com/apache/helix/pull/796#discussion_r384146027", "createdAt": "2020-02-25T21:47:24Z", "author": {"login": "narendly"}, "path": "zookeeper-api/src/test/java/org/apache/helix/zookeeper/impl/client/TestSharedZkClient.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.helix.zookeeper.impl.client;\n+\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n+import org.apache.zookeeper.CreateMode;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestSharedZkClient extends RealmAwareZkClientTestBase {\n+  @BeforeClass\n+  public void beforeClass()\n+      throws Exception {\n+    super.beforeClass();\n+    // Set the factory to SharedZkClientFactory\n+    _realmAwareZkClientFactory = SharedZkClientFactory.getInstance();\n+  }\n+\n+  @Test\n+  public void testCreateEphemeralFailure() {\n+    _realmAwareZkClient.setZkSerializer(new ZNRecordSerializer());\n+\n+    // Create a dummy ZNRecord\n+    ZNRecord znRecord = new ZNRecord(\"DummyRecord\");\n+    znRecord.setSimpleField(\"Dummy\", \"Value\");\n+\n+    // test createEphemeral should fail\n+    try {\n+      _realmAwareZkClient.createEphemeral(TEST_VALID_PATH);\n+      Assert.fail(\"sharedReamlAwareZkClient is not expected to be able to create ephemeral node via createEphemeral\");\n+    } catch (UnsupportedOperationException e){\n+      // this is expected\n+    }\n+\n+    // test creating Ephemeral via creat would also fail\n+    try {\n+      _realmAwareZkClient.create(TEST_VALID_PATH, znRecord, CreateMode.EPHEMERAL);\n+      Assert.fail(\"sharedRealmAwareZkClient is not expected to be able to create ephmeral node via create\");\n+    } catch (UnsupportedOperationException e) {\n+      // this is expected.\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODk3ODIyOnYy", "diffSide": "RIGHT", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNToxN1rOFuXxHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjo0ODozMVrOFuYH0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODIyMA==", "bodyText": "Is this moved from original SharedZKClient?", "url": "https://github.com/apache/helix/pull/796#discussion_r384168220", "createdAt": "2020-02-25T22:35:17Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -128,4 +139,78 @@ public int getActiveConnectionCount() {\n     }\n     return count;\n   }\n+\n+  public interface OnCloseCallback {\n+    /**\n+     * Triggered after the SharedZkClient is closed.\n+     */\n+    void onClose();\n+  }\n+\n+  /**\n+   * NOTE: do NOT use this class directly. Please use SharedZkClientFactory to create an instance of SharedZkClient.\n+   * InnerSharedZkClient is a ZkClient used by SharedZkClient to power ZK operations against a single ZK realm.\n+   *\n+   * NOTE2: current InnerSharedZkClient replace the original SharedZKClient. We intend to keep the behavior of original\n+   * SharedZkClient intact. (Think of rename the original SharedZkClient as InnerSharedZkClient. This would maintain\n+   * backward compatibility.\n+   */\n+  public static class InnerSharedZkClient extends ZkClient implements HelixZkClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NDAzMw==", "bodyText": "Yes, you are right. The intention is to keep the InnerSharedZkClient exactly the same as original sharedZkClient. It is just we need the name of SharedZkClient that we renamed InnerSharedZkClient.", "url": "https://github.com/apache/helix/pull/796#discussion_r384174033", "createdAt": "2020-02-25T22:48:31Z", "author": {"login": "kaisun2000"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/factory/SharedZkClientFactory.java", "diffHunk": "@@ -128,4 +139,78 @@ public int getActiveConnectionCount() {\n     }\n     return count;\n   }\n+\n+  public interface OnCloseCallback {\n+    /**\n+     * Triggered after the SharedZkClient is closed.\n+     */\n+    void onClose();\n+  }\n+\n+  /**\n+   * NOTE: do NOT use this class directly. Please use SharedZkClientFactory to create an instance of SharedZkClient.\n+   * InnerSharedZkClient is a ZkClient used by SharedZkClient to power ZK operations against a single ZK realm.\n+   *\n+   * NOTE2: current InnerSharedZkClient replace the original SharedZKClient. We intend to keep the behavior of original\n+   * SharedZkClient intact. (Think of rename the original SharedZkClient as InnerSharedZkClient. This would maintain\n+   * backward compatibility.\n+   */\n+  public static class InnerSharedZkClient extends ZkClient implements HelixZkClient {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODIyMA=="}, "originalCommit": {"oid": "4dbcfd3fb0e80850a7f76ae285564ea08b20ef2a"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1669, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}