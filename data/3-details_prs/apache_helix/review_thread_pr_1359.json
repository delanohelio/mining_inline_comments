{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0NDk2MDc3", "number": 1359, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMToxMTo0MlrOEiWDEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMToxNjo0OVrOEiWGiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDQ4Mjc0OnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMToxMTo0MlrOHQKzQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMTo0MDo1M1rOHQLQ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNjIyNw==", "bodyText": "If checkBestPossibleStateCalculation(idealState) is true, will we ever get a null partitionStateAssignment?", "url": "https://github.com/apache/helix/pull/1359#discussion_r486716227", "createdAt": "2020-09-11T01:11:42Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -347,36 +347,39 @@ private boolean computeSingleResourceBestPossibleState(ClusterEvent event,\n       LogUtil.logError(logger, _eventId, \"Error computing assignment for resource \" + resourceName\n           + \". no rebalancer found. rebalancer: \" + rebalancer + \" mappingCalculator: \"\n           + mappingCalculator);\n-    }\n-\n-    if (rebalancer != null && mappingCalculator != null) {\n-      ResourceAssignment partitionStateAssignment = null;\n+    } else {\n       try {\n         HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n         rebalancer.init(manager);\n         idealState =\n             rebalancer.computeNewIdealState(resourceName, idealState, currentStateOutput, cache);\n \n-        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());\n+        // Check if calculation is done successfully\n+        if (!checkBestPossibleStateCalculation(idealState)) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"The calculated idealState is not valid, resource: \" + resourceName);\n+          return false;\n+        }\n \n         // Use the internal MappingCalculator interface to compute the final assignment\n         // The next release will support rebalancers that compute the mapping from start to finish\n-        partitionStateAssignment = mappingCalculator\n+        ResourceAssignment partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n \n         if (partitionStateAssignment == null) {\n           LogUtil.logWarn(logger, _eventId,\n-              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+              \"The calculated partitionStateAssignment is null, resource: \" + resourceName);\n           return false;\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "938aa5a3be6de6865e2bb0809b2511c2bc9e731b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzgxMw==", "bodyText": "This depends on the mapping calculator implementation. There is no guarantee. So we'd better keep the check.", "url": "https://github.com/apache/helix/pull/1359#discussion_r486723813", "createdAt": "2020-09-11T01:40:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -347,36 +347,39 @@ private boolean computeSingleResourceBestPossibleState(ClusterEvent event,\n       LogUtil.logError(logger, _eventId, \"Error computing assignment for resource \" + resourceName\n           + \". no rebalancer found. rebalancer: \" + rebalancer + \" mappingCalculator: \"\n           + mappingCalculator);\n-    }\n-\n-    if (rebalancer != null && mappingCalculator != null) {\n-      ResourceAssignment partitionStateAssignment = null;\n+    } else {\n       try {\n         HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n         rebalancer.init(manager);\n         idealState =\n             rebalancer.computeNewIdealState(resourceName, idealState, currentStateOutput, cache);\n \n-        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());\n+        // Check if calculation is done successfully\n+        if (!checkBestPossibleStateCalculation(idealState)) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"The calculated idealState is not valid, resource: \" + resourceName);\n+          return false;\n+        }\n \n         // Use the internal MappingCalculator interface to compute the final assignment\n         // The next release will support rebalancers that compute the mapping from start to finish\n-        partitionStateAssignment = mappingCalculator\n+        ResourceAssignment partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n \n         if (partitionStateAssignment == null) {\n           LogUtil.logWarn(logger, _eventId,\n-              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+              \"The calculated partitionStateAssignment is null, resource: \" + resourceName);\n           return false;\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNjIyNw=="}, "originalCommit": {"oid": "938aa5a3be6de6865e2bb0809b2511c2bc9e731b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDQ5MTYwOnYy", "diffSide": "RIGHT", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMToxNjo0OVrOHQK4eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNToyODozM1rOHQOzZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNzU2Mg==", "bodyText": "Is this to make sure if we ever get a null value for partitionStateAssignment, we don't set anything in the output?\nI wonder if this might cause a behavior change. Before this change, did output get populated with some preferenceList value (maybe the one from the previous, last successful pipeline)? After this change, if the computeBestPossiblePartitionState returns a null, then output will start having nothing, which is a different behavior from before this change?", "url": "https://github.com/apache/helix/pull/1359#discussion_r486717562", "createdAt": "2020-09-11T01:16:49Z", "author": {"login": "narendly"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -347,36 +347,39 @@ private boolean computeSingleResourceBestPossibleState(ClusterEvent event,\n       LogUtil.logError(logger, _eventId, \"Error computing assignment for resource \" + resourceName\n           + \". no rebalancer found. rebalancer: \" + rebalancer + \" mappingCalculator: \"\n           + mappingCalculator);\n-    }\n-\n-    if (rebalancer != null && mappingCalculator != null) {\n-      ResourceAssignment partitionStateAssignment = null;\n+    } else {\n       try {\n         HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n         rebalancer.init(manager);\n         idealState =\n             rebalancer.computeNewIdealState(resourceName, idealState, currentStateOutput, cache);\n \n-        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());\n+        // Check if calculation is done successfully\n+        if (!checkBestPossibleStateCalculation(idealState)) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"The calculated idealState is not valid, resource: \" + resourceName);\n+          return false;\n+        }\n \n         // Use the internal MappingCalculator interface to compute the final assignment\n         // The next release will support rebalancers that compute the mapping from start to finish\n-        partitionStateAssignment = mappingCalculator\n+        ResourceAssignment partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n \n         if (partitionStateAssignment == null) {\n           LogUtil.logWarn(logger, _eventId,\n-              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+              \"The calculated partitionStateAssignment is null, resource: \" + resourceName);\n           return false;\n         }\n \n+        // Set the calculated result to the output.\n+        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "938aa5a3be6de6865e2bb0809b2511c2bc9e731b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNDg3OA==", "bodyText": "Yeah, this is a behavior change. But the original behavior is the problem here. If any value is set in the output, then the later stages will just use it without any doubt. This is very dangerous.\nI checked later stages like intermediate state calc, and message generating, they can handle a null output gracefully. But they cannot handle the output with the wrong information gracefully.", "url": "https://github.com/apache/helix/pull/1359#discussion_r486724878", "createdAt": "2020-09-11T01:44:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -347,36 +347,39 @@ private boolean computeSingleResourceBestPossibleState(ClusterEvent event,\n       LogUtil.logError(logger, _eventId, \"Error computing assignment for resource \" + resourceName\n           + \". no rebalancer found. rebalancer: \" + rebalancer + \" mappingCalculator: \"\n           + mappingCalculator);\n-    }\n-\n-    if (rebalancer != null && mappingCalculator != null) {\n-      ResourceAssignment partitionStateAssignment = null;\n+    } else {\n       try {\n         HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n         rebalancer.init(manager);\n         idealState =\n             rebalancer.computeNewIdealState(resourceName, idealState, currentStateOutput, cache);\n \n-        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());\n+        // Check if calculation is done successfully\n+        if (!checkBestPossibleStateCalculation(idealState)) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"The calculated idealState is not valid, resource: \" + resourceName);\n+          return false;\n+        }\n \n         // Use the internal MappingCalculator interface to compute the final assignment\n         // The next release will support rebalancers that compute the mapping from start to finish\n-        partitionStateAssignment = mappingCalculator\n+        ResourceAssignment partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n \n         if (partitionStateAssignment == null) {\n           LogUtil.logWarn(logger, _eventId,\n-              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+              \"The calculated partitionStateAssignment is null, resource: \" + resourceName);\n           return false;\n         }\n \n+        // Set the calculated result to the output.\n+        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNzU2Mg=="}, "originalCommit": {"oid": "938aa5a3be6de6865e2bb0809b2511c2bc9e731b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTQ4Ng==", "bodyText": "It seems to me that the original code, return checkBestPossibleStateCalculation(idealState); would still return false. Does it feed the wrong info in output to later stage?\nThe main thing is that the new code fixed the issue of missing metric for invalid idealState.", "url": "https://github.com/apache/helix/pull/1359#discussion_r486745486", "createdAt": "2020-09-11T03:01:36Z", "author": {"login": "kaisun2000"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -347,36 +347,39 @@ private boolean computeSingleResourceBestPossibleState(ClusterEvent event,\n       LogUtil.logError(logger, _eventId, \"Error computing assignment for resource \" + resourceName\n           + \". no rebalancer found. rebalancer: \" + rebalancer + \" mappingCalculator: \"\n           + mappingCalculator);\n-    }\n-\n-    if (rebalancer != null && mappingCalculator != null) {\n-      ResourceAssignment partitionStateAssignment = null;\n+    } else {\n       try {\n         HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n         rebalancer.init(manager);\n         idealState =\n             rebalancer.computeNewIdealState(resourceName, idealState, currentStateOutput, cache);\n \n-        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());\n+        // Check if calculation is done successfully\n+        if (!checkBestPossibleStateCalculation(idealState)) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"The calculated idealState is not valid, resource: \" + resourceName);\n+          return false;\n+        }\n \n         // Use the internal MappingCalculator interface to compute the final assignment\n         // The next release will support rebalancers that compute the mapping from start to finish\n-        partitionStateAssignment = mappingCalculator\n+        ResourceAssignment partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n \n         if (partitionStateAssignment == null) {\n           LogUtil.logWarn(logger, _eventId,\n-              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+              \"The calculated partitionStateAssignment is null, resource: \" + resourceName);\n           return false;\n         }\n \n+        // Set the calculated result to the output.\n+        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNzU2Mg=="}, "originalCommit": {"oid": "938aa5a3be6de6865e2bb0809b2511c2bc9e731b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4MTc5Ng==", "bodyText": "The original code returns false while the output is added with an empty assignment mapping item. However, this empty mapping is misleading.", "url": "https://github.com/apache/helix/pull/1359#discussion_r486781796", "createdAt": "2020-09-11T05:28:33Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -347,36 +347,39 @@ private boolean computeSingleResourceBestPossibleState(ClusterEvent event,\n       LogUtil.logError(logger, _eventId, \"Error computing assignment for resource \" + resourceName\n           + \". no rebalancer found. rebalancer: \" + rebalancer + \" mappingCalculator: \"\n           + mappingCalculator);\n-    }\n-\n-    if (rebalancer != null && mappingCalculator != null) {\n-      ResourceAssignment partitionStateAssignment = null;\n+    } else {\n       try {\n         HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n         rebalancer.init(manager);\n         idealState =\n             rebalancer.computeNewIdealState(resourceName, idealState, currentStateOutput, cache);\n \n-        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());\n+        // Check if calculation is done successfully\n+        if (!checkBestPossibleStateCalculation(idealState)) {\n+          LogUtil.logWarn(logger, _eventId,\n+              \"The calculated idealState is not valid, resource: \" + resourceName);\n+          return false;\n+        }\n \n         // Use the internal MappingCalculator interface to compute the final assignment\n         // The next release will support rebalancers that compute the mapping from start to finish\n-        partitionStateAssignment = mappingCalculator\n+        ResourceAssignment partitionStateAssignment = mappingCalculator\n             .computeBestPossiblePartitionState(cache, idealState, resource, currentStateOutput);\n \n         if (partitionStateAssignment == null) {\n           LogUtil.logWarn(logger, _eventId,\n-              \"PartitionStateAssignment is null, resource: \" + resourceName);\n+              \"The calculated partitionStateAssignment is null, resource: \" + resourceName);\n           return false;\n         }\n \n+        // Set the calculated result to the output.\n+        output.setPreferenceLists(resourceName, idealState.getPreferenceLists());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNzU2Mg=="}, "originalCommit": {"oid": "938aa5a3be6de6865e2bb0809b2511c2bc9e731b"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 948, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}