{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NDk3NzM1", "number": 1098, "title": "Fix the issue that the instance may not be assigned a replica as expected.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n#1097\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis is to fix a regression that was introduced by PR #986\nThe PR tried to prioritize the preference list to avoid unnecessary top state transitions. However, there was a bug in the prioritizing logic and if one participant is skipped due to low priority, it won't be picked up again during the calculating. As a result, this participant won't be assigned with any replica even it is originally in the preference list.\nThis only happens if the state model has been customized so it is multiple top states and there is an intermediate state with expected count -1 between the top state and the other states.\nThis fix will ensure the skipped participant being checked again until it gets the assignment.\nTests\n\n The following tests are written for this issue:\n\nTestAbstractRebalancer.java\nAdded test data that simulate a customized state model fits the problem statement.\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[INFO] Results:\n[INFO]\n[ERROR] Failures:\n[ERROR]   TestJobQueueCleanUp.testJobQueueAutoCleanUp \u00bb ThreadTimeout Method org.testng....\n[ERROR]   TestClusterVerifier.testResourceSubset:225 expected: but was:\n[INFO]\n[ERROR] Tests run: 1145, Failures: 2, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 01:25 h\n[INFO] Finished at: 2020-06-17T18:59:29-07:00\n[INFO] ------------------------------------------------------------------------\nRerun\n[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 45.908 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 52.290 s\n[INFO] Finished at: 2020-06-18T11:40:16-07:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-06-16T22:22:19Z", "url": "https://github.com/apache/helix/pull/1098", "merged": true, "mergeCommit": {"oid": "35857a8cc025a1efb49943b6ab31dc12622bf986"}, "closed": true, "closedAt": "2020-06-18T19:56:53Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcr8ylhgH2gAyNDM1NDk3NzM1OjI5Y2UyNDVlYzliZWRiMDA2NGZmMWQyYjllOTRkZGNmZDNhZmFhMzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsicFiAFqTQzMzUyNjM2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35", "committedDate": "2020-06-16T22:14:23Z", "message": "Fix the issue that the instance may not be assigned a replica as expected.\n\nThis is to fix a regression which was introduced by PR #986.\nThe PR tried to prioritize the preference list to avoid unnecessary top state transition. However, there was a bug in the prioritizing logic and if one participant is skipped due to low priority, it won't be picked up again during the cauculating. As a result, this participant won't be assigned with any replica even it is originally in the preference list.\nThis fix will ensure the skipped participant being checked again until it gets the assignment."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMTA3ODk3", "url": "https://github.com/apache/helix/pull/1098#pullrequestreview-432107897", "createdAt": "2020-06-17T06:55:39Z", "commit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo1NTozOVrOGk4EnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoxMDo1N1rOGk4hrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDYwNQ==", "bodyText": "Indent/format.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441320605", "createdAt": "2020-06-17T06:55:39Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/main/java/org/apache/helix/model/OnlineOfflineWithBootstrapSMD.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.HelixDefinedState;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+\n+/**\n+ * Helix built-in state model definition based on Online-Offline but with the additional bootstrap\n+ * state.\n+ */\n+public final class OnlineOfflineWithBootstrapSMD extends StateModelDefinition {\n+  public static final String name = \"OnlineOfflineWithBootstrap\";\n+\n+  /**\n+   * Instantiate from a pre-populated record\n+   *\n+   * @param record ZNRecord representing a state model definition\n+   */\n+  private OnlineOfflineWithBootstrapSMD(ZNRecord record) {\n+    super(record);\n+  }\n+\n+  public enum States {\n+    ONLINE, BOOTSTRAP, OFFLINE\n+  }\n+\n+  /**\n+   * Build OnlineOfflineWithBootstrap state model definition\n+   *\n+   * @return\n+   */\n+  public static OnlineOfflineWithBootstrapSMD build() {\n+    Builder builder = new Builder(name);\n+    // init state\n+    builder.initialState(States.OFFLINE.name());\n+\n+    // add states\n+    builder.addState(States.ONLINE.name(), 0);\n+    builder.addState(States.BOOTSTRAP.name(), 1);\n+    builder.addState(States.OFFLINE.name(), 2);\n+    for (HelixDefinedState state : HelixDefinedState.values()) {\n+    builder.addState(state.name());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNjkwNQ==", "bodyText": "Accident typo?", "url": "https://github.com/apache/helix/pull/1098#discussion_r441326905", "createdAt": "2020-06-17T07:08:38Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "diffHunk": "@@ -56,11 +56,11 @@ public void testComputeBestPossibleState(String comment, String stateModelName,\n             new IdealState(\"test\"), new ClusterConfig(\"TestCluster\"), partition,\n             MonitoredAbnormalResolver.DUMMY_STATE_RESOLVER);\n \n-    Assert.assertEquals(bestPossibleMap, expectedBestPossibleMap);\n+    Assert.assertTrue(bestPossibleMap.equals(expectedBestPossibleMap));\n   }\n \n   @DataProvider(name = \"TestComputeBestPossibleStateInput\")\n-  public Object[][] loadTestComputeBestPossibleStateInput() {\n+  public Object[][] loadTestComputeBestPossiblqeStateInput() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyODA0Nw==", "bodyText": "Just curious: what's your thought of changing to equals style? I think Assert.assertEquals() works fine, even Assert.assertEquals(map, null) or Assert.assertEquals(null, map) still works. But Assert.assertTrue(null.equals(expectedBestPossibleMap)) won't work. (though in this test bestPossibleMap won't be null).", "url": "https://github.com/apache/helix/pull/1098#discussion_r441328047", "createdAt": "2020-06-17T07:10:57Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAbstractRebalancer.java", "diffHunk": "@@ -56,11 +56,11 @@ public void testComputeBestPossibleState(String comment, String stateModelName,\n             new IdealState(\"test\"), new ClusterConfig(\"TestCluster\"), partition,\n             MonitoredAbnormalResolver.DUMMY_STATE_RESOLVER);\n \n-    Assert.assertEquals(bestPossibleMap, expectedBestPossibleMap);\n+    Assert.assertTrue(bestPossibleMap.equals(expectedBestPossibleMap));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29ce245ec9bedb0064ff1d2b9e94ddcfd3afaa35"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d", "committedDate": "2020-06-17T18:04:57Z", "message": "Address comment."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjY3OTMy", "url": "https://github.com/apache/helix/pull/1098#pullrequestreview-432667932", "createdAt": "2020-06-17T18:32:02Z", "commit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozMjowM1rOGlSFFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODozMjowM1rOGlSFFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0NjcxMA==", "bodyText": "We can also additional check for single top state since multi top state even does not require these operations", "url": "https://github.com/apache/helix/pull/1098#discussion_r441746710", "createdAt": "2020-06-17T18:32:03Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjgxNzk5", "url": "https://github.com/apache/helix/pull/1098#pullrequestreview-432681799", "createdAt": "2020-06-17T18:48:00Z", "commit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxODo0ODowMVrOGlSozQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTowNDoyNlrOGlTiWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc1NTg1Mw==", "bodyText": "Is there any reasons to remove the liveAndEnabled check?", "url": "https://github.com/apache/helix/pull/1098#discussion_r441755853", "createdAt": "2020-06-17T18:48:01Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2NTc1Mg==", "bodyText": "Using index will be hard for code reader to understand it. Suggest to using a queue to replace the for loop.\nSo it could be:  while (!queue.isEmpty()) {\nxxxxx\nif (!proposedInstance.equals(instance)) {\nqueue.offer(instance); // add back\n}\n}", "url": "https://github.com/apache/helix/pull/1098#discussion_r441765752", "createdAt": "2020-06-17T18:57:23Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();\n+            if (!assigned.contains(currentStatePrioritizedInstance)) {\n               proposedInstance = currentStatePrioritizedInstance;\n+              // If we find a different instance for the partition placement, then we need to check\n+              // the same instance again or it will not be assigned with any partitions.\n+              if (!proposedInstance.equals(instance)) {\n+                i--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MDU4Ng==", "bodyText": "Maybe I am wrong. But could that be a scenario of:\npreference list = 1, 2, 3\ncurrent state = 4, 5, 6\nThen we keep assign ONLINE to 4,5,6. There will not be any movement. For DelayedAutoRebalance we may dont have it. But for default AutoRebalancer Or SemiAuto, we may use this for AbstractRebalancer then there will not be any movement.", "url": "https://github.com/apache/helix/pull/1098#discussion_r441770586", "createdAt": "2020-06-17T19:04:26Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -385,10 +389,19 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n           // If the desired state is the top state, but the instance cannot be transited to the\n           // top state in one hop, try to keep the top state on current host or a host with a closer\n           // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n+          while (currentStatePrioritizedInstanceIter.hasNext()) {\n+            // Note that it is safe to check the prioritized instance items only once here.\n+            // Since the only possible condition when we don't use an instance in this list is that\n+            // it has been assigned with some state. And this is not revertable in this method. So\n+            // checking it one more time later will only waste time.\n+            String currentStatePrioritizedInstance = currentStatePrioritizedInstanceIter.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01c9d62a996b4287dc34a5b78f7604fd6a3f7d7d"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1162db9e995fa4f622cedb96f455ec1ada8272ad", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/1162db9e995fa4f622cedb96f455ec1ada8272ad", "committedDate": "2020-06-18T00:13:57Z", "message": "Refactor the change with a queue to simplfy code.\nAlso other changes to enhance performance."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6de71e6d43c6ea535103007defc599cf3beabd76", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/6de71e6d43c6ea535103007defc599cf3beabd76", "committedDate": "2020-06-18T00:27:02Z", "message": "Refine the sanity check."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTI2MzY4", "url": "https://github.com/apache/helix/pull/1098#pullrequestreview-433526368", "createdAt": "2020-06-18T18:05:58Z", "commit": {"oid": "6de71e6d43c6ea535103007defc599cf3beabd76"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODowNTo1OFrOGl6hvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODowNTo1OFrOGl6hvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwOTQwNQ==", "bodyText": "This should not happen, right. You do the assignedInstances both for peek of the queue and after adjust instance.", "url": "https://github.com/apache/helix/pull/1098#discussion_r442409405", "createdAt": "2020-06-18T18:05:58Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -352,60 +356,137 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     }\n \n     // (3) Assign normal states to instances.\n-    // When we choose the top-state (e.g. MASTER) replica for a partition, we prefer to choose it from\n-    // these replicas which are already in the secondary states (e.g, SLAVE) instead of in lower-state.\n-    // This is because a replica in secondary state will take shorter time to transition to the top-state,\n-    // which could minimize the impact to the application's availability.\n-    // To achieve that, we sort the preferenceList based on CurrentState, by treating top-state and second-states with\n-    // same priority and rely on the fact that Collections.sort() is stable.\n-    List<String> statesPriorityList = stateModelDef.getStatesPriorityList();\n-    Set<String> assigned = new HashSet<>();\n-    Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n-    liveAndEnabled.removeAll(disabledInstancesForPartition);\n-\n-    // Sort the instances based on replicas' state priority in the current state\n-    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n-    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n-\n-    // Assign the state to the instances that appear in the preference list.\n-    for (String state : statesPriorityList) {\n+    assignStatesToInstances(preferenceList, stateModelDef, currentStateMap, liveInstances,\n+        disabledInstancesForPartition, bestPossibleStateMap);\n+\n+    return bestPossibleStateMap;\n+  }\n+\n+  /**\n+   * Assign the states to the instances listed in the preference list according to inputs.\n+   * Note that when we choose the top-state (e.g. MASTER) replica for a partition, we prefer to\n+   * choose it from these replicas which are already in the secondary states (e.g, SLAVE) instead\n+   * of in lower-state. This is because a replica in secondary state will take shorter time to\n+   * transition to the top-state, which could minimize the impact to the application's availability.\n+   * To achieve that, we sort the preferenceList based on CurrentState, by treating top-state and\n+   * second-states with same priority and rely on the fact that Collections.sort() is stable.\n+   */\n+  private void assignStatesToInstances(final List<String> preferenceList,\n+      final StateModelDefinition stateModelDef, final Map<String, String> currentStateMap,\n+      final Set<String> liveInstances, final Set<String> disabledInstancesForPartition,\n+      Map<String, String> bestPossibleStateMap) {\n+    // Record the assigned instances to avoid double calculating or conflict assignment.\n+    Set<String> assignedInstances = new HashSet<>();\n+\n+    Set<String> liveAndEnabled =\n+        liveInstances.stream().filter(instance -> !disabledInstancesForPartition.contains(instance))\n+            .collect(Collectors.toSet());\n+\n+    Queue<String> preferredActiveInstanceQueue = new LinkedList<>(preferenceList);\n+    preferredActiveInstanceQueue.retainAll(liveAndEnabled);\n+    int totalCandidateCount = preferredActiveInstanceQueue.size();\n+\n+    // Sort the preferred instances based on replicas' state priority in the current state.\n+    // Note that if one instance exists in the current states but not in the preference list, then\n+    // it won't show in the prioritized list.\n+    List<String> currentStatePrioritizedList = new ArrayList<>(preferredActiveInstanceQueue);\n+    currentStatePrioritizedList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n+    Iterator<String> currentStatePrioritizedInstanceIter = currentStatePrioritizedList.iterator();\n+\n+    // Assign the states to the instances that appear in the preference list.\n+    for (String state : stateModelDef.getStatesPriorityList()) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n-      for (String instance : preferenceList) {\n+      while (!preferredActiveInstanceQueue.isEmpty()) {\n         if (stateCount <= 0) {\n           break; // continue assigning for the next state\n         }\n-        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+        String peekInstance = preferredActiveInstanceQueue.peek();\n+        if (assignedInstances.contains(peekInstance)) {\n+          preferredActiveInstanceQueue.poll();\n           continue; // continue checking for the next available instance\n         }\n-        String proposedInstance = instance;\n-        // Additional check and alternate the assignment for reducing top state handoff.\n-        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()\n-            .contains(currentStateMap.getOrDefault(instance, stateModelDef.getInitialState()))) {\n-          // If the desired state is the top state, but the instance cannot be transited to the\n-          // top state in one hop, try to keep the top state on current host or a host with a closer\n-          // state.\n-          for (String currentStatePrioritizedInstance : sortedPreferenceList) {\n-            if (!assigned.contains(currentStatePrioritizedInstance) && liveAndEnabled\n-                .contains(currentStatePrioritizedInstance)) {\n-              proposedInstance = currentStatePrioritizedInstance;\n-              break;\n-            }\n-          }\n-          // Note that if all the current top state instances are not assignable, then we fallback\n-          // to the default logic that assigning the state according to preference list order.\n+        String proposedInstance = adjustInstanceIfNecessary(state, peekInstance,\n+            currentStateMap.getOrDefault(peekInstance, stateModelDef.getInitialState()),\n+            stateModelDef, assignedInstances, totalCandidateCount - assignedInstances.size(),\n+            stateCount, currentStatePrioritizedInstanceIter);\n+\n+        if (proposedInstance.equals(peekInstance)) {\n+          // If the peeked instance is the final decision, then poll it from the queue.\n+          preferredActiveInstanceQueue.poll();\n         }\n-        // Assign the desired state to the proposed instance\n+        // else, if we found a different instance for the partition placement, then we need to\n+        // check the same instance again or it will not be assigned with any partitions.\n+\n+        // Assign the desired state to the proposed instance if not on ERROR state.\n         if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(proposedInstance))) {\n           bestPossibleStateMap.put(proposedInstance, HelixDefinedState.ERROR.toString());\n         } else {\n           bestPossibleStateMap.put(proposedInstance, state);\n           stateCount--;\n         }\n-        assigned.add(proposedInstance);\n+        // Note that in either case, the proposed instance is considered to be assigned with a state\n+        // by now.\n+        if (!assignedInstances.add(proposedInstance)) {\n+          throw new AssertionError(String\n+              .format(\"The proposed instance %s has been already assigned before.\",\n+                  proposedInstance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6de71e6d43c6ea535103007defc599cf3beabd76"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4494, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}