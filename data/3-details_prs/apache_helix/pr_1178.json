{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NzA3NzU2", "number": 1178, "title": "Feature: ZooScalability Improvements", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nFixes #1162\nFixes #1175\nFixes #1176\nFixes #1177\nFixes #1188\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThis PR contains a host of ZooScalability critical feature additions for usability. For details, please see the individual commit titles and messages.\nImplement RoutingDataManager to replace HttpRoutingDataReader\nChange interface for RoutingDataReader\nAdd HttpZkFallbackRoutingDataReader\nImplement ZkRoutingDataReader\nModify realm-aware ZkClient and Helix API for configurable routing source\nMake RoutingDataManager a pure Singleton with double-checked locking\nImplement routing data update upon cache miss for FederatedZkClient\nImplement throttling for routing data update on cache miss\nTests\n\n The following tests are written for this issue:\n\nVarious tests are added to ensure the features are stable and correct. Please see the individual commits.\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\nzookeeper-api:\n[INFO] Tests run: 41, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 51.96 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 41, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n\nhelix-core:\n[ERROR] Failures: \n[ERROR]   TestCustomizedViewAggregation.testCustomizedViewAggregation:413->validateAggregationSnapshot:257 expected:<true> but was:<false>\n[ERROR]   TestEnableCompression.testEnableCompressionResource:117 expected:<true> but was:<false>\n[ERROR]   TestClusterStatusMonitorLifecycle.testClusterStatusMonitorLifecycle:290 expected:<true> but was:<false>\n[INFO] \n[ERROR] Tests run: 1172, Failures: 3, Errors: 0, Skipped: 0\n\nFailures run individually:\n[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 45.75 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n\nhelix-rest:\n[INFO] Tests run: 166, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 36.324 s - in TestSuite\n[INFO] \n[INFO] Results:\n[INFO] \n[INFO] Tests run: 166, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  41.223 s\n[INFO] Finished at: 2020-08-14T11:11:17-07:00\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nDocumentation (Optional)\n\n In case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCode Quality\n\n My diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-07-26T06:14:51Z", "url": "https://github.com/apache/helix/pull/1178", "merged": true, "mergeCommit": {"oid": "28dc1cfbee22797567a056050e9b9f9b5d680e88"}, "closed": true, "closedAt": "2020-08-14T18:13:46Z", "author": {"login": "narendly"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5aeK1gFqTQ1Njg3MTA1NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-4s24ABqjM2NTcyMjIzNzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODcxMDU0", "url": "https://github.com/apache/helix/pull/1178#pullrequestreview-456871054", "createdAt": "2020-07-28T17:50:37Z", "commit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzo1MDozN1rOG4X1rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowNjozOFrOG4Ybwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDAxMw==", "bodyText": "Any reason to remove IOException?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461764013", "createdAt": "2020-07-28T17:50:37Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -83,7 +82,7 @@ protected RealmAwareZkClient createZkClient(RealmAwareZkClient.RealmMode realmMo\n       case MULTI_REALM:\n         try {\n           zkClient = new FederatedZkClient(connectionConfig, clientConfig);\n-        } catch (IOException | InvalidRoutingDataException e) {\n+        } catch (InvalidRoutingDataException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ==", "bodyText": "Does that mean if we dont set both, it fall backs to single realm?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461766775", "createdAt": "2020-07-28T17:54:57Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Nzk3Ng==", "bodyText": "If it is routing related property, shall we have consistent naming system starting with \"routing\"?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461767976", "createdAt": "2020-07-28T17:56:53Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/RoutingSystemPropertyKeys.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.apache.helix.zookeeper.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * This class contains various routing-related system property keys for multi-zk clients.\n+ */\n+public class RoutingSystemPropertyKeys {\n+\n+  /**\n+   * If enabled, FederatedZkClient (multiZkClient) will invalidate the cached routing data and\n+   * re-read the routing data from the routing data source upon ZK path sharding key cache miss.\n+   */\n+  public static final String UPDATE_ROUTING_DATA_ON_CACHE_MISS =\n+      \"update.routing.data.on.cache.miss.enabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MTc5Mw==", "bodyText": "Do we want to move this into try? Is that possible any exception happening in build zkClient?", "url": "https://github.com/apache/helix/pull/1178#discussion_r461771793", "createdAt": "2020-07-28T18:03:13Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/ZkRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+\n+\n+/**\n+ * Zk-based RoutingDataReader that establishes a ZK connection to the routing ZK to fetch routing\n+ * data.\n+ * The reading of routing data by nature should only be performed in cases of a Helix client\n+ * initialization or routing data reset. That means we do not have to maintain an active ZK\n+ * connection. To minimize the number of client-side ZK connections, ZkRoutingDataReader establishes\n+ * a ZK session temporarily only to read from ZK afresh and closes sessions upon read completion.\n+ */\n+public class ZkRoutingDataReader implements RoutingDataReader {\n+\n+  /**\n+   * Returns a map form of metadata store routing data.\n+   * The map fields stand for metadata store realm address (key), and a corresponding list of ZK\n+   * path sharding keys (key).\n+   * @param endpoint\n+   * @return\n+   */\n+  @Override\n+  public Map<String, List<String>> getRawRoutingData(String endpoint) {\n+    ZkClient zkClient =\n+        new ZkClient.Builder().setZkServer(endpoint).setZkSerializer(new ZNRecordSerializer())\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3Mzc2Mg==", "bodyText": "Why not let this read extends the one of the Reader instead of creating a Reader object? This will create ZkRoutingDataReader/HttpRoutingDataReader every time if continuously calling the method.\nOr can we just have make a check wither we check whether we created them as members? If yes, use it. If not, create a new one and keep it.", "url": "https://github.com/apache/helix/pull/1178#discussion_r461773762", "createdAt": "2020-07-28T18:06:38Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/HttpZkFallbackRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * HTTP and ZK-based RoutingDataReader that first tries an HTTP call to MSDS and upon failure,\n+ * falls back to ZK for routing data.\n+ * HttpZkFallbackRoutingDataReader does not maintain a ZK connection - it establishes for reading\n+ * and closes it right away.\n+ */\n+public class HttpZkFallbackRoutingDataReader implements RoutingDataReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTgzNzM3", "url": "https://github.com/apache/helix/pull/1178#pullrequestreview-461183737", "createdAt": "2020-08-04T21:21:22Z", "commit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMToyMToyMlrOG7x8nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTozNzoyMFrOG7yYeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNzUwMA==", "bodyText": "What if some other customer they dont set up the default MSDS? They are using our module for ZKClient use case. So will path ZK address still work?", "url": "https://github.com/apache/helix/pull/1178#discussion_r465337500", "createdAt": "2020-08-04T21:21:22Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MDIwMA==", "bodyText": "Can we simplify the code here?\nFundamentally, it is check path in _metadataStoreRoutingData -> get exception -> update _metadataStoreRoutingData from different level.\nThere are several comment code. we can have a loop to wrap of it and based on the retried times to do different level update.", "url": "https://github.com/apache/helix/pull/1178#discussion_r465340200", "createdAt": "2020-08-04T21:27:16Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -550,17 +546,71 @@ private ZkClient getZkClient(String path) {\n   }\n \n   private String getZkRealm(String path) {\n+    if (_routingDataUpdateOnCacheMissEnabled) {\n+      try {\n+        return updateRoutingDataOnCacheMiss(path);\n+      } catch (InvalidRoutingDataException e) {\n+        LOG.error(\n+            \"FederatedZkClient::getZkRealm: Failed to update routing data due to invalid routing \"\n+                + \"data!\", e);\n+        throw new MultiZkException(e);\n+      }\n+    }\n+    return _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+  }\n+\n+  /**\n+   * Perform a 2-tier routing data cache update:\n+   * 1. Do an in-memory update from the singleton RoutingDataManager\n+   * 2. Do an I/O based read from the routing data source by resetting RoutingDataManager\n+   * @param path\n+   * @return\n+   * @throws InvalidRoutingDataException\n+   */\n+  private String updateRoutingDataOnCacheMiss(String path) throws InvalidRoutingDataException {\n     String zkRealm;\n     try {\n       zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n-    } catch (NoSuchElementException ex) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n-    }\n-\n-    if (zkRealm == null || zkRealm.isEmpty()) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    } catch (NoSuchElementException e1) {\n+      synchronized (this) {\n+        try {\n+          zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+        } catch (NoSuchElementException e2) {\n+          // Try 1) Refresh MetadataStoreRoutingData from RoutingDataManager\n+          // This is an in-memory refresh from the Singleton RoutingDataManager - other\n+          // FederatedZkClient objects may have triggered a cache refresh, so we first update the\n+          // in-memory reference. This refresh only affects this object/thread, so we synchronize\n+          // on \"this\".\n+          _metadataStoreRoutingData =\n+              RealmAwareZkClient.getMetadataStoreRoutingData(_connectionConfig);\n+          try {\n+            zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+          } catch (NoSuchElementException e3) {\n+            synchronized (FederatedZkClient.class) {\n+              try {\n+                zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+              } catch (NoSuchElementException e4) {\n+                if (shouldThrottleRead()) {\n+                  // If routing data update from routing data source has taken place recently,\n+                  // then just skip the update and throw the exception\n+                  throw e4;\n+                }\n+                // Try 2) Reset RoutingDataManager and re-read the routing data from routing data\n+                // source via I/O. Since RoutingDataManager's cache doesn't have it either, so we\n+                // synchronize on all threads by locking on FederatedZkClient.class.\n+                RoutingDataManager.getInstance().reset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDYzNA==", "bodyText": "error log here?", "url": "https://github.com/apache/helix/pull/1178#discussion_r465344634", "createdAt": "2020-08-04T21:37:20Z", "author": {"login": "junkaixue"}, "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/RoutingDataManager.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+\n+\n+/**\n+ * RoutingDataManager is a Singleton that\n+ * 1. resolves RoutingDataReader based on the system config given\n+ * 2. caches routing data\n+ * 3. provides public methods for reading routing data from various sources (configurable)\n+ */\n+public class RoutingDataManager {\n+  /** HTTP call to MSDS is used to fetch routing data by default */\n+  private String _defaultMsdsEndpoint =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be final (volatile) */\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, Raw Routing Data)\n+  private final Map<String, Map<String, List<String>>> _rawRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, MetadataStoreRoutingData)\n+  private final Map<String, MetadataStoreRoutingData> _metadataStoreRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+\n+  // Tracks the time at which reset() was called last. Used to throttle reset()\n+  private volatile long _lastResetTimestamp;\n+\n+  // Singleton instance\n+  private static RoutingDataManager _instance;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private RoutingDataManager() {\n+    // Private constructor for Singleton\n+  }\n+\n+  /**\n+   * Lazy initialization with double-checked locking.\n+   * @return\n+   */\n+  public static RoutingDataManager getInstance() {\n+    if (_instance == null) {\n+      synchronized (RoutingDataManager.class) {\n+        if (_instance == null) {\n+          _instance = new RoutingDataManager();\n+        }\n+      }\n+    }\n+    return _instance;\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP by querying the MSDS configured in the JVM\n+   * config.\n+   * @return\n+   */\n+  public Map<String, List<String>> getRawRoutingData() {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getRawRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   */\n+  public Map<String, List<String>> getRawRoutingData(RoutingDataReaderType routingDataReaderType,\n+      String endpoint) {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    Map<String, List<String>> rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+    if (rawRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+        if (rawRoutingData == null) {\n+          RoutingDataReader reader = resolveRoutingDataReader(routingDataReaderType);\n+          rawRoutingData = reader.getRawRoutingData(endpoint);\n+          _rawRoutingDataMap.put(routingDataCacheKey, rawRoutingData);\n+        }\n+      }\n+    }\n+    return rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format by querying the\n+   * MSDS configured in the JVM config.\n+   * @return MetadataStoreRoutingData\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData() throws InvalidRoutingDataException {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getMetadataStoreRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS as a MetadataStoreRoutingData object.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData(\n+      RoutingDataReaderType routingDataReaderType, String endpoint)\n+      throws InvalidRoutingDataException {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    MetadataStoreRoutingData metadataStoreRoutingData =\n+        _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+    if (metadataStoreRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        metadataStoreRoutingData = _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+        if (metadataStoreRoutingData == null) {\n+          metadataStoreRoutingData =\n+              new TrieRoutingData(getRawRoutingData(routingDataReaderType, endpoint));\n+          _metadataStoreRoutingDataMap.put(routingDataCacheKey, metadataStoreRoutingData);\n+        }\n+      }\n+    }\n+    return metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Clears the statically-cached routing data and private fields.\n+   */\n+  public synchronized void reset() {\n+    _rawRoutingDataMap.clear();\n+    _metadataStoreRoutingDataMap.clear();\n+    _defaultMsdsEndpoint =\n+        System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+    _lastResetTimestamp = System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Returns the timestamp for the last reset().\n+   * @return\n+   */\n+  public long getLastResetTimestamp() {\n+    return _lastResetTimestamp;\n+  }\n+\n+  /**\n+   * Returns an appropriate instance of RoutingDataReader given the type.\n+   * @param routingDataReaderType\n+   * @return\n+   */\n+  private RoutingDataReader resolveRoutingDataReader(RoutingDataReaderType routingDataReaderType) {\n+    // Instantiate an instance of routing data reader using the type\n+    try {\n+      return (RoutingDataReader) Class.forName(routingDataReaderType.getClassName()).newInstance();\n+    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n+      throw new MultiZkException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTgxMjE2", "url": "https://github.com/apache/helix/pull/1178#pullrequestreview-467181216", "createdAt": "2020-08-13T22:48:23Z", "commit": {"oid": "aab6cc926b6c621f28fb7065a9188b6debf1fa57"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59aeaf90709b72ec4956d91bbdbda0a37fcfe78d", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/59aeaf90709b72ec4956d91bbdbda0a37fcfe78d", "committedDate": "2020-08-14T06:32:33Z", "message": "Implement RoutingDataManager to replace HttpRoutingDataReader\n\nWe want to make the routing data source configurable. As such, using HttpRoutingDataReader as the static Singleton that fetches and caches the routing data is no longer appropriate. This change adds an implementation of RoutingDataManager and the new RoutingDataReader interface, with HttpRoutingDataReader as one of its implementations. This is the first step towards making routing data source configurable - other readers will be added in the future commits."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72170f6ee63ab6de6c8265e14ea3aa6bac04edd1", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/72170f6ee63ab6de6c8265e14ea3aa6bac04edd1", "committedDate": "2020-08-14T06:32:33Z", "message": "Fix string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60f3d61510654d25e2e6b24d32e40641a20c515b", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/60f3d61510654d25e2e6b24d32e40641a20c515b", "committedDate": "2020-08-14T06:32:33Z", "message": "Remove unnecessary IOException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "157cedf988a520ac70f3fb4e8d77d0ea9b047c72", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/157cedf988a520ac70f3fb4e8d77d0ea9b047c72", "committedDate": "2020-08-14T06:32:33Z", "message": "Change interface for RoutingDataReader\n\nThis commit changes the interface for RoutingDataReader in order to accommodate various types of routing data source."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fddbd5172cff602f563c5e4c016777a70d86b65e", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/fddbd5172cff602f563c5e4c016777a70d86b65e", "committedDate": "2020-08-14T06:32:33Z", "message": "Add HttpZkFallbackRoutingDataReader\n\nImplement an Http-ZK fallback routing data reader. ZkRoutingDataReader will follow."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72d53623c706ebaa180658cf1d74f66131396455", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/72d53623c706ebaa180658cf1d74f66131396455", "committedDate": "2020-08-14T06:32:33Z", "message": "Implement ZkRoutingDataReader\n\nIn order to allow certain users to use ZK as the sole routing data source, we add ZkRoutingDataReader that transiently creates a ZK connection to read the routing data from the routing ZK."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68af074dd715e3be726d1e415a9463755f712644", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/68af074dd715e3be726d1e415a9463755f712644", "committedDate": "2020-08-14T06:32:33Z", "message": "Modify realm-aware ZkClient and Helix API for configurable routing source\n\nThis commit changes old MSDS-based interfaces and replaces them with a more generic configurable routing data source interfaces. This commit also adds test cases for Helix API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af9d607d57c2336d8fe6d74895a76c75e6a98076", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/af9d607d57c2336d8fe6d74895a76c75e6a98076", "committedDate": "2020-08-14T06:32:34Z", "message": "Make RoutingDataManager a pure Singleton with double-checked locking\n\nRoutingDataManager was a stateful static class, but since it contains caches, it would be better to make it a Singleton. This commit makes it a singleton and updates the code accordingly."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf558f738347af1846307dd592e23e292ffe28e0", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/cf558f738347af1846307dd592e23e292ffe28e0", "committedDate": "2020-08-14T06:32:34Z", "message": "Refactor RealmAwareZkClient code to remove duplicate code\n\nThere was a piece of code that resolves MetadataStoreRoutingData based on RealmAwareZkConnectionConfig in all implementations of RealmAwareZkClient. This commit refactors that logic into a common static method in RealmAwareZkClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5498addd63b158ba6a86b236424ee9d2a1d75852", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/5498addd63b158ba6a86b236424ee9d2a1d75852", "committedDate": "2020-08-14T06:32:34Z", "message": "Implement routing data update upon cache miss for FederatedZkClient\n\nFederatedZkClient is the only implementation of RealmAwareZkClient that is capable of accesing multiple ZKs. There are potential use cases where it would be beneficial for FederatedZkClient and Helix Java APIs on multi-ZK mode to automatically trigger a routing data update when the ZK path sharding key is not found in the cached routing data.\nThis commit implements the feature and allows users to turn it on by setting a field in System Properties."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eda83703980eaca6b305aa495ab6b85d1b9a6301", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/eda83703980eaca6b305aa495ab6b85d1b9a6301", "committedDate": "2020-08-14T06:32:34Z", "message": "Implement throttling for routing data update on cache miss\n\nThis commit implements throttling for routing data update by using a timestamp for last time the cache was reset in RoutingDataManager. It defines a default interval (5 seconds) but makes this interval configurable by way of System Properties config."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "committedDate": "2020-08-14T06:32:34Z", "message": "Change UPDATE_ROUTING_DATA_ON_CACHE_MISS and remove unused imports\n\nThis commit updates the string constant values for UPDATE_ROUTING_DATA_ON_CACHE_MISS so that it's in line with other constants and removes unused imports and unnecessary IOExceptions thrown."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bad1860ed521d6d0f7d80b89c86a286892a85cd3", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/bad1860ed521d6d0f7d80b89c86a286892a85cd3", "committedDate": "2020-08-13T23:51:10Z", "message": "Change UPDATE_ROUTING_DATA_ON_CACHE_MISS and remove unused imports\n\nThis commit updates the string constant values for UPDATE_ROUTING_DATA_ON_CACHE_MISS so that it's in line with other constants and removes unused imports and unnecessary IOExceptions thrown."}, "afterCommit": {"oid": "d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "author": {"user": {"login": "narendly", "name": "Hunter Lee"}}, "url": "https://github.com/apache/helix/commit/d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "committedDate": "2020-08-14T06:32:34Z", "message": "Change UPDATE_ROUTING_DATA_ON_CACHE_MISS and remove unused imports\n\nThis commit updates the string constant values for UPDATE_ROUTING_DATA_ON_CACHE_MISS so that it's in line with other constants and removes unused imports and unnecessary IOExceptions thrown."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4584, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}