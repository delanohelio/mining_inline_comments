{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMTQ3NTk3", "number": 834, "title": "Complete the Routing Table Provider for CustomizedView", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\nFixes #833\n\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\nIn this PR, the routing table provider has been changed in a way\nto include customized view feature.\n\nTests\n\n\n The following tests are written for this issue:\nTestRoutingTableProvider.testExternalViewWithType\nTestRoutingTableProvider.testCustomizedViewWithoutType\nTestRoutingTableProvider.testCustomizedViewCorrectConstructor\nTestRoutingTableProvider.testGetRoutingTableSnapshot\nTestRoutingTableProvider.testSnapshotContents\n\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n\n[INFO] Tests run: 914, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3,559.344 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 914, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  59:24 min\n[INFO] Finished at: 2020-02-27T16:27:09-08:00\n[INFO] ------------------------------------------------------------------------\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-02-28T00:57:17Z", "url": "https://github.com/apache/helix/pull/834", "merged": true, "mergeCommit": {"oid": "3f8ebc3a0bf2dbba4d01bdbea71bd339384e2ba0"}, "closed": true, "closedAt": "2020-03-20T18:32:48Z", "author": {"login": "alirezazamani"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcI3eJZgBqjMwODM3MDU3MTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPVZQEABqjMxNDc3MTY2Njk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2df0815736023083da77af9c7c0c76fdaa6d59aa", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/2df0815736023083da77af9c7c0c76fdaa6d59aa", "committedDate": "2020-02-28T00:47:28Z", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature."}, "afterCommit": {"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/be3d54001a9a418282b21bbf8ddc7a72aaefa772", "committedDate": "2020-02-28T22:14:48Z", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MzkyNzMz", "url": "https://github.com/apache/helix/pull/834#pullrequestreview-367392733", "createdAt": "2020-03-02T17:39:30Z", "commit": {"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzozOTozMVrOFwovRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOToyMjo0MlrOFwsH2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MzQyOQ==", "bodyText": "Java doc for the new constructor.", "url": "https://github.com/apache/helix/pull/834#discussion_r386543429", "createdAt": "2020-03-02T17:39:31Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -30,53 +30,80 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import org.apache.helix.PropertyType;\n import org.apache.helix.model.CurrentState;\n+import org.apache.helix.model.CustomizedView;\n import org.apache.helix.model.ExternalView;\n import org.apache.helix.model.InstanceConfig;\n import org.apache.helix.model.LiveInstance;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n   private final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n+  private final Collection<CustomizedView> _customizedViews;\n+\n+  private final PropertyType _propertyType;\n+  private final String _aggregationType;\n \n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  public RoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType, aggregationType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES, null);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, Collections.<CustomizedView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW, null);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MzU3Ng==", "bodyText": "Java doc for the new constructor.", "url": "https://github.com/apache/helix/pull/834#discussion_r386543576", "createdAt": "2020-03-02T17:39:47Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -41,13 +44,24 @@\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n   private final PropertyType _sourceDataType;\n+  // Aggregation type is used for CustomizedView only.\n+  private final String _aggregationType;\n+\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedViewCache _customizedViewCache;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n+\n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {\n+    this (clusterName, sourceDataType, null);\n+  }\n+\n+  public RoutingDataCache(String clusterName, PropertyType sourceDataType, String aggregationType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU3OTc2Nw==", "bodyText": "This will not work as expected, use \"aggregationType == null || aggregationType.isEmpty()\"", "url": "https://github.com/apache/helix/pull/834#discussion_r386579767", "createdAt": "2020-03-02T18:48:12Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +610,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n    * Return names of all resources (shown in ExternalView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * Function that returns the key associated with the specific _routingTableRef\n+   * @return\n+   */\n+  private String getRoutingTableKey() {\n+    // Check whether there exist only one snapshot (_routingTableRef)\n+    if (_routingTableRef.keySet().size() == 1) {\n+      return _routingTableRef.keySet().iterator().next();\n+    } else {\n+      throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType) {\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+    } else {\n+      return getRoutingTableKey(propertyType, null);\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType, String aggregationType) {\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      if (aggregationType == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5ODg3NQ==", "bodyText": "can we specify propertyType in case we'd like to extend later or the wrong type is input.", "url": "https://github.com/apache/helix/pull/834#discussion_r386598875", "createdAt": "2020-03-02T19:22:42Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -30,53 +30,80 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import org.apache.helix.PropertyType;\n import org.apache.helix.model.CurrentState;\n+import org.apache.helix.model.CustomizedView;\n import org.apache.helix.model.ExternalView;\n import org.apache.helix.model.InstanceConfig;\n import org.apache.helix.model.LiveInstance;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n   private final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n+  private final Collection<CustomizedView> _customizedViews;\n+\n+  private final PropertyType _propertyType;\n+  private final String _aggregationType;\n \n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  public RoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType, aggregationType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES, null);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, Collections.<CustomizedView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW, null);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews,\n+      Collection<CustomizedView> customizedViews, Collection<InstanceConfig> instanceConfigs,\n+      Collection<LiveInstance> liveInstances, PropertyType propertytype, String aggregationType) {\n+    _propertyType = propertytype;\n+    _aggregationType = aggregationType;\n     _resourceInfoMap = new HashMap<>();\n     _resourceGroupInfoMap = new HashMap<>();\n     _liveInstances = new HashSet<>(liveInstances);\n     _instanceConfigs = new HashSet<>(instanceConfigs);\n     _externalViews = new HashSet<>(externalViews);\n-    refresh(externalViews);\n+    _customizedViews = new HashSet<>(customizedViews);\n+    if (_propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      refreshCustomizedView(customizedViews);\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772"}, "originalPosition": 76}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "379d9ec302dbbf6f075b517e8985ed9e3cf590ea", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/379d9ec302dbbf6f075b517e8985ed9e3cf590ea", "committedDate": "2020-03-03T23:01:20Z", "message": "Address comments"}, "afterCommit": {"oid": "ed3b93c999cc5aa700a734b48f3a866b69eb1167", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/ed3b93c999cc5aa700a734b48f3a866b69eb1167", "committedDate": "2020-03-03T23:03:57Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDA3ODEw", "url": "https://github.com/apache/helix/pull/834#pullrequestreview-370007810", "createdAt": "2020-03-06T00:31:18Z", "commit": {"oid": "ed3b93c999cc5aa700a734b48f3a866b69eb1167"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozMToxOFrOFyo94A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDo0MzoxOFrOFypOWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDMyMA==", "bodyText": "Is it overlapped with Meng's PR?\nhttps://github.com/apache/helix/pull/851/files\nCan we change this part as a pre-requisite change so both of you are on the same page.", "url": "https://github.com/apache/helix/pull/834#discussion_r388644320", "createdAt": "2020-03-06T00:31:18Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java", "diffHunk": "@@ -72,6 +74,7 @@\n     typeToClassMapping.put(IDEALSTATES, IdealState.class);\n     typeToClassMapping.put(CONFIGS, InstanceConfig.class);\n     typeToClassMapping.put(EXTERNALVIEW, ExternalView.class);\n+    typeToClassMapping.put(CUSTOMIZEDVIEW, CustomizedView.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed3b93c999cc5aa700a734b48f3a866b69eb1167"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NzYyNw==", "bodyText": "If _aggregationType is empty, do we need to to the following refresh?", "url": "https://github.com/apache/helix/pull/834#discussion_r388647627", "createdAt": "2020-03-06T00:40:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -84,13 +104,23 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n       LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n     }\n \n+    if (_sourceDataType.equals(PropertyType.CUSTOMIZEDVIEW) && _propertyDataChangedMap\n+        .get(HelixConstants.ChangeType.CUSTOMIZED_VIEW) && _aggregationType != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed3b93c999cc5aa700a734b48f3a866b69eb1167"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0ODUzNw==", "bodyText": "With more cases, using if to check _sourceDataType.equals() does not work well.\nCan we change to use switch-case?", "url": "https://github.com/apache/helix/pull/834#discussion_r388648537", "createdAt": "2020-03-06T00:43:18Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -84,13 +104,23 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n       LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n     }\n \n+    if (_sourceDataType.equals(PropertyType.CUSTOMIZEDVIEW) && _propertyDataChangedMap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed3b93c999cc5aa700a734b48f3a866b69eb1167"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35c1d6d31f0ec0ce53f437fb3a4d509f1282cab9", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/35c1d6d31f0ec0ce53f437fb3a4d509f1282cab9", "committedDate": "2020-03-09T17:44:41Z", "message": "new review fixes"}, "afterCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/78d4faf6adf9d892fd930308fb65ba30c6616f2e", "committedDate": "2020-03-09T17:49:03Z", "message": "new review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTU1ODc3", "url": "https://github.com/apache/helix/pull/834#pullrequestreview-371555877", "createdAt": "2020-03-09T21:55:12Z", "commit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "state": "COMMENTED", "comments": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTo1NToxMlrOFz6tjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoyNDoyOFrOFz8njw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzYzMA==", "bodyText": "What's the usage of this constructor? Can we just have one of them?", "url": "https://github.com/apache/helix/pull/834#discussion_r389983630", "createdAt": "2020-03-09T21:55:12Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, aggregationType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NDQxMg==", "bodyText": "This method looks exactly same as \"private void refresh(Collection externalViewList)\".\nCan we do a template class here, and ExternalView/CustomizedView can be the template type.", "url": "https://github.com/apache/helix/pull/834#discussion_r389984412", "createdAt": "2020-03-09T21:56:58Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, aggregationType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      PropertyType propertytype, String aggregationType) {\n+    this(customizedViews, Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertytype, aggregationType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      PropertyType propertytype, String aggregationType) {\n+    super(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.CUSTOMIZEDVIEW);\n+    _aggregationType = aggregationType;\n+    _customizedViews = new HashSet<>(customizedViews);\n+    refresh(_customizedViews);\n+  }\n+\n+  private void refresh(Collection<CustomizedView> customizedViewList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTgwOA==", "bodyText": "I cannot remember what _aggregationType is... This part will need to be commented heavily.", "url": "https://github.com/apache/helix/pull/834#discussion_r389999808", "createdAt": "2020-03-09T22:38:04Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTEyOA==", "bodyText": "I guess we call it customizedStateType?", "url": "https://github.com/apache/helix/pull/834#discussion_r390001128", "createdAt": "2020-03-09T22:42:05Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTgwOA=="}, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMjE3Mw==", "bodyText": "Maybe throw an exception here.", "url": "https://github.com/apache/helix/pull/834#discussion_r390002173", "createdAt": "2020-03-09T22:45:01Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -66,31 +85,46 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n \n     super.refresh(accessor);\n \n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n-    }\n-\n-    if (_sourceDataType.equals(PropertyType.CURRENTSTATES) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.CURRENT_STATE)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n-      Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n-      _currentStateCache.refresh(accessor, liveInstanceMap);\n-      LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    switch (_sourceDataType) {\n+    case TARGETEXTERNALVIEW:\n+      if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+        long start = System.currentTimeMillis();\n+        _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+        _targetExternalViewCache.refresh(accessor);\n+        LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+            + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+      }\n+      break;\n+    case CURRENTSTATES:\n+      if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+        long start = System.currentTimeMillis();\n+        _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+        Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+        _currentStateCache.refresh(accessor, liveInstanceMap);\n+        LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+      }\n+      break;\n+    case CUSTOMIZEDVIEW:\n+      if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)\n+          && !_aggregationType.isEmpty()) {\n+        long start = System.currentTimeMillis();\n+        _propertyDataChangedMap.put(HelixConstants.ChangeType.CUSTOMIZED_VIEW, false);\n+        _customizedViewCache.refresh(accessor);\n+        LOG.info(\"Reload \" + _customizedViewCache.getCustomizedViewMap().keySet().size()\n+            + \" CustomizedView. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+      }\n+      break;\n+    default:\n+      break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTI4Mg==", "bodyText": "So based on your usage now, the cache can be a combination of 2 types of data.\n\nthe partition state map\nthe customized view state map\n\nI can see you are trying to keep the assumption that one cache only serves for one type (also customize state type). However, that assumption becomes useless when we need to output snapshot to be a combination.\nSo 2 alternative ways as my suggestion:\n\nSplit the current cache object as you did for CustomizedViewRoutingTable. So they are still one-one mapping.\nOr, make this cache support multiple types, so it is one-one mapping with the RoutingTableProvider.", "url": "https://github.com/apache/helix/pull/834#discussion_r390005282", "createdAt": "2020-03-09T22:54:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -41,13 +43,30 @@\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n   private final PropertyType _sourceDataType;\n+  // Aggregation type is used for CustomizedView only.\n+  private final String _aggregationType;\n+\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedViewCache _customizedViewCache;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n+\n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTUzNA==", "bodyText": "comment out of date? There is no _aggregationType.", "url": "https://github.com/apache/helix/pull/834#discussion_r390005534", "createdAt": "2020-03-09T22:55:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,62 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType and _aggregationType fields.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjU4MA==", "bodyText": "Protected?", "url": "https://github.com/apache/helix/pull/834#discussion_r390006580", "createdAt": "2020-03-09T22:58:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,62 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType and _aggregationType fields.\n+   * @param propertyType\n+   */\n+  public RoutingTable(PropertyType propertyType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjg2Nw==", "bodyText": "Is this one deprecated?", "url": "https://github.com/apache/helix/pull/834#discussion_r390006867", "createdAt": "2020-03-09T22:59:46Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,62 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n   public RoutingTable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODIzOA==", "bodyText": "Return something constant like \"HELIX_DEFAULT\"", "url": "https://github.com/apache/helix/pull/834#discussion_r390008238", "createdAt": "2020-03-09T23:03:45Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -351,6 +372,23 @@ ResourceGroupInfo getResourceGroup(String resourceGroupName) {\n     return Collections.unmodifiableCollection(_externalViews);\n   }\n \n+  /**\n+   * Returns PropertyTYpe\n+   * @return the PropertyTYpe of this RoutingTable\n+   */\n+  protected PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Returns AggregationType\n+   * @return the AggregationType of this RoutingTable (Used for CustomizedView)\n+   */\n+  protected String getAggregationType() {\n+    return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODM0NQ==", "bodyText": "_routingTableRefMap", "url": "https://github.com/apache/helix/pull/834#discussion_r390008345", "createdAt": "2020-03-09T23:04:06Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODQ3Ng==", "bodyText": "Better to be one updater fand one cache inside.", "url": "https://github.com/apache/helix/pull/834#discussion_r390008476", "createdAt": "2020-03-09T23:04:28Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;\n   private final HelixManager _helixManager;\n-  private final RouterUpdater _routerUpdater;\n-  private final PropertyType _sourceDataType;\n+  private final Map<String, RouterUpdater> _routerUpdater;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODY3Mg==", "bodyText": "BTW, option 2 looks easier to me. I will assume this is the option we take for the following comments.", "url": "https://github.com/apache/helix/pull/834#discussion_r390008672", "createdAt": "2020-03-09T23:05:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -41,13 +43,30 @@\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n   private final PropertyType _sourceDataType;\n+  // Aggregation type is used for CustomizedView only.\n+  private final String _aggregationType;\n+\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedViewCache _customizedViewCache;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n+\n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTI4Mg=="}, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODg3OQ==", "bodyText": "_monitorMap", "url": "https://github.com/apache/helix/pull/834#discussion_r390008879", "createdAt": "2020-03-09T23:05:48Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;\n   private final HelixManager _helixManager;\n-  private final RouterUpdater _routerUpdater;\n-  private final PropertyType _sourceDataType;\n+  private final Map<String, RouterUpdater> _routerUpdater;\n+  private final Map<PropertyType, List<String>> _sourceDataTypes;\n   private final Map<RoutingTableChangeListener, ListenerContext> _routingTableChangeListenerMap;\n-  private final RoutingTableProviderMonitor _monitor;\n+  private final Map<PropertyType, RoutingTableProviderMonitor> _monitor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODk0OQ==", "bodyText": "_sourceDataTypeMap", "url": "https://github.com/apache/helix/pull/834#discussion_r390008949", "createdAt": "2020-03-09T23:05:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;\n   private final HelixManager _helixManager;\n-  private final RouterUpdater _routerUpdater;\n-  private final PropertyType _sourceDataType;\n+  private final Map<String, RouterUpdater> _routerUpdater;\n+  private final Map<PropertyType, List<String>> _sourceDataTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMDk4Mg==", "bodyText": "nit, Make this a private method?\nAnd maybe we can simplify it little bit. I understand this is for clearly log the error. But we can also put the error message more briefly and log the type/path details in the error log so we can debug.", "url": "https://github.com/apache/helix/pull/834#discussion_r390010982", "createdAt": "2020-03-09T23:12:19Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +115,131 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypes\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypes, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    // Check and validate the input of the sourceDataTypes parameter\n+    for (PropertyType propertyType : sourceDataTypes.keySet()) {\n+      if (propertyType.equals(PropertyType.CUSTOMIZEDVIEW)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTY4Mg==", "bodyText": "This should be default string as well.", "url": "https://github.com/apache/helix/pull/834#discussion_r390011682", "createdAt": "2020-03-09T23:14:24Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +115,131 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypes\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypes, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    // Check and validate the input of the sourceDataTypes parameter\n+    for (PropertyType propertyType : sourceDataTypes.keySet()) {\n+      if (propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() == 0) {\n+        logger.error(\"CustomizedView has been used without any aggregation type!\");\n+        throw new HelixException(\"CustomizedView has been used without any aggregation type!\");\n+      }\n+      if (!propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() != 0) {\n+        logger.error(\"Type has been used in addition to the property type {} !\",\n+            propertyType.name());\n+        throw new HelixException(String.format(\n+            \"Type has been used in addition to the property type %s !\", propertyType.name()));\n+      }\n+    }\n+\n+    _routingTableRef = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _routerUpdater = new HashMap<>();\n+    _sourceDataTypes = sourceDataTypes;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _monitor = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      _monitor.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitor.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      if (_sourceDataTypes.get(propertyType).size() == 0) {\n+        // Empty aggregationType\n+        String aggregationType = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjMwNA==", "bodyText": "This can be combined to a method together with the previous condition's code. And, actually, I suggest to put this logic into routerUpdater. And make the routerUpdater support multiple types.", "url": "https://github.com/apache/helix/pull/834#discussion_r390012304", "createdAt": "2020-03-09T23:16:21Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +115,131 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypes\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypes, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    // Check and validate the input of the sourceDataTypes parameter\n+    for (PropertyType propertyType : sourceDataTypes.keySet()) {\n+      if (propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() == 0) {\n+        logger.error(\"CustomizedView has been used without any aggregation type!\");\n+        throw new HelixException(\"CustomizedView has been used without any aggregation type!\");\n+      }\n+      if (!propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() != 0) {\n+        logger.error(\"Type has been used in addition to the property type {} !\",\n+            propertyType.name());\n+        throw new HelixException(String.format(\n+            \"Type has been used in addition to the property type %s !\", propertyType.name()));\n+      }\n+    }\n+\n+    _routingTableRef = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _routerUpdater = new HashMap<>();\n+    _sourceDataTypes = sourceDataTypes;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _monitor = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      _monitor.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitor.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      if (_sourceDataTypes.get(propertyType).size() == 0) {\n+        // Empty aggregationType\n+        String aggregationType = \"\";\n+        String key = propertyType.name() + \"_\" + aggregationType;\n+        if (_routerUpdater.get(key) == null) {\n+          _routerUpdater.put(key, new RouterUpdater(clusterName, propertyType, aggregationType, key));\n+          _routerUpdater.get(key).start();\n+          _routingTableRef.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {\n+        for (String aggregationType : _sourceDataTypes.get(propertyType)) {\n+          String key = propertyType.name() + \"_\" + aggregationType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzU4Nw==", "bodyText": "I would suggest making the return more comprehensive.\nMap<String (path), Map<String (type), RoutingTableSnapshot>>", "url": "https://github.com/apache/helix/pull/834#discussion_r390013587", "createdAt": "2020-03-09T23:20:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -237,7 +332,42 @@ public void shutdown() {\n    * @return snapshot of current routing table.\n    */\n   public RoutingTableSnapshot getRoutingTableSnapshot() {\n-    return new RoutingTableSnapshot(_routingTableRef.get());\n+      String key = getRoutingTableKey();\n+      return new RoutingTableSnapshot(_routingTableRef.get(key).get());\n+  }\n+\n+  /**\n+   * Get an snapshot of current RoutingTable information for specific PropertyType.\n+   * The snapshot is immutable, it reflects the routing table information at the time this method is\n+   * called.\n+   * @return snapshot of current routing table.\n+   */\n+  public RoutingTableSnapshot getRoutingTableSnapshot (PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return new RoutingTableSnapshot(_routingTableRef.get(key).get());\n+  }\n+\n+  /**\n+   * Get an snapshot of all of the available RoutingTable information. The snapshot is immutable, it\n+   * reflects the routing table information at the time this method is called.\n+   * @return snapshot associated with specific propertyType and type.\n+   */\n+  public RoutingTableSnapshot getRoutingTableSnapshot(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return new RoutingTableSnapshot(_routingTableRef.get(key).get());\n+  }\n+\n+  /**\n+   * Get an snapshot of all of the available RoutingTable information. The snapshot is immutable, it\n+   * reflects the routing table information at the time this method is called.\n+   * @return all of the available snapshots of current routing table.\n+   */\n+  public Map<String, RoutingTableSnapshot> getRoutingTableSnapshots() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzgyMQ==", "bodyText": "Are we support customize state reverse search? If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390013821", "createdAt": "2020-03-09T23:21:13Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -279,6 +409,16 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, partitionName, state);\n   }\n \n+  public List<InstanceConfig> getInstances(String resourceName, String partitionName, String state,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzg4OA==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390013888", "createdAt": "2020-03-09T23:21:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -290,7 +430,23 @@ public Object removeRoutingTableChangeListener(\n    */\n   public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,\n       String state) {\n-    return _routingTableRef.get().getInstancesForResource(resourceName, partitionName, state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResource(resourceName, partitionName,\n+        state);\n+  }\n+\n+  public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzk0NQ==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390013945", "createdAt": "2020-03-09T23:21:36Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -305,8 +461,23 @@ public Object removeRoutingTableChangeListener(\n    */\n   public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,\n       String partitionName, String state) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, partitionName,\n-        state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName,\n+        partitionName, state);\n+  }\n+\n+  public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAwNg==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014006", "createdAt": "2020-03-09T23:21:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -322,8 +493,24 @@ public Object removeRoutingTableChangeListener(\n    */\n   public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,\n       String partitionName, String state, List<String> resourceTags) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, partitionName,\n-        state, resourceTags);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName,\n+        partitionName, state, resourceTags);\n+  }\n+\n+  public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAzOA==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014038", "createdAt": "2020-03-09T23:21:55Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +525,37 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDA4MA==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014080", "createdAt": "2020-03-09T23:22:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +525,37 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,\n+      PropertyType propertyType) {\n+    return getInstancesForResource(resourceName, state, propertyType);\n+  }\n+\n+  public Set<InstanceConfig> getInstances(String resourceName, String state,\n+      PropertyType propertyType, String type) {\n+    return getInstancesForResource(resourceName, state, propertyType, type);\n+  }\n+\n   /**\n    * returns all instances for {resource} that are in a specific {state}.\n    * @param resourceName\n    * @param state\n    * @return empty list if there is no instance in a given state\n    */\n   public Set<InstanceConfig> getInstancesForResource(String resourceName, String state) {\n-    return _routingTableRef.get().getInstancesForResource(resourceName, state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResource(resourceName, state);\n+  }\n+\n+  public Set<InstanceConfig> getInstancesForResource(String resourceName, String state,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDEwOA==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014108", "createdAt": "2020-03-09T23:22:07Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -355,7 +565,20 @@ public Object removeRoutingTableChangeListener(\n    * @return empty list if there is no instance in a given state\n    */\n   public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName, state);\n+  }\n+\n+  public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 514}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDEzNA==", "bodyText": "Same here. If not in the design, let's hold this for now.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014134", "createdAt": "2020-03-09T23:22:13Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -367,7 +590,22 @@ public Object removeRoutingTableChangeListener(\n    */\n   public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state,\n       List<String> resourceTags) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, state,\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName, state,\n+        resourceTags);\n+  }\n+\n+  public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 537}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDMxMQ==", "bodyText": "This, I don't understand. Why live instance would be different with different state?", "url": "https://github.com/apache/helix/pull/834#discussion_r390014311", "createdAt": "2020-03-09T23:22:43Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDUxMg==", "bodyText": "Same here, instance config would be different with a different type?", "url": "https://github.com/apache/helix/pull/834#discussion_r390014512", "createdAt": "2020-03-09T23:23:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDU1NQ==", "bodyText": "Same here.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014555", "createdAt": "2020-03-09T23:23:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n    * Return names of all resources (shown in ExternalView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 599}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDg2Mw==", "bodyText": "Just keep this one. For the other 2 usages, just merge the check logic inside here. Put default values in the caller if necessary.", "url": "https://github.com/apache/helix/pull/834#discussion_r390014863", "createdAt": "2020-03-09T23:24:28Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n    * Return names of all resources (shown in ExternalView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * Function that returns the key associated with the specific _routingTableRef\n+   * @return\n+   */\n+  private String getRoutingTableKey() {\n+    // Check whether there exist only one snapshot (_routingTableRef)\n+    if (_routingTableRef.keySet().size() == 1) {\n+      return _routingTableRef.keySet().iterator().next();\n+    } else {\n+      throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType) {\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+    } else {\n+      return getRoutingTableKey(propertyType, \"\");\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType, String aggregationType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 630}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc724260f9cd85dc1b7e45c6445645e0baaa9296", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/fc724260f9cd85dc1b7e45c6445645e0baaa9296", "committedDate": "2020-03-10T19:45:04Z", "message": "work in progress"}, "afterCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/24990ea51b35660e0862cee735c24d9bd3694e32", "committedDate": "2020-03-12T18:23:13Z", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjU4NDMw", "url": "https://github.com/apache/helix/pull/834#pullrequestreview-374658430", "createdAt": "2020-03-13T22:51:22Z", "commit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjo1MToyMlrOF2VdKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwMDozMjoxOVrOF2WluQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODk1Mw==", "bodyText": "customizedState?", "url": "https://github.com/apache/helix/pull/834#discussion_r392518953", "createdAt": "2020-03-13T22:51:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  /*\n+   * The customizedStateType field is the type the controller is aggregating.\n+   * For example if RoutingTableProvider initialized using the code below:\n+   * Map<PropertyType, List<String>> sourceDataTypes = new HashMap<>();\n+   * sourceDataTypes.put(PropertyType.CUSTOMIZEDVIEW, Arrays.asList(\"typeA\", \"typeB\"));\n+   * RoutingTableProvider routingTableProvider =\n+   * new RoutingTableProvider(_spectator, sourceDataTypes);\n+   *\n+   * Each one of the TypeA and TypeB is a customizedStateType.\n+   */\n+  private final String _customizedStateType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String customizedStateType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      PropertyType propertytype, String customizedStateType) {\n+    this(customizedViews, Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertytype, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      PropertyType propertytype, String customizedStateType) {\n+    super(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.CUSTOMIZEDVIEW);\n+    _customizedStateType = customizedStateType;\n+    _customizedViews = new HashSet<>(customizedViews);\n+    refresh(_customizedViews);\n+  }\n+\n+  private void refresh(Collection<CustomizedView> customizedViewList) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    if (customizedViewList != null && !customizedViewList.isEmpty()) {\n+      for (InstanceConfig config : _instanceConfigs) {\n+        instanceConfigMap.put(config.getId(), config);\n+      }\n+      for (CustomizedView customView : customizedViewList) {\n+        String resourceName = customView.getId();\n+        for (String partitionName : customView.getPartitionSet()) {\n+          Map<String, String> stateMap = customView.getStateMap(partitionName);\n+          for (String instanceName : stateMap.keySet()) {\n+            String currentState = stateMap.get(instanceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxOTQxNg==", "bodyText": "Let's add a TODO there. Once we migrate all cache to propetyCache, this hardcoded list of fields won't be necessary.", "url": "https://github.com/apache/helix/pull/834#discussion_r392519416", "createdAt": "2020-03-13T22:53:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -40,14 +47,29 @@\n class RoutingDataCache extends BasicClusterDataCache {\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n-  private final PropertyType _sourceDataType;\n+  private final Map<PropertyType, List<String>> _sourceDataTypeMap;\n+\n   private CurrentStateCache _currentStateCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDAwMA==", "bodyText": "This could be outside the loop?", "url": "https://github.com/apache/helix/pull/834#discussion_r392520000", "createdAt": "2020-03-13T22:56:01Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -65,32 +87,55 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     long startTime = System.currentTimeMillis();\n \n     super.refresh(accessor);\n-\n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      switch (propertyType) {\n+      case TARGETEXTERNALVIEW:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+          _targetExternalViewCache.refresh(accessor);\n+          LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+              + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CURRENTSTATES:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+          Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+          _currentStateCache.refresh(accessor, liveInstanceMap);\n+          LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CUSTOMIZEDVIEW: {\n+        for (String customizedStateType : _sourceDataTypeMap.get(PropertyType.CUSTOMIZEDVIEW)) {\n+          if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDUyMA==", "bodyText": "This can be out of the switch block to reduce code.", "url": "https://github.com/apache/helix/pull/834#discussion_r392520520", "createdAt": "2020-03-13T22:58:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -65,32 +87,55 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     long startTime = System.currentTimeMillis();\n \n     super.refresh(accessor);\n-\n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      switch (propertyType) {\n+      case TARGETEXTERNALVIEW:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+          _targetExternalViewCache.refresh(accessor);\n+          LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+              + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CURRENTSTATES:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+          Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+          _currentStateCache.refresh(accessor, liveInstanceMap);\n+          LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CUSTOMIZEDVIEW: {\n+        for (String customizedStateType : _sourceDataTypeMap.get(PropertyType.CUSTOMIZEDVIEW)) {\n+          if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)) {\n+            long start = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDY3OA==", "bodyText": "Also, this log should be able to move out if we add some local vars for the log info.", "url": "https://github.com/apache/helix/pull/834#discussion_r392520678", "createdAt": "2020-03-13T22:59:01Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -65,32 +87,55 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     long startTime = System.currentTimeMillis();\n \n     super.refresh(accessor);\n-\n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      switch (propertyType) {\n+      case TARGETEXTERNALVIEW:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+          _targetExternalViewCache.refresh(accessor);\n+          LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+              + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CURRENTSTATES:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+          Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+          _currentStateCache.refresh(accessor, liveInstanceMap);\n+          LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CUSTOMIZEDVIEW: {\n+        for (String customizedStateType : _sourceDataTypeMap.get(PropertyType.CUSTOMIZEDVIEW)) {\n+          if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)) {\n+            long start = System.currentTimeMillis();\n+            _customizedViewCaches.get(customizedStateType).refresh(accessor);\n+            LOG.info(\"Reload \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDk5NA==", "bodyText": "Check null. The caller might pass an unknown type.", "url": "https://github.com/apache/helix/pull/834#discussion_r392520994", "createdAt": "2020-03-13T23:00:24Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -103,6 +148,14 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     return _targetExternalViewCache.getExternalViewMap();\n   }\n \n+  /**\n+   * Retrieves the CustomizedView for all resources\n+   * @return\n+   */\n+  public Map<String, CustomizedView> getCustomizedView(String customizedStateType) {\n+    return _customizedViewCaches.get(customizedStateType).getCustomizedViewMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTc0NA==", "bodyText": "Add a TODO here, we really need to refactor these constructors.", "url": "https://github.com/apache/helix/pull/834#discussion_r392521744", "createdAt": "2020-03-13T23:03:42Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,63 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n+  @Deprecated\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType fields.\n+   * @param propertyType\n+   */\n+  protected RoutingTable(PropertyType propertyType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews, Collection<InstanceConfig> instanceConfigs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjA0NA==", "bodyText": "And try to make it private if possible.", "url": "https://github.com/apache/helix/pull/834#discussion_r392522044", "createdAt": "2020-03-13T23:05:00Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,63 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n+  @Deprecated\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType fields.\n+   * @param propertyType\n+   */\n+  protected RoutingTable(PropertyType propertyType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews, Collection<InstanceConfig> instanceConfigs,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTc0NA=="}, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjQ4NA==", "bodyText": "Make it more generic, getStateType(). Every state can refer to this type.", "url": "https://github.com/apache/helix/pull/834#discussion_r392522484", "createdAt": "2020-03-13T23:06:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -351,6 +373,23 @@ ResourceGroupInfo getResourceGroup(String resourceGroupName) {\n     return Collections.unmodifiableCollection(_externalViews);\n   }\n \n+  /**\n+   * Returns PropertyTYpe\n+   * @return the PropertyTYpe of this RoutingTable\n+   */\n+  protected PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Returns CustomizedStateType\n+   * @return the CustomizedStateType of this RoutingTable (Used for CustomizedView)\n+   */\n+  protected String getCustomizedStateType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNDk0MA==", "bodyText": "nit, Some common logic could be merged. We can set the local vars and finish the _routingTableRefMap set up after the condition check.", "url": "https://github.com/apache/helix/pull/834#discussion_r392524940", "createdAt": "2020-03-13T23:18:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +120,113 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      if (_sourceDataTypeMap.get(propertyType).size() == 0) {\n+        // Empty CustomizedStateType\n+        String customizedStateType = DEFAULT_TYPE;\n+        String key = propertyType.name() + \"_\" + customizedStateType;\n+        if (_routingTableRefMap.get(key) == null) {\n+          _routingTableRefMap.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {\n+        for (String customizedStateType : _sourceDataTypeMap.get(propertyType)) {\n+          String key = propertyType.name() + \"_\" + customizedStateType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTEwNw==", "bodyText": "nit, can we move this block to a private method?", "url": "https://github.com/apache/helix/pull/834#discussion_r392525107", "createdAt": "2020-03-13T23:19:10Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +120,113 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      if (_sourceDataTypeMap.get(propertyType).size() == 0) {\n+        // Empty CustomizedStateType\n+        String customizedStateType = DEFAULT_TYPE;\n+        String key = propertyType.name() + \"_\" + customizedStateType;\n+        if (_routingTableRefMap.get(key) == null) {\n+          _routingTableRefMap.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {\n+        for (String customizedStateType : _sourceDataTypeMap.get(propertyType)) {\n+          String key = propertyType.name() + \"_\" + customizedStateType;\n+          if (_routingTableRefMap.get(key) == null) {\n+            _routingTableRefMap.put(key, new AtomicReference<>(\n+                new CustomizedViewRoutingTable(propertyType, customizedStateType)));\n+          }\n         }\n-        break;\n+      }\n+    }\n \n-      case CURRENTSTATES:\n-        // CurrentState change listeners will be added later in LiveInstanceChange call.\n-        break;\n+    if (_helixManager != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTM5MA==", "bodyText": "Better to check NPE for these calls.", "url": "https://github.com/apache/helix/pull/834#discussion_r392525390", "createdAt": "2020-03-13T23:20:37Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -237,7 +337,48 @@ public void shutdown() {\n    * @return snapshot of current routing table.\n    */\n   public RoutingTableSnapshot getRoutingTableSnapshot() {\n-    return new RoutingTableSnapshot(_routingTableRef.get());\n+      String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+      return new RoutingTableSnapshot(_routingTableRefMap.get(key).get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUwMg==", "bodyText": "The \"type\" here is not clear what does it mean.\n\nstate type would be cleaner.\nfor all the public method, add java doc.", "url": "https://github.com/apache/helix/pull/834#discussion_r392526502", "createdAt": "2020-03-13T23:26:22Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +510,26 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,\n+      PropertyType propertyType, String type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 444}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjc2Ng==", "bodyText": "This could be a potential concern since each table will keep a separate instance list. There should be only one copy of the data. Let's add a TODO here for the future improvement.", "url": "https://github.com/apache/helix/pull/834#discussion_r392526766", "createdAt": "2020-03-13T23:27:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjk2Mw==", "bodyText": "Just call it statetype so it's more generic.", "url": "https://github.com/apache/helix/pull/834#discussion_r392526963", "createdAt": "2020-03-13T23:28:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 553}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzE3NQ==", "bodyText": "Do we have DEFAULT_PROPERTY but none DEFAULT_TYPE case? If not, shall we just ignore the state type if DEFAULT_PROPERTY is used?", "url": "https://github.com/apache/helix/pull/834#discussion_r392533175", "createdAt": "2020-03-14T00:02:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {\n+    if (propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 554}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzI3NA==", "bodyText": "DEFAULT_PROPERTY_TYPE and DEFAULT_STATE_TYPE are cleaner, IMHO.", "url": "https://github.com/apache/helix/pull/834#discussion_r392533274", "createdAt": "2020-03-14T00:03:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -83,17 +87,27 @@\n   private ExecutorService _reportExecutor;\n   private Future _reportingTask = null;\n \n+  protected static final  String DEFAULT_PROPERTY = \"HELIX_DEFAULT_PROPERTY\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNDQ3OQ==", "bodyText": "This formula is better to be done in a private method. Otherwise, if you want to replace  \"_\", it would be a headache.", "url": "https://github.com/apache/helix/pull/834#discussion_r392534479", "createdAt": "2020-03-14T00:10:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {\n+    if (propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      // Check whether there exist only one snapshot (_routingTableRefMap)\n+      if (_routingTableRefMap.keySet().size() == 1) {\n+        return _routingTableRefMap.keySet().iterator().next();\n+      } else {\n+        throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+      }\n+    }\n+\n+    if (!propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      if (propertyTypeName.equals(PropertyType.CUSTOMIZEDVIEW.name())) {\n+        throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+      }\n+    }\n+\n+    String key = propertyTypeName + \"_\" + customizedStateType;\n+    if (!_routingTableRefMap.containsKey(key)) {\n+      throw new HelixException(\n+          String.format(\"Currently there is no snapshot available for PropertyType %s and type %s\",\n+              propertyTypeName, customizedStateType));\n+    }\n+    return key;\n+\n   }\n \n   @Override\n   @PreFetch(enabled = false)\n   public void onExternalViewChange(List<ExternalView> externalViewList,\n       NotificationContext changeContext) {\n     HelixConstants.ChangeType changeType = changeContext.getChangeType();\n-    if (changeType != null && !changeType.getPropertyType().equals(_sourceDataType)) {\n+    if (changeType != null && !_sourceDataTypeMap.containsKey(changeType.getPropertyType())) {\n       logger.warn(\n-          \"onExternalViewChange called with mismatched change types. Source data type {}, changed data type: {}\",\n-          _sourceDataType, changeType);\n+          \"onExternalViewChange called with mismatched change types. Source data types does not contain changed data type: {}\",\n+          changeType);\n       return;\n     }\n     // Refresh with full list of external view.\n     if (externalViewList != null && externalViewList.size() > 0) {\n       // keep this here for back-compatibility, application can call onExternalViewChange directly\n       // with externalview list supplied.\n-      refresh(externalViewList, changeContext);\n+      String keyReference = PropertyType.EXTERNALVIEW.name() + \"_\" + DEFAULT_TYPE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 598}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNTI5Mw==", "bodyText": "Instead of having one this type of refresh method, we should split it into 2 refresh methods. One for externalview, another for customizeStatem. Maybe the 3rd one for current state.\nOtherwise, a typical problem is that as a reviewer, I don't know what is \"Collections.emptyList()\" for. As a user, I won't be able to know as well.\nMoreover, the behavior of passing both parameters is not clean.", "url": "https://github.com/apache/helix/pull/834#discussion_r392535293", "createdAt": "2020-03-14T00:16:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {\n+    if (propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      // Check whether there exist only one snapshot (_routingTableRefMap)\n+      if (_routingTableRefMap.keySet().size() == 1) {\n+        return _routingTableRefMap.keySet().iterator().next();\n+      } else {\n+        throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+      }\n+    }\n+\n+    if (!propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      if (propertyTypeName.equals(PropertyType.CUSTOMIZEDVIEW.name())) {\n+        throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+      }\n+    }\n+\n+    String key = propertyTypeName + \"_\" + customizedStateType;\n+    if (!_routingTableRefMap.containsKey(key)) {\n+      throw new HelixException(\n+          String.format(\"Currently there is no snapshot available for PropertyType %s and type %s\",\n+              propertyTypeName, customizedStateType));\n+    }\n+    return key;\n+\n   }\n \n   @Override\n   @PreFetch(enabled = false)\n   public void onExternalViewChange(List<ExternalView> externalViewList,\n       NotificationContext changeContext) {\n     HelixConstants.ChangeType changeType = changeContext.getChangeType();\n-    if (changeType != null && !changeType.getPropertyType().equals(_sourceDataType)) {\n+    if (changeType != null && !_sourceDataTypeMap.containsKey(changeType.getPropertyType())) {\n       logger.warn(\n-          \"onExternalViewChange called with mismatched change types. Source data type {}, changed data type: {}\",\n-          _sourceDataType, changeType);\n+          \"onExternalViewChange called with mismatched change types. Source data types does not contain changed data type: {}\",\n+          changeType);\n       return;\n     }\n     // Refresh with full list of external view.\n     if (externalViewList != null && externalViewList.size() > 0) {\n       // keep this here for back-compatibility, application can call onExternalViewChange directly\n       // with externalview list supplied.\n-      refresh(externalViewList, changeContext);\n+      String keyReference = PropertyType.EXTERNALVIEW.name() + \"_\" + DEFAULT_TYPE;\n+      refresh(externalViewList, Collections.emptyList(), changeContext, keyReference);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 599}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNTkzNg==", "bodyText": "Isn't is fixed for current state? Why need to pass it in?", "url": "https://github.com/apache/helix/pull/834#discussion_r392535936", "createdAt": "2020-03-14T00:20:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -529,68 +791,95 @@ private void updateCurrentStatesListeners(List<LiveInstance> liveInstances,\n \n   private void reset() {\n     logger.info(\"Resetting the routing table.\");\n-    RoutingTable newRoutingTable = new RoutingTable();\n-    _routingTableRef.set(newRoutingTable);\n+    for (String key: _routingTableRefMap.keySet()) {\n+      PropertyType propertyType = _routingTableRefMap.get(key).get().getPropertyType();\n+      if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+        String type = _routingTableRefMap.get(key).get().getCustomizedStateType();\n+        RoutingTable newRoutingTable = new CustomizedViewRoutingTable(propertyType, type);\n+        _routingTableRefMap.get(key).set(newRoutingTable);\n+      } else {\n+        RoutingTable newRoutingTable = new RoutingTable(propertyType);\n+        _routingTableRefMap.get(key).set(newRoutingTable);\n+      }\n+    }\n   }\n \n-  protected void refresh(List<ExternalView> externalViewList, NotificationContext changeContext) {\n+  protected void refresh(List<ExternalView> externalViewList,\n+      List<CustomizedView> customizedViewList, NotificationContext changeContext,\n+      String referenceKey) {\n     HelixDataAccessor accessor = changeContext.getManager().getHelixDataAccessor();\n     PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n \n     List<InstanceConfig> configList = accessor.getChildValues(keyBuilder.instanceConfigs());\n     List<LiveInstance> liveInstances = accessor.getChildValues(keyBuilder.liveInstances());\n-    refresh(externalViewList, configList, liveInstances);\n+    refresh(externalViewList, customizedViewList, configList, liveInstances, referenceKey);\n   }\n \n   protected void refresh(Collection<ExternalView> externalViews,\n-      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+      Collection<CustomizedView> customizedViews, Collection<InstanceConfig> instanceConfigs,\n+      Collection<LiveInstance> liveInstances, String referenceKey) {\n     long startTime = System.currentTimeMillis();\n-    RoutingTable newRoutingTable = new RoutingTable(externalViews, instanceConfigs, liveInstances);\n-    resetRoutingTableAndNotify(startTime, newRoutingTable);\n+    PropertyType propertyType = _routingTableRefMap.get(referenceKey).get().getPropertyType();\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      String customizedStateType = _routingTableRefMap.get(referenceKey).get().getCustomizedStateType();\n+      RoutingTable newRoutingTable = new CustomizedViewRoutingTable(customizedViews,\n+          instanceConfigs, liveInstances, propertyType, customizedStateType);\n+      resetRoutingTableAndNotify(startTime, newRoutingTable, referenceKey);\n+    } else {\n+      RoutingTable newRoutingTable = new RoutingTable(externalViews, instanceConfigs,\n+          liveInstances, propertyType);\n+      resetRoutingTableAndNotify(startTime, newRoutingTable, referenceKey);\n+    }\n   }\n \n   protected void refresh(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n-      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      String referenceKey) {\n     long startTime = System.currentTimeMillis();\n     RoutingTable newRoutingTable =\n         new RoutingTable(currentStateMap, instanceConfigs, liveInstances);\n-    resetRoutingTableAndNotify(startTime, newRoutingTable);\n+    resetRoutingTableAndNotify(startTime, newRoutingTable, referenceKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 715}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzM0OA==", "bodyText": "One question, if we have multiple state types for the customized state view, do we have multiple event count for this monitor? Wil that be bad?", "url": "https://github.com/apache/helix/pull/834#discussion_r392537348", "createdAt": "2020-03-14T00:31:02Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -700,12 +1003,13 @@ public void queueEvent(NotificationContext context, ClusterEventType eventType,\n       event.addAttribute(AttributeName.helixmanager.name(), context.getManager());\n       event.addAttribute(AttributeName.changeContext.name(), context);\n       queueEvent(event);\n-\n-      _monitor.increaseCallbackCounters(_eventQueue.size());\n+      for (PropertyType propertyType : _monitorMap.keySet()) {\n+        _monitorMap.get(propertyType).increaseCallbackCounters(_eventQueue.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 872}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzQzMw==", "bodyText": "StateType should be good enough.", "url": "https://github.com/apache/helix/pull/834#discussion_r392537433", "createdAt": "2020-03-14T00:31:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -33,9 +36,13 @@\n  */\n public class RoutingTableSnapshot {\n   private final RoutingTable _routingTable;\n+  private final PropertyType _propertyType;\n+  private final String _customizedStateType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzUyOQ==", "bodyText": "Since you already kept the routingTable, is it still necessary to keep them as private fields?", "url": "https://github.com/apache/helix/pull/834#discussion_r392537529", "createdAt": "2020-03-14T00:32:19Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -33,9 +36,13 @@\n  */\n public class RoutingTableSnapshot {\n   private final RoutingTable _routingTable;\n+  private final PropertyType _propertyType;\n+  private final String _customizedStateType;\n \n   public RoutingTableSnapshot(RoutingTable routingTable) {\n     _routingTable = routingTable;\n+    _propertyType = routingTable.getPropertyType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2Mzk1Mjgy", "url": "https://github.com/apache/helix/pull/834#pullrequestreview-376395282", "createdAt": "2020-03-17T20:50:42Z", "commit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMDo1MDo0MlrOF3thJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMDo0NTo0OVrOF3y1Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2MTc2Ng==", "bodyText": "Not a must fix, I just want to suggest you try lamda. It would be very convenient and simple here.", "url": "https://github.com/apache/helix/pull/834#discussion_r393961766", "createdAt": "2020-03-17T20:50:42Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -40,14 +47,31 @@\n class RoutingDataCache extends BasicClusterDataCache {\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n-  private final PropertyType _sourceDataType;\n+  private final Map<PropertyType, List<String>> _sourceDataTypeMap;\n+\n   private CurrentStateCache _currentStateCache;\n+  // TODO: CustomizedCache needs to be migrated to propertyCache. Once we migrate all cache to\n+  // propertyCache, this hardcoded list of fields won't be necessary.\n+  private Map<String, CustomizedViewCache> _customizedViewCaches;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {\n+    this (clusterName, ImmutableMap.of(sourceDataType, Collections.emptyList()));\n+  }\n+\n+  /**\n+   * Initialize empty RoutingDataCache with clusterName, _propertyTypes.\n+   * @param clusterName\n+   * @param sourceDataTypeMap\n+   */\n+  public RoutingDataCache(String clusterName, Map<PropertyType, List<String>> sourceDataTypeMap) {\n     super(clusterName);\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _currentStateCache = new CurrentStateCache(clusterName);\n+    _customizedViewCaches = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NDI2MA==", "bodyText": "I guess we want to start the updater after monitors ready.", "url": "https://github.com/apache/helix/pull/834#discussion_r393964260", "createdAt": "2020-03-17T20:54:29Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,74 +120,62 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5Mzk5NQ==", "bodyText": "This else is arbitrary. I know we have the validation to check. But it would be safer to check if the type is as expected again.", "url": "https://github.com/apache/helix/pull/834#discussion_r393993995", "createdAt": "2020-03-17T21:56:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,74 +120,62 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      if (_sourceDataTypeMap.get(propertyType).size() == 0) {\n+        String key = generateReferenceKey(propertyType.name(),  DEFAULT_STATE_TYPE);\n+        if (_routingTableRefMap.get(key) == null) {\n+          _routingTableRefMap.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5NjU2Nw==", "bodyText": "Let's move the table init even earlier than the updater start.\nIMO, it should be\n\ninit tables.\nstart monitoring\nstart updater.\nadd listeners", "url": "https://github.com/apache/helix/pull/834#discussion_r393996567", "createdAt": "2020-03-17T22:02:44Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,74 +120,62 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5NzU4Ng==", "bodyText": "nit, I personally don't think log then throw an exception is a good practice. If you agree, let's don't keep it in the new logic. But I don't have a strong preference here.", "url": "https://github.com/apache/helix/pull/834#discussion_r393997586", "createdAt": "2020-03-17T22:05:12Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -199,6 +201,98 @@ public void run() {\n     }\n   }\n \n+  /**\n+   * A method that adds the ChangeListeners to HelixManager\n+   */\n+  private void addListeners() {\n+    if (_helixManager != null) {\n+      for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+        switch (propertyType) {\n+        case EXTERNALVIEW:\n+          try {\n+            _helixManager.addExternalViewChangeListener(this);\n+          } catch (Exception e) {\n+            shutdown();\n+            logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n+            throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n+          }\n+          break;\n+        case CUSTOMIZEDVIEW:\n+          List<String> customizedStateTypes = _sourceDataTypeMap.get(propertyType);\n+          for (String customizedStateType : customizedStateTypes) {\n+            try {\n+              _helixManager.addCustomizedViewChangeListener(this, customizedStateType);\n+            } catch (Exception e) {\n+              shutdown();\n+              logger.error(\"Failed to attach CustomizedView Listener to HelixManager for type {}!\",\n+                  customizedStateType);\n+              throw new HelixException(String.format(\n+                  \"Failed to attach CustomizedView Listener to HelixManager for type %s!\",\n+                  customizedStateType), e);\n+            }\n+          }\n+          break;\n+        case TARGETEXTERNALVIEW:\n+          // Check whether target external has been enabled or not\n+          if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n+              _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(),\n+              0)) {\n+            shutdown();\n+            throw new HelixException(\"Target External View is not enabled!\");\n+          }\n+\n+          try {\n+            _helixManager.addTargetExternalViewChangeListener(this);\n+          } catch (Exception e) {\n+            shutdown();\n+            logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5OTM4MA==", "bodyText": "It seems all the usage of getRoutingTableKey is for getting the table ref. Why not change it to directly return the table that we find?", "url": "https://github.com/apache/helix/pull/834#discussion_r393999380", "createdAt": "2020-03-17T22:09:51Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -237,7 +337,48 @@ public void shutdown() {\n    * @return snapshot of current routing table.\n    */\n   public RoutingTableSnapshot getRoutingTableSnapshot() {\n-    return new RoutingTableSnapshot(_routingTableRef.get());\n+      String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+      return new RoutingTableSnapshot(_routingTableRefMap.get(key).get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTM5MA=="}, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMjIxOQ==", "bodyText": "Just to confirm that, are we going to remove it or not? This one is duplicate to getInstancesForResource.", "url": "https://github.com/apache/helix/pull/834#discussion_r394002219", "createdAt": "2020-03-17T22:17:02Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +525,37 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAzOA=="}, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMjM0OQ==", "bodyText": "Removed?", "url": "https://github.com/apache/helix/pull/834#discussion_r394002349", "createdAt": "2020-03-17T22:17:19Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -279,6 +409,16 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, partitionName, state);\n   }\n \n+  public List<InstanceConfig> getInstances(String resourceName, String partitionName, String state,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzgyMQ=="}, "originalCommit": {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjM1MQ==", "bodyText": "I'm still concerned about these get methods. I reviewed the design, it seems that we don't have a detailed list of what should be returned in the provider. So let's be strict on these public methods. My feeling is that we don't need all these additional methods. Since our application clients would use the snapshot object to get the info they need.\nOn the other hand, if the method is for testing only, try to keep them protected (and make the test case located in the same package path). Or we can leave only one method to get the detailed customized state map for testing.\nNote that once you add the public methods, we should not remove them later. Without solid business logic usage, I don't think we should add these additional methods.", "url": "https://github.com/apache/helix/pull/834#discussion_r394036351", "createdAt": "2020-03-17T23:55:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -280,17 +425,50 @@ public Object removeRoutingTableChangeListener(\n   }\n \n   /**\n-   * returns the instances for {resource,partition} pair that are in a specific\n-   * {state}\n+   * For specific routing table associated with {propertyType, stateType}\n+   * returns the instances for {resource group,partition} pair contains any of the given tags that\n+   * are in a specific {state}.\n+   * @param resourceName\n+   * @param partitionName\n+   * @param state\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public List<InstanceConfig> getInstances(String resourceName, String partitionName, String state,\n+      PropertyType propertyType, String stateType) {\n+    return getInstancesForResource(resourceName, partitionName, state, propertyType, stateType);\n+  }\n+\n+  /**\n+   * returns the instances for {resource,partition} pair that are in a specific {state}\n    * @param resourceName\n-   *          -\n    * @param partitionName\n    * @param state\n    * @return empty list if there is no instance in a given state\n    */\n   public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,\n       String state) {\n-    return _routingTableRef.get().getInstancesForResource(resourceName, partitionName, state);\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY_TYPE, DEFAULT_STATE_TYPE);\n+    return _routingTableRefMap.get(key).get().getInstancesForResource(resourceName, partitionName,\n+        state);\n+  }\n+\n+  /**\n+   * For specific routing table associated with {propertyType, stateType}\n+   * returns the instances for {resource,partition} pair that are in a specific {state}\n+   * @param resourceName\n+   * @param partitionName\n+   * @param state\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 463}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjc3Mw==", "bodyText": "Logic wise, the user should see the same resource list with any type of the state. So this method is not necessary.", "url": "https://github.com/apache/helix/pull/834#discussion_r394036773", "createdAt": "2020-03-17T23:56:58Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +658,131 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY_TYPE, DEFAULT_STATE_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * For specific RoutingTable associated with {propertyType, stateType}\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public Collection<String> getResources(PropertyType propertyType, String stateType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 690}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjkwNw==", "bodyText": "As mentioned earlier, let this method return the table itself.", "url": "https://github.com/apache/helix/pull/834#discussion_r394036907", "createdAt": "2020-03-17T23:57:26Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +658,131 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY_TYPE, DEFAULT_STATE_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * For specific RoutingTable associated with {propertyType, stateType}\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public Collection<String> getResources(PropertyType propertyType, String stateType) {\n+    String key = getRoutingTableKey(propertyType.name(), stateType);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * Provide the key associated with specific PropertyType and StateType for _routingTableRefMap lookup.\n+   * @param propertyTypeName\n+   * @param stateType\n+   * @return\n+   */\n+  private String getRoutingTableKey(String propertyTypeName, String stateType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 701}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MjgzMw==", "bodyText": "Safer to add the same source type check we did for the other listeners.", "url": "https://github.com/apache/helix/pull/834#discussion_r394042833", "createdAt": "2020-03-18T00:20:57Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -457,13 +819,23 @@ public void onLiveInstanceChange(List<LiveInstance> liveInstances,\n   @PreFetch(enabled = false)\n   public void onStateChange(String instanceName, List<CurrentState> statesInfo,\n       NotificationContext changeContext) {\n-    if (_sourceDataType.equals(PropertyType.CURRENTSTATES)) {\n+    if (_sourceDataTypeMap.containsKey(PropertyType.CURRENTSTATES)) {\n       _routerUpdater.queueEvent(changeContext, ClusterEventType.CurrentStateChange,\n           HelixConstants.ChangeType.CURRENT_STATE);\n     } else {\n       logger.warn(\n           \"RoutingTableProvider does not use CurrentStates as source, ignore CurrentState changes!\");\n     }\n+    _routerUpdater.queueEvent(changeContext, ClusterEventType.CurrentStateChange,\n+        HelixConstants.ChangeType.CURRENT_STATE);\n+  }\n+\n+  @Override\n+  @PreFetch(enabled = false)\n+  public void onCustomizedViewChange(List<CustomizedView> customizedViewList,\n+      NotificationContext changeContext) {\n+    _routerUpdater.queueEvent(changeContext, ClusterEventType.CustomizedViewChange,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 811}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MzU2Nw==", "bodyText": "Thanks for adding this todo.\nBut for the logic, it is too verbose. Why not just get the _routingTableRefMap.values().interator().next()?", "url": "https://github.com/apache/helix/pull/834#discussion_r394043567", "createdAt": "2020-03-18T00:23:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +658,131 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 641}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0NDg0Ng==", "bodyText": "nit, move this outside the condition block for reducing verbose code.", "url": "https://github.com/apache/helix/pull/834#discussion_r394044846", "createdAt": "2020-03-18T00:28:58Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -529,68 +901,88 @@ private void updateCurrentStatesListeners(List<LiveInstance> liveInstances,\n \n   private void reset() {\n     logger.info(\"Resetting the routing table.\");\n-    RoutingTable newRoutingTable = new RoutingTable();\n-    _routingTableRef.set(newRoutingTable);\n+    for (String key: _routingTableRefMap.keySet()) {\n+      PropertyType propertyType = _routingTableRefMap.get(key).get().getPropertyType();\n+      if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+        String stateType = _routingTableRefMap.get(key).get().getStateType();\n+        RoutingTable newRoutingTable = new CustomizedViewRoutingTable(propertyType, stateType);\n+        _routingTableRefMap.get(key).set(newRoutingTable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 827}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODY3Ng==", "bodyText": "TODO is fine, but we need 2 items.\n\nSplit the monitor into 2. One is general router callback tracking. The other one is for each type of tracking. Then we have the right numbers.\nWe may need to add more complexity to the customized view monitor for each state type.", "url": "https://github.com/apache/helix/pull/834#discussion_r394048676", "createdAt": "2020-03-18T00:45:13Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -700,12 +1003,13 @@ public void queueEvent(NotificationContext context, ClusterEventType eventType,\n       event.addAttribute(AttributeName.helixmanager.name(), context.getManager());\n       event.addAttribute(AttributeName.changeContext.name(), context);\n       queueEvent(event);\n-\n-      _monitor.increaseCallbackCounters(_eventQueue.size());\n+      for (PropertyType propertyType : _monitorMap.keySet()) {\n+        _monitorMap.get(propertyType).increaseCallbackCounters(_eventQueue.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzM0OA=="}, "originalCommit": {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32"}, "originalPosition": 872}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODg0Nw==", "bodyText": "getStateType() ?", "url": "https://github.com/apache/helix/pull/834#discussion_r394048847", "createdAt": "2020-03-18T00:45:49Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -145,4 +152,34 @@ public RoutingTableSnapshot(RoutingTable routingTable) {\n   public Collection<ExternalView> getExternalViews() {\n     return _routingTable.getExternalViews();\n   }\n+\n+  /**\n+   * Returns a Collection of latest snapshot of CustomizedView. Note that if the RoutingTable is\n+   * instantiated using CurrentStates, this Collection will be empty.\n+   * @return\n+   */\n+  public Collection<CustomizedView> getCustomizeViews() {\n+    if (_propertyType.equals(PropertyType.CUSTOMIZEDVIEW)){\n+    CustomizedViewRoutingTable customizedViewRoutingTable =\n+        (CustomizedViewRoutingTable) _routingTable;\n+    return customizedViewRoutingTable.geCustomizedViews();\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  /**\n+   * Returns the PropertyType associated with this RoutingTableSnapshot\n+   * @return\n+   */\n+  public PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Return the Type associated with thi RoutingTableSnapshot (mainly used for CustomizedView)\n+   * @return\n+   */\n+  public String getCustomizedStateType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDc5NTM1", "url": "https://github.com/apache/helix/pull/834#pullrequestreview-377079535", "createdAt": "2020-03-18T17:22:04Z", "commit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoyMjowNFrOF4PUrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzo1NDo1M1rOF4Ql4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNTYzMQ==", "bodyText": "Can we use customizeView for consistency.", "url": "https://github.com/apache/helix/pull/834#discussion_r394515631", "createdAt": "2020-03-18T17:22:04Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  /*\n+   * The customizedStateType field is the type the controller is aggregating.\n+   * For example if RoutingTableProvider initialized using the code below:\n+   * Map<PropertyType, List<String>> sourceDataTypes = new HashMap<>();\n+   * sourceDataTypes.put(PropertyType.CUSTOMIZEDVIEW, Arrays.asList(\"typeA\", \"typeB\"));\n+   * RoutingTableProvider routingTableProvider =\n+   * new RoutingTableProvider(_spectator, sourceDataTypes);\n+   *\n+   * Each one of the TypeA and TypeB is a customizedStateType.\n+   */\n+  private final String _customizedStateType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String customizedStateType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      PropertyType propertytype, String customizedStateType) {\n+    this(customizedViews, Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertytype, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      PropertyType propertytype, String customizedStateType) {\n+    super(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.CUSTOMIZEDVIEW);\n+    _customizedStateType = customizedStateType;\n+    _customizedViews = new HashSet<>(customizedViews);\n+    refresh(_customizedViews);\n+  }\n+\n+  private void refresh(Collection<CustomizedView> customizedViewList) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    if (customizedViewList != null && !customizedViewList.isEmpty()) {\n+      for (InstanceConfig config : _instanceConfigs) {\n+        instanceConfigMap.put(config.getId(), config);\n+      }\n+      for (CustomizedView customView : customizedViewList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNjYxMQ==", "bodyText": "You may want to reformat the code, including comments.", "url": "https://github.com/apache/helix/pull/834#discussion_r394516611", "createdAt": "2020-03-18T17:23:32Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  /*\n+   * The customizedStateType field is the type the controller is aggregating.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzNTc2Nw==", "bodyText": "typo here.", "url": "https://github.com/apache/helix/pull/834#discussion_r394535767", "createdAt": "2020-03-18T17:53:44Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -145,4 +152,34 @@ public RoutingTableSnapshot(RoutingTable routingTable) {\n   public Collection<ExternalView> getExternalViews() {\n     return _routingTable.getExternalViews();\n   }\n+\n+  /**\n+   * Returns a Collection of latest snapshot of CustomizedView. Note that if the RoutingTable is\n+   * instantiated using CurrentStates, this Collection will be empty.\n+   * @return\n+   */\n+  public Collection<CustomizedView> getCustomizeViews() {\n+    if (_propertyType.equals(PropertyType.CUSTOMIZEDVIEW)){\n+    CustomizedViewRoutingTable customizedViewRoutingTable =\n+        (CustomizedViewRoutingTable) _routingTable;\n+    return customizedViewRoutingTable.geCustomizedViews();\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  /**\n+   * Returns the PropertyType associated with this RoutingTableSnapshot\n+   * @return\n+   */\n+  public PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Return the Type associated with thi RoutingTableSnapshot (mainly used for CustomizedView)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzNjQxNw==", "bodyText": "getCustomizedStateType would be clearer. As this is a snapshot class for different kinds of views.", "url": "https://github.com/apache/helix/pull/834#discussion_r394536417", "createdAt": "2020-03-18T17:54:53Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -145,4 +152,34 @@ public RoutingTableSnapshot(RoutingTable routingTable) {\n   public Collection<ExternalView> getExternalViews() {\n     return _routingTable.getExternalViews();\n   }\n+\n+  /**\n+   * Returns a Collection of latest snapshot of CustomizedView. Note that if the RoutingTable is\n+   * instantiated using CurrentStates, this Collection will be empty.\n+   * @return\n+   */\n+  public Collection<CustomizedView> getCustomizeViews() {\n+    if (_propertyType.equals(PropertyType.CUSTOMIZEDVIEW)){\n+    CustomizedViewRoutingTable customizedViewRoutingTable =\n+        (CustomizedViewRoutingTable) _routingTable;\n+    return customizedViewRoutingTable.geCustomizedViews();\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  /**\n+   * Returns the PropertyType associated with this RoutingTableSnapshot\n+   * @return\n+   */\n+  public PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Return the Type associated with thi RoutingTableSnapshot (mainly used for CustomizedView)\n+   * @return\n+   */\n+  public String getCustomizedStateType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODg0Nw=="}, "originalCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a13cf1b763280433ec0e951a7bf3027d74437e32", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/a13cf1b763280433ec0e951a7bf3027d74437e32", "committedDate": "2020-03-19T22:55:35Z", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a64c703e2f698fce475190112ee2e57ccad8db2", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/4a64c703e2f698fce475190112ee2e57ccad8db2", "committedDate": "2020-03-19T22:55:35Z", "message": "Address the comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "committedDate": "2020-03-17T00:58:32Z", "message": "Address the comments"}, "afterCommit": {"oid": "4ab199c964177e7b65d3e8a1ad032b997f6e2d0b", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/4ab199c964177e7b65d3e8a1ad032b997f6e2d0b", "committedDate": "2020-03-19T22:55:35Z", "message": "Address new comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "committedDate": "2020-03-20T00:29:55Z", "message": "Address new comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ab199c964177e7b65d3e8a1ad032b997f6e2d0b", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/4ab199c964177e7b65d3e8a1ad032b997f6e2d0b", "committedDate": "2020-03-19T22:55:35Z", "message": "Address new comments"}, "afterCommit": {"oid": "789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "author": {"user": {"login": "alirezazamani", "name": "Ali Reza Zamani Zadeh Najari"}}, "url": "https://github.com/apache/helix/commit/789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "committedDate": "2020-03-20T00:29:55Z", "message": "Address new comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4992, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}