{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2OTMxNzQz", "number": 1514, "title": "Add default message handling retry count for state transition messages.", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\nResolves #1513\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\n\nThe retry count will be counted when message handler creation fails or state transition times out.\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n\nThe cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\nThe retry count is not strictly followed in some conditions.\nThe to-be-retried message is not automatically read when there are no other new message changes. In this PR we change this behavior and ensure the retry will be done even no other message created.\n\nFinally, improve the tests to cover the new changes.\nTests\n\n The following tests are written for this issue:\n\nTestStateTransitionAppFailureHandling\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n\n[ERROR] Failures:\n[ERROR]   TestTaskRebalancerFailover.test \u00bb ThreadTimeout Method org.testng.internal.Tes...\n[INFO]\n[ERROR] Tests run: 1247, Failures: 1, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 01:36 h\n[INFO] Finished at: 2020-11-06T00:46:51-08:00\n[INFO] ------------------------------------------------------------------------\nRerun the test and it will pass. But it is not stable due to issue #1512\nDocumentation (Optional)\n\nIn case of new functionality, my PR adds documentation in the following wiki page:\n\n(Link the GitHub wiki you added)\nCommits\n\nMy commits all reference appropriate Apache Helix GitHub issues in their subject lines. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\nMy diff has been formatted using helix-style.xml\n(helix-style-intellij.xml if IntelliJ IDE is used)", "createdAt": "2020-11-06T19:17:28Z", "url": "https://github.com/apache/helix/pull/1514", "merged": true, "mergeCommit": {"oid": "f38915cc11b18934ecad1450a75b6d890b351448"}, "closed": true, "closedAt": "2020-11-12T01:21:38Z", "author": {"login": "jiajunwang"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdaAfcugBqjM5NjkzNjIzMTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdboEP5AFqTUyODY2NTU2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bdb4d65b9fbf1cc9dd1685dfeaa5386688b5f3e1", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/bdb4d65b9fbf1cc9dd1685dfeaa5386688b5f3e1", "committedDate": "2020-11-06T07:06:37Z", "message": "Add default message handling retry count for state transition messages.\n\nThe retry count will be counted when message handler creation fails or state transition times out.\n\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n1. The cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\n2. The retry count is not strictly followed in some conditions.\n3. The to-be-retried message won't be automatically read when there is no other new message changes.\n\nFinally, improve the tests to cover the new changes."}, "afterCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/92b72efdc20b83f6393d26f16cc6b86533ae404f", "committedDate": "2020-11-07T00:33:17Z", "message": "Add default message handling retry count for state transition messages.\n\nThe retry count will be counted when message handler creation fails or state transition times out.\n\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n1. The cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\n2. The retry count is not strictly followed in some conditions.\n3. The to-be-retried message won't be automatically read when there is no other new message changes.\n\nFinally, improve the tests to cover the new changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDg1OTQ1", "url": "https://github.com/apache/helix/pull/1514#pullrequestreview-527485945", "createdAt": "2020-11-10T18:26:17Z", "commit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODoyNjoxN1rOHwpt2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODozMjoxNFrOHwp7Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3NzE3Nw==", "bodyText": "This function will trigger another event and retry the message, right? Why in the PR it said the message will not be automatically retried?", "url": "https://github.com/apache/helix/pull/1514#discussion_r520777177", "createdAt": "2020-11-10T18:26:17Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -1288,6 +1308,19 @@ private void removeMessageFromZK(HelixDataAccessor accessor, Message message,\n     }\n   }\n \n+  private void sendNopMessage(HelixDataAccessor accessor, String instanceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3NzM0Ng==", "bodyText": "Can we have a more detailed error message here?", "url": "https://github.com/apache/helix/pull/1514#discussion_r520777346", "createdAt": "2020-11-10T18:26:32Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -1288,6 +1308,19 @@ private void removeMessageFromZK(HelixDataAccessor accessor, Message message,\n     }\n   }\n \n+  private void sendNopMessage(HelixDataAccessor accessor, String instanceName) {\n+    try {\n+      Message nopMsg = new Message(MessageType.NO_OP, UUID.randomUUID().toString());\n+      nopMsg.setSrcName(instanceName);\n+      nopMsg.setTgtName(instanceName);\n+      accessor\n+          .setProperty(accessor.keyBuilder().message(nopMsg.getTgtName(), nopMsg.getId()), nopMsg);\n+      LOG.info(\"Send NO_OP message to \" + nopMsg.getTgtName() + \", msgId: \" + nopMsg.getId());\n+    } catch (Exception e) {\n+      LOG.error(e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3OTIwNw==", "bodyText": "The naming here makes me a bit confusing. This message is updated as NEW because it is cannot be processed right? Maybe call it MessageUpdatedAsNew or something.", "url": "https://github.com/apache/helix/pull/1514#discussion_r520779207", "createdAt": "2020-11-10T18:29:49Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -521,29 +523,51 @@ public void finishTask(MessageTask task) {\n     }\n   }\n \n-  private void updateMessageState(List<Message> readMsgs, HelixDataAccessor accessor,\n+  private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    Builder keyBuilder = accessor.keyBuilder();\n-    List<String> readMsgPaths = new ArrayList<>();\n-    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-    for (Message msg : readMsgs) {\n-      readMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-      _knownMessageIds.add(msg.getId());\n-      /**\n-       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-       * If there is no message at this path, meaning the message is removed so we do not write the message\n-       */\n-      updaters.add(currentData -> {\n-        if (currentData == null) {\n-          LOG.warn(\n-              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-              msg.getId(), msg.getTgtName(), instanceName);\n-          return null;\n-        }\n-        return msg.getRecord();\n-      });\n+    if (!msgsToBeUpdated.isEmpty()) {\n+      Builder keyBuilder = accessor.keyBuilder();\n+      List<String> updateMsgPaths = new ArrayList<>();\n+      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+      for (Message msg : msgsToBeUpdated) {\n+        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+        /**\n+         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+         * If there is no message at this path, meaning the message is removed so we do not write the message\n+         */\n+        updaters.add(currentData -> {\n+          if (currentData == null) {\n+            LOG.warn(\n+                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+                msg.getId(), msg.getTgtName(), instanceName);\n+            return null;\n+          }\n+          return msg.getRecord();\n+        });\n+      }\n+      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    }\n+\n+    // Note that only cache the known message Ids after the update to ZK is successfully done.\n+    // This is to avoid inconsistent cache.\n+\n+    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n+    boolean isNewMessageUpdated = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc3OTQzMQ==", "bodyText": "same here: what does \"new and updated\" mean?", "url": "https://github.com/apache/helix/pull/1514#discussion_r520779431", "createdAt": "2020-11-10T18:30:10Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -521,29 +523,51 @@ public void finishTask(MessageTask task) {\n     }\n   }\n \n-  private void updateMessageState(List<Message> readMsgs, HelixDataAccessor accessor,\n+  private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    Builder keyBuilder = accessor.keyBuilder();\n-    List<String> readMsgPaths = new ArrayList<>();\n-    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-    for (Message msg : readMsgs) {\n-      readMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-      _knownMessageIds.add(msg.getId());\n-      /**\n-       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-       * If there is no message at this path, meaning the message is removed so we do not write the message\n-       */\n-      updaters.add(currentData -> {\n-        if (currentData == null) {\n-          LOG.warn(\n-              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-              msg.getId(), msg.getTgtName(), instanceName);\n-          return null;\n-        }\n-        return msg.getRecord();\n-      });\n+    if (!msgsToBeUpdated.isEmpty()) {\n+      Builder keyBuilder = accessor.keyBuilder();\n+      List<String> updateMsgPaths = new ArrayList<>();\n+      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+      for (Message msg : msgsToBeUpdated) {\n+        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+        /**\n+         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+         * If there is no message at this path, meaning the message is removed so we do not write the message\n+         */\n+        updaters.add(currentData -> {\n+          if (currentData == null) {\n+            LOG.warn(\n+                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+                msg.getId(), msg.getTgtName(), instanceName);\n+            return null;\n+          }\n+          return msg.getRecord();\n+        });\n+      }\n+      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    }\n+\n+    // Note that only cache the known message Ids after the update to ZK is successfully done.\n+    // This is to avoid inconsistent cache.\n+\n+    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n+    boolean isNewMessageUpdated = false;\n+    for (Message msg : msgsToBeUpdated) {\n+      if (msg.getMsgState().equals(MessageState.NEW)) {\n+        isNewMessageUpdated = true;\n+        // If a message is still \"NEW\", it is not a known message. The message may not be able to\n+        // processed now in an expected way.\n+      } else {\n+        // else, cache the known messages.\n+        _knownMessageIds.add(msg.getId());\n+      }\n+    }\n+    if (isNewMessageUpdated) {\n+      // Sending a NO-OP message to trigger another message callback to re-process the New and\n+      // updated messsages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MDU1MQ==", "bodyText": "\"negative\" doesn't match if condition.", "url": "https://github.com/apache/helix/pull/1514#discussion_r520780551", "createdAt": "2020-11-10T18:32:14Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -821,32 +843,29 @@ public void onMessage(String instanceName, List<Message> messages,\n         LOG.error(\n             \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n             message.getMsgId(), remainingRetryCount);\n-        // Set the message retry count to avoid infinite retrying.\n+        // Reduce the message retry count to avoid infinite retrying.\n         message.setRetryCount(remainingRetryCount - 1);\n         message.setExecuteSessionId(sessionId);\n-        // continue processing in the next section where handler object is double-checked.\n-      }\n-\n-      if (msgHandler == null) {\n         // Note that we are re-using the retry count of Message that was original designed to control\n         // timeout retries. So it is not checked before the first try in order to ensure consistent\n         // behavior. It is possible that we introduce a new behavior for this method. But it requires\n         // us to split the configuration item so as to avoid confusion.\n-        if (message.getRetryCount() < 0) {\n+        if (message.getRetryCount() <= 0) {\n           // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n-          String errorMsg = String\n-              .format(\"No available message Handler found!\"\n-                      + \" Stop processing message %s since it has a negative remaining retry count %d!\",\n-                  message.getMsgId(), message.getRetryCount());\n+          String errorMsg = String.format(\"No available message Handler found!\"\n+                  + \" Stop processing message %s since it has negative remaining retry count %d!\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NTI2NTI4", "url": "https://github.com/apache/helix/pull/1514#pullrequestreview-527526528", "createdAt": "2020-11-10T19:12:28Z", "commit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxMjoyOFrOHwryNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxNjo1MlrOHwr8Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTA2Mg==", "bodyText": "Is this the same thing as the message attribute of retrying? Otherwise, we need an accurate name since it is the retry for state model creation.", "url": "https://github.com/apache/helix/pull/1514#discussion_r520811062", "createdAt": "2020-11-10T19:12:28Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "diffHunk": "@@ -70,6 +70,8 @@\n       .getSystemPropertyAsLong(SystemPropertyKeys.CONTROLLER_MESSAGE_PURGE_DELAY, 60 * 1000);\n   private final static String PENDING_MESSAGE = \"pending message\";\n   private final static String STALE_MESSAGE = \"stale message\";\n+  // TODO: Make the message retry count configurable through the Cluster Config or IdealStates.\n+  public final static int DEFAULT_STATE_TRANSITION_MESSAGE_RETRY_COUNT = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMzYzMA==", "bodyText": "Why we dont move this check in the previous block? Since it already does the looping of the msgsToBeUpdated.", "url": "https://github.com/apache/helix/pull/1514#discussion_r520813630", "createdAt": "2020-11-10T19:16:52Z", "author": {"login": "junkaixue"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -521,29 +523,51 @@ public void finishTask(MessageTask task) {\n     }\n   }\n \n-  private void updateMessageState(List<Message> readMsgs, HelixDataAccessor accessor,\n+  private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    Builder keyBuilder = accessor.keyBuilder();\n-    List<String> readMsgPaths = new ArrayList<>();\n-    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-    for (Message msg : readMsgs) {\n-      readMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-      _knownMessageIds.add(msg.getId());\n-      /**\n-       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-       * If there is no message at this path, meaning the message is removed so we do not write the message\n-       */\n-      updaters.add(currentData -> {\n-        if (currentData == null) {\n-          LOG.warn(\n-              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-              msg.getId(), msg.getTgtName(), instanceName);\n-          return null;\n-        }\n-        return msg.getRecord();\n-      });\n+    if (!msgsToBeUpdated.isEmpty()) {\n+      Builder keyBuilder = accessor.keyBuilder();\n+      List<String> updateMsgPaths = new ArrayList<>();\n+      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+      for (Message msg : msgsToBeUpdated) {\n+        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+        /**\n+         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+         * If there is no message at this path, meaning the message is removed so we do not write the message\n+         */\n+        updaters.add(currentData -> {\n+          if (currentData == null) {\n+            LOG.warn(\n+                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+                msg.getId(), msg.getTgtName(), instanceName);\n+            return null;\n+          }\n+          return msg.getRecord();\n+        });\n+      }\n+      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    }\n+\n+    // Note that only cache the known message Ids after the update to ZK is successfully done.\n+    // This is to avoid inconsistent cache.\n+\n+    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n+    boolean isNewMessageUpdated = false;\n+    for (Message msg : msgsToBeUpdated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDk1OTk3", "url": "https://github.com/apache/helix/pull/1514#pullrequestreview-527495997", "createdAt": "2020-11-10T18:37:29Z", "commit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODozNzoyOVrOHwqGlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0MDo1NlrOHwsyvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MzUxMA==", "bodyText": "We decided to get rid of sleep, right?", "url": "https://github.com/apache/helix/pull/1514#discussion_r520783510", "createdAt": "2020-11-10T18:37:29Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java", "diffHunk": "@@ -563,23 +564,42 @@ public void testCreateHandlerException() throws InterruptedException {\n     HelixManager manager = new MockClusterManager();\n     HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n     PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n-\n-    TestMessageHandlerFactory factory = new TestMessageHandlerFactory();\n-    for (String type : factory.getMessageTypes()) {\n-      executor.registerMessageHandlerFactory(type, factory);\n-    }\n-\n     NotificationContext changeContext = new NotificationContext(manager);\n+    TestMessageHandlerFactory factory = new TestMessageHandlerFactory();\n \n+    // Sending message without registering the factory.\n+    // The message won't be processed since creating handler returns null.\n     int nMsgs1 = 5;\n+    List<Message> msgList = new ArrayList<>();\n     for (int i = 0; i < nMsgs1; i++) {\n       Message msg = new Message(factory.getMessageTypes().get(0), UUID.randomUUID().toString());\n       msg.setTgtSessionId(manager.getSessionId());\n       msg.setTgtName(\"Localhost_1123\");\n       msg.setSrcName(\"127.101.1.23_2234\");\n       msg.setCorrelationId(UUID.randomUUID().toString());\n       dataAccessor.setProperty(keyBuilder.message(manager.getInstanceName(), msg.getMsgId()), msg);\n+      msgList.add(msg);\n+    }\n+\n+    changeContext.setChangeType(HelixConstants.ChangeType.MESSAGE);\n+    executor.onMessage(manager.getInstanceName(), Collections.emptyList(), changeContext);\n+\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyNzU4MQ==", "bodyText": "You mean retried and succeeded finally, right?", "url": "https://github.com/apache/helix/pull/1514#discussion_r520827581", "createdAt": "2020-11-10T19:40:56Z", "author": {"login": "zhangmeng916"}, "path": "helix-core/src/test/java/org/apache/helix/integration/paticipant/TestStateTransitionAppFailureHandling.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.apache.helix.integration.paticipant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixDefinedState;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.controller.stages.MessageGenerationPhase;\n+import org.apache.helix.integration.common.ZkStandAloneCMTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.mock.participant.MockMSStateModel;\n+import org.apache.helix.mock.participant.MockTransition;\n+import org.apache.helix.model.CurrentState;\n+import org.apache.helix.model.Message;\n+import org.apache.helix.participant.statemachine.StateModelFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestStateTransitionAppFailureHandling extends ZkStandAloneCMTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestStateTransitionAppFailureHandling.class);\n+  private final static int REPLICAS = 3;\n+\n+  @Override\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    // Clean up the resource that is created in the super cluster beforeClass method.\n+    _gSetupTool.dropResourceFromCluster(CLUSTER_NAME, TEST_DB);\n+    _clusterVerifier.verifyByPolling();\n+  }\n+\n+  public static class RetryStateModelFactory extends StateModelFactory<MockMSStateModel> {\n+    int _retryCountUntilSucceed;\n+\n+    public RetryStateModelFactory(int retryCountUntilSucceed) {\n+      _retryCountUntilSucceed = retryCountUntilSucceed;\n+    }\n+\n+    public int getRemainingRetryCountUntilSucceed() {\n+      return _retryCountUntilSucceed;\n+    }\n+\n+    @Override\n+    public MockMSStateModel createNewStateModel(String resource, String stateUnitKey) {\n+      if (_retryCountUntilSucceed > 0) {\n+        _retryCountUntilSucceed--;\n+        throw new HelixException(\"You Shall Not PASS!!!\");\n+      } else {\n+        return new MockMSStateModel(new MockTransition());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSTHandlerInitFailureRetry() throws Exception {\n+    int retryCountUntilSucceed =\n+        Integer.MAX_VALUE; // ensure the retry count is large so the message retry will fail.\n+    Map<String, RetryStateModelFactory> retryFactoryMap = resetParticipants(retryCountUntilSucceed);\n+\n+    _gSetupTool.addResourceToCluster(CLUSTER_NAME, TEST_DB, _PARTITIONS, STATE_MODEL);\n+    _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, TEST_DB, REPLICAS);\n+\n+    HelixDataAccessor accessor = _controller.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    // Verify and wait until all messages have been retried and failed.\n+    Map<String, List<Message>> partitionMessageMap = new HashMap<>();\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      int totalMessageCount = 0;\n+      for (int i = 0; i < NODE_NR; i++) {\n+        String instanceName = _participants[i].getInstanceName();\n+        List<Message> messageList = accessor.getProperty(\n+            accessor.getChildNames(keyBuilder.messages(instanceName)).stream()\n+                .map(childName -> keyBuilder.message(instanceName, childName))\n+                .collect(Collectors.toList()), true);\n+        for (Message message : messageList) {\n+          if (message.getMsgState() != Message.MessageState.UNPROCESSABLE) {\n+            return false;\n+          }\n+        }\n+        partitionMessageMap.put(instanceName, messageList);\n+        totalMessageCount += messageList.size();\n+      }\n+      return totalMessageCount == _PARTITIONS * REPLICAS;\n+    }, TestHelper.WAIT_DURATION));\n+\n+    // Verify that the correct numbers of retry has been done on each node.\n+    for (String instanceName : partitionMessageMap.keySet()) {\n+      List<Message> instanceMessages = partitionMessageMap.get(instanceName);\n+      for (Message message : instanceMessages) {\n+        Assert.assertTrue(message.getRetryCount() <= 0);\n+        Assert.assertEquals(message.getMsgState(), Message.MessageState.UNPROCESSABLE);\n+      }\n+      // Check if the factory has tried enough times before fail the message.\n+      Assert.assertEquals(retryCountUntilSucceed - retryFactoryMap.get(instanceName)\n+          .getRemainingRetryCountUntilSucceed(), instanceMessages.size()\n+          * MessageGenerationPhase.DEFAULT_STATE_TRANSITION_MESSAGE_RETRY_COUNT);\n+    }\n+\n+    // Verify that the partition is not initialized.\n+    for (int i = 0; i < NODE_NR; i++) {\n+      String instanceName = _participants[i].getInstanceName();\n+      String sessionId = _participants[i].getSessionId();\n+      List<CurrentState> currentStates = accessor.getProperty(\n+          accessor.getChildNames(keyBuilder.currentStates(instanceName, sessionId)).stream()\n+              .map(childName -> keyBuilder.currentState(instanceName, sessionId, childName))\n+              .collect(Collectors.toList()), true);\n+      for (CurrentState currentState : currentStates) {\n+        Assert.assertTrue(currentState.getPartitionStateMap().isEmpty());\n+      }\n+    }\n+\n+    _gSetupTool.dropResourceFromCluster(CLUSTER_NAME, TEST_DB);\n+  }\n+\n+  @Test(dependsOnMethods = \"testSTHandlerInitFailureRetry\")\n+  public void testSTHandlerInitFailureRetrySucceed() {\n+    // Make the mock StateModelFactory return handler before last retry. So it will successfully\n+    // finish handler initialization.\n+    int retryCountUntilSucceed =\n+        MessageGenerationPhase.DEFAULT_STATE_TRANSITION_MESSAGE_RETRY_COUNT - 1;\n+    Map<String, RetryStateModelFactory> retryFactoryMap = resetParticipants(retryCountUntilSucceed);\n+\n+    _gSetupTool.addResourceToCluster(CLUSTER_NAME, TEST_DB, _PARTITIONS, STATE_MODEL);\n+    _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, TEST_DB, REPLICAS);\n+\n+    HelixDataAccessor accessor = _controller.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    // Verify and wait until all messages have been retried and failed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e21f924502dd7976dcb1b9ee412c895e2367e1f1", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/e21f924502dd7976dcb1b9ee412c895e2367e1f1", "committedDate": "2020-11-10T20:47:17Z", "message": "Add default message handling retry count for state transition messages.\n\nThe retry count will be counted when message handler creation fails or state transition times out.\n\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n1. The cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\n2. The retry count is not strictly followed in some conditions.\n3. The to-be-retried message won't be automatically read when there is no other new message changes.\n\nFinally, improve the tests to cover the new changes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92b72efdc20b83f6393d26f16cc6b86533ae404f", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/92b72efdc20b83f6393d26f16cc6b86533ae404f", "committedDate": "2020-11-07T00:33:17Z", "message": "Add default message handling retry count for state transition messages.\n\nThe retry count will be counted when message handler creation fails or state transition times out.\n\nIn addition, this PR also improves several ambiguous behaviors that may block a normal retry.\n1. The cache of known messages list in HelixTaskExecutor may not be updated correctly if a message is going to be retried.\n2. The retry count is not strictly followed in some conditions.\n3. The to-be-retried message won't be automatically read when there is no other new message changes.\n\nFinally, improve the tests to cover the new changes."}, "afterCommit": {"oid": "00971c049c0540a0a32e7f27fe553ac578d24ec7", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/00971c049c0540a0a32e7f27fe553ac578d24ec7", "committedDate": "2020-11-10T20:51:57Z", "message": "Address comment."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00971c049c0540a0a32e7f27fe553ac578d24ec7", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/00971c049c0540a0a32e7f27fe553ac578d24ec7", "committedDate": "2020-11-10T20:51:57Z", "message": "Address comment."}, "afterCommit": {"oid": "58a04489fcb2dcbf07495708924669a02c2a0c6f", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/58a04489fcb2dcbf07495708924669a02c2a0c6f", "committedDate": "2020-11-10T20:55:34Z", "message": "Address comment."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58a04489fcb2dcbf07495708924669a02c2a0c6f", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/58a04489fcb2dcbf07495708924669a02c2a0c6f", "committedDate": "2020-11-10T20:55:34Z", "message": "Address comment."}, "afterCommit": {"oid": "be3f7fab44a209ada7fc21f5de00d0286ef43b0d", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/be3f7fab44a209ada7fc21f5de00d0286ef43b0d", "committedDate": "2020-11-10T21:09:47Z", "message": "Address comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35aec6dc57057a2aec3d35d2138208235a96289f", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/35aec6dc57057a2aec3d35d2138208235a96289f", "committedDate": "2020-11-10T21:14:27Z", "message": "Address comment."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be3f7fab44a209ada7fc21f5de00d0286ef43b0d", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/be3f7fab44a209ada7fc21f5de00d0286ef43b0d", "committedDate": "2020-11-10T21:09:47Z", "message": "Address comment."}, "afterCommit": {"oid": "35aec6dc57057a2aec3d35d2138208235a96289f", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/35aec6dc57057a2aec3d35d2138208235a96289f", "committedDate": "2020-11-10T21:14:27Z", "message": "Address comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aca1653a8639de281a590cd5b62365307ea6a2a6", "author": {"user": {"login": "jiajunwang", "name": "Jiajun Wang"}}, "url": "https://github.com/apache/helix/commit/aca1653a8639de281a590cd5b62365307ea6a2a6", "committedDate": "2020-11-10T23:22:06Z", "message": "Avoid modifying the message update logic."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Njg1ODE5", "url": "https://github.com/apache/helix/pull/1514#pullrequestreview-527685819", "createdAt": "2020-11-10T23:19:17Z", "commit": {"oid": "35aec6dc57057a2aec3d35d2138208235a96289f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoxOToxN1rOHwzasw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzoxOToxN1rOHwzasw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjExNQ==", "bodyText": "On my second thought, I think this is dangerous since changed the behavior unnecessarily. Let me just log in this case instead of modifying the original logic.", "url": "https://github.com/apache/helix/pull/1514#discussion_r520936115", "createdAt": "2020-11-10T23:19:17Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -525,47 +525,51 @@ public void finishTask(MessageTask task) {\n \n   private void updateMessageState(Collection<Message> msgsToBeUpdated, HelixDataAccessor accessor,\n       String instanceName) {\n-    if (!msgsToBeUpdated.isEmpty()) {\n-      Builder keyBuilder = accessor.keyBuilder();\n-      List<String> updateMsgPaths = new ArrayList<>();\n-      List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n-      for (Message msg : msgsToBeUpdated) {\n-        updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n-        /**\n-         * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n-         * If there is no message at this path, meaning the message is removed so we do not write the message\n-         */\n-        updaters.add(currentData -> {\n-          if (currentData == null) {\n-            LOG.warn(\n-                \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n-                msg.getId(), msg.getTgtName(), instanceName);\n-            return null;\n-          }\n-          return msg.getRecord();\n-        });\n-      }\n-      accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n+    if (msgsToBeUpdated.isEmpty()) {\n+      return;\n+    }\n+\n+    Builder keyBuilder = accessor.keyBuilder();\n+    List<Message> updateMsgs = new ArrayList<>();\n+    List<String> updateMsgPaths = new ArrayList<>();\n+    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n+    for (Message msg : msgsToBeUpdated) {\n+      updateMsgs.add(msg);\n+      updateMsgPaths.add(msg.getKey(keyBuilder, instanceName).getPath());\n+      /**\n+       * We use the updater to avoid race condition between writing message to zk as READ state and removing message after ST is done\n+       * If there is no message at this path, meaning the message is removed so we do not write the message\n+       */\n+      updaters.add(currentData -> {\n+        if (currentData == null) {\n+          LOG.warn(\n+              \"Message {} targets at {} has already been removed before it is set as READ on instance {}\",\n+              msg.getId(), msg.getTgtName(), instanceName);\n+          return null;\n+        }\n+        return msg.getRecord();\n+      });\n     }\n+    boolean[] updateResults =\n+        accessor.updateChildren(updateMsgPaths, updaters, AccessOption.PERSISTENT);\n \n+    boolean isMessageUpdatedAsNew = false;\n     // Note that only cache the known message Ids after the update to ZK is successfully done.\n     // This is to avoid inconsistent cache.\n-\n-    // if a message in \"NEW\" state is updated, then we might need to process it soon.\n-    boolean isNewMessageUpdated = false;\n-    for (Message msg : msgsToBeUpdated) {\n+    for (int i = 0; i < updateMsgs.size(); i++) {\n+      Message msg = updateMsgs.get(i);\n       if (msg.getMsgState().equals(MessageState.NEW)) {\n-        isNewMessageUpdated = true;\n-        // If a message is still \"NEW\", it is not a known message. The message may not be able to\n-        // processed now in an expected way.\n-      } else {\n-        // else, cache the known messages.\n+        // If a message is updated as NEW state, then we might need to process it again soon.\n+        isMessageUpdatedAsNew = true;\n+        // And it shall not be treated as a known messages.\n+      } else if (updateResults[i]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35aec6dc57057a2aec3d35d2138208235a96289f"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NjY1NTY2", "url": "https://github.com/apache/helix/pull/1514#pullrequestreview-528665566", "createdAt": "2020-11-12T01:14:02Z", "commit": {"oid": "aca1653a8639de281a590cd5b62365307ea6a2a6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4105, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}