{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3Mzg5ODcz", "number": 888, "title": "Modify data providers and add customized view aggregation stage", "bodyText": "Issues\n\n My PR addresses the following Helix issues and references them in the PR description:\n\n(#850 )\nDescription\n\n Here are some details about my PR, including screenshots of any UI changes:\nTo support customized view aggregation, we need to change the current data providers to add the refresh for customized state and customized view. We also need to have two extra stages that perform computation from customized state to customized view.\n\nTests\n\n The following is the result of the \"mvn test\" command on the appropriate module:\n[INFO] Tests run: 909, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3,438.097 s - in TestSuite\n[INFO]\n[INFO] Results:\n[INFO]\n[INFO] Tests run: 909, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n\nCommits\n\n My commits all reference appropriate Apache Helix GitHub issues in their subject lines, and I have squashed multiple commits if they address the same issue. In addition, my commits follow the guidelines from \"How to write a good git commit message\":\n\nSubject is separated from body by a blank line\nSubject is limited to 50 characters (not including Jira issue reference)\nSubject does not end with a period\nSubject uses the imperative mood (\"add\", not \"adding\")\nBody wraps at 72 characters\nBody explains \"what\" and \"why\", not \"how\"\n\n\n\nCode Quality\n\n My diff has been formatted using helix-style.xml", "createdAt": "2020-03-12T17:58:49Z", "url": "https://github.com/apache/helix/pull/888", "merged": true, "mergeCommit": {"oid": "966a4b8838d33ce340d4713bc83ee49d88604f12"}, "closed": true, "closedAt": "2020-03-18T06:08:20Z", "author": {"login": "zhangmeng916"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcM_hh8gH2gAyMzg3Mzg5ODczOjZiYWQwYWExOGZhMTBmOWQ5Y2Y2NTYwOGYzNTcxZWM4ZWJkODc0NDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOs79OAFqTM3NjUwNjI0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6bad0aa18fa10f9d9cf65608f3571ec8ebd87446", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/6bad0aa18fa10f9d9cf65608f3571ec8ebd87446", "committedDate": "2020-03-12T17:53:49Z", "message": "modify providers and add customized view aggregation stage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/ee66bf8f53084ac086d9b0282d239b813c6afc75", "committedDate": "2020-03-12T18:11:38Z", "message": "add one more stage"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjgyOTUz", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-374682953", "createdAt": "2020-03-14T00:54:23Z", "commit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwMDo1NDoyM1rOF2Wzdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwMTo1ODozNVrOF2XJ4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTA0Ng==", "bodyText": "Instead of calling the raw method, do we have a method in customizedStateConfig to get the types?", "url": "https://github.com/apache/helix/pull/888#discussion_r392541046", "createdAt": "2020-03-14T00:54:23Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -286,6 +292,27 @@ private void refreshResourceConfig(final HelixDataAccessor accessor,\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor,\n+      Set<HelixConstants.ChangeType> refreshedType) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {\n+        _aggregationEnabledTypes = new HashSet<>(customizedStateConfig.getRecord().getListFields()\n+            .get(CustomizedStateConfig.CustomizedStateProperty.AGGREGATION_ENABLED_TYPES.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTMzNQ==", "bodyText": "getEnabledCustomizedStateTypes()?", "url": "https://github.com/apache/helix/pull/888#discussion_r392541335", "createdAt": "2020-03-14T00:56:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -374,6 +405,14 @@ public void setClusterConfig(ClusterConfig clusterConfig) {\n     _clusterConfig = clusterConfig;\n   }\n \n+  public Set<String> getCustomizedStateConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTQzNQ==", "bodyText": "Same, the name should reflect what we set. Moreover, do we need this set to be public?", "url": "https://github.com/apache/helix/pull/888#discussion_r392541435", "createdAt": "2020-03-14T00:57:20Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -374,6 +405,14 @@ public void setClusterConfig(ClusterConfig clusterConfig) {\n     _clusterConfig = clusterConfig;\n   }\n \n+  public Set<String> getCustomizedStateConfig() {\n+    return _aggregationEnabledTypes;\n+  }\n+\n+  public void setCustomizedStateConfig(Set<String> aggregationEnabledTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjMyMw==", "bodyText": "The map is initialized as en empty map. Do we need to check for NPE here?", "url": "https://github.com/apache/helix/pull/888#discussion_r392542323", "createdAt": "2020-03-14T01:05:40Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +161,23 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> stateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType: stateTypes) {\n+        _customizedViewCacheMap.get(stateType).refresh(accessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjUxNg==", "bodyText": "Haven't we refreshed this in the BaseControllerDataProvider, can we just use that result here?", "url": "https://github.com/apache/helix/pull/888#discussion_r392542516", "createdAt": "2020-03-14T01:07:08Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.controller.dataproviders.BaseControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedStateComputationStage extends AbstractBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateComputationStage.class);\n+\n+  @Override\n+  public void process(ClusterEvent event) throws Exception {\n+    HelixManager helixManager = event.getAttribute(AttributeName.helixmanager.name());\n+    Set<String> aggregationEnabledTypes = new HashSet<>();\n+    if (helixManager.getHelixDataAccessor().getProperty(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NDE1Nw==", "bodyText": "If you passed \"this\", I guess you don't need to pass \"_aggregationEnabledTypes\" in addition. You can always call BaseControllerDataProvider.getCustomizedStateConfig() in the CustomizedStateCache. And that method is safer and cleaner.", "url": "https://github.com/apache/helix/pull/888#discussion_r392544157", "createdAt": "2020-03-14T01:24:56Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -217,6 +222,7 @@ public String getObjName(StateModelDefinition obj) {\n       }\n     }, false);\n     _currentStateCache = new CurrentStateCache(this);\n+    _customizedStateCache = new CustomizedStateCache(this, _aggregationEnabledTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjA5Mg==", "bodyText": "I think if we add it here, it will be done by the Task pipeline as well. Is it necessary?", "url": "https://github.com/apache/helix/pull/888#discussion_r392546092", "createdAt": "2020-03-14T01:49:14Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -96,13 +99,15 @@\n \n   // Special caches\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedStateCache _customizedStateCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjQ4NQ==", "bodyText": "This logic confused me. Are we setting curCustomizedViews or customizedViewCache? Or both?\nCould you please split these 2 parts?", "url": "https://github.com/apache/helix/pull/888#discussion_r392546485", "createdAt": "2020-03-14T01:54:12Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjU1OA==", "bodyText": "I think this has been done in the external view stage. There is no need to do it twice.", "url": "https://github.com/apache/helix/pull/888#discussion_r392546558", "createdAt": "2020-03-14T01:55:20Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+          // Keep MBeans for existing resources and unregister MBeans for dropped resources\n+          if (clusterStatusMonitor != null) {\n+            clusterStatusMonitor.retainResourceMonitor(monitoringResources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA==", "bodyText": "Shall we just pass the in-memory content to the cache instead of requiring it to read from ZK again?", "url": "https://github.com/apache/helix/pull/888#discussion_r392546784", "createdAt": "2020-03-14T01:58:35Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+          // Keep MBeans for existing resources and unregister MBeans for dropped resources\n+          if (clusterStatusMonitor != null) {\n+            clusterStatusMonitor.retainResourceMonitor(monitoringResources);\n+          }\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "committedDate": "2020-03-14T06:17:54Z", "message": "fix some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0ODQyNjcz", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-374842673", "createdAt": "2020-03-15T22:56:52Z", "commit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMjo1Njo1MlrOF2h3Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMzo1OTo0N1rOF2iSBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMjI0Ng==", "bodyText": "This will increase the read throughput and pipeline latency, which is one of the major concerns. Before we have a real use case, I prefer to keep it in the resource data provider only.", "url": "https://github.com/apache/helix/pull/888#discussion_r392722246", "createdAt": "2020-03-15T22:56:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -96,13 +99,15 @@\n \n   // Special caches\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedStateCache _customizedStateCache;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjA5Mg=="}, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMzQ0MQ==", "bodyText": "If it is null, shall we change clean the _aggregationEnabledTypes?", "url": "https://github.com/apache/helix/pull/888#discussion_r392723441", "createdAt": "2020-03-15T23:08:53Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -286,6 +292,27 @@ private void refreshResourceConfig(final HelixDataAccessor accessor,\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor,\n+      Set<HelixConstants.ChangeType> refreshedType) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMzc1OA==", "bodyText": "My major concern is that it relies on the reference of the input set (aggregationEnabledTypes) to accept any types update. Ideally, it should be read explicitly in the CustomizedStateCache logic. So it exactly knows that this set might have been changed. For now, every read of this set in the CustomizedStateCache can return different content. This may introduce bugs.", "url": "https://github.com/apache/helix/pull/888#discussion_r392723758", "createdAt": "2020-03-15T23:12:55Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -217,6 +222,7 @@ public String getObjName(StateModelDefinition obj) {\n       }\n     }, false);\n     _currentStateCache = new CurrentStateCache(this);\n+    _customizedStateCache = new CustomizedStateCache(this, _aggregationEnabledTypes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NDE1Nw=="}, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMzk3Nw==", "bodyText": "Can we leverage the removeCustomizedViewTypes() that already defined?", "url": "https://github.com/apache/helix/pull/888#discussion_r392723977", "createdAt": "2020-03-15T23:15:32Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +161,30 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> stateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType : stateTypes) {\n+        if (!_customizedViewCacheMap.containsKey(stateType)) {\n+          CustomizedViewCache newCustomizedViewCache =\n+              new CustomizedViewCache(getClusterName(), stateType);\n+          newCustomizedViewCache.refresh(accessor);\n+          _customizedViewCacheMap.put(stateType, newCustomizedViewCache);\n+        } else {\n+          _customizedViewCacheMap.get(stateType).refresh(accessor);\n+        }\n+      }\n+      for (String stateType : _customizedViewCacheMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDExNw==", "bodyText": "nit, the var names here are confusing.\nstateTypes -> currentStateTypes\nthe stateType here -> cachedStateType\nWill that be cleaner?", "url": "https://github.com/apache/helix/pull/888#discussion_r392724117", "createdAt": "2020-03-15T23:16:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +161,30 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> stateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType : stateTypes) {\n+        if (!_customizedViewCacheMap.containsKey(stateType)) {\n+          CustomizedViewCache newCustomizedViewCache =\n+              new CustomizedViewCache(getClusterName(), stateType);\n+          newCustomizedViewCache.refresh(accessor);\n+          _customizedViewCacheMap.put(stateType, newCustomizedViewCache);\n+        } else {\n+          _customizedViewCacheMap.get(stateType).refresh(accessor);\n+        }\n+      }\n+      for (String stateType : _customizedViewCacheMap.keySet()) {\n+        if (!stateTypes.contains(stateType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDMzNQ==", "bodyText": "How about just pass the instanceName?", "url": "https://github.com/apache/helix/pull/888#discussion_r392724335", "createdAt": "2020-03-15T23:19:17Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.controller.dataproviders.BaseControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedStateComputationStage extends AbstractBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateComputationStage.class);\n+\n+  @Override\n+  public void process(ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    BaseControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+    final Map<String, Resource> resourceMap = event.getAttribute(AttributeName.RESOURCES.name());\n+    Set<String> aggregationEnabledTypes = cache.getAggregationEnabledCustomizedStateTypes();\n+\n+    if (cache == null || resourceMap == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires DataCache|RESOURCE\");\n+    }\n+\n+    Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n+    final CustomizedStateOutput customizedStateOutput = new CustomizedStateOutput();\n+\n+    for (LiveInstance instance : liveInstances.values()) {\n+      String instanceName = instance.getInstanceName();\n+      // update customized states.\n+      for (String customizedStateType : aggregationEnabledTypes) {\n+        Map<String, CustomizedState> customizedStateMap =\n+            cache.getCustomizedState(instanceName, customizedStateType);\n+        updateCustomizedStates(instance, customizedStateType, customizedStateMap,\n+            customizedStateOutput, resourceMap);\n+      }\n+    }\n+    event.addAttribute(AttributeName.CUSTOMIZED_STATE.name(), customizedStateOutput);\n+  }\n+\n+  // update customized state in CustomizedStateOutput\n+  private void updateCustomizedStates(LiveInstance instance, String customizedStateType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDc5Mw==", "bodyText": "As you mentioned it is now for test only, I would prefer protected.", "url": "https://github.com/apache/helix/pull/888#discussion_r392724793", "createdAt": "2020-03-15T23:24:27Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -374,6 +405,14 @@ public void setClusterConfig(ClusterConfig clusterConfig) {\n     _clusterConfig = clusterConfig;\n   }\n \n+  public Set<String> getAggregationEnabledCustomizedStateTypes() {\n+    return _aggregationEnabledTypes;\n+  }\n+\n+  public void SetAggregationEnabledCustomizedStateTypes(Set<String> aggregationEnabledTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDk4Nw==", "bodyText": "Question, I assume the reason that we refresh it in this stage is to read the most recent status. If this is the case, can we bypass the refresh that is done in the cache refresh? It seems to me that one of them is not necessary.", "url": "https://github.com/apache/helix/pull/888#discussion_r392724987", "createdAt": "2020-03-15T23:26:19Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    cache.refreshCustomizedViewMap(dataAccessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODAwMA==", "bodyText": "Maybe you can enrich the comment here.\nIf customizedViewCache != null, you have curCustomizedViews assigned. Otherwise, you have an empty curCustomizedViews. And a customizedViewCache will be initialized then assign to the local var \"customizedViewCache\".\nThe thing confused me the most is what's the difference between curCustomizedViews and customizedViewCache? For the following code, they could be completely different things. To be honest, I can still not following.\nI was expecting either one of the following cases:\ncurCustomizedViews = (customizedViewCache != null)? customizedViewCache.getCustomizedViewMap() : new HashMap<>();\nOr,\nCustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\nif (customizedViewCache != null) {\ncustomizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n}\ncurCustomizedViews = customizedViewCache.getCustomizedViewMap();\nBut never the mix.", "url": "https://github.com/apache/helix/pull/888#discussion_r392728000", "createdAt": "2020-03-15T23:49:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjQ4NQ=="}, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODI5Ng==", "bodyText": "Worth it. Because if you have 1K resources, you might refresh 1K times, right?", "url": "https://github.com/apache/helix/pull/888#discussion_r392728296", "createdAt": "2020-03-15T23:52:41Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+          // Keep MBeans for existing resources and unregister MBeans for dropped resources\n+          if (clusterStatusMonitor != null) {\n+            clusterStatusMonitor.retainResourceMonitor(monitoringResources);\n+          }\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODQyNw==", "bodyText": "But, actually, I have another question even before that. Why do you need to refresh this cache? It is not used in the following logic. And as for the next pipeline, it will refresh the cache from ZK anyway.\nFinally, in your previous logic, CustomizedViewCache could be a newly created instance (created by \"new CustomizedViewCache(event.getClusterName(), stateType);\" And you are not put it back to the Resource Cache), right? So refresh it does not help anyone in my understanding. Please correct me if I missed anything.", "url": "https://github.com/apache/helix/pull/888#discussion_r392728427", "createdAt": "2020-03-15T23:53:59Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+          // Keep MBeans for existing resources and unregister MBeans for dropped resources\n+          if (clusterStatusMonitor != null) {\n+            clusterStatusMonitor.retainResourceMonitor(monitoringResources);\n+          }\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}, "originalCommit": {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODc2NQ==", "bodyText": "Same here, if we don't remove it, will the next pipeline refresh the cache and delete it anyway?", "url": "https://github.com/apache/helix/pull/888#discussion_r392728765", "createdAt": "2020-03-15T23:56:50Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);\n+          }\n+\n+          List<String> customizedViewsToRemove = new ArrayList<>();\n+\n+          // remove stale customized views\n+          for (String resourceName : curCustomizedViews.keySet()) {\n+            if (!resourceMap.keySet().contains(resourceName)) {\n+              LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for resource: \" + resourceName);\n+              dataAccessor.removeProperty(keyBuilder.customizedView(stateType, resourceName));\n+              customizedViewsToRemove.add(resourceName);\n+            }\n+          }\n+          customizedViewCache.removeCustomizedView(customizedViewsToRemove);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyOTA5NA==", "bodyText": "Shall we call it updatedCustomizedViews to be clearer?", "url": "https://github.com/apache/helix/pull/888#discussion_r392729094", "createdAt": "2020-03-15T23:59:47Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);\n+          }\n+\n+          List<String> customizedViewsToRemove = new ArrayList<>();\n+\n+          // remove stale customized views\n+          for (String resourceName : curCustomizedViews.keySet()) {\n+            if (!resourceMap.keySet().contains(resourceName)) {\n+              LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for resource: \" + resourceName);\n+              dataAccessor.removeProperty(keyBuilder.customizedView(stateType, resourceName));\n+              customizedViewsToRemove.add(resourceName);\n+            }\n+          }\n+          customizedViewCache.removeCustomizedView(customizedViewsToRemove);\n+        } catch (HelixException ex) {\n+          LogUtil.logError(LOG, _eventId,\n+              \"Failed to calculate customized view for resource \" + resource.getResourceName(), ex);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void computeCustomizedStateView(final Resource resource, final String stateType,\n+      CustomizedStateOutput customizedStateOutput,\n+      final Map<String, CustomizedView> curCustomizedViews,\n+      List<CustomizedView> newCustomizedViews) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "766c1d7df4f5f5478055dd9079395f52c71fa54f", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/766c1d7df4f5f5478055dd9079395f52c71fa54f", "committedDate": "2020-03-16T05:46:55Z", "message": "move to resource provider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/3d97f24bbeedc8369fdc1710c60426e3bde2b115", "committedDate": "2020-03-16T07:05:20Z", "message": "change one test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MjYxNTI2", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-376261526", "createdAt": "2020-03-17T17:39:30Z", "commit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNzozOTozMFrOF3nD-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODoyNzowMVrOF3o1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NTk5NA==", "bodyText": "nit, not necessary", "url": "https://github.com/apache/helix/pull/888#discussion_r393855994", "createdAt": "2020-03-17T17:39:30Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -286,6 +286,7 @@ private void refreshResourceConfig(final HelixDataAccessor accessor,\n     }\n   }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NzcyNw==", "bodyText": "nit, since the customizedStateConfig is created in the current method scope, I think directly assign the type set to _aggregationEnabledTypes is fine. A copy constructor is not necessary.\nBut no strong preference here.", "url": "https://github.com/apache/helix/pull/888#discussion_r393857727", "createdAt": "2020-03-17T17:42:17Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -139,6 +155,27 @@ protected void dumpDebugInfo() {\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {\n+        _aggregationEnabledTypes =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzUwNA==", "bodyText": "nit, this else is not necessary.", "url": "https://github.com/apache/helix/pull/888#discussion_r393863504", "createdAt": "2020-03-17T17:51:34Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +193,47 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> newStateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType : newStateTypes) {\n+        if (!_customizedViewCacheMap.containsKey(stateType)) {\n+          CustomizedViewCache newCustomizedViewCache =\n+              new CustomizedViewCache(getClusterName(), stateType);\n+          newCustomizedViewCache.refresh(accessor);\n+          _customizedViewCacheMap.put(stateType, newCustomizedViewCache);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NDk0Mw==", "bodyText": "private?", "url": "https://github.com/apache/helix/pull/888#discussion_r393864943", "createdAt": "2020-03-17T17:53:52Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -193,6 +279,17 @@ public void removeExternalViews(List<String> resourceNames) {\n     }\n   }\n \n+  /**\n+   * Remove dead customized views for certain state types from map\n+   * @param stateTypeNames\n+   */\n+\n+  public void removeCustomizedViewTypes(List<String> stateTypeNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NTQxMg==", "bodyText": "Should this be RESOURCES_TO_REBALANCE like the CustomizedViewAggregationStage does?", "url": "https://github.com/apache/helix/pull/888#discussion_r393865412", "createdAt": "2020-03-17T17:54:38Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedStateComputationStage extends AbstractBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateComputationStage.class);\n+\n+  @Override\n+  public void process(ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+    final Map<String, Resource> resourceMap = event.getAttribute(AttributeName.RESOURCES.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4NDk3Nw==", "bodyText": "Maybe we shall consider moving these 3 calculations to the update stages in the async thread. But let's leave it here for now. We will revisit anyway.", "url": "https://github.com/apache/helix/pull/888#discussion_r393884977", "createdAt": "2020-03-17T18:27:01Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -123,8 +136,11 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     }\n \n     // Refresh resource controller specific property caches\n+    refreshCustomizedStateConfig(accessor);\n+    _customizedStateCache.refresh(accessor, _liveInstanceCache.getPropertyMap());\n     refreshExternalViews(accessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cced13eb96bbe0b7b052b33ab1f6866594143d3", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/9cced13eb96bbe0b7b052b33ab1f6866594143d3", "committedDate": "2020-03-17T21:17:40Z", "message": "minor fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c866f259af102bb5aa475ef0a21920a59227c81b", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/c866f259af102bb5aa475ef0a21920a59227c81b", "committedDate": "2020-03-17T22:28:28Z", "message": "add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/3cc5d99007c2e9b0b30af64cb059c54fd849cb7b", "committedDate": "2020-03-17T22:30:25Z", "message": "change resource map"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDgzOTY1", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-376483965", "createdAt": "2020-03-18T00:03:31Z", "commit": {"oid": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMDowMzozMVrOF3yMoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMDoxNjoxNVrOF3yY0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzODQzMg==", "bodyText": "nit, safer to add a protected readonly method for getting the list instead of returning the list. Otherwise, the children may modify this list.", "url": "https://github.com/apache/helix/pull/888#discussion_r394038432", "createdAt": "2020-03-18T00:03:31Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -89,7 +89,7 @@\n   // Property caches\n   private final PropertyCache<ResourceConfig> _resourceConfigCache;\n   private final PropertyCache<InstanceConfig> _instanceConfigCache;\n-  private final PropertyCache<LiveInstance> _liveInstanceCache;\n+  protected final PropertyCache<LiveInstance> _liveInstanceCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MTU1Mg==", "bodyText": "Can we explicitly call this outside the refreshCustomizedStateConfig and just before _customizedStateCache.refresh()? Since _customizedStateCache.setAggregationEnabledTypes and refresh must be ordered, putting them together is easier for us to understand and maintain.", "url": "https://github.com/apache/helix/pull/888#discussion_r394041552", "createdAt": "2020-03-18T00:16:15Z", "author": {"login": "jiajunwang"}, "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -139,6 +155,28 @@ protected void dumpDebugInfo() {\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {\n+        _aggregationEnabledTypes =\n+            new HashSet<>(customizedStateConfig.getAggregationEnabledTypes());\n+      } else {\n+        _aggregationEnabledTypes.clear();\n+      }\n+      _customizedStateCache.setAggregationEnabledTypes(_aggregationEnabledTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7add5ce7f747c42220226a372c8f94073640e989", "author": {"user": {"login": "zhangmeng916", "name": "Meng Zhang"}}, "url": "https://github.com/apache/helix/commit/7add5ce7f747c42220226a372c8f94073640e989", "committedDate": "2020-03-18T00:35:13Z", "message": "minor fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDkzOTY2", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-376493966", "createdAt": "2020-03-18T00:37:41Z", "commit": {"oid": "7add5ce7f747c42220226a372c8f94073640e989"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDk1MzE2", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-376495316", "createdAt": "2020-03-18T00:42:44Z", "commit": {"oid": "7add5ce7f747c42220226a372c8f94073640e989"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMDo0Mjo0NFrOF3yySA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMDo0Mjo0NFrOF3yySA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODA3Mg==", "bodyText": "More accurate to convert the 2 lists to sets for assertion? If the ordering is different, this assert would fail.", "url": "https://github.com/apache/helix/pull/888#discussion_r394048072", "createdAt": "2020-03-18T00:42:44Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.Pipeline;\n+import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewStage extends ZkUnitTestBase {\n+  private final String RESOURCE_NAME = \"testResourceName\";\n+  private final String PARTITION_NAME = \"testResourceName_0\";\n+  private final String CUSTOMIZED_STATE_NAME = \"customizedState1\";\n+  private final String INSTANCE_NAME = \"localhost_1\";\n+\n+  @Test\n+  public void testCachedCustomizedViews() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STARTED\");\n+    accessor\n+        .setProperty(keyBuilder.customizedState(INSTANCE_NAME, \"customizedState1\", RESOURCE_NAME),\n+            customizedState);\n+\n+    CustomizedViewAggregationStage customizedViewComputeStage =\n+        new CustomizedViewAggregationStage();\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, customizedViewComputeStage);\n+    Assert.assertEquals(cache.getCustomizedViewCacheMap().values(),\n+        accessor.getChildValues(accessor.keyBuilder().customizedViews()));\n+\n+    // Assure there is no customized view got updated when running the stage again\n+    List<CustomizedView> oldCustomizedViews =\n+        accessor.getChildValues(accessor.keyBuilder().customizedViews());\n+    runStage(event, customizedViewComputeStage);\n+    List<CustomizedView> newCustomizedViews =\n+        accessor.getChildValues(accessor.keyBuilder().customizedViews());\n+    Assert.assertEquals(oldCustomizedViews, newCustomizedViews);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7add5ce7f747c42220226a372c8f94073640e989"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTA2MjQx", "url": "https://github.com/apache/helix/pull/888#pullrequestreview-376506241", "createdAt": "2020-03-18T01:22:20Z", "commit": {"oid": "7add5ce7f747c42220226a372c8f94073640e989"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMToyMjoyMFrOF3zWhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMToyMjoyMFrOF3zWhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NzM0OQ==", "bodyText": "And also here. Collection vs List. Would be better to make them 2 sets.", "url": "https://github.com/apache/helix/pull/888#discussion_r394057349", "createdAt": "2020-03-18T01:22:20Z", "author": {"login": "huizhilu"}, "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.Pipeline;\n+import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewStage extends ZkUnitTestBase {\n+  private final String RESOURCE_NAME = \"testResourceName\";\n+  private final String PARTITION_NAME = \"testResourceName_0\";\n+  private final String CUSTOMIZED_STATE_NAME = \"customizedState1\";\n+  private final String INSTANCE_NAME = \"localhost_1\";\n+\n+  @Test\n+  public void testCachedCustomizedViews() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STARTED\");\n+    accessor\n+        .setProperty(keyBuilder.customizedState(INSTANCE_NAME, \"customizedState1\", RESOURCE_NAME),\n+            customizedState);\n+\n+    CustomizedViewAggregationStage customizedViewComputeStage =\n+        new CustomizedViewAggregationStage();\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, customizedViewComputeStage);\n+    Assert.assertEquals(cache.getCustomizedViewCacheMap().values(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7add5ce7f747c42220226a372c8f94073640e989"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4694, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}