{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDYyMDM1", "number": 3484, "title": "HHH-14124 Entity graph (fetch graph) is incorrectly applied to query results beyond the first one", "bodyText": "https://hibernate.atlassian.net/browse/HHH-14124\nEssentially, the current implementation of sub-graph handling relies on side-effects in the session: when it loads an entity with an entity graph, it will replace the entity graph in the session with the subgraph, and hope that the next loaded entity needs this subgraph.\nThis will sort of work, though it's probably riddled with bugs (what if there are multiple subgraphs? what if entities are not processed in the expected order?). These bugs are not what HHH-14124 is about, however, so I won't try to address them.\nThe real problem that caused HHH-14124 is that this implementation of sub-graph handling doesn't take care of restoring the \"root\" entity graph after we're done processing one row in the result set. It may leave an incorrect graph, or even set the graph to null. As a result, in many cases only the very first entity in the result set will be loaded correctly. The next ones won't have the correct entity graph in the session, and thus won't be loaded correctly.\nThis PR tries to solve the problem with a workaround: by storing the entities to load in a structure that lets us know when we're moving from one row to the next, we're able to \"restore\" the original entity graph before we load the entities of each row. That way, the bugs of the sub-graph handling implementation won't affect the next row, and simple graphs without a sub-graph will work correctly (like they used to). Sub-graphs will still be buggy, but that's been the case for a long time, and as I wrote above, solving this is not the goal of this PR.\nYou'll notice there are two commits.\nThe first one uses a naive approach of storing the entities to load in a List<List<Object>>, each sub-list containing all the objects to load for a given row. That's a very straightforward approach, but it requires to allocate one list per result row, which I think is something we want to avoid. Thus I added a second commit which stores entities to load in a List<Object>, but inserts a null element to signal that the next elements were extracted from a different row.\nEither solution is fine to me, but I think the second one, while quite ugly, is less likely to lead to performance regressions (since it'll allocate memory very similarly to the current code). It might be a good-enough compromise until we rewrite it all in Hibernate ORM 6.0?", "createdAt": "2020-07-29T14:04:01Z", "url": "https://github.com/hibernate/hibernate-orm/pull/3484", "merged": true, "mergeCommit": {"oid": "9323d426f15279645dd37876810236ffd70fbce0"}, "closed": true, "closedAt": "2020-07-30T12:34:42Z", "author": {"login": "yrodiere"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5pTV6AH2gAyNDU4NDYyMDM1OjE4Nzk3MTFmNzU1OTJlZjE2ZWIyMThmNzFkMjBhODNkM2Q0NDJlMGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5wS-WAFqTQ1NzgyODYwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1879711f75592ef16eb218f71d20a83d3d442e0a", "author": {"user": {"login": "yrodiere", "name": "Yoann Rodi\u00e8re"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/1879711f75592ef16eb218f71d20a83d3d442e0a", "committedDate": "2020-07-29T11:27:00Z", "message": "HHH-14124 Work around side-effects of TwoPhaseLoad.initializeEntity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f82826b81d1a9a0cf2aeaaa8a1642108625abb7d", "author": {"user": {"login": "yrodiere", "name": "Yoann Rodi\u00e8re"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/f82826b81d1a9a0cf2aeaaa8a1642108625abb7d", "committedDate": "2020-07-29T11:27:01Z", "message": "HHH-14124 Avoid too many list allocations when hydrating query results\n\nI suspect the original goal of having a single list of hydrated objects\nfor all rows was to avoid instantiating one list per row, but we did\njust that in the fix in the last commit.\n\nThis introduces a hack to signal that we're starting to process a new\nrow while still keeping a flat, single-list structure: we inserting\nnull elements in the list of hydrated objects.\n\nThis is admittedly very ugly, but it's the only solution I can come up\nwith if we want to keep the number of memory allocations similar to what\nwe used to have. And hopefully this code will disappear in ORM 6.0."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5656622ed54fdd707ae3fec1e78b47af128fb363", "author": {"user": {"login": "yrodiere", "name": "Yoann Rodi\u00e8re"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/5656622ed54fdd707ae3fec1e78b47af128fb363", "committedDate": "2020-07-29T12:31:18Z", "message": "HHH-14124 Test that the FETCH entitygraph semantic overrides EAGER associations to LAZY"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea5825bc943796305f873548b0c92b81046a4b50", "author": {"user": {"login": "yrodiere", "name": "Yoann Rodi\u00e8re"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/ea5825bc943796305f873548b0c92b81046a4b50", "committedDate": "2020-07-29T12:31:28Z", "message": "HHH-14124 Test that the FETCH entitygraph semantic overrides EAGER associations to LAZY for all results"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NTk2MTg1", "url": "https://github.com/hibernate/hibernate-orm/pull/3484#pullrequestreview-457596185", "createdAt": "2020-07-29T14:45:25Z", "commit": {"oid": "ea5825bc943796305f873548b0c92b81046a4b50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNDo0NToyNVrOG47_bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNDo0NToyNVrOG47_bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM1NjMzMg==", "bodyText": "It seems a good catch. I am the community developer who implemented 'fetch graph' in v5. Also I implemented entity graph fully in v6. Yeah, I agree. The current implementation is buggy and difficult to maintain. That is because v5 infrastructure and design makes it difficult to implement and that is why 'fetch graph' was not implemented for a long time. The status has been changed in v6 and I think we have implemented the whole entity graph elegantly there already.\nI would take a look at the PR and thanks for the two options to choose from. However, I am community contributor and have very limited free cycles out of my daily job. Seems an endless fixing of entity graph in v5, :(.", "url": "https://github.com/hibernate/hibernate-orm/pull/3484#discussion_r462356332", "createdAt": "2020-07-29T14:45:25Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/main/java/org/hibernate/loader/Loader.java", "diffHunk": "@@ -68,6 +68,7 @@\n import org.hibernate.event.spi.PostLoadEvent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5825bc943796305f873548b0c92b81046a4b50"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjYyMjIz", "url": "https://github.com/hibernate/hibernate-orm/pull/3484#pullrequestreview-457662223", "createdAt": "2020-07-29T15:55:00Z", "commit": {"oid": "ea5825bc943796305f873548b0c92b81046a4b50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo1NTowMFrOG4_G4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo1NTowMFrOG4_G4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwNzM5Mw==", "bodyText": "Did you conduct some MPH benchmark comparison to justify the hack? It would be great to avoid such hack for the entity graph implementation logic has been so difficult to understand and maintain.", "url": "https://github.com/hibernate/hibernate-orm/pull/3484#discussion_r462407393", "createdAt": "2020-07-29T15:55:00Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/main/java/org/hibernate/loader/Loader.java", "diffHunk": "@@ -1215,8 +1242,13 @@ private void initializeEntitiesAndCollections(\n \t\t\t}\n \t\t}\n \n-\t\tif ( hydratedObjects != null ) {\n-\t\t\tfor ( Object hydratedObject : hydratedObjects ) {\n+\t\tif ( nullSeparatedHydratedObjects != null ) {\n+\t\t\tfor ( Object hydratedObject : nullSeparatedHydratedObjects ) {\n+\t\t\t\tif ( hydratedObject == null ) {\n+\t\t\t\t\t// This is a hack to signal that we're starting to process a new row\n+\t\t\t\t\t// Ignore\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5825bc943796305f873548b0c92b81046a4b50"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3ODI4NjA2", "url": "https://github.com/hibernate/hibernate-orm/pull/3484#pullrequestreview-457828606", "createdAt": "2020-07-29T19:35:56Z", "commit": {"oid": "ea5825bc943796305f873548b0c92b81046a4b50"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2827, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}