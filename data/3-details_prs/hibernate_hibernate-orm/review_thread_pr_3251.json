{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NjUzOTEy", "number": 3251, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMjo1Nzo0NFrODhg4HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMDoxOVrODhhh_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDY4MjUyOnYy", "diffSide": "RIGHT", "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMjo1Nzo0NFrOFsSUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDozMDo0NVrOFsVg1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4MTY5Ng==", "bodyText": "You import it, but never apply it.  Really all of these should be new classes ought to be marked incubating", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r381981696", "createdAt": "2020-02-20T12:57:44Z", "author": {"login": "sebersole"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzNDEzMw==", "bodyText": "I used it at first, but then I took it out because I didn't know which features qualify for @Incubating. Now, it's clear.", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r382034133", "createdAt": "2020-02-20T14:30:45Z", "author": {"login": "vladmihalcea"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4MTY5Ng=="}, "originalCommit": null, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDc3OTc1OnYy", "diffSide": "RIGHT", "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzoyNzozM1rOFsTNpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDo0Nzo0NVrOFsWMsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NjQ1Mw==", "bodyText": "Seems another exciting PR from Vlad. I just wanna raise some awareness of the maintenance cost of the current implementation. So suppose next JVM adds some new method to Stream, do we need to modify the class accordingly to sync up? Seems not a concern for JVM maintains backward compatibility by interface default method?\nOther than delegator, Spring's AOP might be a good implementation alternative provided JDK exposes some mean to know whether the current method is 'terminal' one or not.", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r381996453", "createdAt": "2020-02-20T13:27:33Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;\n+\n+/**\n+ * The {@link StreamDecorator} wraps a Java {@link Stream} and registers a {@code closeHandler}\n+ * which is passed further to any resulting {@link Stream}.\n+ *\n+ * The goal of the {@link StreamDecorator} is to close the underlying {@link Stream} upon\n+ * calling a terminal operation.\n+ *\n+ * @author Vlad Mihalcea\n+ * @since 5.4\n+ */\n+public class StreamDecorator<R> implements Stream<R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzNjI0NA==", "bodyText": "@sebersole @NathanQingyangXu I thought of that too, but then I run the tests with Java 13 and there was no issue.  I'm curious why there was no issue. I'll have to check the Gradle configs to see if the compiler is set to JDK 8.\nI've been using this approach in FlexyPool as an alternative to dynamic proxies for the JDBC Connection. If there's a method added in a new JDK version, and we need to compile with JDK 8, we can just add the new methods without @Override and use Reflection to invoke the method on the delegate.\nAnother approach is to use Byte Buddy, but there will be many if/else checks to determine which methods we need to call close and which require creating a new StreamDecorator.", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r382036244", "createdAt": "2020-02-20T14:33:58Z", "author": {"login": "vladmihalcea"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;\n+\n+/**\n+ * The {@link StreamDecorator} wraps a Java {@link Stream} and registers a {@code closeHandler}\n+ * which is passed further to any resulting {@link Stream}.\n+ *\n+ * The goal of the {@link StreamDecorator} is to close the underlying {@link Stream} upon\n+ * calling a terminal operation.\n+ *\n+ * @author Vlad Mihalcea\n+ * @since 5.4\n+ */\n+public class StreamDecorator<R> implements Stream<R> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NjQ1Mw=="}, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA0NTM2Mg==", "bodyText": "@sebersole @NathanQingyangXu Cool. I found why it works on Java 13. It looks like the JDK folks decided to mark the new Stream methods (takeWhile and dropWhile) using default, so that's why the test run. The iterate and ofNullable new methods are static, so they are fine.\nHowever, we still need to override those two default methods so that we can decorate the returning Stream. I'll issue a new commit based on these comments.", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r382045362", "createdAt": "2020-02-20T14:47:45Z", "author": {"login": "vladmihalcea"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;\n+\n+/**\n+ * The {@link StreamDecorator} wraps a Java {@link Stream} and registers a {@code closeHandler}\n+ * which is passed further to any resulting {@link Stream}.\n+ *\n+ * The goal of the {@link StreamDecorator} is to close the underlying {@link Stream} upon\n+ * calling a terminal operation.\n+ *\n+ * @author Vlad Mihalcea\n+ * @since 5.4\n+ */\n+public class StreamDecorator<R> implements Stream<R> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NjQ1Mw=="}, "originalCommit": null, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDc4OTczOnYy", "diffSide": "RIGHT", "path": "hibernate-core/src/test/java/org/hibernate/test/stream/basic/JpaStreamTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMDoxOVrOFsTTcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDozODo1MlrOFsV1Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzkzOQ==", "bodyText": "One good edge case for this PR is to verify the following scenario:\n\nsome stream client code has closed stream already (to adhere to best practice, maybe via 'try' block);\nthis new feature was added without client knowing and the stream might be closed twice;\n\nIt would be excellent to add a testing case to ensure the above common scenario won't throw some exception (not only for now, but for the long future).", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r381997939", "createdAt": "2020-02-20T13:30:19Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/test/java/org/hibernate/test/stream/basic/JpaStreamTest.java", "diffHunk": "@@ -70,12 +79,100 @@ public void testQueryStream() {\n \t\t} );\n \t}\n \n+\t@Test\n+\t@TestForIssue( jiraKey = \"HHH-13872\")\n+\t@RequiresDialect(H2Dialect.class)\n+\tpublic void testStreamCloseOnTerminalOperation() {\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tsession.createQuery( \"delete from MyEntity\" ).executeUpdate();\n+\n+\t\t\tfor ( int i = 1; i <= 10; i++ ) {\n+\t\t\t\tMyEntity e = new MyEntity();\n+\t\t\t\te.id = i;\n+\t\t\t\te.name = \"Test\";\n+\t\t\t\tsession.persist( e );\n+\t\t\t}\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tList<MyEntity> entities = stream.collect( Collectors.toList() ) ;\n+\t\t\tassertEquals(10, entities.size());\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tint sum = stream.mapToInt( MyEntity::getId ).sum();\n+\t\t\tassertEquals(55, sum);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tlong result = stream.mapToLong( entity -> entity.id * 10 ).min().getAsLong();\n+\t\t\tassertEquals(10, result);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tdouble result = stream.mapToDouble( entity -> entity.id * 0.1D ).max().getAsDouble();\n+\t\t\tassertEquals(1, result, 0.1);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\t}\n+\n+\tprivate ResourceRegistry resourceRegistry(Session session) {\n+\t\tSharedSessionContractImplementor sharedSessionContractImplementor = (SharedSessionContractImplementor) session;\n+\t\tJdbcCoordinator jdbcCoordinator = sharedSessionContractImplementor.getJdbcCoordinator();\n+\t\treturn jdbcCoordinator.getLogicalConnection().getResourceRegistry();\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzNzI1NA==", "bodyText": "Yes, we should totally add that test case. Luckily, the AsbtractScrollableResults returns immediately from close if the RS was already closed:\nif ( this.closed ) {\n\t// noop if already closed\n\treturn;\n}", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r382037254", "createdAt": "2020-02-20T14:35:37Z", "author": {"login": "vladmihalcea"}, "path": "hibernate-core/src/test/java/org/hibernate/test/stream/basic/JpaStreamTest.java", "diffHunk": "@@ -70,12 +79,100 @@ public void testQueryStream() {\n \t\t} );\n \t}\n \n+\t@Test\n+\t@TestForIssue( jiraKey = \"HHH-13872\")\n+\t@RequiresDialect(H2Dialect.class)\n+\tpublic void testStreamCloseOnTerminalOperation() {\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tsession.createQuery( \"delete from MyEntity\" ).executeUpdate();\n+\n+\t\t\tfor ( int i = 1; i <= 10; i++ ) {\n+\t\t\t\tMyEntity e = new MyEntity();\n+\t\t\t\te.id = i;\n+\t\t\t\te.name = \"Test\";\n+\t\t\t\tsession.persist( e );\n+\t\t\t}\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tList<MyEntity> entities = stream.collect( Collectors.toList() ) ;\n+\t\t\tassertEquals(10, entities.size());\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tint sum = stream.mapToInt( MyEntity::getId ).sum();\n+\t\t\tassertEquals(55, sum);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tlong result = stream.mapToLong( entity -> entity.id * 10 ).min().getAsLong();\n+\t\t\tassertEquals(10, result);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tdouble result = stream.mapToDouble( entity -> entity.id * 0.1D ).max().getAsDouble();\n+\t\t\tassertEquals(1, result, 0.1);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\t}\n+\n+\tprivate ResourceRegistry resourceRegistry(Session session) {\n+\t\tSharedSessionContractImplementor sharedSessionContractImplementor = (SharedSessionContractImplementor) session;\n+\t\tJdbcCoordinator jdbcCoordinator = sharedSessionContractImplementor.getJdbcCoordinator();\n+\t\treturn jdbcCoordinator.getLogicalConnection().getResourceRegistry();\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzkzOQ=="}, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzOTMwNg==", "bodyText": "Yeah, I noticed that, but adding testing case would make us sleep well if the above code was refactored.", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r382039306", "createdAt": "2020-02-20T14:38:52Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/test/java/org/hibernate/test/stream/basic/JpaStreamTest.java", "diffHunk": "@@ -70,12 +79,100 @@ public void testQueryStream() {\n \t\t} );\n \t}\n \n+\t@Test\n+\t@TestForIssue( jiraKey = \"HHH-13872\")\n+\t@RequiresDialect(H2Dialect.class)\n+\tpublic void testStreamCloseOnTerminalOperation() {\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tsession.createQuery( \"delete from MyEntity\" ).executeUpdate();\n+\n+\t\t\tfor ( int i = 1; i <= 10; i++ ) {\n+\t\t\t\tMyEntity e = new MyEntity();\n+\t\t\t\te.id = i;\n+\t\t\t\te.name = \"Test\";\n+\t\t\t\tsession.persist( e );\n+\t\t\t}\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tList<MyEntity> entities = stream.collect( Collectors.toList() ) ;\n+\t\t\tassertEquals(10, entities.size());\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tint sum = stream.mapToInt( MyEntity::getId ).sum();\n+\t\t\tassertEquals(55, sum);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tlong result = stream.mapToLong( entity -> entity.id * 10 ).min().getAsLong();\n+\t\t\tassertEquals(10, result);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tdouble result = stream.mapToDouble( entity -> entity.id * 0.1D ).max().getAsDouble();\n+\t\t\tassertEquals(1, result, 0.1);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\t}\n+\n+\tprivate ResourceRegistry resourceRegistry(Session session) {\n+\t\tSharedSessionContractImplementor sharedSessionContractImplementor = (SharedSessionContractImplementor) session;\n+\t\tJdbcCoordinator jdbcCoordinator = sharedSessionContractImplementor.getJdbcCoordinator();\n+\t\treturn jdbcCoordinator.getLogicalConnection().getResourceRegistry();\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzkzOQ=="}, "originalCommit": null, "originalPosition": 126}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4031, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}