{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NjUzOTEy", "number": 3251, "title": "HHH-13872 - Make the Java Stream close the underlying ScrollableResultsIterator upon calling a terminal operation", "bodyText": "https://hibernate.atlassian.net/browse/HHH-13872", "createdAt": "2020-02-20T09:50:35Z", "url": "https://github.com/hibernate/hibernate-orm/pull/3251", "merged": true, "mergeCommit": {"oid": "d9a335c429ef812bc9726e9d467597ebae2b81a5"}, "closed": true, "closedAt": "2020-02-21T12:03:43Z", "author": {"login": "vladmihalcea"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGIbrZABqjMwNTUyMDg2MTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGPW8iABqjMwNTc2MDY1MzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxODc4ODIz", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#pullrequestreview-361878823", "createdAt": "2020-02-20T12:57:44Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMjo1Nzo0NFrOFsSUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMjo1Nzo0NFrOFsSUAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4MTY5Ng==", "bodyText": "You import it, but never apply it.  Really all of these should be new classes ought to be marked incubating", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r381981696", "createdAt": "2020-02-20T12:57:44Z", "author": {"login": "sebersole"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxODk3NjU4", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#pullrequestreview-361897658", "createdAt": "2020-02-20T13:27:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzoyNzozM1rOFsTNpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzoyNzozM1rOFsTNpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NjQ1Mw==", "bodyText": "Seems another exciting PR from Vlad. I just wanna raise some awareness of the maintenance cost of the current implementation. So suppose next JVM adds some new method to Stream, do we need to modify the class accordingly to sync up? Seems not a concern for JVM maintains backward compatibility by interface default method?\nOther than delegator, Spring's AOP might be a good implementation alternative provided JDK exposes some mean to know whether the current method is 'terminal' one or not.", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r381996453", "createdAt": "2020-02-20T13:27:33Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/main/java/org/hibernate/query/spi/StreamDecorator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n+ * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n+ */\n+package org.hibernate.query.spi;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Collector;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.hibernate.Incubating;\n+\n+/**\n+ * The {@link StreamDecorator} wraps a Java {@link Stream} and registers a {@code closeHandler}\n+ * which is passed further to any resulting {@link Stream}.\n+ *\n+ * The goal of the {@link StreamDecorator} is to close the underlying {@link Stream} upon\n+ * calling a terminal operation.\n+ *\n+ * @author Vlad Mihalcea\n+ * @since 5.4\n+ */\n+public class StreamDecorator<R> implements Stream<R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxODk5NTIx", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#pullrequestreview-361899521", "createdAt": "2020-02-20T13:30:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMDoxOVrOFsTTcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMDoxOVrOFsTTcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzkzOQ==", "bodyText": "One good edge case for this PR is to verify the following scenario:\n\nsome stream client code has closed stream already (to adhere to best practice, maybe via 'try' block);\nthis new feature was added without client knowing and the stream might be closed twice;\n\nIt would be excellent to add a testing case to ensure the above common scenario won't throw some exception (not only for now, but for the long future).", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#discussion_r381997939", "createdAt": "2020-02-20T13:30:19Z", "author": {"login": "NathanQingyangXu"}, "path": "hibernate-core/src/test/java/org/hibernate/test/stream/basic/JpaStreamTest.java", "diffHunk": "@@ -70,12 +79,100 @@ public void testQueryStream() {\n \t\t} );\n \t}\n \n+\t@Test\n+\t@TestForIssue( jiraKey = \"HHH-13872\")\n+\t@RequiresDialect(H2Dialect.class)\n+\tpublic void testStreamCloseOnTerminalOperation() {\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tsession.createQuery( \"delete from MyEntity\" ).executeUpdate();\n+\n+\t\t\tfor ( int i = 1; i <= 10; i++ ) {\n+\t\t\t\tMyEntity e = new MyEntity();\n+\t\t\t\te.id = i;\n+\t\t\t\te.name = \"Test\";\n+\t\t\t\tsession.persist( e );\n+\t\t\t}\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tList<MyEntity> entities = stream.collect( Collectors.toList() ) ;\n+\t\t\tassertEquals(10, entities.size());\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tint sum = stream.mapToInt( MyEntity::getId ).sum();\n+\t\t\tassertEquals(55, sum);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tlong result = stream.mapToLong( entity -> entity.id * 10 ).min().getAsLong();\n+\t\t\tassertEquals(10, result);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\n+\t\tdoInHibernate( this::sessionFactory, session -> {\n+\t\t\tStream<MyEntity> stream = session\n+\t\t\t\t\t.createQuery( \"SELECT me FROM MyEntity me\" )\n+\t\t\t\t\t.getResultStream();\n+\n+\t\t\tResourceRegistry resourceRegistry = resourceRegistry(session);\n+\t\t\tassertTrue( resourceRegistry.hasRegisteredResources() );\n+\n+\t\t\tdouble result = stream.mapToDouble( entity -> entity.id * 0.1D ).max().getAsDouble();\n+\t\t\tassertEquals(1, result, 0.1);\n+\n+\t\t\tassertFalse( resourceRegistry.hasRegisteredResources() );\n+\t\t} );\n+\t}\n+\n+\tprivate ResourceRegistry resourceRegistry(Session session) {\n+\t\tSharedSessionContractImplementor sharedSessionContractImplementor = (SharedSessionContractImplementor) session;\n+\t\tJdbcCoordinator jdbcCoordinator = sharedSessionContractImplementor.getJdbcCoordinator();\n+\t\treturn jdbcCoordinator.getLogicalConnection().getResourceRegistry();\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxOTg2ODE1", "url": "https://github.com/hibernate/hibernate-orm/pull/3251#pullrequestreview-361986815", "createdAt": "2020-02-20T15:17:33Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "69d91554b5da486e4cb364050addca4b14df9b8b", "author": {"user": {"login": "vladmihalcea", "name": "Vlad Mihalcea"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/69d91554b5da486e4cb364050addca4b14df9b8b", "committedDate": "2020-02-20T18:22:55Z", "message": "HHH-13872 - Make the Java Stream close the underlying ScrollableResultsIterator upon calling a terminal operation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "69d91554b5da486e4cb364050addca4b14df9b8b", "author": {"user": {"login": "vladmihalcea", "name": "Vlad Mihalcea"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/69d91554b5da486e4cb364050addca4b14df9b8b", "committedDate": "2020-02-20T18:22:55Z", "message": "HHH-13872 - Make the Java Stream close the underlying ScrollableResultsIterator upon calling a terminal operation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3165, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}