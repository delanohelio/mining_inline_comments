{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1Mzk1NTMx", "number": 3238, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowNDoyOVrODf_NWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowODowM1rODf_REA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODY4MDU2OnYy", "diffSide": "RIGHT", "path": "design/working/circular-fetching.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowNDoyOVrOFqAp3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowNDoyOVrOFqAp3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NTIzMQ==", "bodyText": "throw an exception?", "url": "https://github.com/hibernate/hibernate-orm/pull/3238#discussion_r379595231", "createdAt": "2020-02-14T19:04:29Z", "author": {"login": "NathanQingyangXu"}, "path": "design/working/circular-fetching.adoc", "diffHunk": "@@ -0,0 +1,208 @@\n+= Circular fetching\n+\n+[IMPORTANT]\n+====\n+We need to make sure that any association is only join-fetched once.  E.g.\n+\n+```\n+from LineItem l\n+    join fetch l.order o\n+    join fetch l.order o2\n+```\n+\n+This should be illegal.  It is possible to handle it specially, but that would be very complicated.\n+\n+`FromClauseIndex#findJoinFetch(NavigablePath parentPath, String fetchableName)` - if this does not return null we\n+know that the association is already join fetched and we should throw and exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4479e5517f971e394ea628a2be3e5cb6eeb32109"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODY5MDA4OnYy", "diffSide": "RIGHT", "path": "design/working/circular-fetching.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowODowM1rOFqAvrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowODowM1rOFqAvrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NjcxOA==", "bodyText": "guess there is some indentation issue here", "url": "https://github.com/hibernate/hibernate-orm/pull/3238#discussion_r379596718", "createdAt": "2020-02-14T19:08:03Z", "author": {"login": "NathanQingyangXu"}, "path": "design/working/circular-fetching.adoc", "diffHunk": "@@ -0,0 +1,208 @@\n+= Circular fetching\n+\n+[IMPORTANT]\n+====\n+We need to make sure that any association is only join-fetched once.  E.g.\n+\n+```\n+from LineItem l\n+    join fetch l.order o\n+    join fetch l.order o2\n+```\n+\n+This should be illegal.  It is possible to handle it specially, but that would be very complicated.\n+\n+`FromClauseIndex#findJoinFetch(NavigablePath parentPath, String fetchableName)` - if this does not return null we\n+know that the association is already join fetched and we should throw and exception\n+====\n+\n+== one-to-one\n+\n+```\n+@Entity\n+class Root {\n+    ...\n+\n+    @OneToOne(mappedBy=\"root1\")\n+    Leaf leaf1;\n+\n+    @OneToOne(mappedBy=\"root2\")\n+    Leaf leaf2;\n+}\n+\n+@Entity\n+class Leaf {\n+    ...\n+\n+    @OneToOne\n+    @JoinColumn(name=\"root_id_1\")\n+    Root root1;\n+\n+    @OneToOne\n+    @JoinColumn(name=\"root_id_2\")\n+    Root root2;\n+}\n+```\n+\n+\n+Given this model, we have the following mappings from modelPart to \"identifying columns\":\n+\n+* `Root#leaf1` -> `leaf.root_id_1`\n+* `Root#leaf2` -> `leaf.root_id_2`\n+* `Leaf#root1` -> `leaf.root_id_1`\n+* `Leaf#root2` -> `leaf.root_id_2`\n+\n+So given a query like:\n+\n+```\n+from Root r\n+    join fetch r.leaf1 l\n+    join fetch l.root1\n+    join fetch l.root2\n+```\n+\n+`l.root1` is circular whereas `l.root2` is not.  We'd know this by looking at the \"identifying columns\".\n+\n+Specifically, `l.root1` is considered circular **not** because it refers back to `Root(r)` but because it maps to the\n+same column(s) as its parent: `leaf.root_id_1`\n+\n+\n+// we need to be able to ultimately be able to resolve the \"identifying columns\" for a given path.  E.g.\n+\n+```\n+interface DomainResultCreationState {\n+    ...\n+\n+    Fetchable resolveFetchable(NavigablePath navigablePath) {\n+        // the path passed in here would be `pathToParent` (i.e. `Root(r).leaf1(l)`)\n+        // we'd used that to determine the lhs's identifying columns via\n+        // `Fetchable#getIdentifyingColumnExpressions` and check them against the\n+        // identifying columns for the Fetchable we are processing\n+    }\n+}\n+```\n+\n+\n+\n+== many-to-one\n+\n+```\n+@Entity\n+@Table(name=\"orders\")\n+class Order {\n+    ...\n+\n+    @OneToMany(mappedBy=\"order\")\n+    List<LineItem> lineItems;\n+}\n+\n+@Entity\n+@Table(name=\"lines\")\n+class LineItem {\n+    ...\n+\n+    @ManyToOne\n+    @JoinColumn(name=\"order_id\")\n+    Order order;\n+}\n+```\n+\n+Given this model, we have the following mappings from modelPart to \"identifying columns\":\n+\n+* `LineItem#order` -> `lines.order_id`\n+* `Order#lineItems#{element}` -> `lines.order_id`\n+\n+\n+Once we find a circularity we should build the `BiDirectionalFetch` reference pointing to the\n+Initializer for the \"parent parent path\".  See `RowProcessingState#.resolveInitializer`\n+\n+\n+\n+\n+Hibernate needs to handle circularity in a fetch-graph.  E.g.:\n+\n+```\n+select o\n+from Order o\n+    join fetch o.lineItems l\n+    join fetch l.order o2\n+    join fetch o2.lineItems\n+```\n+\n+Here, the join fetch of `l.order` is circular, meaning we do not want to render a join in the SQL for it\n+because it is already part of the from-clause via `Order o`.\n+\n+Recognizing circularity needs to happen in a number of mapping scenarios and I believe the conditions vary\n+depending on the type of mapping involved (one-to-one, many-to-one, many-to-many).  Ideally we can find commonality\n+and handle these conditions uniformly.\n+\n+\n+== with embeddables\n+\n+```\n+@Entity\n+@Table(name=\"root\")\n+class RootEntity {\n+    ...\n+\n+    @Embedded\n+    IntermediateComponent intermediateComponent;\n+}\n+\n+@Embeddable\n+class IntermediateComponent {\n+    ...\n+\n+\t@OneToMany( mappedBy = \"rootEntity\" )\n+\tSet<LeafEntity> leaves\n+}\n+\n+@Entity\n+@Table(name=\"leaf\")\n+class LeafEntity {\n+    ...\n+\n+\t@ManyToOne\n+\t@JoinColumn(name=\"root_id)\n+    RootEntity rootEntity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4479e5517f971e394ea628a2be3e5cb6eeb32109"}, "originalPosition": 167}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4018, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}