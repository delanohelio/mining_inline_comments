{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MjczMDI1", "number": 3453, "title": "HHH-14097 Fix redundant SQLs issue for fetch entity graph", "bodyText": "https://hibernate.atlassian.net/browse/HHH-14097\nThe root cause is we lack fetch entity graph validation. For the initial multiple hydrated objects, only the first one is applicable to root entity graph.\nImported andrea's testing code from #3452. Tons of thanks to him!\nRemember only the testing case is needed to be merged into v6 for entity graph implementation is incompatible between v5 and v6 and the code changes except the testing case are not needed in v6 (actually I've carefully deleted the v5 implementation in v6 previously).", "createdAt": "2020-07-04T11:26:15Z", "url": "https://github.com/hibernate/hibernate-orm/pull/3453", "merged": true, "mergeCommit": {"oid": "5952c0abc3357a7346c4d12e4b13e1103926a89e"}, "closed": true, "closedAt": "2020-07-09T13:08:32Z", "author": {"login": "NathanQingyangXu"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxpMaNABqjM1MTI2MTQxMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyoRC7gFqTQ0NDA0ODYxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyODg1MzIw", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#pullrequestreview-442885320", "createdAt": "2020-07-06T08:45:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo0NToxOFrOGtOS_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo0NToxOFrOGtOS_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3MzM0Mw==", "bodyText": "Since this is an example in documentation, I think it would be clearer to just use the string (as it was)?\nIf you really want to use a constant in documentation, we should also show the import statement, or use the fully qualified classname.", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450073343", "createdAt": "2020-07-06T08:45:18Z", "author": {"login": "Sanne"}, "path": "documentation/src/test/java/org/hibernate/userguide/fetching/GraphFetchingTest.java", "diffHunk": "@@ -89,7 +85,7 @@ public void test() {\n \t\t\t\tEmployee.class,\n \t\t\t\tuserId,\n \t\t\t\tCollections.singletonMap(\n-\t\t\t\t\t\"javax.persistence.fetchgraph\",\n+\t\t\t\t\tGraphSemantic.FETCH.getJpaHintName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMTUyMDM0", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#pullrequestreview-443152034", "createdAt": "2020-07-06T14:55:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNDo1NToxMlrOGta2_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNDo1NToxMlrOGta2_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI3OTE2NA==", "bodyText": "I'm not sure about this, are we entirely sure that the fetch graph is no longer needed at this point?\nWouldn't it be possible for the fetch grapth to need to span multiple load events?\nIF this is correct, should line 285 be removed as it seems redundant?", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450279164", "createdAt": "2020-07-06T14:55:12Z", "author": {"login": "Sanne"}, "path": "hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java", "diffHunk": "@@ -206,62 +206,91 @@ public static void initializeEntityEntryLoadedState(\n \t\tString entityName = persister.getEntityName();\n \t\tString[] propertyNames = persister.getPropertyNames();\n \t\tfinal Type[] types = persister.getPropertyTypes();\n-\t\t\n-\t\tfinal GraphImplementor<?> fetchGraphContext = session.getFetchGraphLoadContext();\n-\t\t\n-\t\tfor ( int i = 0; i < hydratedState.length; i++ ) {\n-\t\t\tfinal Object value = hydratedState[i];\n-\t\t\tif ( debugEnabled ) {\n-\t\t\t\tLOG.debugf(\n-\t\t\t\t\t\"Processing attribute `%s` : value = %s\",\n-\t\t\t\t\tpropertyNames[i],\n-\t\t\t\t\tvalue == LazyPropertyInitializer.UNFETCHED_PROPERTY ? \"<un-fetched>\" : value == PropertyAccessStrategyBackRefImpl.UNKNOWN ? \"<unknown>\" : value\n-\t\t\t\t);\n-\t\t\t}\n \n-\t\t\tif ( value == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n+\t\tGraphImplementor fetchGraphContext = session.getFetchGraphLoadContext();\n+\t\tif ( fetchGraphContext != null && !fetchGraphContext.appliesTo( entity.getClass() ) ) {\n+\t\t\tLOG.warnf( \"Entity graph specified is not applicable to the entity [%s]. Ignored.\", entity);\n+\t\t\tfetchGraphContext = null;\n+\t\t\tsession.setFetchGraphLoadContext( null );\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfor ( int i = 0; i < hydratedState.length; i++ ) {\n+\t\t\t\tfinal Object value = hydratedState[i];\n \t\t\t\tif ( debugEnabled ) {\n-\t\t\t\t\tLOG.debugf( \"Resolving <un-fetched> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\tLOG.debugf(\n+\t\t\t\t\t\t\t\"Processing attribute `%s` : value = %s\",\n+\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\tvalue == LazyPropertyInitializer.UNFETCHED_PROPERTY ?\n+\t\t\t\t\t\t\t\t\t\"<un-fetched>\" :\n+\t\t\t\t\t\t\t\t\tvalue == PropertyAccessStrategyBackRefImpl.UNKNOWN ? \"<unknown>\" : value\n+\t\t\t\t\t);\n \t\t\t\t}\n \n-\t\t\t\t// IMPLEMENTATION NOTE: This is a lazy property on a bytecode-enhanced entity.\n-\t\t\t\t// hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY so that\n-\t\t\t\t// setPropertyValues() below (ultimately AbstractEntityTuplizer#setPropertyValues) works properly\n-\t\t\t\t// No resolution is necessary, unless the lazy property is a collection.\n-\t\t\t\tif ( types[i].isCollectionType() ) {\n-\t\t\t\t\t// IMPLEMENTATION NOTE: this is a lazy collection property on a bytecode-enhanced entity.\n-\t\t\t\t\t// HHH-10989: We need to resolve the collection so that a CollectionReference is added to StatefulPersistentContext.\n-\t\t\t\t\t// As mentioned above, hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY\n-\t\t\t\t\t// so do not assign the resolved, uninitialized PersistentCollection back to hydratedState[i].\n-\t\t\t\t\tBoolean overridingEager = getOverridingEager( session, entityName, propertyNames[i], types[i], debugEnabled );\n-\t\t\t\t\ttypes[i].resolve( value, session, entity, overridingEager );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if ( value != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {\n-\t\t\t\tif ( debugEnabled ) {\n-\t\t\t\t\tfinal boolean isLazyEnhanced = persister.getBytecodeEnhancementMetadata()\n-\t\t\t\t\t\t.getLazyAttributesMetadata()\n-\t\t\t\t\t\t.getLazyAttributeNames()\n-\t\t\t\t\t\t.contains( propertyNames[i] );\n-\t\t\t\t\tLOG.debugf( \"Attribute (`%s`)  - enhanced for lazy-loading? - %s\", propertyNames[i], isLazyEnhanced );\n+\t\t\t\tif ( value == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n+\t\t\t\t\tif ( debugEnabled ) {\n+\t\t\t\t\t\tLOG.debugf( \"Resolving <un-fetched> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// IMPLEMENTATION NOTE: This is a lazy property on a bytecode-enhanced entity.\n+\t\t\t\t\t// hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY so that\n+\t\t\t\t\t// setPropertyValues() below (ultimately AbstractEntityTuplizer#setPropertyValues) works properly\n+\t\t\t\t\t// No resolution is necessary, unless the lazy property is a collection.\n+\t\t\t\t\tif ( types[i].isCollectionType() ) {\n+\t\t\t\t\t\t// IMPLEMENTATION NOTE: this is a lazy collection property on a bytecode-enhanced entity.\n+\t\t\t\t\t\t// HHH-10989: We need to resolve the collection so that a CollectionReference is added to StatefulPersistentContext.\n+\t\t\t\t\t\t// As mentioned above, hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY\n+\t\t\t\t\t\t// so do not assign the resolved, uninitialized PersistentCollection back to hydratedState[i].\n+\t\t\t\t\t\tBoolean overridingEager = getOverridingEager(\n+\t\t\t\t\t\t\t\tsession,\n+\t\t\t\t\t\t\t\tentityName,\n+\t\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\t\ttypes[i],\n+\t\t\t\t\t\t\t\tdebugEnabled\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\ttypes[i].resolve( value, session, entity, overridingEager );\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\telse if ( value != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {\n+\t\t\t\t\tif ( debugEnabled ) {\n+\t\t\t\t\t\tfinal boolean isLazyEnhanced = persister.getBytecodeEnhancementMetadata()\n+\t\t\t\t\t\t\t\t.getLazyAttributesMetadata()\n+\t\t\t\t\t\t\t\t.getLazyAttributeNames()\n+\t\t\t\t\t\t\t\t.contains( propertyNames[i] );\n+\t\t\t\t\t\tLOG.debugf(\n+\t\t\t\t\t\t\t\t\"Attribute (`%s`)  - enhanced for lazy-loading? - %s\",\n+\t\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\t\tisLazyEnhanced\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n \n-\t\t\t\t// we know value != LazyPropertyInitializer.UNFETCHED_PROPERTY\n-\t\t\t\tBoolean overridingEager = getOverridingEager( session, entityName, propertyNames[i], types[i], debugEnabled );\n-\t\t\t\thydratedState[i] = types[i].isEntityType()\n-\t\t\t\t\t\t? entityResolver.resolve( (EntityType) types[i], value, session, entity, overridingEager )\n-\t\t\t\t\t\t: types[i].resolve( value, session, entity, overridingEager );\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif ( debugEnabled ) {\n-\t\t\t\t\tLOG.debugf( \"Skipping <unknown> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\t// we know value != LazyPropertyInitializer.UNFETCHED_PROPERTY\n+\t\t\t\t\tBoolean overridingEager = getOverridingEager(\n+\t\t\t\t\t\t\tsession,\n+\t\t\t\t\t\t\tentityName,\n+\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\ttypes[i],\n+\t\t\t\t\t\t\tdebugEnabled\n+\t\t\t\t\t);\n+\t\t\t\t\thydratedState[i] = types[i].isEntityType()\n+\t\t\t\t\t\t\t? entityResolver.resolve( (EntityType) types[i], value, session, entity, overridingEager )\n+\t\t\t\t\t\t\t: types[i].resolve( value, session, entity, overridingEager );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tif ( debugEnabled ) {\n+\t\t\t\t\t\tLOG.debugf( \"Skipping <unknown> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n-\t\t\tif ( session.getFetchGraphLoadContext() != fetchGraphContext ) {\n \t\t\t\tsession.setFetchGraphLoadContext( fetchGraphContext );\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\t// HHH-14097\n+\t\t\t// Fetch entity graph should be applied only once on top level (for root hydrated object)\n+\t\t\t// e.g., see org.hibernate.loader.Loader for details\n+\t\t\tsession.setFetchGraphLoadContext( null );", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "author": {"user": {"login": "NathanQingyangXu", "name": "Nathan Xu"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "committedDate": "2020-07-07T13:17:04Z", "message": "HHH-14097 fix bug that redundant SQLs might be issued for 'FETCH' entity graph"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "author": {"user": {"login": "NathanQingyangXu", "name": "Nathan Xu"}}, "url": "https://github.com/hibernate/hibernate-orm/commit/ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "committedDate": "2020-07-07T13:17:04Z", "message": "HHH-14097 fix bug that redundant SQLs might be issued for 'FETCH' entity graph"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzODgxNjk0", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#pullrequestreview-443881694", "createdAt": "2020-07-07T13:19:54Z", "commit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxOTo1NFrOGt-KUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMzoxOTo1NFrOGt-KUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzU1NQ==", "bodyText": "The above content was copied from v6's counterpart. Thought the basic explanation of the two types of entity graph modes is supposed to exist in v5 as well.\nGiven the content has existed in v6 already, we don't need to bother merging this part to v6 as well.", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450857555", "createdAt": "2020-07-07T13:19:54Z", "author": {"login": "NathanQingyangXu"}, "path": "documentation/src/main/asciidoc/userguide/chapters/fetching/Fetching.adoc", "diffHunk": "@@ -188,8 +188,15 @@ In both cases, this resolves to exactly one database query to get all that infor\n [[fetching-strategies-dynamic-fetching-entity-graph]]\n === Dynamic fetching via JPA entity graph\n \n-JPA 2.1 introduced entity graphs so the application developer has more control over fetch plans.\n+JPA 2.1 introduced ``entity graph`` so the application developer has more control over fetch plans. It has two modes to choose from:\n \n+fetch graph:::\n+In this case, all attributes specified in the entity graph will be treated as FetchType.EAGER, and all attributes not specified will *ALWAYS* be treated as FetchType.LAZY.\n+\n+load graph:::\n+In this case, all attributes specified in the entity graph will be treated as FetchType.EAGER, but attributes not specified use their static mapping specification.\n+\n+Below is an `fetch graph` dynamic fetching example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDQ4NDQz", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#pullrequestreview-444048443", "createdAt": "2020-07-07T16:16:54Z", "commit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoxNjo1NFrOGuF9nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoxNjo1NFrOGuF9nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NTM3NQ==", "bodyText": "just a minor but I think the session.setFetchGraphLoadContext( null ); is redundant", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450985375", "createdAt": "2020-07-07T16:16:54Z", "author": {"login": "dreab8"}, "path": "hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java", "diffHunk": "@@ -206,62 +206,91 @@ public static void initializeEntityEntryLoadedState(\n \t\tString entityName = persister.getEntityName();\n \t\tString[] propertyNames = persister.getPropertyNames();\n \t\tfinal Type[] types = persister.getPropertyTypes();\n-\t\t\n-\t\tfinal GraphImplementor<?> fetchGraphContext = session.getFetchGraphLoadContext();\n-\t\t\n-\t\tfor ( int i = 0; i < hydratedState.length; i++ ) {\n-\t\t\tfinal Object value = hydratedState[i];\n-\t\t\tif ( debugEnabled ) {\n-\t\t\t\tLOG.debugf(\n-\t\t\t\t\t\"Processing attribute `%s` : value = %s\",\n-\t\t\t\t\tpropertyNames[i],\n-\t\t\t\t\tvalue == LazyPropertyInitializer.UNFETCHED_PROPERTY ? \"<un-fetched>\" : value == PropertyAccessStrategyBackRefImpl.UNKNOWN ? \"<unknown>\" : value\n-\t\t\t\t);\n-\t\t\t}\n \n-\t\t\tif ( value == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n+\t\tGraphImplementor fetchGraphContext = session.getFetchGraphLoadContext();\n+\t\tif ( fetchGraphContext != null && !fetchGraphContext.appliesTo( entity.getClass() ) ) {\n+\t\t\tLOG.warnf( \"Entity graph specified is not applicable to the entity [%s]. Ignored.\", entity);\n+\t\t\tfetchGraphContext = null;\n+\t\t\tsession.setFetchGraphLoadContext( null );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDQ4NjE5", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#pullrequestreview-444048619", "createdAt": "2020-07-07T16:17:07Z", "commit": {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2985, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}