{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyMjgzNjI3", "number": 1013, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1MDozNVrOE6mloA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxODo1Njo0NlrOFxKAnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODg1MDg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackAnalyticsReporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1MDozNVrOH1xcgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1MDozNVrOH1xcgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE0NjY4OA==", "bodyText": "Wouldn't JacksonMapper#decodeValue() work in this case? It wraps deserialization exceptions into proper DecodeException.", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r526146688", "createdAt": "2020-11-18T14:50:35Z", "author": {"login": "schernysh"}, "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackAnalyticsReporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import org.apache.commons.collections4.MapUtils;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.prebid.server.analytics.AnalyticsReporter;\n+import org.prebid.server.analytics.model.AmpEvent;\n+import org.prebid.server.analytics.model.AuctionEvent;\n+import org.prebid.server.analytics.model.CookieSyncEvent;\n+import org.prebid.server.analytics.model.SetuidEvent;\n+import org.prebid.server.analytics.model.VideoEvent;\n+import org.prebid.server.analytics.pubstack.model.EventType;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.analytics.pubstack.model.PubstackConfig;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.Initializable;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class PubstackAnalyticsReporter implements AnalyticsReporter, Initializable {\n+\n+    private static final String EVENT_REPORT_ENDPOINT_PATH = \"/intake\";\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackAnalyticsReporter.class);\n+    private static final Map<String, EventType> CLASS_TO_EVENT_TYPE;\n+\n+    static {\n+        CLASS_TO_EVENT_TYPE = new HashMap<>();\n+        CLASS_TO_EVENT_TYPE.put(AuctionEvent.class.getName(), EventType.auction);\n+        CLASS_TO_EVENT_TYPE.put(AmpEvent.class.getName(), EventType.amp);\n+        CLASS_TO_EVENT_TYPE.put(VideoEvent.class.getName(), EventType.video);\n+        CLASS_TO_EVENT_TYPE.put(SetuidEvent.class.getName(), EventType.setuid);\n+        CLASS_TO_EVENT_TYPE.put(CookieSyncEvent.class.getName(), EventType.cookiesync);\n+    }\n+\n+    private static final String CONFIG_URL_SUFFIX = \"/bootstrap?scopeId=\";\n+\n+    private final long configurationRefreshDelay;\n+    private final long timeout;\n+    private final Map<EventType, PubstackEventHandler> eventHandlers;\n+    private final HttpClient httpClient;\n+    private final JacksonMapper jacksonMapper;\n+    private final Vertx vertx;\n+    private PubstackConfig pubstackConfig;\n+\n+    public PubstackAnalyticsReporter(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                     Map<EventType, PubstackEventHandler> eventHandlers,\n+                                     HttpClient httpClient,\n+                                     JacksonMapper jacksonMapper,\n+                                     Vertx vertx) {\n+        this.configurationRefreshDelay =\n+                Objects.requireNonNull(pubstackAnalyticsProperties.getConfigurationRefreshDelayMs());\n+        this.timeout = Objects.requireNonNull(pubstackAnalyticsProperties.getTimeoutMs());\n+        this.eventHandlers = Objects.requireNonNull(eventHandlers);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.pubstackConfig = PubstackConfig.of(pubstackAnalyticsProperties.getScopeId(),\n+                pubstackAnalyticsProperties.getEndpoint(), Collections.emptyMap());\n+\n+    }\n+\n+    public <T> void processEvent(T event) {\n+        final EventType eventType = CLASS_TO_EVENT_TYPE.get(event.getClass().getName());\n+        if (eventType != null) {\n+            eventHandlers.get(eventType).handle(event);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        vertx.setPeriodic(configurationRefreshDelay, id -> fetchRemoteConfig());\n+        fetchRemoteConfig();\n+    }\n+\n+    public void shutdown() {\n+        eventHandlers.values().forEach(PubstackEventHandler::reportEvents);\n+    }\n+\n+    private void fetchRemoteConfig() {\n+        logger.info(\"[pubstack] Updating config: {0}\", pubstackConfig);\n+        httpClient.get(makeEventEndpointUrl(pubstackConfig.getEndpoint(), pubstackConfig.getScopeId()), timeout)\n+                .map(this::processRemoteConfigurationResponse)\n+                .setHandler(this::updateConfigsOnChange);\n+    }\n+\n+    private PubstackConfig processRemoteConfigurationResponse(HttpClientResponse response) {\n+        final int statusCode = response.getStatusCode();\n+        if (statusCode != 200) {\n+            throw new PreBidException(String.format(\"[pubstack] Failed to fetch config, reason: HTTP status code %d\",\n+                    statusCode));\n+        }\n+        final String body = response.getBody();\n+        try {\n+            return jacksonMapper.mapper().readValue(body, PubstackConfig.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3269efce9432448655b31e58562dee6371ab606"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTE0MjIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo0Nzo1MlrOH10Rlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo0Nzo1MlrOH10Rlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MzA0Nw==", "bodyText": "I suggest that we stick with io.netty.handler.codec.http.HttpResponseStatus because we already use it throughout our codebase.", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r526193047", "createdAt": "2020-11-18T15:47:52Z", "author": {"login": "schernysh"}, "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import org.apache.http.HttpStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3269efce9432448655b31e58562dee6371ab606"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTE2MDAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/spring/config/AnalyticsConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1MToyN1rOH10c9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1MToyN1rOH10c9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NTk1OA==", "bodyText": "This initialization looks like a good candidate to move inside PubstackAnalyticsReporter. Are there solid reasons not to do this?", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r526195958", "createdAt": "2020-11-18T15:51:27Z", "author": {"login": "schernysh"}, "path": "src/main/java/org/prebid/server/spring/config/AnalyticsConfiguration.java", "diffHunk": "@@ -28,4 +42,98 @@ CompositeAnalyticsReporter compositeAnalyticsReporter(\n     LogAnalyticsReporter logAnalyticsReporter(JacksonMapper mapper) {\n         return new LogAnalyticsReporter(mapper);\n     }\n+\n+    @Configuration\n+    @ConditionalOnProperty(prefix = \"analytics.pubstack\", name = \"enabled\", havingValue = \"true\")\n+    public static class PubstackAnalyticsConfiguration {\n+\n+        private static final String EVENT_REPORT_ENDPOINT_PATH = \"/intake\";\n+\n+        @Bean\n+        PubstackAnalyticsReporter pubstackAnalyticsReporter(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                                            HttpClient httpClient,\n+                                                            JacksonMapper jacksonMapper,\n+                                                            Vertx vertx) {\n+            final org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties properties =\n+                    pubstackAnalyticsProperties.toComponentProperties();\n+            final Map<EventType, PubstackEventHandler> eventHandlers = Arrays.stream(EventType.values())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3269efce9432448655b31e58562dee6371ab606"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg3MDg3NzkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxODo1NTowMVrOJHh_Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxODo1NTowMVrOJHh_Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3NjYzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Queue<String> copyToSend = events.get();\n          \n          \n            \n                    final Queue<String> copyToSend = events.getAndSet(new ConcurrentLinkedQueue<>());\n          \n      \n    \n    \n  \n\nOtherwise this is not an atomic swap", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r611876635", "createdAt": "2021-04-12T18:55:01Z", "author": {"login": "muuki88"}, "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "390928e863e8985c4f6e2d316110d1e91cf41721"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg3MDg3OTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxODo1NToyM1rOJHh__g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxODo1NToyM1rOJHh__g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3Njg2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    events.set(new ConcurrentLinkedQueue<>());\n          \n      \n    \n    \n  \n\nShould be set above with getAndSet()", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r611876862", "createdAt": "2021-04-12T18:55:23Z", "author": {"login": "muuki88"}, "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();\n+        resetReportEventsConditions(events);\n+        httpClient.request(HttpMethod.POST, HttpUtil.validateUrl(endpoint), headers, toGzippedBytes(copyToSend),\n+                timeoutMs)\n+                .setHandler(this::handleReportResponse);\n+    }\n+\n+    private void resetReportEventsConditions(AtomicReference<Queue<String>> events) {\n+        events.set(new ConcurrentLinkedQueue<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "390928e863e8985c4f6e2d316110d1e91cf41721"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg3MDg4NTQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxODo1Njo0NlrOJHiDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yOFQxMDo1ODowNlrOJjvrmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3Nzc3MQ==", "bodyText": "Not sure if these are thread safe. The rest of the code seems to be implemented in a thread safe way, so this should probably be too.\nMaybe calculating the byteSize with the copied queue is a better way than having two states that can separately be set.", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r611877771", "createdAt": "2021-04-12T18:56:46Z", "author": {"login": "muuki88"}, "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();\n+        resetReportEventsConditions(events);\n+        httpClient.request(HttpMethod.POST, HttpUtil.validateUrl(endpoint), headers, toGzippedBytes(copyToSend),\n+                timeoutMs)\n+                .setHandler(this::handleReportResponse);\n+    }\n+\n+    private void resetReportEventsConditions(AtomicReference<Queue<String>> events) {\n+        events.set(new ConcurrentLinkedQueue<>());\n+        byteSize.set(0);\n+        vertx.cancelTimer(reportTimerId);\n+        reportTimerId = setReportTtlTimer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "390928e863e8985c4f6e2d316110d1e91cf41721"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTQ2MTE0Ng==", "bodyText": "Since ReentrantLock is used while sending the events, imho it is quite safe to use those in such way.", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r641461146", "createdAt": "2021-05-28T10:58:06Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();\n+        resetReportEventsConditions(events);\n+        httpClient.request(HttpMethod.POST, HttpUtil.validateUrl(endpoint), headers, toGzippedBytes(copyToSend),\n+                timeoutMs)\n+                .setHandler(this::handleReportResponse);\n+    }\n+\n+    private void resetReportEventsConditions(AtomicReference<Queue<String>> events) {\n+        events.set(new ConcurrentLinkedQueue<>());\n+        byteSize.set(0);\n+        vertx.cancelTimer(reportTimerId);\n+        reportTimerId = setReportTtlTimer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3Nzc3MQ=="}, "originalCommit": {"oid": "390928e863e8985c4f6e2d316110d1e91cf41721"}, "originalPosition": 142}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3809, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}