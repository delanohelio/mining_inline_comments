{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMzYwNTQx", "number": 728, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDozMTo0NVrOEUoRLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNTowMDo0MVrOEUo_sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDY2NzM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDozMTo0NVrOG675KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDozMTo0NVrOG675KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1MTg4MA==", "bodyText": "Would it be better if we hide getting amp & ampData in updateAmpData(..) method?\nSeems they are not used in local fun-n.", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464451880", "createdAt": "2020-08-03T14:31:45Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -175,12 +182,23 @@ private BidRequest fillExplicitParameters(BidRequest bidRequest, RoutingContext\n                 ? debugQueryParam\n                 : null;\n \n+        final ExtRequestPrebidAmp amp = prebid != null ? prebid.getAmp() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDczMDY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0Njo1OVrOG68f2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0Njo1OVrOG68f2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MTc4NA==", "bodyText": "Minor. Pls adhere the order of method calls, so place this method declaration before extBidRequestNode(..).", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464461784", "createdAt": "2020-08-03T14:46:59Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -541,4 +567,20 @@ private ExtRequestTargeting createTargetingWithDefaults(ExtRequestPrebid prebid)\n                 .includebidderkeys(includeBidderKeys)\n                 .build();\n     }\n+\n+    private static Map<String, String> updateAmpData(Map<String, String> existingAmpData, HttpServerRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDczODY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0ODo1NVrOG68klQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMTo0NTo0NVrOG7cycw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mjk5Nw==", "bodyText": "Should we check ampQueryData for empty before composing result?\nSeems we don't need to update if no AMP-related params.", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464462997", "createdAt": "2020-08-03T14:48:55Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -541,4 +567,20 @@ private ExtRequestTargeting createTargetingWithDefaults(ExtRequestPrebid prebid)\n                 .includebidderkeys(includeBidderKeys)\n                 .build();\n     }\n+\n+    private static Map<String, String> updateAmpData(Map<String, String> existingAmpData, HttpServerRequest request) {\n+        final MultiMap queryParams = request.params();\n+        if (queryParams.isEmpty()) {\n+            return null;\n+        }\n+\n+        final Map<String, String> ampQueryData = queryParams.entries().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (value1, value2) -> value1));\n+\n+        final Map<String, String> updatedAmpData =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk2NjgxNA==", "bodyText": "Do you think that queryParams.isEmpty() check a few lines above isn't enough to cover this case?", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464966814", "createdAt": "2020-08-04T10:54:57Z", "author": {"login": "schernysh"}, "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -541,4 +567,20 @@ private ExtRequestTargeting createTargetingWithDefaults(ExtRequestPrebid prebid)\n                 .includebidderkeys(includeBidderKeys)\n                 .build();\n     }\n+\n+    private static Map<String, String> updateAmpData(Map<String, String> existingAmpData, HttpServerRequest request) {\n+        final MultiMap queryParams = request.params();\n+        if (queryParams.isEmpty()) {\n+            return null;\n+        }\n+\n+        final Map<String, String> ampQueryData = queryParams.entries().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (value1, value2) -> value1));\n+\n+        final Map<String, String> updatedAmpData =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mjk5Nw=="}, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5MDgzNQ==", "bodyText": "you're right, thanks!", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464990835", "createdAt": "2020-08-04T11:45:45Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -541,4 +567,20 @@ private ExtRequestTargeting createTargetingWithDefaults(ExtRequestPrebid prebid)\n                 .includebidderkeys(includeBidderKeys)\n                 .build();\n     }\n+\n+    private static Map<String, String> updateAmpData(Map<String, String> existingAmpData, HttpServerRequest request) {\n+        final MultiMap queryParams = request.params();\n+        if (queryParams.isEmpty()) {\n+            return null;\n+        }\n+\n+        final Map<String, String> ampQueryData = queryParams.entries().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (value1, value2) -> value1));\n+\n+        final Map<String, String> updatedAmpData =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mjk5Nw=="}, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDc2MjIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo1NDo1NVrOG68zLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo1NDo1NVrOG68zLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NjczNA==", "bodyText": "i'd rather suggest to rename extractor to resolver to in same style.", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464466734", "createdAt": "2020-08-03T14:54:55Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java", "diffHunk": "@@ -92,31 +92,64 @@\n     private final boolean includeWinners;\n     private final boolean includeBidderKeys;\n     private final boolean isApp;\n+    private final String cacheHost;\n+    private final String cachePath;\n+    private final TargetingKeywordsResolver resolver;\n+\n+    private TargetingKeywordsCreator(PriceGranularity priceGranularity,\n+                                     boolean includeWinners,\n+                                     boolean includeBidderKeys,\n+                                     boolean isApp,\n+                                     String cacheHost,\n+                                     String cachePath,\n+                                     TargetingKeywordsResolver resolver) {\n \n-    private TargetingKeywordsCreator(PriceGranularity priceGranularity, boolean includeWinners,\n-                                     boolean includeBidderKeys, boolean isApp) {\n         this.priceGranularity = priceGranularity;\n         this.includeWinners = includeWinners;\n         this.includeBidderKeys = includeBidderKeys;\n         this.isApp = isApp;\n+        this.cacheHost = cacheHost;\n+        this.cachePath = cachePath;\n+        this.resolver = resolver;\n     }\n \n     /**\n      * Creates {@link TargetingKeywordsCreator} for the given params.\n      */\n-    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity, boolean includeWinners,\n-                                                  boolean includeBidderKeys, boolean isApp) {\n-        return new TargetingKeywordsCreator(PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n-                includeWinners, includeBidderKeys, isApp);\n+    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n+                                                  boolean includeWinners,\n+                                                  boolean includeBidderKeys,\n+                                                  boolean isApp,\n+                                                  String cacheHost,\n+                                                  String cachePath,\n+                                                  TargetingKeywordsResolver extractor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDc4NjQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/prebid/server/auction/TargetingKeywordsResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNTowMDo0MVrOG69Bzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNTowMDo0MVrOG69Bzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDQ3OA==", "bodyText": "This can be inlined since there is only one usage.", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464470478", "createdAt": "2020-08-03T15:00:41Z", "author": {"login": "rpanchyk"}, "path": "src/main/java/org/prebid/server/auction/TargetingKeywordsResolver.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.prebid.server.auction;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.response.Bid;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.proto.openrtb.ext.request.ExtBidRequest;\n+import org.prebid.server.proto.openrtb.ext.request.ExtRequestPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.ExtRequestPrebidAdservertargetingRule;\n+import org.prebid.server.proto.openrtb.ext.request.ExtRequestPrebidAdservertargetingRule.Source;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+public class TargetingKeywordsResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TargetingKeywordsResolver.class);\n+\n+    public static final String IMP_PREFIX = \"imp.\";\n+    public static final String SEATBID_BID_PREFIX = \"seatbid.bid.\";\n+    public static final String BIDDER_MACRO = \"{{BIDDER}}\";\n+\n+    private final BidRequest bidRequest;\n+    private final JacksonMapper mapper;\n+\n+    private final Map<String, String> staticAndRequestKeywords;\n+    private final List<ExtRequestPrebidAdservertargetingRule> impRequestRules;\n+    private final List<ExtRequestPrebidAdservertargetingRule> responseRules;\n+\n+    private TargetingKeywordsResolver(BidRequest bidRequest, JacksonMapper mapper) {\n+        this.bidRequest = Objects.requireNonNull(bidRequest);\n+        this.mapper = Objects.requireNonNull(mapper);\n+\n+        final Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource = rulesBySource();\n+\n+        this.impRequestRules = impRequestRules(rulesBySource);\n+        this.responseRules = responseRules(rulesBySource);\n+        this.staticAndRequestKeywords = resolveStaticAndRequestKeywords(rulesBySource);\n+    }\n+\n+    public static TargetingKeywordsResolver create(BidRequest bidRequest, JacksonMapper mapper) {\n+        return new TargetingKeywordsResolver(bidRequest, mapper);\n+    }\n+\n+    public Map<String, String> resolve(Bid bid, String bidder) {\n+        final Map<String, String> result = new HashMap<>(staticAndRequestKeywords);\n+        result.putAll(resolveImpRequestKeywords(bid));\n+        result.putAll(resolveResponseKeywords(bid, bidder));\n+\n+        return result;\n+    }\n+\n+    private Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource() {\n+        final ExtBidRequest extRequest = parseExt(bidRequest.getExt());\n+        final List<ExtRequestPrebidAdservertargetingRule> rules =\n+                get(get(extRequest, ExtBidRequest::getPrebid), ExtRequestPrebid::getAdservertargeting);\n+\n+        return ObjectUtils.<List<ExtRequestPrebidAdservertargetingRule>>defaultIfNull(rules, Collections.emptyList())\n+                .stream()\n+                .filter(TargetingKeywordsResolver::isValid)\n+                .collect(Collectors.groupingBy(ExtRequestPrebidAdservertargetingRule::getSource));\n+    }\n+\n+    private static List<ExtRequestPrebidAdservertargetingRule> impRequestRules(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.bidrequest, Collections.emptyList()).stream()\n+                .filter(TargetingKeywordsResolver::hasImpPath)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static List<ExtRequestPrebidAdservertargetingRule> responseRules(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.bidresponse, Collections.emptyList()).stream()\n+                .filter(TargetingKeywordsResolver::hasSeatbidBidPath)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, String> resolveStaticAndRequestKeywords(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        final Map<String, String> result = new HashMap<>(resolveStaticKeywords(rulesBySource));\n+        result.putAll(resolveRequestKeywords(rulesBySource));\n+\n+        return result;\n+    }\n+\n+    private static Map<String, String> resolveStaticKeywords(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.xStatic, Collections.emptyList()).stream()\n+                .collect(Collectors.toMap(\n+                        ExtRequestPrebidAdservertargetingRule::getKey,\n+                        ExtRequestPrebidAdservertargetingRule::getValue,\n+                        (value1, value2) -> value2));\n+    }\n+\n+    private Map<String, String> resolveRequestKeywords(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        final List<ExtRequestPrebidAdservertargetingRule> requestRules = requestRules(rulesBySource);\n+\n+        if (!requestRules.isEmpty()) {\n+            return lookupValues(\n+                    mapper.mapper().valueToTree(bidRequest),\n+                    requestRules,\n+                    Function.identity(),\n+                    Function.identity());\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    private static List<ExtRequestPrebidAdservertargetingRule> requestRules(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.bidrequest, Collections.emptyList()).stream()\n+                .filter(rule -> !hasImpPath(rule))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, String> resolveImpRequestKeywords(Bid bid) {\n+        if (!impRequestRules.isEmpty()) {\n+            final JsonNode impNode = locateImp(bid);\n+\n+            if (impNode != null) {\n+                return lookupValues(\n+                        impNode,\n+                        impRequestRules,\n+                        value -> StringUtils.substringAfter(value, IMP_PREFIX),\n+                        Function.identity());\n+            }\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    private JsonNode locateImp(Bid bid) {\n+        final String impid = bid.getImpid();\n+        if (StringUtils.isBlank(impid)) {\n+            return null;\n+        }\n+\n+        return bidRequest.getImp().stream()\n+                .filter(imp -> Objects.equals(imp.getId(), impid))\n+                .findFirst()\n+                .<JsonNode>map(imp -> mapper.mapper().valueToTree(imp))\n+                .orElse(null);\n+    }\n+\n+    private Map<String, String> resolveResponseKeywords(Bid bid, String bidder) {\n+        if (!responseRules.isEmpty()) {\n+            final JsonNode bidNode = mapper.mapper().valueToTree(bid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef"}, "originalPosition": 165}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4068, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}