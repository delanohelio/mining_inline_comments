{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NTY5MjAx", "number": 8978, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNTowODo1N1rOD9GB3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjozOFrOD9GFag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mzg4NTEwOnYy", "diffSide": "RIGHT", "path": "OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapTransportReaderAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNTowODo1N1rOGWa2og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNTowODo1N1rOGWa2og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MTgyNg==", "bodyText": "This is not part of cachedosmandindexes so it won't work correctly with cache", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426161826", "createdAt": "2020-05-16T15:08:57Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapTransportReaderAdapter.java", "diffHunk": "@@ -43,6 +44,8 @@ private int readInt() throws IOException {\n \n \t\tint stopsFileOffset = 0;\n \t\tint stopsFileLength = 0;\n+\t\tint incompleteRoutesOffset = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4873ab04a95af48214f5db6bcfe6d9accc12425b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mzg5MjQ2OnYy", "diffSide": "RIGHT", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToxOTo1OFrOGWa6bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToxOTo1OFrOGWa6bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Mjc5OQ==", "bodyText": "???", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426162799", "createdAt": "2020-05-16T15:19:58Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -378,7 +382,7 @@ public QuadRect getSegmentRect() {\n \n \t\tpublic List<Way> getGeometry() {\n \t\t\tList<Way> list = new ArrayList<>();\n-\t\t\troute.mergeForwardWays();\n+\t\t\troute.mergeForwardWays(); //TODO merge ways of all Route parts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mzg5MzgyOnYy", "diffSide": "RIGHT", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxNVrOGWa7NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxNVrOGWa7NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Mjk5Nw==", "bodyText": "TODO", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426162997", "createdAt": "2020-05-16T15:22:15Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -903,7 +923,229 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \n \t\t\treturn stops;\n \t\t}\n+\t\t\n+\t\tprivate TransportRoute getCombinedRoute(TransportRoute route) throws IOException {\n+\t\t\tif (!route.isIncomplete()) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\tTransportRoute c = combinedRoutesCache.get(route.getId());\n+\t\t\tif (c == null) {\n+\t\t\t\tc = combineRoute(route);\n+\t\t\t\tcombinedRoutesCache.put(route.getId(), c);\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t} \n+\n+\t\tprivate TransportRoute combineRoute(TransportRoute route) throws IOException {\n+\t\t\t// 1. Get all available route parts;\n+\t\t\tList<TransportRoute> incompleteRoutes = findIncompleteRouteParts(route);\n+\t\t\tif (incompleteRoutes == null) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\t// here could be multiple overlays between same points\n+\t\t\t// It's better to remove them especially identical segments\n+\t\t\tList<Way> allWays = getAllWays(incompleteRoutes);\n+\t\t\t\n+\t\t\t\n+\t\t\t// 2. Get array of segments (each array size > 1):\n+\t\t\tLinkedList<List<TransportStop>> stopSegments = parseRoutePartsToSegments(incompleteRoutes);\n+\t\t\t\n+\t\t\t// 3. Merge segments and remove excess missingStops (when they are closer then MISSING_STOP_SEARCH_RADIUS):\n+\t\t\t//    + Check for missingStops. If they present in the middle/there more then one segment - we have a hole in the  map data\n+\t\t\tList<List<TransportStop>> mergedSegments = combineSegmentsOfSameRoute(stopSegments);\n+\t\t\t\n+\t\t\t// 4. Now we need to properly sort segments, proper sorting is minimizing distance between stops\n+\t\t\t// So it is salesman problem, we have this solution at TspAnt, but if we know last or first segment we can solve it straightforward\n+\t\t\tList<TransportStop> firstSegment = null;\n+\t\t\tList<TransportStop> lastSegment = null;\n+\t\t\tfor(List<TransportStop> l : mergedSegments) {\n+\t\t\t\tif(!l.get(0).isMissingStop()) {\n+\t\t\t\t\tfirstSegment = l;\n+\t\t\t\t} \n+\t\t\t\tif(!l.get(l.size() - 1).isMissingStop()) {\n+\t\t\t\t\tlastSegment = l;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tList<List<TransportStop>> sortedSegments = new ArrayList<List<TransportStop>>(); \n+\t\t\tif(firstSegment != null) {\n+\t\t\t\tsortedSegments.add(firstSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> last = sortedSegments.get(sortedSegments.size() - 1);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(last.get(last.size() - 1).getLocation(), mergedSegments, true);\n+\t\t\t\t\tsortedSegments.add(add);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t} else if(lastSegment != null) {\n+\t\t\t\tsortedSegments.add(lastSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> first = sortedSegments.get(0);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(first.get(0).getLocation(), mergedSegments, false);\n+\t\t\t\t\tsortedSegments.add(0, add);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsortedSegments = mergedSegments;\n+\t\t\t}\n+\t\t\tList<TransportStop> finalList = new ArrayList<TransportStop>();\n+\t\t\tfor(List<TransportStop> s : sortedSegments) {\n+\t\t\t\tfinalList.addAll(s);\n+\t\t\t}\n+\t\t\t// 5. Create combined TransportRoute and return it\n+\t\t\treturn new TransportRoute(route, finalList, allWays);\n+\t\t}\n+\n+\t\tprivate List<TransportStop> findAndDeleteMinDistance(LatLon location, List<List<TransportStop>> mergedSegments,\n+\t\t\t\tboolean attachToBegin) {\n+\t\t\tint ind = attachToBegin ? 0 : mergedSegments.get(0).size() - 1;\n+\t\t\tdouble minDist = MapUtils.getDistance(mergedSegments.get(0).get(ind).getLocation(), location);\n+\t\t\tint minInd = 0;\n+\t\t\tfor(int i = 1; i < mergedSegments.size(); i++) {\n+\t\t\t\tind = attachToBegin ? 0 : mergedSegments.get(i).size() - 1;\n+\t\t\t\tdouble dist = MapUtils.getDistance(mergedSegments.get(i).get(ind).getLocation(), location);\n+\t\t\t\tif(dist < minDist) {\n+\t\t\t\t\tminInd = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mergedSegments.remove(minInd);\n+\t\t}\n \n+\t\tprivate List<Way> getAllWays(List<TransportRoute> parts) {\n+\t\t\tList<Way> w = new ArrayList<Way>();\n+\t\t\tfor (TransportRoute t : parts) {\n+\t\t\t\tw.addAll(t.getForwardWays());\n+\t\t\t}\n+\t\t\treturn w;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\tprivate List<List<TransportStop>> combineSegmentsOfSameRoute(LinkedList<List<TransportStop>> segments) {\n+\t\t\tList<List<TransportStop>> resultSegments = new ArrayList<List<TransportStop>>();\n+\t\t\twhile (!segments.isEmpty()) {\n+\t\t\t\tList<TransportStop> firstSegment = segments.poll();\n+\t\t\t\tboolean merged = true;\n+\t\t\t\twhile (merged) {\n+\t\t\t\t\tmerged = false;\n+\t\t\t\t\tIterator<List<TransportStop>> it = segments.iterator();\n+\t\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\t\tList<TransportStop> segmentToMerge = it.next();\n+\t\t\t\t\t\tmerged = tryToMerge(firstSegment, segmentToMerge);\n+\t\t\t\t\t\tif (merged) {\n+\t\t\t\t\t\t\tit.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresultSegments.add(firstSegment);\n+\t\t\t}\n+\t\t\treturn resultSegments;\n+\t\t}\t\n+\t\t\n+\t\tprivate boolean tryToMerge(List<TransportStop> firstSegment, List<TransportStop> segmentToMerge) {\n+\t\t\tif(firstSegment.size() < 2 || segmentToMerge.size() < 2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t// 1st we check that segments overlap by stop\n+\t\t\tint commonStopFirst = 0;\n+\t\t\tint commonStopSecond = 0;\n+\t\t\tfor(;commonStopFirst < firstSegment.size(); commonStopFirst++) {\n+\t\t\t\tfor(; commonStopSecond < segmentToMerge.size(); commonStopSecond++ ) {\n+\t\t\t\t\tlong lid1 = firstSegment.get(commonStopFirst).getId();\n+\t\t\t\t\tlong lid2 = segmentToMerge.get(commonStopSecond).getId();\n+\t\t\t\t\tif(lid1 > 0 && lid2 == lid1) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(commonStopFirst < firstSegment.size()) {\n+\t\t\t\t// we've found common stop so we can merge based on stops\n+\t\t\t\t// merge last part first\n+\t\t\t\tif(firstSegment.size() - commonStopFirst < segmentToMerge.size() - commonStopSecond) {\n+\t\t\t\t\twhile(firstSegment.size() > commonStopFirst) {\n+\t\t\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// merge first part\n+\t\t\t\tif(commonStopFirst < commonStopSecond) {\n+\t\t\t\t\tfor(int i = 0; i < commonStopFirst; i++) {\n+\t\t\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i >= 0; i--) {\n+\t\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t\t}\t\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t// no common stops, so try to connect to the end or beginning\n+\t\t\t// beginning\n+\t\t\tboolean merged = false;\n+\t\t\tif (MapUtils.getDistance(firstSegment.get(0).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(segmentToMerge.size() - 1).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\tfor(int i = segmentToMerge.size() - 2; i >= 0; i--) {\n+\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t} else if(MapUtils.getDistance(firstSegment.get(firstSegment.size() - 1).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(0).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\tfor(int i = 1; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t}\n+\t\t\treturn merged;\n+\t\t}\n+\n+\t\t\n+\t\t\n+\t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n+\t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n+\t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n+\t\t\t// TODO check generation that are doubles\n+\t\t\tfor (TransportRoute part : routeParts) {\n+\t\t\t\tList<TransportStop> newSeg = new ArrayList<TransportStop>();\n+\t\t\t\tfor (TransportStop s : part.getForwardStops()) {\n+\t\t\t\t\tnewSeg.add(s);\n+\t\t\t\t\tif (s.isMissingStop()) {\n+\t\t\t\t\t\tif (newSeg.size() > 1) {\n+\t\t\t\t\t\t\tsegs.add(newSeg);\n+\t\t\t\t\t\t\tnewSeg = new ArrayList<TransportStop>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (newSeg.size() > 1) {\n+\t\t\t\t\tsegs.add(newSeg);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn segs;\n+\t\t}\n+\t\t\n+\t\tprivate List<TransportRoute> findIncompleteRouteParts(TransportRoute baseRoute) throws IOException {\n+\t\t\tList<TransportRoute> allRoutes = null;\n+\t\t\t// TODO completely irrelevant always reiteration over all maps (especially not in bbox of the route probabl)\n+\t\t\tfor (BinaryMapIndexReader bmir : routeMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mzg5Mzg2OnYy", "diffSide": "RIGHT", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxOVrOGWa7PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxOVrOGWa7PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzAwNQ==", "bodyText": "TODO", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426163005", "createdAt": "2020-05-16T15:22:19Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -903,7 +923,229 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \n \t\t\treturn stops;\n \t\t}\n+\t\t\n+\t\tprivate TransportRoute getCombinedRoute(TransportRoute route) throws IOException {\n+\t\t\tif (!route.isIncomplete()) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\tTransportRoute c = combinedRoutesCache.get(route.getId());\n+\t\t\tif (c == null) {\n+\t\t\t\tc = combineRoute(route);\n+\t\t\t\tcombinedRoutesCache.put(route.getId(), c);\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t} \n+\n+\t\tprivate TransportRoute combineRoute(TransportRoute route) throws IOException {\n+\t\t\t// 1. Get all available route parts;\n+\t\t\tList<TransportRoute> incompleteRoutes = findIncompleteRouteParts(route);\n+\t\t\tif (incompleteRoutes == null) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\t// here could be multiple overlays between same points\n+\t\t\t// It's better to remove them especially identical segments\n+\t\t\tList<Way> allWays = getAllWays(incompleteRoutes);\n+\t\t\t\n+\t\t\t\n+\t\t\t// 2. Get array of segments (each array size > 1):\n+\t\t\tLinkedList<List<TransportStop>> stopSegments = parseRoutePartsToSegments(incompleteRoutes);\n+\t\t\t\n+\t\t\t// 3. Merge segments and remove excess missingStops (when they are closer then MISSING_STOP_SEARCH_RADIUS):\n+\t\t\t//    + Check for missingStops. If they present in the middle/there more then one segment - we have a hole in the  map data\n+\t\t\tList<List<TransportStop>> mergedSegments = combineSegmentsOfSameRoute(stopSegments);\n+\t\t\t\n+\t\t\t// 4. Now we need to properly sort segments, proper sorting is minimizing distance between stops\n+\t\t\t// So it is salesman problem, we have this solution at TspAnt, but if we know last or first segment we can solve it straightforward\n+\t\t\tList<TransportStop> firstSegment = null;\n+\t\t\tList<TransportStop> lastSegment = null;\n+\t\t\tfor(List<TransportStop> l : mergedSegments) {\n+\t\t\t\tif(!l.get(0).isMissingStop()) {\n+\t\t\t\t\tfirstSegment = l;\n+\t\t\t\t} \n+\t\t\t\tif(!l.get(l.size() - 1).isMissingStop()) {\n+\t\t\t\t\tlastSegment = l;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tList<List<TransportStop>> sortedSegments = new ArrayList<List<TransportStop>>(); \n+\t\t\tif(firstSegment != null) {\n+\t\t\t\tsortedSegments.add(firstSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> last = sortedSegments.get(sortedSegments.size() - 1);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(last.get(last.size() - 1).getLocation(), mergedSegments, true);\n+\t\t\t\t\tsortedSegments.add(add);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t} else if(lastSegment != null) {\n+\t\t\t\tsortedSegments.add(lastSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> first = sortedSegments.get(0);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(first.get(0).getLocation(), mergedSegments, false);\n+\t\t\t\t\tsortedSegments.add(0, add);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsortedSegments = mergedSegments;\n+\t\t\t}\n+\t\t\tList<TransportStop> finalList = new ArrayList<TransportStop>();\n+\t\t\tfor(List<TransportStop> s : sortedSegments) {\n+\t\t\t\tfinalList.addAll(s);\n+\t\t\t}\n+\t\t\t// 5. Create combined TransportRoute and return it\n+\t\t\treturn new TransportRoute(route, finalList, allWays);\n+\t\t}\n+\n+\t\tprivate List<TransportStop> findAndDeleteMinDistance(LatLon location, List<List<TransportStop>> mergedSegments,\n+\t\t\t\tboolean attachToBegin) {\n+\t\t\tint ind = attachToBegin ? 0 : mergedSegments.get(0).size() - 1;\n+\t\t\tdouble minDist = MapUtils.getDistance(mergedSegments.get(0).get(ind).getLocation(), location);\n+\t\t\tint minInd = 0;\n+\t\t\tfor(int i = 1; i < mergedSegments.size(); i++) {\n+\t\t\t\tind = attachToBegin ? 0 : mergedSegments.get(i).size() - 1;\n+\t\t\t\tdouble dist = MapUtils.getDistance(mergedSegments.get(i).get(ind).getLocation(), location);\n+\t\t\t\tif(dist < minDist) {\n+\t\t\t\t\tminInd = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mergedSegments.remove(minInd);\n+\t\t}\n \n+\t\tprivate List<Way> getAllWays(List<TransportRoute> parts) {\n+\t\t\tList<Way> w = new ArrayList<Way>();\n+\t\t\tfor (TransportRoute t : parts) {\n+\t\t\t\tw.addAll(t.getForwardWays());\n+\t\t\t}\n+\t\t\treturn w;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\tprivate List<List<TransportStop>> combineSegmentsOfSameRoute(LinkedList<List<TransportStop>> segments) {\n+\t\t\tList<List<TransportStop>> resultSegments = new ArrayList<List<TransportStop>>();\n+\t\t\twhile (!segments.isEmpty()) {\n+\t\t\t\tList<TransportStop> firstSegment = segments.poll();\n+\t\t\t\tboolean merged = true;\n+\t\t\t\twhile (merged) {\n+\t\t\t\t\tmerged = false;\n+\t\t\t\t\tIterator<List<TransportStop>> it = segments.iterator();\n+\t\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\t\tList<TransportStop> segmentToMerge = it.next();\n+\t\t\t\t\t\tmerged = tryToMerge(firstSegment, segmentToMerge);\n+\t\t\t\t\t\tif (merged) {\n+\t\t\t\t\t\t\tit.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresultSegments.add(firstSegment);\n+\t\t\t}\n+\t\t\treturn resultSegments;\n+\t\t}\t\n+\t\t\n+\t\tprivate boolean tryToMerge(List<TransportStop> firstSegment, List<TransportStop> segmentToMerge) {\n+\t\t\tif(firstSegment.size() < 2 || segmentToMerge.size() < 2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t// 1st we check that segments overlap by stop\n+\t\t\tint commonStopFirst = 0;\n+\t\t\tint commonStopSecond = 0;\n+\t\t\tfor(;commonStopFirst < firstSegment.size(); commonStopFirst++) {\n+\t\t\t\tfor(; commonStopSecond < segmentToMerge.size(); commonStopSecond++ ) {\n+\t\t\t\t\tlong lid1 = firstSegment.get(commonStopFirst).getId();\n+\t\t\t\t\tlong lid2 = segmentToMerge.get(commonStopSecond).getId();\n+\t\t\t\t\tif(lid1 > 0 && lid2 == lid1) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(commonStopFirst < firstSegment.size()) {\n+\t\t\t\t// we've found common stop so we can merge based on stops\n+\t\t\t\t// merge last part first\n+\t\t\t\tif(firstSegment.size() - commonStopFirst < segmentToMerge.size() - commonStopSecond) {\n+\t\t\t\t\twhile(firstSegment.size() > commonStopFirst) {\n+\t\t\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// merge first part\n+\t\t\t\tif(commonStopFirst < commonStopSecond) {\n+\t\t\t\t\tfor(int i = 0; i < commonStopFirst; i++) {\n+\t\t\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i >= 0; i--) {\n+\t\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t\t}\t\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t// no common stops, so try to connect to the end or beginning\n+\t\t\t// beginning\n+\t\t\tboolean merged = false;\n+\t\t\tif (MapUtils.getDistance(firstSegment.get(0).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(segmentToMerge.size() - 1).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\tfor(int i = segmentToMerge.size() - 2; i >= 0; i--) {\n+\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t} else if(MapUtils.getDistance(firstSegment.get(firstSegment.size() - 1).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(0).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\tfor(int i = 1; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t}\n+\t\t\treturn merged;\n+\t\t}\n+\n+\t\t\n+\t\t\n+\t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n+\t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n+\t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n+\t\t\t// TODO check generation that are doubles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mzg5NDE4OnYy", "diffSide": "RIGHT", "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjozOFrOGWa7Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwOToyNTo0M1rOGWfh7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng==", "bodyText": "TODO why do we skip missing stop?", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426163046", "createdAt": "2020-05-16T15:22:38Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -785,18 +794,23 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \t\t\t\n \t\t\t// could be global ?\n \t\t\tTLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();\n-\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>();\n+\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>(); //reference, route\n \t\t\tfor (BinaryMapIndexReader r : routeMap.keySet()) {\n \t\t\t\tsr.clearSearchResults();\n \t\t\t\tList<TransportStop> stops = r.searchTransportIndex(sr);\n \n \t\t\t\tlocalFileRoutes.clear();\n \t\t\t\tmergeTransportStops(r, loadedTransportStops, stops, localFileRoutes, routeMap.get(r));\n-\n+\t\t\t\t\t\n \t\t\t\tfor (TransportStop stop : stops) {\n+\t\t\t\t\t// skip missing stops\n+\t\t\t\t\tif (stop.isMissingStop()) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tlong stopId = stop.getId();\n \t\t\t\t\tTransportStop multifileStop = loadedTransportStops.get(stopId);\n \t\t\t\t\tint[] rrs = stop.getReferencesToRoutes();\n+\t\t\t\t\t// TODO what is this?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3NzY3MQ==", "bodyText": "TODO why duplicate same code?", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426177671", "createdAt": "2020-05-16T18:16:12Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -785,18 +794,23 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \t\t\t\n \t\t\t// could be global ?\n \t\t\tTLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();\n-\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>();\n+\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>(); //reference, route\n \t\t\tfor (BinaryMapIndexReader r : routeMap.keySet()) {\n \t\t\t\tsr.clearSearchResults();\n \t\t\t\tList<TransportStop> stops = r.searchTransportIndex(sr);\n \n \t\t\t\tlocalFileRoutes.clear();\n \t\t\t\tmergeTransportStops(r, loadedTransportStops, stops, localFileRoutes, routeMap.get(r));\n-\n+\t\t\t\t\t\n \t\t\t\tfor (TransportStop stop : stops) {\n+\t\t\t\t\t// skip missing stops\n+\t\t\t\t\tif (stop.isMissingStop()) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tlong stopId = stop.getId();\n \t\t\t\t\tTransportStop multifileStop = loadedTransportStops.get(stopId);\n \t\t\t\t\tint[] rrs = stop.getReferencesToRoutes();\n+\t\t\t\t\t// TODO what is this?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng=="}, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzODQ0NA==", "bodyText": "I thought that we need to skip missing stops so that they were not used during route calculation as valid start/finish/change stops. But I could be wrong with the exact place of such skip. Will look into this.", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426238444", "createdAt": "2020-05-17T09:25:43Z", "author": {"login": "MadWasp79"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -785,18 +794,23 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \t\t\t\n \t\t\t// could be global ?\n \t\t\tTLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();\n-\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>();\n+\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>(); //reference, route\n \t\t\tfor (BinaryMapIndexReader r : routeMap.keySet()) {\n \t\t\t\tsr.clearSearchResults();\n \t\t\t\tList<TransportStop> stops = r.searchTransportIndex(sr);\n \n \t\t\t\tlocalFileRoutes.clear();\n \t\t\t\tmergeTransportStops(r, loadedTransportStops, stops, localFileRoutes, routeMap.get(r));\n-\n+\t\t\t\t\t\n \t\t\t\tfor (TransportStop stop : stops) {\n+\t\t\t\t\t// skip missing stops\n+\t\t\t\t\tif (stop.isMissingStop()) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tlong stopId = stop.getId();\n \t\t\t\t\tTransportStop multifileStop = loadedTransportStops.get(stopId);\n \t\t\t\t\tint[] rrs = stop.getReferencesToRoutes();\n+\t\t\t\t\t// TODO what is this?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng=="}, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3343, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}