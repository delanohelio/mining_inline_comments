{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NTY5MjAx", "number": 8978, "title": "Route merge", "bodyText": "", "createdAt": "2020-05-15T12:40:38Z", "url": "https://github.com/osmandapp/OsmAnd/pull/8978", "merged": true, "mergeCommit": {"oid": "36ae49de65ef55f08952f92fd69c2035ef6775e0"}, "closed": true, "closedAt": "2020-05-17T11:24:17Z", "author": {"login": "MadWasp79"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfSEhhAH2gAyNDE4NTY5MjAxOjg3YTdiNDJmNjZlNGQxNGFkZTgxYjY4YTY3N2ZmYTQ5NGFkOTZjMmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABciJeg9gH2gAyNDE4NTY5MjAxOjY4NGUyZDNkMzY2YTQ4ZTlhZTMzZWNhODdhNjhhYWUyOWEwYmM2Yzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "87a7b42f66e4d14ade81b68a677ffa494ad96c2e", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/87a7b42f66e4d14ade81b68a677ffa494ad96c2e", "committedDate": "2020-05-08T13:40:58Z", "message": "work in project, crude merge working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c8824341ad1c4f5df1e87da8de4c9ca9d19b014", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/2c8824341ad1c4f5df1e87da8de4c9ca9d19b014", "committedDate": "2020-05-12T09:42:12Z", "message": "work in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e56faabd1bb9610826327c94ea7e93f5250de2b", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/8e56faabd1bb9610826327c94ea7e93f5250de2b", "committedDate": "2020-05-12T09:45:18Z", "message": "Merge branch 'master' into route_merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7699e2061c75bcf13697145f79f1522c5f40ec79", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/7699e2061c75bcf13697145f79f1522c5f40ec79", "committedDate": "2020-05-13T12:09:30Z", "message": "add reading of incomplete routes. Add cache - work in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aafda798b60692a7eaaf7cd73865735c878e731", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/3aafda798b60692a7eaaf7cd73865735c878e731", "committedDate": "2020-05-13T12:12:45Z", "message": "Merge branch 'master' into route_merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3d55cec4b3c419c1bc2b5c6a8e52abf06c786d4", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/d3d55cec4b3c419c1bc2b5c6a8e52abf06c786d4", "committedDate": "2020-05-14T07:18:21Z", "message": "combine routes WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ec03040ea68f3412145d4d92f8b26cce45fcbc8", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/3ec03040ea68f3412145d4d92f8b26cce45fcbc8", "committedDate": "2020-05-15T11:36:31Z", "message": "merge route parts implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c655c4f986f192fe49d08332ba8d19d48b55b54", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/3c655c4f986f192fe49d08332ba8d19d48b55b54", "committedDate": "2020-05-15T11:39:42Z", "message": "fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fe736957dbd13abb7234c454934ceb310bf935e", "author": {"user": {"login": "MadWasp79", "name": "Denis Kolomiets"}}, "url": "https://github.com/osmandapp/OsmAnd/commit/9fe736957dbd13abb7234c454934ceb310bf935e", "committedDate": "2020-05-15T11:57:06Z", "message": "clear garbage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87f49ed3d9845e806dbd8c20b2cd19cf8d4b4e88", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/87f49ed3d9845e806dbd8c20b2cd19cf8d4b4e88", "committedDate": "2020-05-15T15:27:59Z", "message": "Transport route"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99503fdec5b1a6139bde6af4707d776779a33c78", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/99503fdec5b1a6139bde6af4707d776779a33c78", "committedDate": "2020-05-16T14:03:54Z", "message": "Update transport rotues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b456c41b341e7f1bd6c60c08abc4b0ab816770e6", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/b456c41b341e7f1bd6c60c08abc4b0ab816770e6", "committedDate": "2020-05-16T14:33:59Z", "message": "Update transport rotues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52fec9c7cc46f8455b9e13a1c36ef5e04d813b66", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/52fec9c7cc46f8455b9e13a1c36ef5e04d813b66", "committedDate": "2020-05-16T14:48:01Z", "message": "Update transport rotues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5bd6cb065ab46cdbf177773f7a90f8a8df2c67b", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/e5bd6cb065ab46cdbf177773f7a90f8a8df2c67b", "committedDate": "2020-05-16T14:49:17Z", "message": "Update transport rotues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4873ab04a95af48214f5db6bcfe6d9accc12425b", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/4873ab04a95af48214f5db6bcfe6d9accc12425b", "committedDate": "2020-05-16T14:51:51Z", "message": "Update transport rotues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDgzODMw", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#pullrequestreview-413083830", "createdAt": "2020-05-16T15:08:57Z", "commit": {"oid": "4873ab04a95af48214f5db6bcfe6d9accc12425b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNTowODo1N1rOGWa2og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNTowODo1N1rOGWa2og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MTgyNg==", "bodyText": "This is not part of cachedosmandindexes so it won't work correctly with cache", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426161826", "createdAt": "2020-05-16T15:08:57Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapTransportReaderAdapter.java", "diffHunk": "@@ -43,6 +44,8 @@ private int readInt() throws IOException {\n \n \t\tint stopsFileOffset = 0;\n \t\tint stopsFileLength = 0;\n+\t\tint incompleteRoutesOffset = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4873ab04a95af48214f5db6bcfe6d9accc12425b"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7319a235c0c778c089c9b6b935d7e27f1ea2ffb8", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/7319a235c0c778c089c9b6b935d7e27f1ea2ffb8", "committedDate": "2020-05-16T15:12:34Z", "message": "Lazy loading reading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a52767bdb3a819d2eaad2255151f02311354889e", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/a52767bdb3a819d2eaad2255151f02311354889e", "committedDate": "2020-05-16T15:17:04Z", "message": "clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/a00011693acdfa4aac0f04fd8557719a07256e29", "committedDate": "2020-05-16T15:18:58Z", "message": "clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDg0Njc5", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#pullrequestreview-413084679", "createdAt": "2020-05-16T15:19:58Z", "commit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToxOTo1OFrOGWa6bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToxOTo1OFrOGWa6bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Mjc5OQ==", "bodyText": "???", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426162799", "createdAt": "2020-05-16T15:19:58Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -378,7 +382,7 @@ public QuadRect getSegmentRect() {\n \n \t\tpublic List<Way> getGeometry() {\n \t\t\tList<Way> list = new ArrayList<>();\n-\t\t\troute.mergeForwardWays();\n+\t\t\troute.mergeForwardWays(); //TODO merge ways of all Route parts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDg0ODMx", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#pullrequestreview-413084831", "createdAt": "2020-05-16T15:22:15Z", "commit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxNVrOGWa7NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxNVrOGWa7NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Mjk5Nw==", "bodyText": "TODO", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426162997", "createdAt": "2020-05-16T15:22:15Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -903,7 +923,229 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \n \t\t\treturn stops;\n \t\t}\n+\t\t\n+\t\tprivate TransportRoute getCombinedRoute(TransportRoute route) throws IOException {\n+\t\t\tif (!route.isIncomplete()) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\tTransportRoute c = combinedRoutesCache.get(route.getId());\n+\t\t\tif (c == null) {\n+\t\t\t\tc = combineRoute(route);\n+\t\t\t\tcombinedRoutesCache.put(route.getId(), c);\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t} \n+\n+\t\tprivate TransportRoute combineRoute(TransportRoute route) throws IOException {\n+\t\t\t// 1. Get all available route parts;\n+\t\t\tList<TransportRoute> incompleteRoutes = findIncompleteRouteParts(route);\n+\t\t\tif (incompleteRoutes == null) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\t// here could be multiple overlays between same points\n+\t\t\t// It's better to remove them especially identical segments\n+\t\t\tList<Way> allWays = getAllWays(incompleteRoutes);\n+\t\t\t\n+\t\t\t\n+\t\t\t// 2. Get array of segments (each array size > 1):\n+\t\t\tLinkedList<List<TransportStop>> stopSegments = parseRoutePartsToSegments(incompleteRoutes);\n+\t\t\t\n+\t\t\t// 3. Merge segments and remove excess missingStops (when they are closer then MISSING_STOP_SEARCH_RADIUS):\n+\t\t\t//    + Check for missingStops. If they present in the middle/there more then one segment - we have a hole in the  map data\n+\t\t\tList<List<TransportStop>> mergedSegments = combineSegmentsOfSameRoute(stopSegments);\n+\t\t\t\n+\t\t\t// 4. Now we need to properly sort segments, proper sorting is minimizing distance between stops\n+\t\t\t// So it is salesman problem, we have this solution at TspAnt, but if we know last or first segment we can solve it straightforward\n+\t\t\tList<TransportStop> firstSegment = null;\n+\t\t\tList<TransportStop> lastSegment = null;\n+\t\t\tfor(List<TransportStop> l : mergedSegments) {\n+\t\t\t\tif(!l.get(0).isMissingStop()) {\n+\t\t\t\t\tfirstSegment = l;\n+\t\t\t\t} \n+\t\t\t\tif(!l.get(l.size() - 1).isMissingStop()) {\n+\t\t\t\t\tlastSegment = l;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tList<List<TransportStop>> sortedSegments = new ArrayList<List<TransportStop>>(); \n+\t\t\tif(firstSegment != null) {\n+\t\t\t\tsortedSegments.add(firstSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> last = sortedSegments.get(sortedSegments.size() - 1);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(last.get(last.size() - 1).getLocation(), mergedSegments, true);\n+\t\t\t\t\tsortedSegments.add(add);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t} else if(lastSegment != null) {\n+\t\t\t\tsortedSegments.add(lastSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> first = sortedSegments.get(0);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(first.get(0).getLocation(), mergedSegments, false);\n+\t\t\t\t\tsortedSegments.add(0, add);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsortedSegments = mergedSegments;\n+\t\t\t}\n+\t\t\tList<TransportStop> finalList = new ArrayList<TransportStop>();\n+\t\t\tfor(List<TransportStop> s : sortedSegments) {\n+\t\t\t\tfinalList.addAll(s);\n+\t\t\t}\n+\t\t\t// 5. Create combined TransportRoute and return it\n+\t\t\treturn new TransportRoute(route, finalList, allWays);\n+\t\t}\n+\n+\t\tprivate List<TransportStop> findAndDeleteMinDistance(LatLon location, List<List<TransportStop>> mergedSegments,\n+\t\t\t\tboolean attachToBegin) {\n+\t\t\tint ind = attachToBegin ? 0 : mergedSegments.get(0).size() - 1;\n+\t\t\tdouble minDist = MapUtils.getDistance(mergedSegments.get(0).get(ind).getLocation(), location);\n+\t\t\tint minInd = 0;\n+\t\t\tfor(int i = 1; i < mergedSegments.size(); i++) {\n+\t\t\t\tind = attachToBegin ? 0 : mergedSegments.get(i).size() - 1;\n+\t\t\t\tdouble dist = MapUtils.getDistance(mergedSegments.get(i).get(ind).getLocation(), location);\n+\t\t\t\tif(dist < minDist) {\n+\t\t\t\t\tminInd = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mergedSegments.remove(minInd);\n+\t\t}\n \n+\t\tprivate List<Way> getAllWays(List<TransportRoute> parts) {\n+\t\t\tList<Way> w = new ArrayList<Way>();\n+\t\t\tfor (TransportRoute t : parts) {\n+\t\t\t\tw.addAll(t.getForwardWays());\n+\t\t\t}\n+\t\t\treturn w;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\tprivate List<List<TransportStop>> combineSegmentsOfSameRoute(LinkedList<List<TransportStop>> segments) {\n+\t\t\tList<List<TransportStop>> resultSegments = new ArrayList<List<TransportStop>>();\n+\t\t\twhile (!segments.isEmpty()) {\n+\t\t\t\tList<TransportStop> firstSegment = segments.poll();\n+\t\t\t\tboolean merged = true;\n+\t\t\t\twhile (merged) {\n+\t\t\t\t\tmerged = false;\n+\t\t\t\t\tIterator<List<TransportStop>> it = segments.iterator();\n+\t\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\t\tList<TransportStop> segmentToMerge = it.next();\n+\t\t\t\t\t\tmerged = tryToMerge(firstSegment, segmentToMerge);\n+\t\t\t\t\t\tif (merged) {\n+\t\t\t\t\t\t\tit.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresultSegments.add(firstSegment);\n+\t\t\t}\n+\t\t\treturn resultSegments;\n+\t\t}\t\n+\t\t\n+\t\tprivate boolean tryToMerge(List<TransportStop> firstSegment, List<TransportStop> segmentToMerge) {\n+\t\t\tif(firstSegment.size() < 2 || segmentToMerge.size() < 2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t// 1st we check that segments overlap by stop\n+\t\t\tint commonStopFirst = 0;\n+\t\t\tint commonStopSecond = 0;\n+\t\t\tfor(;commonStopFirst < firstSegment.size(); commonStopFirst++) {\n+\t\t\t\tfor(; commonStopSecond < segmentToMerge.size(); commonStopSecond++ ) {\n+\t\t\t\t\tlong lid1 = firstSegment.get(commonStopFirst).getId();\n+\t\t\t\t\tlong lid2 = segmentToMerge.get(commonStopSecond).getId();\n+\t\t\t\t\tif(lid1 > 0 && lid2 == lid1) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(commonStopFirst < firstSegment.size()) {\n+\t\t\t\t// we've found common stop so we can merge based on stops\n+\t\t\t\t// merge last part first\n+\t\t\t\tif(firstSegment.size() - commonStopFirst < segmentToMerge.size() - commonStopSecond) {\n+\t\t\t\t\twhile(firstSegment.size() > commonStopFirst) {\n+\t\t\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// merge first part\n+\t\t\t\tif(commonStopFirst < commonStopSecond) {\n+\t\t\t\t\tfor(int i = 0; i < commonStopFirst; i++) {\n+\t\t\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i >= 0; i--) {\n+\t\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t\t}\t\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t// no common stops, so try to connect to the end or beginning\n+\t\t\t// beginning\n+\t\t\tboolean merged = false;\n+\t\t\tif (MapUtils.getDistance(firstSegment.get(0).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(segmentToMerge.size() - 1).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\tfor(int i = segmentToMerge.size() - 2; i >= 0; i--) {\n+\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t} else if(MapUtils.getDistance(firstSegment.get(firstSegment.size() - 1).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(0).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\tfor(int i = 1; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t}\n+\t\t\treturn merged;\n+\t\t}\n+\n+\t\t\n+\t\t\n+\t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n+\t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n+\t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n+\t\t\t// TODO check generation that are doubles\n+\t\t\tfor (TransportRoute part : routeParts) {\n+\t\t\t\tList<TransportStop> newSeg = new ArrayList<TransportStop>();\n+\t\t\t\tfor (TransportStop s : part.getForwardStops()) {\n+\t\t\t\t\tnewSeg.add(s);\n+\t\t\t\t\tif (s.isMissingStop()) {\n+\t\t\t\t\t\tif (newSeg.size() > 1) {\n+\t\t\t\t\t\t\tsegs.add(newSeg);\n+\t\t\t\t\t\t\tnewSeg = new ArrayList<TransportStop>();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (newSeg.size() > 1) {\n+\t\t\t\t\tsegs.add(newSeg);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn segs;\n+\t\t}\n+\t\t\n+\t\tprivate List<TransportRoute> findIncompleteRouteParts(TransportRoute baseRoute) throws IOException {\n+\t\t\tList<TransportRoute> allRoutes = null;\n+\t\t\t// TODO completely irrelevant always reiteration over all maps (especially not in bbox of the route probabl)\n+\t\t\tfor (BinaryMapIndexReader bmir : routeMap.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 402}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDg0ODM5", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#pullrequestreview-413084839", "createdAt": "2020-05-16T15:22:19Z", "commit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxOVrOGWa7PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjoxOVrOGWa7PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzAwNQ==", "bodyText": "TODO", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426163005", "createdAt": "2020-05-16T15:22:19Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -903,7 +923,229 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \n \t\t\treturn stops;\n \t\t}\n+\t\t\n+\t\tprivate TransportRoute getCombinedRoute(TransportRoute route) throws IOException {\n+\t\t\tif (!route.isIncomplete()) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\tTransportRoute c = combinedRoutesCache.get(route.getId());\n+\t\t\tif (c == null) {\n+\t\t\t\tc = combineRoute(route);\n+\t\t\t\tcombinedRoutesCache.put(route.getId(), c);\n+\t\t\t}\n+\t\t\treturn c;\n+\t\t} \n+\n+\t\tprivate TransportRoute combineRoute(TransportRoute route) throws IOException {\n+\t\t\t// 1. Get all available route parts;\n+\t\t\tList<TransportRoute> incompleteRoutes = findIncompleteRouteParts(route);\n+\t\t\tif (incompleteRoutes == null) {\n+\t\t\t\treturn route;\n+\t\t\t}\n+\t\t\t// here could be multiple overlays between same points\n+\t\t\t// It's better to remove them especially identical segments\n+\t\t\tList<Way> allWays = getAllWays(incompleteRoutes);\n+\t\t\t\n+\t\t\t\n+\t\t\t// 2. Get array of segments (each array size > 1):\n+\t\t\tLinkedList<List<TransportStop>> stopSegments = parseRoutePartsToSegments(incompleteRoutes);\n+\t\t\t\n+\t\t\t// 3. Merge segments and remove excess missingStops (when they are closer then MISSING_STOP_SEARCH_RADIUS):\n+\t\t\t//    + Check for missingStops. If they present in the middle/there more then one segment - we have a hole in the  map data\n+\t\t\tList<List<TransportStop>> mergedSegments = combineSegmentsOfSameRoute(stopSegments);\n+\t\t\t\n+\t\t\t// 4. Now we need to properly sort segments, proper sorting is minimizing distance between stops\n+\t\t\t// So it is salesman problem, we have this solution at TspAnt, but if we know last or first segment we can solve it straightforward\n+\t\t\tList<TransportStop> firstSegment = null;\n+\t\t\tList<TransportStop> lastSegment = null;\n+\t\t\tfor(List<TransportStop> l : mergedSegments) {\n+\t\t\t\tif(!l.get(0).isMissingStop()) {\n+\t\t\t\t\tfirstSegment = l;\n+\t\t\t\t} \n+\t\t\t\tif(!l.get(l.size() - 1).isMissingStop()) {\n+\t\t\t\t\tlastSegment = l;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tList<List<TransportStop>> sortedSegments = new ArrayList<List<TransportStop>>(); \n+\t\t\tif(firstSegment != null) {\n+\t\t\t\tsortedSegments.add(firstSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> last = sortedSegments.get(sortedSegments.size() - 1);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(last.get(last.size() - 1).getLocation(), mergedSegments, true);\n+\t\t\t\t\tsortedSegments.add(add);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t} else if(lastSegment != null) {\n+\t\t\t\tsortedSegments.add(lastSegment);\n+\t\t\t\twhile(!mergedSegments.isEmpty()) {\n+\t\t\t\t\tList<TransportStop> first = sortedSegments.get(0);\n+\t\t\t\t\tList<TransportStop> add = findAndDeleteMinDistance(first.get(0).getLocation(), mergedSegments, false);\n+\t\t\t\t\tsortedSegments.add(0, add);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsortedSegments = mergedSegments;\n+\t\t\t}\n+\t\t\tList<TransportStop> finalList = new ArrayList<TransportStop>();\n+\t\t\tfor(List<TransportStop> s : sortedSegments) {\n+\t\t\t\tfinalList.addAll(s);\n+\t\t\t}\n+\t\t\t// 5. Create combined TransportRoute and return it\n+\t\t\treturn new TransportRoute(route, finalList, allWays);\n+\t\t}\n+\n+\t\tprivate List<TransportStop> findAndDeleteMinDistance(LatLon location, List<List<TransportStop>> mergedSegments,\n+\t\t\t\tboolean attachToBegin) {\n+\t\t\tint ind = attachToBegin ? 0 : mergedSegments.get(0).size() - 1;\n+\t\t\tdouble minDist = MapUtils.getDistance(mergedSegments.get(0).get(ind).getLocation(), location);\n+\t\t\tint minInd = 0;\n+\t\t\tfor(int i = 1; i < mergedSegments.size(); i++) {\n+\t\t\t\tind = attachToBegin ? 0 : mergedSegments.get(i).size() - 1;\n+\t\t\t\tdouble dist = MapUtils.getDistance(mergedSegments.get(i).get(ind).getLocation(), location);\n+\t\t\t\tif(dist < minDist) {\n+\t\t\t\t\tminInd = i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mergedSegments.remove(minInd);\n+\t\t}\n \n+\t\tprivate List<Way> getAllWays(List<TransportRoute> parts) {\n+\t\t\tList<Way> w = new ArrayList<Way>();\n+\t\t\tfor (TransportRoute t : parts) {\n+\t\t\t\tw.addAll(t.getForwardWays());\n+\t\t\t}\n+\t\t\treturn w;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\tprivate List<List<TransportStop>> combineSegmentsOfSameRoute(LinkedList<List<TransportStop>> segments) {\n+\t\t\tList<List<TransportStop>> resultSegments = new ArrayList<List<TransportStop>>();\n+\t\t\twhile (!segments.isEmpty()) {\n+\t\t\t\tList<TransportStop> firstSegment = segments.poll();\n+\t\t\t\tboolean merged = true;\n+\t\t\t\twhile (merged) {\n+\t\t\t\t\tmerged = false;\n+\t\t\t\t\tIterator<List<TransportStop>> it = segments.iterator();\n+\t\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\t\tList<TransportStop> segmentToMerge = it.next();\n+\t\t\t\t\t\tmerged = tryToMerge(firstSegment, segmentToMerge);\n+\t\t\t\t\t\tif (merged) {\n+\t\t\t\t\t\t\tit.remove();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresultSegments.add(firstSegment);\n+\t\t\t}\n+\t\t\treturn resultSegments;\n+\t\t}\t\n+\t\t\n+\t\tprivate boolean tryToMerge(List<TransportStop> firstSegment, List<TransportStop> segmentToMerge) {\n+\t\t\tif(firstSegment.size() < 2 || segmentToMerge.size() < 2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t// 1st we check that segments overlap by stop\n+\t\t\tint commonStopFirst = 0;\n+\t\t\tint commonStopSecond = 0;\n+\t\t\tfor(;commonStopFirst < firstSegment.size(); commonStopFirst++) {\n+\t\t\t\tfor(; commonStopSecond < segmentToMerge.size(); commonStopSecond++ ) {\n+\t\t\t\t\tlong lid1 = firstSegment.get(commonStopFirst).getId();\n+\t\t\t\t\tlong lid2 = segmentToMerge.get(commonStopSecond).getId();\n+\t\t\t\t\tif(lid1 > 0 && lid2 == lid1) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(commonStopFirst < firstSegment.size()) {\n+\t\t\t\t// we've found common stop so we can merge based on stops\n+\t\t\t\t// merge last part first\n+\t\t\t\tif(firstSegment.size() - commonStopFirst < segmentToMerge.size() - commonStopSecond) {\n+\t\t\t\t\twhile(firstSegment.size() > commonStopFirst) {\n+\t\t\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// merge first part\n+\t\t\t\tif(commonStopFirst < commonStopSecond) {\n+\t\t\t\t\tfor(int i = 0; i < commonStopFirst; i++) {\n+\t\t\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\t\t}\n+\t\t\t\t\tfor(int i = commonStopSecond; i >= 0; i--) {\n+\t\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t\t}\t\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t\t\n+\t\t\t}\n+\t\t\t// no common stops, so try to connect to the end or beginning\n+\t\t\t// beginning\n+\t\t\tboolean merged = false;\n+\t\t\tif (MapUtils.getDistance(firstSegment.get(0).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(segmentToMerge.size() - 1).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(0);\n+\t\t\t\tfor(int i = segmentToMerge.size() - 2; i >= 0; i--) {\n+\t\t\t\t\tfirstSegment.add(0, segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t} else if(MapUtils.getDistance(firstSegment.get(firstSegment.size() - 1).getLocation(),\n+\t\t\t\t\tsegmentToMerge.get(0).getLocation()) < MISSING_STOP_SEARCH_RADIUS) {\n+\t\t\t\tfirstSegment.remove(firstSegment.size() - 1);\n+\t\t\t\tfor(int i = 1; i < segmentToMerge.size(); i++) {\n+\t\t\t\t\tfirstSegment.add(segmentToMerge.get(i));\n+\t\t\t\t}\n+\t\t\t\tmerged = true;\n+\t\t\t}\n+\t\t\treturn merged;\n+\t\t}\n+\n+\t\t\n+\t\t\n+\t\tprivate LinkedList<List<TransportStop>> parseRoutePartsToSegments(List<TransportRoute> routeParts) {\n+\t\t\tLinkedList<List<TransportStop>> segs = new LinkedList<List<TransportStop>>();\n+\t\t\t// here we assume that missing stops come in pairs <A, B, C, MISSING, MISSING, D, E...>\n+\t\t\t// TODO check generation that are doubles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 380}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDg0ODY1", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#pullrequestreview-413084865", "createdAt": "2020-05-16T15:22:38Z", "commit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjozOFrOGWa7Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxNToyMjozOFrOGWa7Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzA0Ng==", "bodyText": "TODO why do we skip missing stop?", "url": "https://github.com/osmandapp/OsmAnd/pull/8978#discussion_r426163046", "createdAt": "2020-05-16T15:22:38Z", "author": {"login": "vshcherb"}, "path": "OsmAnd-java/src/main/java/net/osmand/router/TransportRoutePlanner.java", "diffHunk": "@@ -785,18 +794,23 @@ public TransportRoutingContext(TransportRoutingConfiguration cfg, NativeLibrary\n \t\t\t\n \t\t\t// could be global ?\n \t\t\tTLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();\n-\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>();\n+\t\t\tTIntObjectHashMap<TransportRoute> localFileRoutes = new TIntObjectHashMap<>(); //reference, route\n \t\t\tfor (BinaryMapIndexReader r : routeMap.keySet()) {\n \t\t\t\tsr.clearSearchResults();\n \t\t\t\tList<TransportStop> stops = r.searchTransportIndex(sr);\n \n \t\t\t\tlocalFileRoutes.clear();\n \t\t\t\tmergeTransportStops(r, loadedTransportStops, stops, localFileRoutes, routeMap.get(r));\n-\n+\t\t\t\t\t\n \t\t\t\tfor (TransportStop stop : stops) {\n+\t\t\t\t\t// skip missing stops\n+\t\t\t\t\tif (stop.isMissingStop()) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tlong stopId = stop.getId();\n \t\t\t\t\tTransportStop multifileStop = loadedTransportStops.get(stopId);\n \t\t\t\t\tint[] rrs = stop.getReferencesToRoutes();\n+\t\t\t\t\t// TODO what is this?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a00011693acdfa4aac0f04fd8557719a07256e29"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15ce3fa998e7b65a3943ccef337e141a7fec0944", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/15ce3fa998e7b65a3943ccef337e141a7fec0944", "committedDate": "2020-05-16T17:57:11Z", "message": "Add incomplete stops to cached indexes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d96394a0e19c13d589f988987944523814041c8", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/0d96394a0e19c13d589f988987944523814041c8", "committedDate": "2020-05-16T18:15:16Z", "message": "Udpate planner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a01a4ad63e24e96f37d125b22803513989cf9832", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/a01a4ad63e24e96f37d125b22803513989cf9832", "committedDate": "2020-05-16T19:28:00Z", "message": "Fix broken geometry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f529dfad5d0989c7695ea18c0949832b83e7002b", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/f529dfad5d0989c7695ea18c0949832b83e7002b", "committedDate": "2020-05-16T20:24:08Z", "message": "Optimize drawing geometry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee1f8c683b544861d646053e5e75afd0d140a7ba", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/ee1f8c683b544861d646053e5e75afd0d140a7ba", "committedDate": "2020-05-16T20:35:30Z", "message": "Optimize drawing geometry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30fe9c86983c46593d4610c9a90623e0cfecec7a", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/30fe9c86983c46593d4610c9a90623e0cfecec7a", "committedDate": "2020-05-16T20:41:21Z", "message": "Add more info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7589610a278f86fe3eaeca86f02dcba21e0ed074", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/7589610a278f86fe3eaeca86f02dcba21e0ed074", "committedDate": "2020-05-16T20:55:40Z", "message": "Fix routing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "684e2d3d366a48e9ae33eca87a68aae29a0bc6c9", "author": {"user": {"login": "vshcherb", "name": null}}, "url": "https://github.com/osmandapp/OsmAnd/commit/684e2d3d366a48e9ae33eca87a68aae29a0bc6c9", "committedDate": "2020-05-17T11:21:59Z", "message": "Fix routing"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3523, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}