{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwNjgyMTg3", "number": 456, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo1Mjo1MFrOE8wiVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo1Mjo1MFrOE8wiVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTQ1MjM3OnYy", "diffSide": "RIGHT", "path": "process-optaplanner-quarkus/src/main/java/org/kie/kogito/examples/service/FlightSeatingSolveService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo1Mjo1MFrOH5Ehaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowMzo0M1rOH5FDNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDk3MQ==", "bodyText": "If an error occurs, does the user somehow get told in the UI that it did? (and kind of of error it was?)\nOr does the error get swept under the carpet?", "url": "https://github.com/kiegroup/kogito-examples/pull/456#discussion_r529604971", "createdAt": "2020-11-24T14:52:50Z", "author": {"login": "ge0ffrey"}, "path": "process-optaplanner-quarkus/src/main/java/org/kie/kogito/examples/service/FlightSeatingSolveService.java", "diffHunk": "@@ -39,23 +36,17 @@\n     Process<?> process;\n \n     public void assignSeats(String id, Flight problem) {\n-        SolverJob<Flight, String> solverJob = solverManager.solveAndListen(id, (problemId) -> problem, (bestSolution) -> {\n-            process.instances().findById(id).ifPresent(pi -> {\n-                pi.send(Sig.of(\"newSolution\", bestSolution));\n-            });\n-        });\n-\n-        // TODO: Workaround for https://issues.redhat.com/browse/PLANNER-1868\n-        // Wait for solving to finish in new thread (so we don't block the return)\n-        new Thread(() -> {\n-            try {\n-                Flight finalBestSolution = solverJob.getFinalBestSolution();\n-                process.instances().findById(id).ifPresent(pi -> {\n-                    pi.send(Sig.of(\"solvingTerminated\", finalBestSolution));\n-                });\n-            } catch (InterruptedException | ExecutionException e) {\n-                e.printStackTrace();\n-            }\n-        }).start();\n+        solverManager.solveAndListen(id, (problemId) -> problem, bestSolution -> {\n+                                         process.instances().findById(id).ifPresent(pi -> {\n+                                             pi.send(Sig.of(\"newSolution\", bestSolution));\n+                                         });\n+                                     }, finalBestSolution -> {\n+                                         process.instances().findById(id).ifPresent(pi -> {\n+                                             pi.send(Sig.of(\"solvingTerminated\", finalBestSolution));\n+                                         });\n+                                     },\n+                                     (message, exception) -> {\n+                                         process.instances().findById(id).ifPresent(ProcessInstance::abort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae1c8acf9cbc51d6251c91ca56999334ba18b7a5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMTUzNA==", "bodyText": "In this case, we would need to save the exception somewhere as this exception will happen AFTER the REST call returns (so even if we did throw it, the REST call have no way of knowing). The flight will disappear from the UI. So we would need to poll a new REST endpoint for errors.", "url": "https://github.com/kiegroup/kogito-examples/pull/456#discussion_r529611534", "createdAt": "2020-11-24T15:01:01Z", "author": {"login": "Christopher-Chianelli"}, "path": "process-optaplanner-quarkus/src/main/java/org/kie/kogito/examples/service/FlightSeatingSolveService.java", "diffHunk": "@@ -39,23 +36,17 @@\n     Process<?> process;\n \n     public void assignSeats(String id, Flight problem) {\n-        SolverJob<Flight, String> solverJob = solverManager.solveAndListen(id, (problemId) -> problem, (bestSolution) -> {\n-            process.instances().findById(id).ifPresent(pi -> {\n-                pi.send(Sig.of(\"newSolution\", bestSolution));\n-            });\n-        });\n-\n-        // TODO: Workaround for https://issues.redhat.com/browse/PLANNER-1868\n-        // Wait for solving to finish in new thread (so we don't block the return)\n-        new Thread(() -> {\n-            try {\n-                Flight finalBestSolution = solverJob.getFinalBestSolution();\n-                process.instances().findById(id).ifPresent(pi -> {\n-                    pi.send(Sig.of(\"solvingTerminated\", finalBestSolution));\n-                });\n-            } catch (InterruptedException | ExecutionException e) {\n-                e.printStackTrace();\n-            }\n-        }).start();\n+        solverManager.solveAndListen(id, (problemId) -> problem, bestSolution -> {\n+                                         process.instances().findById(id).ifPresent(pi -> {\n+                                             pi.send(Sig.of(\"newSolution\", bestSolution));\n+                                         });\n+                                     }, finalBestSolution -> {\n+                                         process.instances().findById(id).ifPresent(pi -> {\n+                                             pi.send(Sig.of(\"solvingTerminated\", finalBestSolution));\n+                                         });\n+                                     },\n+                                     (message, exception) -> {\n+                                         process.instances().findById(id).ifPresent(ProcessInstance::abort);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDk3MQ=="}, "originalCommit": {"oid": "ae1c8acf9cbc51d6251c91ca56999334ba18b7a5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzYyMw==", "bodyText": "(for errors thrown during REST call invocation, those are shown in the UI already; for an error that occurs in this place, no exception is shown in the UI as it isn't thrown + it requires a new REST endpoint to work (or does Kogito generate an process aborted REST endpoint?)", "url": "https://github.com/kiegroup/kogito-examples/pull/456#discussion_r529613623", "createdAt": "2020-11-24T15:03:43Z", "author": {"login": "Christopher-Chianelli"}, "path": "process-optaplanner-quarkus/src/main/java/org/kie/kogito/examples/service/FlightSeatingSolveService.java", "diffHunk": "@@ -39,23 +36,17 @@\n     Process<?> process;\n \n     public void assignSeats(String id, Flight problem) {\n-        SolverJob<Flight, String> solverJob = solverManager.solveAndListen(id, (problemId) -> problem, (bestSolution) -> {\n-            process.instances().findById(id).ifPresent(pi -> {\n-                pi.send(Sig.of(\"newSolution\", bestSolution));\n-            });\n-        });\n-\n-        // TODO: Workaround for https://issues.redhat.com/browse/PLANNER-1868\n-        // Wait for solving to finish in new thread (so we don't block the return)\n-        new Thread(() -> {\n-            try {\n-                Flight finalBestSolution = solverJob.getFinalBestSolution();\n-                process.instances().findById(id).ifPresent(pi -> {\n-                    pi.send(Sig.of(\"solvingTerminated\", finalBestSolution));\n-                });\n-            } catch (InterruptedException | ExecutionException e) {\n-                e.printStackTrace();\n-            }\n-        }).start();\n+        solverManager.solveAndListen(id, (problemId) -> problem, bestSolution -> {\n+                                         process.instances().findById(id).ifPresent(pi -> {\n+                                             pi.send(Sig.of(\"newSolution\", bestSolution));\n+                                         });\n+                                     }, finalBestSolution -> {\n+                                         process.instances().findById(id).ifPresent(pi -> {\n+                                             pi.send(Sig.of(\"solvingTerminated\", finalBestSolution));\n+                                         });\n+                                     },\n+                                     (message, exception) -> {\n+                                         process.instances().findById(id).ifPresent(ProcessInstance::abort);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNDk3MQ=="}, "originalCommit": {"oid": "ae1c8acf9cbc51d6251c91ca56999334ba18b7a5"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 367, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}