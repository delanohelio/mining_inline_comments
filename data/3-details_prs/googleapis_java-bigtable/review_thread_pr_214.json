{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTU4MjM3", "number": 214, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTowOToyNFrODt_5vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozMToyMlrOD8nsHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTU5NDg1OnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTowOToyNFrOF_v7aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTowOToyNFrOF_v7aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM4OTg2Nw==", "bodyText": "add*", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r402389867", "createdAt": "2020-04-02T15:09:24Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "diffHunk": "@@ -117,22 +119,64 @@\n \n   public static EnhancedBigtableStub create(EnhancedBigtableStubSettings settings)\n       throws IOException {\n-    ClientContext clientContext = ClientContext.create(settings);\n \n     return new EnhancedBigtableStub(\n-        settings, clientContext, Tags.getTagger(), Stats.getStatsRecorder());\n+        settings, ClientContext.create(settings), Tags.getTagger(), Stats.getStatsRecorder());\n   }\n \n   @InternalApi(\"Visible for testing\")\n-  private EnhancedBigtableStub(\n+  public EnhancedBigtableStub(\n       EnhancedBigtableStubSettings settings,\n       ClientContext clientContext,\n       Tagger tagger,\n       StatsRecorder statsRecorder) {\n     this.settings = settings;\n-    this.clientContext = clientContext;\n-    this.tagger = tagger;\n-    this.statsRecorder = statsRecorder;\n+\n+    this.clientContext =\n+        clientContext\n+            .toBuilder()\n+            .setTracerFactory(\n+                new CompositeTracerFactory(\n+                    ImmutableList.of(\n+                        // Ad OpenCensus Tracing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fcc4da89014f81bb4b09bc4667856ecfe02c84"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTYwNDA1OnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToxMToyMlrOF_wBSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNDoxNVrOF_wnbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5MTM2OA==", "bodyText": "is nextAttemptDelay used anywhere?", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r402391368", "createdAt": "2020-04-02T15:11:22Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracer.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.cloud.bigtable.data.v2.stub.metrics;\n+\n+import com.google.api.gax.tracing.ApiTracer;\n+import com.google.api.gax.tracing.ApiTracerFactory.OperationType;\n+import com.google.api.gax.tracing.SpanName;\n+import com.google.common.base.Stopwatch;\n+import io.opencensus.stats.MeasureMap;\n+import io.opencensus.stats.StatsRecorder;\n+import io.opencensus.tags.TagContext;\n+import io.opencensus.tags.TagContextBuilder;\n+import io.opencensus.tags.TagKey;\n+import io.opencensus.tags.TagValue;\n+import io.opencensus.tags.Tagger;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import org.threeten.bp.Duration;\n+\n+class MetricsTracer implements ApiTracer {\n+  private final OperationType operationType;\n+\n+  private final Tagger tagger;\n+  private final StatsRecorder stats;\n+\n+  // Tags\n+  private final TagContext parentContext;\n+  private final SpanName spanName;\n+  private final Map<TagKey, TagValue> statsAttributes;\n+\n+  // Operation level metrics\n+  private final AtomicBoolean opFinished = new AtomicBoolean();\n+  private final Stopwatch operationTimer = Stopwatch.createStarted();\n+  private final Stopwatch firstResponsePerOpTimer = Stopwatch.createStarted();\n+  private long operationResponseCount = 0;\n+\n+  // Attempt level metrics\n+  private int attemptCount = 0;\n+  private Stopwatch attemptTimer;\n+  private long attemptResponseCount = 0;\n+\n+  MetricsTracer(\n+      OperationType operationType,\n+      Tagger tagger,\n+      StatsRecorder stats,\n+      SpanName spanName,\n+      Map<TagKey, TagValue> statsAttributes) {\n+    this.operationType = operationType;\n+    this.tagger = tagger;\n+    this.stats = stats;\n+    this.parentContext = tagger.getCurrentTagContext();\n+    this.spanName = spanName;\n+    this.statsAttributes = statsAttributes;\n+  }\n+\n+  @Override\n+  public Scope inScope() {\n+    return new Scope() {\n+      @Override\n+      public void close() {}\n+    };\n+  }\n+\n+  @Override\n+  public void operationSucceeded() {\n+    recordOperationCompletion(null);\n+  }\n+\n+  @Override\n+  public void operationCancelled() {\n+    recordOperationCompletion(new CancellationException());\n+  }\n+\n+  @Override\n+  public void operationFailed(Throwable throwable) {\n+    recordOperationCompletion(throwable);\n+  }\n+\n+  private void recordOperationCompletion(@Nullable Throwable throwable) {\n+    if (!opFinished.compareAndSet(false, true)) {\n+      return;\n+    }\n+    operationTimer.stop();\n+\n+    long elapsed = operationTimer.elapsed(TimeUnit.MILLISECONDS);\n+\n+    MeasureMap measures =\n+        stats\n+            .newMeasureMap()\n+            .put(RpcMeasureConstants.BIGTABLE_OP_LATENCY, elapsed)\n+            .put(RpcMeasureConstants.BIGTABLE_OP_ATTEMPT_COUNT, attemptCount);\n+\n+    if (operationType == OperationType.ServerStreaming\n+        && spanName.getMethodName().equals(\"ReadRows\")) {\n+      measures.put(\n+          RpcMeasureConstants.BIGTABLE_READ_ROWS_FIRST_ROW_LATENCY,\n+          firstResponsePerOpTimer.elapsed(TimeUnit.MILLISECONDS));\n+    }\n+\n+    TagContextBuilder tagCtx =\n+        newTagCtxBuilder()\n+            .putLocal(RpcMeasureConstants.BIGTABLE_STATUS, Util.extractStatus(throwable));\n+\n+    measures.record(tagCtx.build());\n+  }\n+\n+  @Override\n+  public void connectionSelected(String s) {\n+    // noop: cardinality for connection ids is too high to use as tags\n+  }\n+\n+  @Override\n+  public void attemptStarted(int i) {\n+    attemptCount++;\n+    attemptTimer = Stopwatch.createStarted();\n+    attemptResponseCount = 0;\n+  }\n+\n+  @Override\n+  public void attemptSucceeded() {\n+    recordAttemptCompletion(null, null);\n+  }\n+\n+  @Override\n+  public void attemptCancelled() {\n+    recordAttemptCompletion(new CancellationException(), null);\n+  }\n+\n+  @Override\n+  public void attemptFailed(Throwable throwable, Duration duration) {\n+    recordAttemptCompletion(throwable, duration);\n+  }\n+\n+  @Override\n+  public void attemptFailedRetriesExhausted(Throwable throwable) {\n+    recordAttemptCompletion(throwable, null);\n+  }\n+\n+  @Override\n+  public void attemptPermanentFailure(Throwable throwable) {\n+    recordAttemptCompletion(throwable, null);\n+  }\n+\n+  private void recordAttemptCompletion(\n+      @Nullable Throwable throwable, @Nullable Duration nextAttemptDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78fcc4da89014f81bb4b09bc4667856ecfe02c84"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5OTMxNw==", "bodyText": "No, but it's part of the ApiTracer interface and  can be used to record delay", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r402399317", "createdAt": "2020-04-02T15:21:52Z", "author": {"login": "igorbernstein2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracer.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.cloud.bigtable.data.v2.stub.metrics;\n+\n+import com.google.api.gax.tracing.ApiTracer;\n+import com.google.api.gax.tracing.ApiTracerFactory.OperationType;\n+import com.google.api.gax.tracing.SpanName;\n+import com.google.common.base.Stopwatch;\n+import io.opencensus.stats.MeasureMap;\n+import io.opencensus.stats.StatsRecorder;\n+import io.opencensus.tags.TagContext;\n+import io.opencensus.tags.TagContextBuilder;\n+import io.opencensus.tags.TagKey;\n+import io.opencensus.tags.TagValue;\n+import io.opencensus.tags.Tagger;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import org.threeten.bp.Duration;\n+\n+class MetricsTracer implements ApiTracer {\n+  private final OperationType operationType;\n+\n+  private final Tagger tagger;\n+  private final StatsRecorder stats;\n+\n+  // Tags\n+  private final TagContext parentContext;\n+  private final SpanName spanName;\n+  private final Map<TagKey, TagValue> statsAttributes;\n+\n+  // Operation level metrics\n+  private final AtomicBoolean opFinished = new AtomicBoolean();\n+  private final Stopwatch operationTimer = Stopwatch.createStarted();\n+  private final Stopwatch firstResponsePerOpTimer = Stopwatch.createStarted();\n+  private long operationResponseCount = 0;\n+\n+  // Attempt level metrics\n+  private int attemptCount = 0;\n+  private Stopwatch attemptTimer;\n+  private long attemptResponseCount = 0;\n+\n+  MetricsTracer(\n+      OperationType operationType,\n+      Tagger tagger,\n+      StatsRecorder stats,\n+      SpanName spanName,\n+      Map<TagKey, TagValue> statsAttributes) {\n+    this.operationType = operationType;\n+    this.tagger = tagger;\n+    this.stats = stats;\n+    this.parentContext = tagger.getCurrentTagContext();\n+    this.spanName = spanName;\n+    this.statsAttributes = statsAttributes;\n+  }\n+\n+  @Override\n+  public Scope inScope() {\n+    return new Scope() {\n+      @Override\n+      public void close() {}\n+    };\n+  }\n+\n+  @Override\n+  public void operationSucceeded() {\n+    recordOperationCompletion(null);\n+  }\n+\n+  @Override\n+  public void operationCancelled() {\n+    recordOperationCompletion(new CancellationException());\n+  }\n+\n+  @Override\n+  public void operationFailed(Throwable throwable) {\n+    recordOperationCompletion(throwable);\n+  }\n+\n+  private void recordOperationCompletion(@Nullable Throwable throwable) {\n+    if (!opFinished.compareAndSet(false, true)) {\n+      return;\n+    }\n+    operationTimer.stop();\n+\n+    long elapsed = operationTimer.elapsed(TimeUnit.MILLISECONDS);\n+\n+    MeasureMap measures =\n+        stats\n+            .newMeasureMap()\n+            .put(RpcMeasureConstants.BIGTABLE_OP_LATENCY, elapsed)\n+            .put(RpcMeasureConstants.BIGTABLE_OP_ATTEMPT_COUNT, attemptCount);\n+\n+    if (operationType == OperationType.ServerStreaming\n+        && spanName.getMethodName().equals(\"ReadRows\")) {\n+      measures.put(\n+          RpcMeasureConstants.BIGTABLE_READ_ROWS_FIRST_ROW_LATENCY,\n+          firstResponsePerOpTimer.elapsed(TimeUnit.MILLISECONDS));\n+    }\n+\n+    TagContextBuilder tagCtx =\n+        newTagCtxBuilder()\n+            .putLocal(RpcMeasureConstants.BIGTABLE_STATUS, Util.extractStatus(throwable));\n+\n+    measures.record(tagCtx.build());\n+  }\n+\n+  @Override\n+  public void connectionSelected(String s) {\n+    // noop: cardinality for connection ids is too high to use as tags\n+  }\n+\n+  @Override\n+  public void attemptStarted(int i) {\n+    attemptCount++;\n+    attemptTimer = Stopwatch.createStarted();\n+    attemptResponseCount = 0;\n+  }\n+\n+  @Override\n+  public void attemptSucceeded() {\n+    recordAttemptCompletion(null, null);\n+  }\n+\n+  @Override\n+  public void attemptCancelled() {\n+    recordAttemptCompletion(new CancellationException(), null);\n+  }\n+\n+  @Override\n+  public void attemptFailed(Throwable throwable, Duration duration) {\n+    recordAttemptCompletion(throwable, duration);\n+  }\n+\n+  @Override\n+  public void attemptFailedRetriesExhausted(Throwable throwable) {\n+    recordAttemptCompletion(throwable, null);\n+  }\n+\n+  @Override\n+  public void attemptPermanentFailure(Throwable throwable) {\n+    recordAttemptCompletion(throwable, null);\n+  }\n+\n+  private void recordAttemptCompletion(\n+      @Nullable Throwable throwable, @Nullable Duration nextAttemptDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5MTM2OA=="}, "originalCommit": {"oid": "78fcc4da89014f81bb4b09bc4667856ecfe02c84"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMTEzMw==", "bodyText": "Actually you are right, its unnecessary", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r402401133", "createdAt": "2020-04-02T15:24:15Z", "author": {"login": "igorbernstein2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracer.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.cloud.bigtable.data.v2.stub.metrics;\n+\n+import com.google.api.gax.tracing.ApiTracer;\n+import com.google.api.gax.tracing.ApiTracerFactory.OperationType;\n+import com.google.api.gax.tracing.SpanName;\n+import com.google.common.base.Stopwatch;\n+import io.opencensus.stats.MeasureMap;\n+import io.opencensus.stats.StatsRecorder;\n+import io.opencensus.tags.TagContext;\n+import io.opencensus.tags.TagContextBuilder;\n+import io.opencensus.tags.TagKey;\n+import io.opencensus.tags.TagValue;\n+import io.opencensus.tags.Tagger;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import org.threeten.bp.Duration;\n+\n+class MetricsTracer implements ApiTracer {\n+  private final OperationType operationType;\n+\n+  private final Tagger tagger;\n+  private final StatsRecorder stats;\n+\n+  // Tags\n+  private final TagContext parentContext;\n+  private final SpanName spanName;\n+  private final Map<TagKey, TagValue> statsAttributes;\n+\n+  // Operation level metrics\n+  private final AtomicBoolean opFinished = new AtomicBoolean();\n+  private final Stopwatch operationTimer = Stopwatch.createStarted();\n+  private final Stopwatch firstResponsePerOpTimer = Stopwatch.createStarted();\n+  private long operationResponseCount = 0;\n+\n+  // Attempt level metrics\n+  private int attemptCount = 0;\n+  private Stopwatch attemptTimer;\n+  private long attemptResponseCount = 0;\n+\n+  MetricsTracer(\n+      OperationType operationType,\n+      Tagger tagger,\n+      StatsRecorder stats,\n+      SpanName spanName,\n+      Map<TagKey, TagValue> statsAttributes) {\n+    this.operationType = operationType;\n+    this.tagger = tagger;\n+    this.stats = stats;\n+    this.parentContext = tagger.getCurrentTagContext();\n+    this.spanName = spanName;\n+    this.statsAttributes = statsAttributes;\n+  }\n+\n+  @Override\n+  public Scope inScope() {\n+    return new Scope() {\n+      @Override\n+      public void close() {}\n+    };\n+  }\n+\n+  @Override\n+  public void operationSucceeded() {\n+    recordOperationCompletion(null);\n+  }\n+\n+  @Override\n+  public void operationCancelled() {\n+    recordOperationCompletion(new CancellationException());\n+  }\n+\n+  @Override\n+  public void operationFailed(Throwable throwable) {\n+    recordOperationCompletion(throwable);\n+  }\n+\n+  private void recordOperationCompletion(@Nullable Throwable throwable) {\n+    if (!opFinished.compareAndSet(false, true)) {\n+      return;\n+    }\n+    operationTimer.stop();\n+\n+    long elapsed = operationTimer.elapsed(TimeUnit.MILLISECONDS);\n+\n+    MeasureMap measures =\n+        stats\n+            .newMeasureMap()\n+            .put(RpcMeasureConstants.BIGTABLE_OP_LATENCY, elapsed)\n+            .put(RpcMeasureConstants.BIGTABLE_OP_ATTEMPT_COUNT, attemptCount);\n+\n+    if (operationType == OperationType.ServerStreaming\n+        && spanName.getMethodName().equals(\"ReadRows\")) {\n+      measures.put(\n+          RpcMeasureConstants.BIGTABLE_READ_ROWS_FIRST_ROW_LATENCY,\n+          firstResponsePerOpTimer.elapsed(TimeUnit.MILLISECONDS));\n+    }\n+\n+    TagContextBuilder tagCtx =\n+        newTagCtxBuilder()\n+            .putLocal(RpcMeasureConstants.BIGTABLE_STATUS, Util.extractStatus(throwable));\n+\n+    measures.record(tagCtx.build());\n+  }\n+\n+  @Override\n+  public void connectionSelected(String s) {\n+    // noop: cardinality for connection ids is too high to use as tags\n+  }\n+\n+  @Override\n+  public void attemptStarted(int i) {\n+    attemptCount++;\n+    attemptTimer = Stopwatch.createStarted();\n+    attemptResponseCount = 0;\n+  }\n+\n+  @Override\n+  public void attemptSucceeded() {\n+    recordAttemptCompletion(null, null);\n+  }\n+\n+  @Override\n+  public void attemptCancelled() {\n+    recordAttemptCompletion(new CancellationException(), null);\n+  }\n+\n+  @Override\n+  public void attemptFailed(Throwable throwable, Duration duration) {\n+    recordAttemptCompletion(throwable, duration);\n+  }\n+\n+  @Override\n+  public void attemptFailedRetriesExhausted(Throwable throwable) {\n+    recordAttemptCompletion(throwable, null);\n+  }\n+\n+  @Override\n+  public void attemptPermanentFailure(Throwable throwable) {\n+    recordAttemptCompletion(throwable, null);\n+  }\n+\n+  private void recordAttemptCompletion(\n+      @Nullable Throwable throwable, @Nullable Duration nextAttemptDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5MTM2OA=="}, "originalCommit": {"oid": "78fcc4da89014f81bb4b09bc4667856ecfe02c84"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTAzNTY2OnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDoxNjo0NVrOGDawAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNzoxNzowN1rOGU7q7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzNzE4NQ==", "bodyText": "super minor, but while you're here can you delete these random comments?", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r406237185", "createdAt": "2020-04-09T14:16:45Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "diffHunk": "@@ -544,19 +570,9 @@ private EnhancedBigtableStub(\n \n     UnaryCallable<RequestT, ResponseT> traced =\n         new TracedUnaryCallable<>(\n-            inner,\n-            clientContext.getTracerFactory(),\n-            SpanName.of(TRACING_OUTER_CLIENT_NAME, methodName));\n-\n-    UnaryCallable<RequestT, ResponseT> measured =\n-        new MeasuredUnaryCallable<>(\n-            traced,\n-            TRACING_OUTER_CLIENT_NAME + \".\" + methodName,\n-            tagger,\n-            statsRecorder,\n-            clientContext.getClock());\n+            inner, clientContext.getTracerFactory(), SpanName.of(CLIENT_NAME, methodName));\n \n-    return measured.withDefaultCallContext(clientContext.getDefaultCallContext());\n+    return traced.withDefaultCallContext(clientContext.getDefaultCallContext());\n   }\n   // </editor-fold>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b39dc5a32c8136c7a669f59a19592d81024722fb"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU1NDk2Ng==", "bodyText": "I find those comments useful, they allow me to enable code folding in intellij", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r424554966", "createdAt": "2020-05-13T16:03:01Z", "author": {"login": "igorbernstein2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "diffHunk": "@@ -544,19 +570,9 @@ private EnhancedBigtableStub(\n \n     UnaryCallable<RequestT, ResponseT> traced =\n         new TracedUnaryCallable<>(\n-            inner,\n-            clientContext.getTracerFactory(),\n-            SpanName.of(TRACING_OUTER_CLIENT_NAME, methodName));\n-\n-    UnaryCallable<RequestT, ResponseT> measured =\n-        new MeasuredUnaryCallable<>(\n-            traced,\n-            TRACING_OUTER_CLIENT_NAME + \".\" + methodName,\n-            tagger,\n-            statsRecorder,\n-            clientContext.getClock());\n+            inner, clientContext.getTracerFactory(), SpanName.of(CLIENT_NAME, methodName));\n \n-    return measured.withDefaultCallContext(clientContext.getDefaultCallContext());\n+    return traced.withDefaultCallContext(clientContext.getDefaultCallContext());\n   }\n   // </editor-fold>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzNzE4NQ=="}, "originalCommit": {"oid": "b39dc5a32c8136c7a669f59a19592d81024722fb"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwMjM1MA==", "bodyText": "ohh, a feature I didn't know existed :) Sounds good then!", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r424602350", "createdAt": "2020-05-13T17:17:07Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "diffHunk": "@@ -544,19 +570,9 @@ private EnhancedBigtableStub(\n \n     UnaryCallable<RequestT, ResponseT> traced =\n         new TracedUnaryCallable<>(\n-            inner,\n-            clientContext.getTracerFactory(),\n-            SpanName.of(TRACING_OUTER_CLIENT_NAME, methodName));\n-\n-    UnaryCallable<RequestT, ResponseT> measured =\n-        new MeasuredUnaryCallable<>(\n-            traced,\n-            TRACING_OUTER_CLIENT_NAME + \".\" + methodName,\n-            tagger,\n-            statsRecorder,\n-            clientContext.getClock());\n+            inner, clientContext.getTracerFactory(), SpanName.of(CLIENT_NAME, methodName));\n \n-    return measured.withDefaultCallContext(clientContext.getDefaultCallContext());\n+    return traced.withDefaultCallContext(clientContext.getDefaultCallContext());\n   }\n   // </editor-fold>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzNzE4NQ=="}, "originalCommit": {"oid": "b39dc5a32c8136c7a669f59a19592d81024722fb"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzgxMzg5OnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjowMTo1OVrOGU4u4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjowMTo1OVrOGU4u4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU1NDIwOA==", "bodyText": "I have a bit of concern here. The end user will have to declare both of these dependencies. I think it might be good to directly depend only on opencensus-impl and have it pull opencensus-impl-core transitively (and exclude it from from dependency enforcer", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r424554208", "createdAt": "2020-05-13T16:01:59Z", "author": {"login": "igorbernstein2"}, "path": "google-cloud-bigtable/pom.xml", "diffHunk": "@@ -218,6 +212,16 @@\n       <artifactId>grpc-testing</artifactId>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>io.opencensus</groupId>\n+      <artifactId>opencensus-impl-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.opencensus</groupId>\n+      <artifactId>opencensus-impl</artifactId>\n+      <scope>test</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8153020fc716d72176cb6d4010660b7560606f95"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzY2MjI1OnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/src/test/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyMDo0N1rOGVenxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyMjo1MlrOGVet1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NDk4Mg==", "bodyText": "why are we wrapping this in a list?", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r425174982", "createdAt": "2020-05-14T14:20:47Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/test/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracerTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.cloud.bigtable.data.v2.stub.metrics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+\n+import com.google.api.gax.rpc.ClientContext;\n+import com.google.bigtable.v2.BigtableGrpc;\n+import com.google.bigtable.v2.ReadRowsRequest;\n+import com.google.bigtable.v2.ReadRowsResponse;\n+import com.google.bigtable.v2.ReadRowsResponse.CellChunk;\n+import com.google.cloud.bigtable.data.v2.BigtableDataSettings;\n+import com.google.cloud.bigtable.data.v2.models.Query;\n+import com.google.cloud.bigtable.data.v2.stub.EnhancedBigtableStub;\n+import com.google.cloud.bigtable.data.v2.stub.EnhancedBigtableStubSettings;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.BytesValue;\n+import com.google.protobuf.StringValue;\n+import io.grpc.Server;\n+import io.grpc.ServerBuilder;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.opencensus.common.Function;\n+import io.opencensus.impl.stats.StatsComponentImpl;\n+import io.opencensus.stats.AggregationData;\n+import io.opencensus.stats.AggregationData.CountData;\n+import io.opencensus.stats.AggregationData.DistributionData;\n+import io.opencensus.stats.AggregationData.LastValueDataDouble;\n+import io.opencensus.stats.AggregationData.LastValueDataLong;\n+import io.opencensus.stats.AggregationData.SumDataDouble;\n+import io.opencensus.stats.AggregationData.SumDataLong;\n+import io.opencensus.stats.View;\n+import io.opencensus.stats.ViewData;\n+import io.opencensus.tags.TagKey;\n+import io.opencensus.tags.TagValue;\n+import io.opencensus.tags.Tags;\n+import java.net.ServerSocket;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Answers;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.mockito.stubbing.Answer;\n+\n+@RunWith(JUnit4.class)\n+public class MetricsTracerTest {\n+  private static final String PROJECT_ID = \"fake-project\";\n+  private static final String INSTANCE_ID = \"fake-instance\";\n+  private static final String APP_PROFILE_ID = \"default\";\n+  private static final String TABLE_ID = \"fake-table\";\n+\n+  private static final ReadRowsResponse DEFAULT_READ_ROWS_RESPONSES =\n+      ReadRowsResponse.newBuilder()\n+          .addChunks(\n+              CellChunk.newBuilder()\n+                  .setRowKey(ByteString.copyFromUtf8(\"fake-key\"))\n+                  .setFamilyName(StringValue.of(\"cf\"))\n+                  .setQualifier(BytesValue.newBuilder().setValue(ByteString.copyFromUtf8(\"q\")))\n+                  .setTimestampMicros(1_000)\n+                  .setValue(ByteString.copyFromUtf8(\"value\"))\n+                  .setCommitRow(true))\n+          .build();\n+\n+  @Rule public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private Server server;\n+\n+  @Mock(answer = Answers.CALLS_REAL_METHODS)\n+  private BigtableGrpc.BigtableImplBase mockService;\n+\n+  private StatsComponentImpl localStats = new StatsComponentImpl();\n+  private EnhancedBigtableStub stub;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    int port;\n+    try (ServerSocket ss = new ServerSocket(0)) {\n+      port = ss.getLocalPort();\n+    }\n+    server = ServerBuilder.forPort(port).addService(mockService).build();\n+    server.start();\n+\n+    RpcViews.registerBigtableClientViews(localStats.getViewManager());\n+\n+    BigtableDataSettings settings =\n+        BigtableDataSettings.newBuilderForEmulator(port)\n+            .setProjectId(PROJECT_ID)\n+            .setInstanceId(INSTANCE_ID)\n+            .setAppProfileId(APP_PROFILE_ID)\n+            .build();\n+    EnhancedBigtableStubSettings stubSettings = settings.getStubSettings();\n+\n+    stub =\n+        new EnhancedBigtableStub(\n+            stubSettings,\n+            ClientContext.create(stubSettings),\n+            Tags.getTagger(),\n+            localStats.getStatsRecorder());\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    stub.close();\n+    server.shutdown();\n+  }\n+\n+  @Test\n+  public void testReadRowsLatency() throws InterruptedException {\n+    final long sleepTime = 50;\n+\n+    doAnswer(\n+            new Answer() {\n+              @Override\n+              public Object answer(InvocationOnMock invocation) throws Throwable {\n+                @SuppressWarnings(\"unchecked\")\n+                StreamObserver<ReadRowsResponse> observer =\n+                    (StreamObserver<ReadRowsResponse>) invocation.getArguments()[1];\n+                Thread.sleep(sleepTime);\n+                observer.onNext(DEFAULT_READ_ROWS_RESPONSES);\n+                observer.onCompleted();\n+                return null;\n+              }\n+            })\n+        .when(mockService)\n+        .readRows(any(ReadRowsRequest.class), anyObserver(ReadRowsResponse.class));\n+\n+    Stopwatch stopwatch = Stopwatch.createStarted();\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));\n+    long elapsed = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n+\n+    // Give OpenCensus a chance to update the views asynchronously.\n+    Thread.sleep(100);\n+\n+    long opLatency =\n+        getAggregationValueAsLong(\n+            RpcViewConstants.BIGTABLE_OP_LATENCY_VIEW,\n+            ImmutableMap.of(\n+                RpcMeasureConstants.BIGTABLE_OP, TagValue.create(\"Bigtable.ReadRows\"),\n+                RpcMeasureConstants.BIGTABLE_STATUS, TagValue.create(\"OK\")));\n+    assertThat(opLatency).isIn(Range.closed(sleepTime, elapsed));\n+  }\n+\n+  @Test\n+  public void testReadRowsOpCount() throws InterruptedException {\n+    doAnswer(\n+            new Answer() {\n+              @Override\n+              public Object answer(InvocationOnMock invocation) {\n+                @SuppressWarnings(\"unchecked\")\n+                StreamObserver<ReadRowsResponse> observer =\n+                    (StreamObserver<ReadRowsResponse>) invocation.getArguments()[1];\n+                observer.onNext(DEFAULT_READ_ROWS_RESPONSES);\n+                observer.onCompleted();\n+                return null;\n+              }\n+            })\n+        .when(mockService)\n+        .readRows(any(ReadRowsRequest.class), anyObserver(ReadRowsResponse.class));\n+\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));\n+\n+    // Give OpenCensus a chance to update the views asynchronously.\n+    Thread.sleep(100);\n+\n+    long opLatency =\n+        getAggregationValueAsLong(\n+            RpcViewConstants.BIGTABLE_COMPLETED_OP_VIEW,\n+            ImmutableMap.of(\n+                RpcMeasureConstants.BIGTABLE_OP, TagValue.create(\"Bigtable.ReadRows\"),\n+                RpcMeasureConstants.BIGTABLE_STATUS, TagValue.create(\"OK\")));\n+    assertThat(opLatency).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testReadRowsFirstRow() throws InterruptedException {\n+    final long beforeSleep = 50;\n+    final long afterSleep = 50;\n+\n+    doAnswer(\n+            new Answer() {\n+              @Override\n+              public Object answer(InvocationOnMock invocation) throws Throwable {\n+                @SuppressWarnings(\"unchecked\")\n+                StreamObserver<ReadRowsResponse> observer =\n+                    (StreamObserver<ReadRowsResponse>) invocation.getArguments()[1];\n+                Thread.sleep(beforeSleep);\n+                observer.onNext(DEFAULT_READ_ROWS_RESPONSES);\n+                Thread.sleep(afterSleep);\n+                observer.onCompleted();\n+                return null;\n+              }\n+            })\n+        .when(mockService)\n+        .readRows(any(ReadRowsRequest.class), anyObserver(ReadRowsResponse.class));\n+\n+    Stopwatch stopwatch = Stopwatch.createStarted();\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8779aeed65b7aa8349f24caf3e3b130b6e8b452"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NjUzNA==", "bodyText": "To read the stream...the returned iterator is lazy and needs to be consumed", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r425176534", "createdAt": "2020-05-14T14:22:52Z", "author": {"login": "igorbernstein2"}, "path": "google-cloud-bigtable/src/test/java/com/google/cloud/bigtable/data/v2/stub/metrics/MetricsTracerTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.cloud.bigtable.data.v2.stub.metrics;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+\n+import com.google.api.gax.rpc.ClientContext;\n+import com.google.bigtable.v2.BigtableGrpc;\n+import com.google.bigtable.v2.ReadRowsRequest;\n+import com.google.bigtable.v2.ReadRowsResponse;\n+import com.google.bigtable.v2.ReadRowsResponse.CellChunk;\n+import com.google.cloud.bigtable.data.v2.BigtableDataSettings;\n+import com.google.cloud.bigtable.data.v2.models.Query;\n+import com.google.cloud.bigtable.data.v2.stub.EnhancedBigtableStub;\n+import com.google.cloud.bigtable.data.v2.stub.EnhancedBigtableStubSettings;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.BytesValue;\n+import com.google.protobuf.StringValue;\n+import io.grpc.Server;\n+import io.grpc.ServerBuilder;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.opencensus.common.Function;\n+import io.opencensus.impl.stats.StatsComponentImpl;\n+import io.opencensus.stats.AggregationData;\n+import io.opencensus.stats.AggregationData.CountData;\n+import io.opencensus.stats.AggregationData.DistributionData;\n+import io.opencensus.stats.AggregationData.LastValueDataDouble;\n+import io.opencensus.stats.AggregationData.LastValueDataLong;\n+import io.opencensus.stats.AggregationData.SumDataDouble;\n+import io.opencensus.stats.AggregationData.SumDataLong;\n+import io.opencensus.stats.View;\n+import io.opencensus.stats.ViewData;\n+import io.opencensus.tags.TagKey;\n+import io.opencensus.tags.TagValue;\n+import io.opencensus.tags.Tags;\n+import java.net.ServerSocket;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Answers;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.mockito.stubbing.Answer;\n+\n+@RunWith(JUnit4.class)\n+public class MetricsTracerTest {\n+  private static final String PROJECT_ID = \"fake-project\";\n+  private static final String INSTANCE_ID = \"fake-instance\";\n+  private static final String APP_PROFILE_ID = \"default\";\n+  private static final String TABLE_ID = \"fake-table\";\n+\n+  private static final ReadRowsResponse DEFAULT_READ_ROWS_RESPONSES =\n+      ReadRowsResponse.newBuilder()\n+          .addChunks(\n+              CellChunk.newBuilder()\n+                  .setRowKey(ByteString.copyFromUtf8(\"fake-key\"))\n+                  .setFamilyName(StringValue.of(\"cf\"))\n+                  .setQualifier(BytesValue.newBuilder().setValue(ByteString.copyFromUtf8(\"q\")))\n+                  .setTimestampMicros(1_000)\n+                  .setValue(ByteString.copyFromUtf8(\"value\"))\n+                  .setCommitRow(true))\n+          .build();\n+\n+  @Rule public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private Server server;\n+\n+  @Mock(answer = Answers.CALLS_REAL_METHODS)\n+  private BigtableGrpc.BigtableImplBase mockService;\n+\n+  private StatsComponentImpl localStats = new StatsComponentImpl();\n+  private EnhancedBigtableStub stub;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    int port;\n+    try (ServerSocket ss = new ServerSocket(0)) {\n+      port = ss.getLocalPort();\n+    }\n+    server = ServerBuilder.forPort(port).addService(mockService).build();\n+    server.start();\n+\n+    RpcViews.registerBigtableClientViews(localStats.getViewManager());\n+\n+    BigtableDataSettings settings =\n+        BigtableDataSettings.newBuilderForEmulator(port)\n+            .setProjectId(PROJECT_ID)\n+            .setInstanceId(INSTANCE_ID)\n+            .setAppProfileId(APP_PROFILE_ID)\n+            .build();\n+    EnhancedBigtableStubSettings stubSettings = settings.getStubSettings();\n+\n+    stub =\n+        new EnhancedBigtableStub(\n+            stubSettings,\n+            ClientContext.create(stubSettings),\n+            Tags.getTagger(),\n+            localStats.getStatsRecorder());\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    stub.close();\n+    server.shutdown();\n+  }\n+\n+  @Test\n+  public void testReadRowsLatency() throws InterruptedException {\n+    final long sleepTime = 50;\n+\n+    doAnswer(\n+            new Answer() {\n+              @Override\n+              public Object answer(InvocationOnMock invocation) throws Throwable {\n+                @SuppressWarnings(\"unchecked\")\n+                StreamObserver<ReadRowsResponse> observer =\n+                    (StreamObserver<ReadRowsResponse>) invocation.getArguments()[1];\n+                Thread.sleep(sleepTime);\n+                observer.onNext(DEFAULT_READ_ROWS_RESPONSES);\n+                observer.onCompleted();\n+                return null;\n+              }\n+            })\n+        .when(mockService)\n+        .readRows(any(ReadRowsRequest.class), anyObserver(ReadRowsResponse.class));\n+\n+    Stopwatch stopwatch = Stopwatch.createStarted();\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));\n+    long elapsed = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n+\n+    // Give OpenCensus a chance to update the views asynchronously.\n+    Thread.sleep(100);\n+\n+    long opLatency =\n+        getAggregationValueAsLong(\n+            RpcViewConstants.BIGTABLE_OP_LATENCY_VIEW,\n+            ImmutableMap.of(\n+                RpcMeasureConstants.BIGTABLE_OP, TagValue.create(\"Bigtable.ReadRows\"),\n+                RpcMeasureConstants.BIGTABLE_STATUS, TagValue.create(\"OK\")));\n+    assertThat(opLatency).isIn(Range.closed(sleepTime, elapsed));\n+  }\n+\n+  @Test\n+  public void testReadRowsOpCount() throws InterruptedException {\n+    doAnswer(\n+            new Answer() {\n+              @Override\n+              public Object answer(InvocationOnMock invocation) {\n+                @SuppressWarnings(\"unchecked\")\n+                StreamObserver<ReadRowsResponse> observer =\n+                    (StreamObserver<ReadRowsResponse>) invocation.getArguments()[1];\n+                observer.onNext(DEFAULT_READ_ROWS_RESPONSES);\n+                observer.onCompleted();\n+                return null;\n+              }\n+            })\n+        .when(mockService)\n+        .readRows(any(ReadRowsRequest.class), anyObserver(ReadRowsResponse.class));\n+\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));\n+\n+    // Give OpenCensus a chance to update the views asynchronously.\n+    Thread.sleep(100);\n+\n+    long opLatency =\n+        getAggregationValueAsLong(\n+            RpcViewConstants.BIGTABLE_COMPLETED_OP_VIEW,\n+            ImmutableMap.of(\n+                RpcMeasureConstants.BIGTABLE_OP, TagValue.create(\"Bigtable.ReadRows\"),\n+                RpcMeasureConstants.BIGTABLE_STATUS, TagValue.create(\"OK\")));\n+    assertThat(opLatency).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testReadRowsFirstRow() throws InterruptedException {\n+    final long beforeSleep = 50;\n+    final long afterSleep = 50;\n+\n+    doAnswer(\n+            new Answer() {\n+              @Override\n+              public Object answer(InvocationOnMock invocation) throws Throwable {\n+                @SuppressWarnings(\"unchecked\")\n+                StreamObserver<ReadRowsResponse> observer =\n+                    (StreamObserver<ReadRowsResponse>) invocation.getArguments()[1];\n+                Thread.sleep(beforeSleep);\n+                observer.onNext(DEFAULT_READ_ROWS_RESPONSES);\n+                Thread.sleep(afterSleep);\n+                observer.onCompleted();\n+                return null;\n+              }\n+            })\n+        .when(mockService)\n+        .readRows(any(ReadRowsRequest.class), anyObserver(ReadRowsResponse.class));\n+\n+    Stopwatch stopwatch = Stopwatch.createStarted();\n+    Lists.newArrayList(stub.readRowsCallable().call(Query.create(TABLE_ID)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NDk4Mg=="}, "originalCommit": {"oid": "f8779aeed65b7aa8349f24caf3e3b130b6e8b452"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzY5NDE0OnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyNzozMFrOGVe8jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyNzozMFrOGVe8jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MDMwMA==", "bodyText": "Sorry for being confusing before, but opencensus-impl should stay as a test dep. I just meant that impl-core should be transitive. As it stands endusers should add -impl to activate opencensus (I just wanted to avoid users having to specify both", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r425180300", "createdAt": "2020-05-14T14:27:30Z", "author": {"login": "igorbernstein2"}, "path": "google-cloud-bigtable/pom.xml", "diffHunk": "@@ -124,6 +124,10 @@\n       <groupId>io.opencensus</groupId>\n       <artifactId>opencensus-api</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>io.opencensus</groupId>\n+      <artifactId>opencensus-impl</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8779aeed65b7aa8349f24caf3e3b130b6e8b452"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODkxMzcyOnYy", "diffSide": "LEFT", "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozMToxM1rOGVrLGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozMToxM1rOGVrLGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MDYzMw==", "bodyText": "@igorbernstein2, please take a look here to ensure I didn't miss anything in updating the branch", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r425380633", "createdAt": "2020-05-14T19:31:13Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStub.java", "diffHunk": "@@ -59,9 +62,9 @@\n import com.google.cloud.bigtable.data.v2.models.RowAdapter;\n import com.google.cloud.bigtable.data.v2.models.RowMutation;\n import com.google.cloud.bigtable.data.v2.models.RowMutationEntry;\n-import com.google.cloud.bigtable.data.v2.stub.metrics.MeasuredMutateRowsCallable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "787bc594a3579f9bcd8c9076befe4c787baeceeb"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODkxNDIxOnYy", "diffSide": "RIGHT", "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStubSettings.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozMToyMlrOGVrLag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozMToyMlrOGVrLag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4MDcxNA==", "bodyText": "@igorbernstein2 same here please :)", "url": "https://github.com/googleapis/java-bigtable/pull/214#discussion_r425380714", "createdAt": "2020-05-14T19:31:22Z", "author": {"login": "kolea2"}, "path": "google-cloud-bigtable/src/main/java/com/google/cloud/bigtable/data/v2/stub/EnhancedBigtableStubSettings.java", "diffHunk": "@@ -20,17 +20,14 @@\n import com.google.api.gax.batching.BatchingSettings;\n import com.google.api.gax.batching.FlowControlSettings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "787bc594a3579f9bcd8c9076befe4c787baeceeb"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3431, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}