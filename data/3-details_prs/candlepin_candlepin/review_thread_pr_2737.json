{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNzk2NDg2", "number": 2737, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDowNDo0NlrOEZZ6Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDo0Njo1OVrOEakZcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDc0MzkxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/async/tasks/OrphanCleanupJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDowNDo0NlrOHCMjHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzoxNjo1OVrOHCT2zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA2NDc5Nw==", "bodyText": "Log argument is missing.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472064797", "createdAt": "2020-08-18T10:04:46Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/async/tasks/OrphanCleanupJob.java", "diffHunk": "@@ -88,23 +91,29 @@ private int deleteOrphanedContent() {\n             ++count;\n         }\n \n-        this.productCurator.flush();\n+        this.contentCurator.flush();\n         log.debug(\"{} orphaned product entities deleted\", count);\n \n         return count;\n     }\n \n     private int deleteOrphanedProducts() {\n-        int count = 0;\n-        CandlepinQuery<Product> productQuery = this.ownerProductCurator.getOrphanedProducts()\n-            .setLockMode(LockModeType.PESSIMISTIC_WRITE);\n+        List<String> orphanedProductUuids = this.ownerProductCurator.getOrphanedProductUuids();\n \n-        for (Product product : productQuery) {\n-            this.productCurator.delete(product);\n-            ++count;\n+        Set<Pair<String, String>> activePoolProducts = this.productCurator\n+            .getProductsWithPools(orphanedProductUuids);\n+\n+        if (activePoolProducts != null && !activePoolProducts.isEmpty()) {\n+            log.warn(\"Found {} pools referencing orphaned products:\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE4NDUyNQ==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472184525", "createdAt": "2020-08-18T13:16:59Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/async/tasks/OrphanCleanupJob.java", "diffHunk": "@@ -88,23 +91,29 @@ private int deleteOrphanedContent() {\n             ++count;\n         }\n \n-        this.productCurator.flush();\n+        this.contentCurator.flush();\n         log.debug(\"{} orphaned product entities deleted\", count);\n \n         return count;\n     }\n \n     private int deleteOrphanedProducts() {\n-        int count = 0;\n-        CandlepinQuery<Product> productQuery = this.ownerProductCurator.getOrphanedProducts()\n-            .setLockMode(LockModeType.PESSIMISTIC_WRITE);\n+        List<String> orphanedProductUuids = this.ownerProductCurator.getOrphanedProductUuids();\n \n-        for (Product product : productQuery) {\n-            this.productCurator.delete(product);\n-            ++count;\n+        Set<Pair<String, String>> activePoolProducts = this.productCurator\n+            .getProductsWithPools(orphanedProductUuids);\n+\n+        if (activePoolProducts != null && !activePoolProducts.isEmpty()) {\n+            log.warn(\"Found {} pools referencing orphaned products:\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA2NDc5Nw=="}, "originalCommit": {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDc4MjA2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoxNTozMFrOHCM6eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNToyMTo1M1rOHCZrCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDc3OA==", "bodyText": "Could we do something about our use of raw types? It's starting to feel a bit excessive. We could at least use the wildcards.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472070778", "createdAt": "2020-08-18T10:15:30Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -67,23 +71,45 @@ public NodeFactory addBuilder(NodeBuilder builder) {\n     }\n \n     /**\n-     * Sets the mapper to use for mapping nodes created by this factory.\n+     * Adds a mapper to this factory. The mapper will be used to provide entities during node\n+     * construction for the class returned by the mapper's <tt>getEntityClass</tt> method.\n      *\n      * @param mapper\n-     *  the mapper to use for mapping nodes\n+     *  the mapper to add to this factory\n      *\n      * @throws IllegalArgumentException\n      *  if the provided mapper is null\n      *\n      * @return\n      *  a reference to this node factory\n      */\n-    public NodeFactory setNodeMapper(NodeMapper mapper) {\n+    public NodeFactory addMapper(EntityMapper mapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3OTgxOA==", "bodyText": "I've added wildcards where appropriate, but this doesn't really buy us much outside of one weird compiler error that required a random cast to the same type.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472279818", "createdAt": "2020-08-18T15:21:53Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -67,23 +71,45 @@ public NodeFactory addBuilder(NodeBuilder builder) {\n     }\n \n     /**\n-     * Sets the mapper to use for mapping nodes created by this factory.\n+     * Adds a mapper to this factory. The mapper will be used to provide entities during node\n+     * construction for the class returned by the mapper's <tt>getEntityClass</tt> method.\n      *\n      * @param mapper\n-     *  the mapper to use for mapping nodes\n+     *  the mapper to add to this factory\n      *\n      * @throws IllegalArgumentException\n      *  if the provided mapper is null\n      *\n      * @return\n      *  a reference to this node factory\n      */\n-    public NodeFactory setNodeMapper(NodeMapper mapper) {\n+    public NodeFactory addMapper(EntityMapper mapper) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDc3OA=="}, "originalCommit": {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDgwMDQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMDoyMDo1OFrOHCNFuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzoxNzo0MlrOHCT5YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzY1Ng==", "bodyText": "We could you Map.computeIfAbsent here.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472073656", "createdAt": "2020-08-18T10:20:58Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitor.java", "diffHunk": "@@ -87,32 +89,38 @@ public ContentNodeVisitor(ContentCurator contentCurator, OwnerContentCurator own\n     public void processNode(NodeProcessor processor, NodeMapper mapper,\n         EntityNode<Content, ContentInfo> node) {\n \n-        if (node.visited()) {\n-            return;\n-        }\n-\n         // Content nodes should not have any children\n         if (!node.isLeafNode()) {\n             throw new IllegalStateException(\"Content node has one or more children nodes\");\n         }\n \n+        // If this node already has a state, we don't need to reprocess it (probably)\n+        if (node.getNodeState() != null) {\n+            return;\n+        }\n+\n         Content existingEntity = node.getExistingEntity();\n         ContentInfo importedEntity = node.getImportedEntity();\n \n+        // Default the node state to UNCHANGED and let our cases below overwrite this\n+        node.setNodeState(NodeState.UNCHANGED);\n+\n         if (existingEntity != null) {\n-            if (importedEntity != null && ContentManager.isChangedBy(existingEntity, importedEntity)) {\n-                Content mergedEntity = this.createEntity(mapper, node);\n-                node.setMergedEntity(mergedEntity);\n-\n-                // Store the mapping to be updated later\n-                Map<String, String> contentUuidMap = this.ownerContentUuidMap.get(node.getOwner());\n-                if (contentUuidMap == null) {\n-                    contentUuidMap = new HashMap<>();\n-                    this.ownerContentUuidMap.put(node.getOwner(), contentUuidMap);\n+            if (importedEntity != null) {\n+                if (ContentManager.isChangedBy(existingEntity, importedEntity)) {\n+                    Content mergedEntity = this.createEntity(mapper, node);\n+                    node.setMergedEntity(mergedEntity);\n+\n+                    // Store the mapping to be updated later\n+                    Map<String, String> contentUuidMap = this.ownerContentUuidMap.get(node.getOwner());\n+                    if (contentUuidMap == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE4NTE4NQ==", "bodyText": "Ahh, nice. Turns out it's ever-so-slightly faster, too. Fixed here and in a few other places.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r472185185", "createdAt": "2020-08-18T13:17:42Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitor.java", "diffHunk": "@@ -87,32 +89,38 @@ public ContentNodeVisitor(ContentCurator contentCurator, OwnerContentCurator own\n     public void processNode(NodeProcessor processor, NodeMapper mapper,\n         EntityNode<Content, ContentInfo> node) {\n \n-        if (node.visited()) {\n-            return;\n-        }\n-\n         // Content nodes should not have any children\n         if (!node.isLeafNode()) {\n             throw new IllegalStateException(\"Content node has one or more children nodes\");\n         }\n \n+        // If this node already has a state, we don't need to reprocess it (probably)\n+        if (node.getNodeState() != null) {\n+            return;\n+        }\n+\n         Content existingEntity = node.getExistingEntity();\n         ContentInfo importedEntity = node.getImportedEntity();\n \n+        // Default the node state to UNCHANGED and let our cases below overwrite this\n+        node.setNodeState(NodeState.UNCHANGED);\n+\n         if (existingEntity != null) {\n-            if (importedEntity != null && ContentManager.isChangedBy(existingEntity, importedEntity)) {\n-                Content mergedEntity = this.createEntity(mapper, node);\n-                node.setMergedEntity(mergedEntity);\n-\n-                // Store the mapping to be updated later\n-                Map<String, String> contentUuidMap = this.ownerContentUuidMap.get(node.getOwner());\n-                if (contentUuidMap == null) {\n-                    contentUuidMap = new HashMap<>();\n-                    this.ownerContentUuidMap.put(node.getOwner(), contentUuidMap);\n+            if (importedEntity != null) {\n+                if (ContentManager.isChangedBy(existingEntity, importedEntity)) {\n+                    Content mergedEntity = this.createEntity(mapper, node);\n+                    node.setMergedEntity(mergedEntity);\n+\n+                    // Store the mapping to be updated later\n+                    Map<String, String> contentUuidMap = this.ownerContentUuidMap.get(node.getOwner());\n+                    if (contentUuidMap == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzY1Ng=="}, "originalCommit": {"oid": "edd1c3bc34f5cb4653ceb7d23f239c1bed7adbff"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NzE2MjU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDo1Njo0NVrOHDLYXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNDowMzoxNVrOHEufyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg==", "bodyText": "If we want the buildNodes() method to be the primary interface that users of this class should build the nodes with, then we should change this method from public to protected or private, (unless there's a reason to keep this public?) to make the API clearer.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r473094236", "createdAt": "2020-08-19T14:56:45Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -101,38 +127,66 @@ public NodeFactory setNodeMapper(NodeMapper mapper) {\n      *  the entity ID of the node to create\n      *\n      * @throws IllegalStateException\n-     *  if the mapper has not been set, or a builder has not been provided for the given entity\n-     *  class, or the builder failed to create a node for the entity\n+     *  if the node mapper has not been set, or a mapper or builder has not been provided for the\n+     *  given entity class, or the builder failed to create a node for the entity\n      *\n      * @return\n      *  the entity node for the given entity class and ID\n      */\n     public <E extends AbstractHibernateObject, I extends ServiceAdapterModel> EntityNode<E, I>\n         buildNode(Owner owner, Class<E> cls, String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwMTY0NQ==", "bodyText": "This method is intended to be used by the builders which create children (ProductNodeBuilder, PoolNodeBuilder in the future) so the correct builder can be called and the caching is performed in a single place.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474701645", "createdAt": "2020-08-21T13:35:44Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -101,38 +127,66 @@ public NodeFactory setNodeMapper(NodeMapper mapper) {\n      *  the entity ID of the node to create\n      *\n      * @throws IllegalStateException\n-     *  if the mapper has not been set, or a builder has not been provided for the given entity\n-     *  class, or the builder failed to create a node for the entity\n+     *  if the node mapper has not been set, or a mapper or builder has not been provided for the\n+     *  given entity class, or the builder failed to create a node for the entity\n      *\n      * @return\n      *  the entity node for the given entity class and ID\n      */\n     public <E extends AbstractHibernateObject, I extends ServiceAdapterModel> EntityNode<E, I>\n         buildNode(Owner owner, Class<E> cls, String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg=="}, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNTUxOA==", "bodyText": "Oops you're right, I just noticed that PoolNodeBuilder does use it.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474705518", "createdAt": "2020-08-21T13:42:18Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -101,38 +127,66 @@ public NodeFactory setNodeMapper(NodeMapper mapper) {\n      *  the entity ID of the node to create\n      *\n      * @throws IllegalStateException\n-     *  if the mapper has not been set, or a builder has not been provided for the given entity\n-     *  class, or the builder failed to create a node for the entity\n+     *  if the node mapper has not been set, or a mapper or builder has not been provided for the\n+     *  given entity class, or the builder failed to create a node for the entity\n      *\n      * @return\n      *  the entity node for the given entity class and ID\n      */\n     public <E extends AbstractHibernateObject, I extends ServiceAdapterModel> EntityNode<E, I>\n         buildNode(Owner owner, Class<E> cls, String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg=="}, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcxODE1Mg==", "bodyText": "I've bumped it to protected anyway, since it seems like we won't be using it outside of that package, and it probably doesn't have a ton of use externally.", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474718152", "createdAt": "2020-08-21T14:03:15Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -101,38 +127,66 @@ public NodeFactory setNodeMapper(NodeMapper mapper) {\n      *  the entity ID of the node to create\n      *\n      * @throws IllegalStateException\n-     *  if the mapper has not been set, or a builder has not been provided for the given entity\n-     *  class, or the builder failed to create a node for the entity\n+     *  if the node mapper has not been set, or a mapper or builder has not been provided for the\n+     *  given entity class, or the builder failed to create a node for the entity\n      *\n      * @return\n      *  the entity node for the given entity class and ID\n      */\n     public <E extends AbstractHibernateObject, I extends ServiceAdapterModel> EntityNode<E, I>\n         buildNode(Owner owner, Class<E> cls, String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5NDIzNg=="}, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjc5MjQ3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshResult.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDoxMzo1N1rOHEDmww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzozMTowM1rOHEtScQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTQyNw==", "bodyText": "This should probably not say that the method is used for adding a \"created\" entity, since the method actually accepts a state argument", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474015427", "createdAt": "2020-08-20T14:13:57Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshResult.java", "diffHunk": "@@ -32,501 +34,284 @@\n  */\n public class RefreshResult {\n \n-    // TODO: Flesh out the collection types here a bit more, in accordance with the table below\n-    //\n-    // Existing     Imported    Merged entity       Result\n-    // not-null     not-null    not-null            updated entity\n-    // not-null     not-null    null                unchanged entity (imported but unchanged)\n-    // not-null     null        not-null            children updated\n-    // not-null     null        null                unchanged entity (not imported, no changes to children)\n-    // null         not-null    not-null            created entity\n-    // null         not-null    null                ERROR STATE - creation failed\n-    // null         null        null                ERROR STATE - uninitialized node\n-    //\n-    // Following this, we have 3 states to report, and 2 pseudo-states:\n-    // - resultant states: created (5), updated (1, 3), unchanged (2, 4)\n-    // - pseudo-states: imported (1, 2, 5) and skipped (3, 4)\n-    //\n-    // At the time of writing, we can kind of discern the pseudo-states by getting the collections\n-    // back out of the refresh worker, so maybe this is a non-issue.\n-\n-    private Map<String, Pool> createdPools;\n-    private Map<String, Pool> updatedPools;\n-    private Map<String, Pool> skippedPools;\n-\n-    private Map<String, Product> createdProducts;\n-    private Map<String, Product> updatedProducts;\n-    private Map<String, Product> skippedProducts;\n-\n-    private Map<String, Content> createdContent;\n-    private Map<String, Content> updatedContent;\n-    private Map<String, Content> skippedContent;\n-\n-\n     /**\n-     * Creates a new RefreshResult instance with no data\n+     * The known states an entity can be in post-refresh\n      */\n-    public RefreshResult() {\n-        this.createdPools = new HashMap<>();\n-        this.updatedPools = new HashMap<>();\n-        this.skippedPools = new HashMap<>();\n-\n-        this.createdProducts = new HashMap<>();\n-        this.updatedProducts = new HashMap<>();\n-        this.skippedProducts = new HashMap<>();\n-\n-        this.createdContent = new HashMap<>();\n-        this.updatedContent = new HashMap<>();\n-        this.skippedContent = new HashMap<>();\n+    public static enum EntityState {\n+        CREATED,\n+        UPDATED,\n+        UNCHANGED,\n+        DELETED\n     }\n \n     /**\n-     * Adds the specified pool as a \"created\" pool, where a created pool is defined as a pool which\n-     * did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as a created pool\n+     * Stores refreshed entities of a given type\n      *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     * @param <T>\n+     *  the class of entity managed by this entity store\n      */\n-    public boolean addCreatedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+    public static class EntityStore<T extends AbstractHibernateObject> {\n+\n+        /**\n+         * Container class for storing entity and entity state\n+         */\n+        private static class EntityData<T extends AbstractHibernateObject> {\n+            private final String entityId;\n+            private final T entity;\n+            private final EntityState state;\n+\n+            public EntityData(String entityId, T entity, EntityState state) {\n+                this.entityId = entityId;\n+                this.entity = entity;\n+                this.state = state;\n+            }\n+\n+            public String getEntityId() {\n+                return this.entityId;\n+            }\n+\n+            public T getEntity() {\n+                return this.entity;\n+            }\n+\n+            public EntityState getEntityState() {\n+                return this.state;\n+            }\n         }\n \n-        return (this.createdPools.put(pool.getId(), pool) != pool);\n-    }\n+        private Map<String, EntityData<T>> entities;\n \n-    /**\n-     * Adds the specified pool as an \"updated\" pool, where an updated pool is defined as a pool\n-     * which was already defined locally, and was changed or updated during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as an updated pool\n-     *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addUpdatedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+        public EntityStore() {\n+            this.entities = new HashMap<>();\n         }\n \n-        return (this.updatedPools.put(pool.getId(), pool) != pool);\n-    }\n+        public void addEntity(T entity, EntityState state) {\n+            if (entity == null) {\n+                throw new IllegalArgumentException(\"entity is null\");\n+            }\n \n-    /**\n-     * Adds the specified pool as a \"skipped\" pool, where a skipped pool is defined as a pool which\n-     * was already defined locally, but remained unchanged during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as a skipped pool\n-     *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+            if (state == null) {\n+                throw new IllegalArgumentException(\"state is null\");\n+            }\n+\n+            EntityData<T> data = new EntityData<>((String) entity.getId(), entity, state);\n+            this.entities.put(data.getEntityId(), data);\n         }\n \n-        return (this.skippedPools.put(pool.getId(), pool) != pool);\n-    }\n+        public T getEntity(String id, Collection<EntityState> states) {\n+            EntityData<T> data = this.entities.get(id);\n \n-    /**\n-     * Adds the specified product as a \"created\" product, where a created product is defined as a\n-     * product which did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param product\n-     *  the product to add as a created product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addCreatedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n-        }\n+            if (data != null) {\n+                return states == null || states.isEmpty() || states.contains(data.getEntityState()) ?\n+                    data.getEntity() :\n+                    null;\n+            }\n \n-        return (this.createdProducts.put(product.getId(), product) != product);\n-    }\n+            return null;\n+        }\n \n-    /**\n-     * Adds the specified product as an \"updated\" product, where an updated product is defined as a\n-     * product which was already defined locally, and was changed or updated during the refresh\n-     * operation.\n-     *\n-     * @param product\n-     *  the product to add as an updated product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addUpdatedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n+        public EntityState getEntityState(String id) {\n+            EntityData<T> data = this.entities.get(id);\n+            return data != null ? data.getEntityState() : null;\n         }\n \n-        return (this.updatedProducts.put(product.getId(), product) != product);\n-    }\n+        public Map<String, T> getEntities(Collection<EntityState> states) {\n+            Stream<EntityData<T>> stream = this.entities.values()\n+                .stream();\n \n-    /**\n-     * Adds the specified product as a \"skipped\" product, where a skipped product is defined as a\n-     * product which was already defined locally, but remained unchanged during the refresh\n-     * operation.\n-     *\n-     * @param product\n-     *  the product to add as a skipped product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n-        }\n+            if (states != null && !states.isEmpty()) {\n+                stream = stream.filter(edata -> states.contains(edata.getEntityState()));\n+            }\n \n-        return (this.skippedProducts.put(product.getId(), product) != product);\n+            return stream.collect(Collectors.toMap(EntityData::getEntityId, EntityData::getEntity));\n+        }\n     }\n \n+    private Map<Class, EntityStore> entityStoreMap;\n+\n     /**\n-     * Adds the specified content as a \"created\" content, where a created content is defined as\n-     * content which did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param content\n-     *  the content to add as a created content\n-     *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     * Creates a new RefreshResult instance with no data\n      */\n-    public boolean addCreatedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n-        }\n-\n-        return (this.createdContent.put(content.getId(), content) != content);\n+    public RefreshResult() {\n+        this.entityStoreMap = new HashMap<>();\n     }\n \n     /**\n-     * Adds the specified content as an \"updated\" content, where an updated content is defined as\n-     * content which was already defined locally, and was changed or updated during the refresh\n-     * operation.\n+     * Fetches the entity store for the given class, optionally creating it as necessary.\n      *\n-     * @param content\n-     *  the content to add as an updated content\n+     * @param cls\n+     *  the class of the entity store to fetch\n      *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n+     * @param create\n+     *  whether or not to create the entity store if it doesn't already exist\n      *\n      * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     *  the entity store for the given class, or null if an appropriate entity store does not exist\n+     *  and the create flag is false.\n      */\n-    public boolean addUpdatedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n+    private <T extends AbstractHibernateObject> EntityStore<T> getEntityStore(Class<T> cls, boolean create) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"cls is null\");\n         }\n \n-        return (this.updatedContent.put(content.getId(), content) != content);\n-    }\n-\n-    /**\n-     * Adds the specified content as a \"skipped\" content, where a skipped content is defined as\n-     * content which was already defined locally, but remained unchanged during the refresh\n-     * operation.\n-     *\n-     * @param content\n-     *  the content to add as a skipped content\n-     *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n+        EntityStore<T> entityStore = (EntityStore<T>) this.entityStoreMap.get(cls);\n+        if (entityStore == null && create) {\n+            entityStore = new EntityStore<T>();\n+            this.entityStoreMap.put(cls, entityStore);\n         }\n \n-        return (this.skippedContent.put(content.getId(), content) != content);\n+        return entityStore;\n     }\n \n-    // TODO: Return copy-on-write versions of the maps from the getters, rather than returning\n-    // our internal maps directly.\n-\n     /**\n-     * Fetches the pools created during refresh as a mapping of pool IDs to pool instances. If no\n-     * pools were created during the refresh operation, this method returns an empty map.\n+     * Adds the specified entity as a \"created\" entity, where a created entity is defined as a\n+     * entity which did not have a local definition and was created during the refresh operation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5ODM1Mw==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474698353", "createdAt": "2020-08-21T13:31:03Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshResult.java", "diffHunk": "@@ -32,501 +34,284 @@\n  */\n public class RefreshResult {\n \n-    // TODO: Flesh out the collection types here a bit more, in accordance with the table below\n-    //\n-    // Existing     Imported    Merged entity       Result\n-    // not-null     not-null    not-null            updated entity\n-    // not-null     not-null    null                unchanged entity (imported but unchanged)\n-    // not-null     null        not-null            children updated\n-    // not-null     null        null                unchanged entity (not imported, no changes to children)\n-    // null         not-null    not-null            created entity\n-    // null         not-null    null                ERROR STATE - creation failed\n-    // null         null        null                ERROR STATE - uninitialized node\n-    //\n-    // Following this, we have 3 states to report, and 2 pseudo-states:\n-    // - resultant states: created (5), updated (1, 3), unchanged (2, 4)\n-    // - pseudo-states: imported (1, 2, 5) and skipped (3, 4)\n-    //\n-    // At the time of writing, we can kind of discern the pseudo-states by getting the collections\n-    // back out of the refresh worker, so maybe this is a non-issue.\n-\n-    private Map<String, Pool> createdPools;\n-    private Map<String, Pool> updatedPools;\n-    private Map<String, Pool> skippedPools;\n-\n-    private Map<String, Product> createdProducts;\n-    private Map<String, Product> updatedProducts;\n-    private Map<String, Product> skippedProducts;\n-\n-    private Map<String, Content> createdContent;\n-    private Map<String, Content> updatedContent;\n-    private Map<String, Content> skippedContent;\n-\n-\n     /**\n-     * Creates a new RefreshResult instance with no data\n+     * The known states an entity can be in post-refresh\n      */\n-    public RefreshResult() {\n-        this.createdPools = new HashMap<>();\n-        this.updatedPools = new HashMap<>();\n-        this.skippedPools = new HashMap<>();\n-\n-        this.createdProducts = new HashMap<>();\n-        this.updatedProducts = new HashMap<>();\n-        this.skippedProducts = new HashMap<>();\n-\n-        this.createdContent = new HashMap<>();\n-        this.updatedContent = new HashMap<>();\n-        this.skippedContent = new HashMap<>();\n+    public static enum EntityState {\n+        CREATED,\n+        UPDATED,\n+        UNCHANGED,\n+        DELETED\n     }\n \n     /**\n-     * Adds the specified pool as a \"created\" pool, where a created pool is defined as a pool which\n-     * did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as a created pool\n+     * Stores refreshed entities of a given type\n      *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     * @param <T>\n+     *  the class of entity managed by this entity store\n      */\n-    public boolean addCreatedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+    public static class EntityStore<T extends AbstractHibernateObject> {\n+\n+        /**\n+         * Container class for storing entity and entity state\n+         */\n+        private static class EntityData<T extends AbstractHibernateObject> {\n+            private final String entityId;\n+            private final T entity;\n+            private final EntityState state;\n+\n+            public EntityData(String entityId, T entity, EntityState state) {\n+                this.entityId = entityId;\n+                this.entity = entity;\n+                this.state = state;\n+            }\n+\n+            public String getEntityId() {\n+                return this.entityId;\n+            }\n+\n+            public T getEntity() {\n+                return this.entity;\n+            }\n+\n+            public EntityState getEntityState() {\n+                return this.state;\n+            }\n         }\n \n-        return (this.createdPools.put(pool.getId(), pool) != pool);\n-    }\n+        private Map<String, EntityData<T>> entities;\n \n-    /**\n-     * Adds the specified pool as an \"updated\" pool, where an updated pool is defined as a pool\n-     * which was already defined locally, and was changed or updated during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as an updated pool\n-     *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addUpdatedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+        public EntityStore() {\n+            this.entities = new HashMap<>();\n         }\n \n-        return (this.updatedPools.put(pool.getId(), pool) != pool);\n-    }\n+        public void addEntity(T entity, EntityState state) {\n+            if (entity == null) {\n+                throw new IllegalArgumentException(\"entity is null\");\n+            }\n \n-    /**\n-     * Adds the specified pool as a \"skipped\" pool, where a skipped pool is defined as a pool which\n-     * was already defined locally, but remained unchanged during the refresh operation.\n-     *\n-     * @param pool\n-     *  the pool to add as a skipped pool\n-     *\n-     * @throws IllegalArgumentException\n-     *  if pool is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedPool(Pool pool) {\n-        if (pool == null) {\n-            throw new IllegalArgumentException(\"pool is null\");\n+            if (state == null) {\n+                throw new IllegalArgumentException(\"state is null\");\n+            }\n+\n+            EntityData<T> data = new EntityData<>((String) entity.getId(), entity, state);\n+            this.entities.put(data.getEntityId(), data);\n         }\n \n-        return (this.skippedPools.put(pool.getId(), pool) != pool);\n-    }\n+        public T getEntity(String id, Collection<EntityState> states) {\n+            EntityData<T> data = this.entities.get(id);\n \n-    /**\n-     * Adds the specified product as a \"created\" product, where a created product is defined as a\n-     * product which did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param product\n-     *  the product to add as a created product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addCreatedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n-        }\n+            if (data != null) {\n+                return states == null || states.isEmpty() || states.contains(data.getEntityState()) ?\n+                    data.getEntity() :\n+                    null;\n+            }\n \n-        return (this.createdProducts.put(product.getId(), product) != product);\n-    }\n+            return null;\n+        }\n \n-    /**\n-     * Adds the specified product as an \"updated\" product, where an updated product is defined as a\n-     * product which was already defined locally, and was changed or updated during the refresh\n-     * operation.\n-     *\n-     * @param product\n-     *  the product to add as an updated product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addUpdatedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n+        public EntityState getEntityState(String id) {\n+            EntityData<T> data = this.entities.get(id);\n+            return data != null ? data.getEntityState() : null;\n         }\n \n-        return (this.updatedProducts.put(product.getId(), product) != product);\n-    }\n+        public Map<String, T> getEntities(Collection<EntityState> states) {\n+            Stream<EntityData<T>> stream = this.entities.values()\n+                .stream();\n \n-    /**\n-     * Adds the specified product as a \"skipped\" product, where a skipped product is defined as a\n-     * product which was already defined locally, but remained unchanged during the refresh\n-     * operation.\n-     *\n-     * @param product\n-     *  the product to add as a skipped product\n-     *\n-     * @throws IllegalArgumentException\n-     *  if product is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedProduct(Product product) {\n-        if (product == null) {\n-            throw new IllegalArgumentException(\"product is null\");\n-        }\n+            if (states != null && !states.isEmpty()) {\n+                stream = stream.filter(edata -> states.contains(edata.getEntityState()));\n+            }\n \n-        return (this.skippedProducts.put(product.getId(), product) != product);\n+            return stream.collect(Collectors.toMap(EntityData::getEntityId, EntityData::getEntity));\n+        }\n     }\n \n+    private Map<Class, EntityStore> entityStoreMap;\n+\n     /**\n-     * Adds the specified content as a \"created\" content, where a created content is defined as\n-     * content which did not have a local definition and was created during the refresh operation.\n-     *\n-     * @param content\n-     *  the content to add as a created content\n-     *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     * Creates a new RefreshResult instance with no data\n      */\n-    public boolean addCreatedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n-        }\n-\n-        return (this.createdContent.put(content.getId(), content) != content);\n+    public RefreshResult() {\n+        this.entityStoreMap = new HashMap<>();\n     }\n \n     /**\n-     * Adds the specified content as an \"updated\" content, where an updated content is defined as\n-     * content which was already defined locally, and was changed or updated during the refresh\n-     * operation.\n+     * Fetches the entity store for the given class, optionally creating it as necessary.\n      *\n-     * @param content\n-     *  the content to add as an updated content\n+     * @param cls\n+     *  the class of the entity store to fetch\n      *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n+     * @param create\n+     *  whether or not to create the entity store if it doesn't already exist\n      *\n      * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n+     *  the entity store for the given class, or null if an appropriate entity store does not exist\n+     *  and the create flag is false.\n      */\n-    public boolean addUpdatedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n+    private <T extends AbstractHibernateObject> EntityStore<T> getEntityStore(Class<T> cls, boolean create) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"cls is null\");\n         }\n \n-        return (this.updatedContent.put(content.getId(), content) != content);\n-    }\n-\n-    /**\n-     * Adds the specified content as a \"skipped\" content, where a skipped content is defined as\n-     * content which was already defined locally, but remained unchanged during the refresh\n-     * operation.\n-     *\n-     * @param content\n-     *  the content to add as a skipped content\n-     *\n-     * @throws IllegalArgumentException\n-     *  if content is null\n-     *\n-     * @return\n-     *  true if this result instance is modified by this operation; false otherwise\n-     */\n-    public boolean addSkippedContent(Content content) {\n-        if (content == null) {\n-            throw new IllegalArgumentException(\"content is null\");\n+        EntityStore<T> entityStore = (EntityStore<T>) this.entityStoreMap.get(cls);\n+        if (entityStore == null && create) {\n+            entityStore = new EntityStore<T>();\n+            this.entityStoreMap.put(cls, entityStore);\n         }\n \n-        return (this.skippedContent.put(content.getId(), content) != content);\n+        return entityStore;\n     }\n \n-    // TODO: Return copy-on-write versions of the maps from the getters, rather than returning\n-    // our internal maps directly.\n-\n     /**\n-     * Fetches the pools created during refresh as a mapping of pool IDs to pool instances. If no\n-     * pools were created during the refresh operation, this method returns an empty map.\n+     * Adds the specified entity as a \"created\" entity, where a created entity is defined as a\n+     * entity which did not have a local definition and was created during the refresh operation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTQyNw=="}, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mjk0NzY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/refresher/nodes/EntityNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNDo0Njo1OVrOHEFHGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzozMTo1OVrOHEtW4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDA4OQ==", "bodyText": "UNPROCESSED doesn't seem to be a state, and isn't referenced anywhere else afaik", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474040089", "createdAt": "2020-08-20T14:46:59Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/nodes/EntityNode.java", "diffHunk": "@@ -125,33 +160,33 @@\n     boolean isLeafNode();\n \n     /**\n-     * Checks if this node has been \"visited\", indicating that a visitor has processed the node and\n-     * marked it as visited.\n+     * Checks if this node represents a new or updated database entity.\n      *\n      * @return\n-     *  true if this node has been marked as visited; false otherwise\n-     */\n-    boolean visited();\n-\n-    /**\n-     * Marks this node as visited. If the node has already been marked visited, this method silently\n-     * returns.\n+     *  true if this node represents a new or updated database entity; false otherwise\n      */\n-    void markVisited();\n+    boolean changed();\n \n     /**\n-     * Checks if this node represents a new or updated database entity.\n+     * Fetches the operation to be performed on this node\n      *\n      * @return\n-     *  true if this node represents a new or updated database entity; false otherwise\n+     *  a NodeState representing the pseudo-state of this node\n      */\n-    boolean changed();\n+    NodeState getNodeState();\n \n     /**\n-     * Marks this node as changed. If the node has already been marked changed, this method silently\n-     * returns.\n+     * Sets the pseudo-state of this node. If the provided state is null or UNPROCESSED, any", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5OTQ5MA==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2737#discussion_r474699490", "createdAt": "2020-08-21T13:31:59Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/nodes/EntityNode.java", "diffHunk": "@@ -125,33 +160,33 @@\n     boolean isLeafNode();\n \n     /**\n-     * Checks if this node has been \"visited\", indicating that a visitor has processed the node and\n-     * marked it as visited.\n+     * Checks if this node represents a new or updated database entity.\n      *\n      * @return\n-     *  true if this node has been marked as visited; false otherwise\n-     */\n-    boolean visited();\n-\n-    /**\n-     * Marks this node as visited. If the node has already been marked visited, this method silently\n-     * returns.\n+     *  true if this node represents a new or updated database entity; false otherwise\n      */\n-    void markVisited();\n+    boolean changed();\n \n     /**\n-     * Checks if this node represents a new or updated database entity.\n+     * Fetches the operation to be performed on this node\n      *\n      * @return\n-     *  true if this node represents a new or updated database entity; false otherwise\n+     *  a NodeState representing the pseudo-state of this node\n      */\n-    boolean changed();\n+    NodeState getNodeState();\n \n     /**\n-     * Marks this node as changed. If the node has already been marked changed, this method silently\n-     * returns.\n+     * Sets the pseudo-state of this node. If the provided state is null or UNPROCESSED, any", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDA4OQ=="}, "originalCommit": {"oid": "11773f6f21a55a56972f9d2fa2b39e74c15c251b"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4037, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}