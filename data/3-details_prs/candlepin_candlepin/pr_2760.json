{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1Mzc1NjA2", "number": 2760, "title": "[M] 1854221: Added additional job cleanup to JobManager and JobCleaner (ENT-2632, ENT-2630, ENT-2586)", "bodyText": "JobCleaner will now abort non-terminal, non-running jobs older\nthan three days (by default; configurable)\nJobCleaner will now abort running jobs older than two days\n(by default; configurable)\nJobManager will now attempt to \"rewind\" the job state for\nabandoned jobs during startup, where an \"abandoned\" job is\ndefined as one in the RUNNING state with the same executor\nas the node which is performing the check", "createdAt": "2020-07-22T21:56:56Z", "url": "https://github.com/candlepin/candlepin/pull/2760", "merged": true, "mergeCommit": {"oid": "0ec7e1ce5a54b7e310ac1e38b86d1feda5584bbb"}, "closed": true, "closedAt": "2020-07-28T11:44:43Z", "author": {"login": "Ceiu"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3iLf_gBqjM1Nzc3MjIwMjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5DHR_ABqjM1OTAyNjg5OTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "806cfa703ce34837787d3f1903540975f7df652c", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/806cfa703ce34837787d3f1903540975f7df652c", "committedDate": "2020-07-22T21:51:25Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}, "afterCommit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/15464457fd029a8703ac7623f2efbe18e617ec85", "committedDate": "2020-07-22T22:01:01Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjI1MDkz", "url": "https://github.com/candlepin/candlepin/pull/2760#pullrequestreview-454225093", "createdAt": "2020-07-23T15:00:45Z", "commit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTowMDo0NVrOG2OqdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToxOTo0MlrOG2Pg4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg==", "bodyText": "This could be a performance hit. Why do we need to fetch the actual objects before changing their state?\nIf the only reason is to utilize the transition validation the setJobState does, then maybe we should be doing that validation without fetching the job objects into memory (we have the collection of JobState, we can just validate against JobState.ABORTED).", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459516532", "createdAt": "2020-07-23T15:00:45Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/async/JobManager.java", "diffHunk": "@@ -1717,11 +1746,59 @@ public int cleanupJobs(AsyncJobStatusQueryBuilder queryBuilder) {\n \n         queryBuilder.setJobStates(states);\n \n-        // TODO: any other sanity restrictions deemed necessary\n+        // Add any other sanity restrictions deemed necessary here\n \n         return this.jobCurator.deleteJobs(queryBuilder);\n     }\n \n+    /**\n+     * Aborts all non-terminal jobs matching the query parameters provided. If the query does not\n+     * specify any states, this method defaults to all non-terminal, non-running states. If any\n+     * terminal or running states are provided, they will be ignored.\n+     *\n+     * @param queryBuilder\n+     *  an AsyncJobStatusQueryBuilder instance containing the various arguments or filters to use\n+     *  to select jobs to abort\n+     *\n+     * @return\n+     *  the number of jobs aborted as a result of this operation\n+     */\n+    @Transactional\n+    public int abortNonTerminalJobs(AsyncJobStatusQueryBuilder queryBuilder) {\n+        // Prepare for the defaults...\n+        if (queryBuilder == null) {\n+            queryBuilder = new AsyncJobStatusQueryBuilder();\n+        }\n+\n+        Collection<JobState> states = queryBuilder.getJobStates();\n+        if (states != null && !states.isEmpty()) {\n+            // Make sure we don't attempt to abort some jobs that are already in terminal states\n+            states = states.stream()\n+                .filter(state -> state != null && !state.isTerminal() && state != JobState.RUNNING)\n+                .collect(Collectors.toSet());\n+        }\n+        else {\n+            // Set the default: all terminal states\n+            states = Arrays.stream(JobState.values())\n+                .filter(state -> state != null && !state.isTerminal() && state != JobState.RUNNING)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        queryBuilder.setJobStates(states);\n+\n+        // Add any other sanity restrictions deemed necessary here\n+\n+        List<AsyncJobStatus> jobs = this.jobCurator.findJobs(queryBuilder);\n+\n+        // Step through each job and update the job state\n+        for (AsyncJobStatus job : jobs) {\n+            this.setJobState(job, JobState.ABORTED);\n+            this.jobCurator.merge(job);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyMTkxNw==", "bodyText": "Same question here: why fetch job objects into memory? we don't even do transition validation here, so an update query would be much faster", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459521917", "createdAt": "2020-07-23T15:08:10Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/async/JobManager.java", "diffHunk": "@@ -495,6 +500,30 @@ public synchronized void initialize() throws StateManagementException {\n         }\n     }\n \n+    /**\n+     * Attempts to recover all jobs that were abandoned by this node if it shutdown abnormally\n+     * while executing jobs. Any jobs in the RUNNING state with an executor set to this node\n+     * will have their state forcefully rewound to QUEUED in an attempt to allow the task to be\n+     * rerun.\n+     */\n+    private void recoverAbandonedJobs() {\n+        AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n+            .setJobStates(Collections.singleton(JobState.RUNNING))\n+            .setExecutors(Collections.singleton(Util.getHostname()));\n+\n+        // Impl note: this violates normal state transitions, but we're trying to recover from an\n+        // ungraceful shutdown in which our process was terminated while a job was running. We'll\n+        // set the job's state to QUEUED, which will allow us to pick up the job and run it again\n+        // next time the message is received. If the message has been lost, then the job cleaner\n+        // will eventually nuke this job as part of its non-terminal job aborting step.\n+        for (AsyncJobStatus job : this.jobCurator.findJobs(queryBuilder)) {\n+            log.warn(\"Recovering abandoned job: {}\", job);\n+\n+            job.setState(JobState.QUEUED);\n+            this.jobCurator.merge(job);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDI5Nw==", "bodyText": "This logging doesn't work. When the JobCleaner runs the logs print the literal string Removed %d terminal jobs older than %2$tF %2$tT%2$tz. The intellij tooltip says \"More arguments provided (2) than placeholders specified (0)\"", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459530297", "createdAt": "2020-07-23T15:19:26Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/async/tasks/JobCleaner.java", "diffHunk": "@@ -63,36 +66,66 @@ public JobCleaner(Configuration config, JobManager jobManager) {\n \n     @Override\n     public void execute(JobExecutionContext context) throws JobExecutionException {\n-        String cfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_JOB_AGE);\n-        int maxAgeInMinutes = this.config.getInt(cfgName, CFG_DEFAULT_MAX_JOB_AGE);\n+        String termCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_TERMINAL_JOB_AGE);\n+        Date termCutoff = this.parseMaxJobAgeConfig(termCfgName, CFG_DEFAULT_MAX_TERMINAL_JOB_AGE);\n+\n+        String nontermCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_NONTERMINAL_JOB_AGE);\n+        Date nontermCutoff = this.parseMaxJobAgeConfig(nontermCfgName, CFG_DEFAULT_MAX_NONTERMINAL_JOB_AGE);\n+\n+        int removed = this.cleanupTerminalJobs(termCutoff);\n+        int aborted = this.abortNonTerminalJobs(nontermCutoff);\n+\n+        context.setJobResult(String.format(\n+            \"Removed %1$d terminal jobs older than %2$tF %2$tT%2$tz\\n\" +\n+            \"Aborted %3$d non-running jobs older than %4$tF %4$tT%4$tz\",\n+            removed, termCutoff, aborted, nontermCutoff));\n+    }\n \n-        if (maxAgeInMinutes < 1) {\n-            String errmsg = String.format(\"Invalid value for max age, must be a positive integer: %s\",\n-                maxAgeInMinutes);\n+    private Date parseMaxJobAgeConfig(String cfgName, int defaultValue) throws JobExecutionException {\n+        int value = this.config.getInt(cfgName, defaultValue);\n+\n+        if (value < 1) {\n+            String errmsg = String.format(\"Invalid value for %s, must be a positive integer: %s\",\n+                cfgName, value);\n \n             log.error(errmsg);\n             throw new JobExecutionException(errmsg, true);\n         }\n \n-        // Set cutoff (end) date to now - max age in minutes\n-        Date cutoff = Util.addMinutesToDt(maxAgeInMinutes * -1);\n+        return Util.addMinutesToDt(value * -1);\n+    }\n \n+    private int cleanupTerminalJobs(Date cutoff) {\n         // We're targeting every terminal job\n         Set<JobState> jobStates = Arrays.stream(JobState.values())\n-            .filter(state -> state.isTerminal())\n+            .filter(JobState::isTerminal)\n             .collect(Collectors.toSet());\n \n         // Build the query builder with our config\n         AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n             .setJobStates(jobStates)\n             .setEndDate(cutoff);\n \n-        int deleted = this.jobManager.cleanupJobs(queryBuilder);\n+        int removed = this.jobManager.cleanupJobs(queryBuilder);\n+        log.info(\"Removed %d terminal jobs older than %2$tF %2$tT%2$tz\", removed, cutoff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDQ2Nw==", "bodyText": "Same here, logging doesn't work", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459530467", "createdAt": "2020-07-23T15:19:42Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/async/tasks/JobCleaner.java", "diffHunk": "@@ -63,36 +66,66 @@ public JobCleaner(Configuration config, JobManager jobManager) {\n \n     @Override\n     public void execute(JobExecutionContext context) throws JobExecutionException {\n-        String cfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_JOB_AGE);\n-        int maxAgeInMinutes = this.config.getInt(cfgName, CFG_DEFAULT_MAX_JOB_AGE);\n+        String termCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_TERMINAL_JOB_AGE);\n+        Date termCutoff = this.parseMaxJobAgeConfig(termCfgName, CFG_DEFAULT_MAX_TERMINAL_JOB_AGE);\n+\n+        String nontermCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_NONTERMINAL_JOB_AGE);\n+        Date nontermCutoff = this.parseMaxJobAgeConfig(nontermCfgName, CFG_DEFAULT_MAX_NONTERMINAL_JOB_AGE);\n+\n+        int removed = this.cleanupTerminalJobs(termCutoff);\n+        int aborted = this.abortNonTerminalJobs(nontermCutoff);\n+\n+        context.setJobResult(String.format(\n+            \"Removed %1$d terminal jobs older than %2$tF %2$tT%2$tz\\n\" +\n+            \"Aborted %3$d non-running jobs older than %4$tF %4$tT%4$tz\",\n+            removed, termCutoff, aborted, nontermCutoff));\n+    }\n \n-        if (maxAgeInMinutes < 1) {\n-            String errmsg = String.format(\"Invalid value for max age, must be a positive integer: %s\",\n-                maxAgeInMinutes);\n+    private Date parseMaxJobAgeConfig(String cfgName, int defaultValue) throws JobExecutionException {\n+        int value = this.config.getInt(cfgName, defaultValue);\n+\n+        if (value < 1) {\n+            String errmsg = String.format(\"Invalid value for %s, must be a positive integer: %s\",\n+                cfgName, value);\n \n             log.error(errmsg);\n             throw new JobExecutionException(errmsg, true);\n         }\n \n-        // Set cutoff (end) date to now - max age in minutes\n-        Date cutoff = Util.addMinutesToDt(maxAgeInMinutes * -1);\n+        return Util.addMinutesToDt(value * -1);\n+    }\n \n+    private int cleanupTerminalJobs(Date cutoff) {\n         // We're targeting every terminal job\n         Set<JobState> jobStates = Arrays.stream(JobState.values())\n-            .filter(state -> state.isTerminal())\n+            .filter(JobState::isTerminal)\n             .collect(Collectors.toSet());\n \n         // Build the query builder with our config\n         AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n             .setJobStates(jobStates)\n             .setEndDate(cutoff);\n \n-        int deleted = this.jobManager.cleanupJobs(queryBuilder);\n+        int removed = this.jobManager.cleanupJobs(queryBuilder);\n+        log.info(\"Removed %d terminal jobs older than %2$tF %2$tT%2$tz\", removed, cutoff);\n+\n+        return removed;\n+    }\n+\n+    private int abortNonTerminalJobs(Date cutoff) {\n+        // We're targeting every non-terminal, non-running job\n+        Set<JobState> jobStates = Arrays.stream(JobState.values())\n+            .filter(state -> !state.isTerminal() && state != JobState.RUNNING)\n+            .collect(Collectors.toSet());\n+\n+        // Build the query builder with our config\n+        AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n+            .setJobStates(jobStates)\n+            .setEndDate(cutoff);\n \n-        String result = String.format(\"Removed %d terminal jobs older than %2$tF %2$tT%2$tz\",\n-            deleted, cutoff);\n+        int aborted = this.jobManager.abortNonTerminalJobs(queryBuilder);\n+        log.info(\"Aborted %d non-running jobs older than %2$tF %2$tT%2$tz\", aborted, cutoff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85"}, "originalPosition": 87}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15464457fd029a8703ac7623f2efbe18e617ec85", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/15464457fd029a8703ac7623f2efbe18e617ec85", "committedDate": "2020-07-22T22:01:01Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}, "afterCommit": {"oid": "6d996dff247e4375c8cff66ed7d58da5a5f301f8", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/6d996dff247e4375c8cff66ed7d58da5a5f301f8", "committedDate": "2020-07-23T20:17:18Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1760d14380c64b4114076886ef3fce4bee23fdc6", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/1760d14380c64b4114076886ef3fce4bee23fdc6", "committedDate": "2020-07-27T14:56:45Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobCleaner will now abort running jobs older than two days\n  (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d996dff247e4375c8cff66ed7d58da5a5f301f8", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/6d996dff247e4375c8cff66ed7d58da5a5f301f8", "committedDate": "2020-07-23T20:17:18Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}, "afterCommit": {"oid": "1760d14380c64b4114076886ef3fce4bee23fdc6", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/1760d14380c64b4114076886ef3fce4bee23fdc6", "committedDate": "2020-07-27T14:56:45Z", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobCleaner will now abort running jobs older than two days\n  (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2280, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}