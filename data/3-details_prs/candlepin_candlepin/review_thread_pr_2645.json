{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwOTg5MTEx", "number": 2645, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMTowMzowOVrODvgmoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTowNTozNFrODvs5VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTQzODQxOnYy", "diffSide": "RIGHT", "path": "server/spec/autobind_disabled_for_owner_spec.rb", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMTowMzowOVrOGB-UbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoxNTowNlrOGCurIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMjc5Nw==", "bodyText": "Unless I'm misunderstanding something, this is not correct, right? org_environment is definitely used in standalone mode, it's just that we can't directly set/update it (that should only happen during import)? This test (and the next one in the same file) should still be running in standalone mode, since they are testing the registration & heal logic, not the create_owner logic.", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r404722797", "createdAt": "2020-04-07T11:03:09Z", "author": {"login": "nikosmoum"}, "path": "server/spec/autobind_disabled_for_owner_spec.rb", "diffHunk": "@@ -85,10 +85,14 @@\n   end\n \n   it 'will still register when content access setting enabled and autobind enabled on activation key' do\n+    # org_environment mode cannot be used in standalone mode\n+    skip(\"candlepin running in standalone mode\") if not is_hosted?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4MTkwNQ==", "bodyText": "I'll go back and take a look at this more closely, but in general, the places that relied on setting the org_environment during creation were somewhat broken on the CP side, and the new restrictions renders the tests broken in standalone mode. I'll get into more details with the comment below in OwnerResource.", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405081905", "createdAt": "2020-04-07T20:10:41Z", "author": {"login": "Ceiu"}, "path": "server/spec/autobind_disabled_for_owner_spec.rb", "diffHunk": "@@ -85,10 +85,14 @@\n   end\n \n   it 'will still register when content access setting enabled and autobind enabled on activation key' do\n+    # org_environment mode cannot be used in standalone mode\n+    skip(\"candlepin running in standalone mode\") if not is_hosted?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMjc5Nw=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MTI4Mg==", "bodyText": "Looking at the tests again, both of them attempt to use org_environment as the operating CA mode, which is what got the tests disabled.\nSetting the list is still possible in standalone mode during creation, but it's the reliance on the mode change which is not.", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405091282", "createdAt": "2020-04-07T20:27:33Z", "author": {"login": "Ceiu"}, "path": "server/spec/autobind_disabled_for_owner_spec.rb", "diffHunk": "@@ -85,10 +85,14 @@\n   end\n \n   it 'will still register when content access setting enabled and autobind enabled on activation key' do\n+    # org_environment mode cannot be used in standalone mode\n+    skip(\"candlepin running in standalone mode\") if not is_hosted?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMjc5Nw=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5MjM1Nw==", "bodyText": "Alright, it's just that the comment is misleading when it says \"org_environment mode cannot be used in standalone mode\". An org can get into org_environment mode through the import process, while someone new to the code looking at this comment might think that org_environment is a hosted-only feature (I certainly would think so, since I always looked to the spec tests to find out more about use cases of features). Maybe It would be more accurate to change this comment (and other similar ones in the spec tests, where appropriate) to \"org_environment mode cannot be set directly in standalone mode\"?", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405392357", "createdAt": "2020-04-08T09:37:53Z", "author": {"login": "nikosmoum"}, "path": "server/spec/autobind_disabled_for_owner_spec.rb", "diffHunk": "@@ -85,10 +85,14 @@\n   end\n \n   it 'will still register when content access setting enabled and autobind enabled on activation key' do\n+    # org_environment mode cannot be used in standalone mode\n+    skip(\"candlepin running in standalone mode\") if not is_hosted?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMjc5Nw=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTA0Mw==", "bodyText": "I've updated the comment above the skip on these tests to read \"org_environment mode cannot be set via API in standalone mode\"", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405515043", "createdAt": "2020-04-08T13:15:06Z", "author": {"login": "Ceiu"}, "path": "server/spec/autobind_disabled_for_owner_spec.rb", "diffHunk": "@@ -85,10 +85,14 @@\n   end\n \n   it 'will still register when content access setting enabled and autobind enabled on activation key' do\n+    # org_environment mode cannot be used in standalone mode\n+    skip(\"candlepin running in standalone mode\") if not is_hosted?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMjc5Nw=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjIyNTYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDoyMTowN1rOGCF79A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoyMjozOVrOGCUo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg0NzYwNA==", "bodyText": "I don't know if this is something that could happen, but this will set listUpdated to true if the order of csv in the list is switched (e.g. currentList is org_environment,entitlement and updatedList is entitlement,org_environment. The final effect might be the same, but we'll be running some of the following code unnecesserilly. Maybe it should be comparing after both strings are split into arrays of Strings?\nIf we decide we care about the ordering of these, then we should also change this in the other places we compare the list Strings (create/update owner calls).", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r404847604", "createdAt": "2020-04-07T14:21:07Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -388,4 +489,172 @@ private String createDN(Consumer consumer, Owner owner) {\n         return v3extensionUtil.createEntitlementDataPayload(productModels,\n             emptyConsumer, emptyPool, null);\n     }\n+\n+    public boolean hasCertChangedSince(Consumer consumer, Date date) {\n+        if (date == null) {\n+            return true;\n+        }\n+\n+        Environment env = this.environmentCurator.getConsumerEnvironment(consumer);\n+        OwnerEnvContentAccess oeca = ownerEnvContentAccessCurator\n+            .getContentAccess(consumer.getOwnerId(), env == null ? null : env.getId());\n+\n+        return oeca == null ||\n+            consumer.getContentAccessCert() == null ||\n+            oeca.getUpdated().getTime() > date.getTime();\n+    }\n+\n+    @Transactional\n+    public void removeContentAccessCert(Consumer consumer) {\n+        if (consumer.getContentAccessCert() == null) {\n+            return;\n+        }\n+        contentAccessCertificateCurator.delete(consumer.getContentAccessCert());\n+        consumer.setContentAccessCert(null);\n+    }\n+\n+\n+    /**\n+     * Updates the content access mode state for the given owner using the updated content access mode\n+     * list and content access mode provided.\n+     *\n+     * @param owner\n+     *  The owner to refresh\n+     *\n+     * @param updatedList\n+     *  the updated content access mode list to apply, or an empty string to restore the default value\n+     *\n+     * @param updatedMode\n+     *  the updated content access mode to apply, or an empty string to restore the default value\n+     *\n+     * @throws IllegalStateException\n+     *  if the requested content access mode is not in the provided content access mode list\n+     *\n+     * @return\n+     *  the refreshed owner; may be a different instance than the input owner\n+     */\n+    @Transactional\n+    public Owner updateOwnerContentAccess(Owner owner, String updatedList, String updatedMode) {\n+        if (owner == null) {\n+            throw new IllegalArgumentException(\"owner is null\");\n+        }\n+\n+        boolean listUpdated = false;\n+        boolean modeUpdated = false;\n+\n+        this.ownerCurator.lock(owner);\n+\n+        final String defaultMode = ContentAccessMode.getDefault().toDatabaseValue();\n+\n+        // Grab the current list and mode\n+        String currentList = this.resolveContentAccessValue(owner.getContentAccessModeList(), true);\n+        String currentMode = this.resolveContentAccessValue(owner.getContentAccessMode(), true);\n+\n+        // Resolve the updated list and mode\n+        updatedList = this.resolveContentAccessValue(updatedList, false);\n+        updatedMode = this.resolveContentAccessValue(updatedMode, false);\n+\n+        if (updatedList != null) {\n+            String[] modes = updatedList.split(\",\");\n+\n+            // We're not interested in storing access modes that we don't support\n+            for (String mode : modes) {\n+                // This will throw an IAE if the mode isn't one we support.\n+                ContentAccessMode.resolveModeName(mode);\n+            }\n+\n+            listUpdated = !updatedList.equals(currentList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4ODQ3Ng==", "bodyText": "You're right in that this triggers in an order swap, but I made the choice to not care about that since the overhead associated with a list change is minimal (and is something we just assumed was the case, prior). The only extra work this incurs is the persisting of the owner if the mode is unchanged, and a database call to cull invalid modes.\nI'm not entirely opposed to adding the logic to do an unordered comparison, but I feel it's not going to be a very common case, and we'll lose runtime from the extra computation in the general case vs what I assume to be the uncommon cases of an order change.", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405088476", "createdAt": "2020-04-07T20:22:39Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -388,4 +489,172 @@ private String createDN(Consumer consumer, Owner owner) {\n         return v3extensionUtil.createEntitlementDataPayload(productModels,\n             emptyConsumer, emptyPool, null);\n     }\n+\n+    public boolean hasCertChangedSince(Consumer consumer, Date date) {\n+        if (date == null) {\n+            return true;\n+        }\n+\n+        Environment env = this.environmentCurator.getConsumerEnvironment(consumer);\n+        OwnerEnvContentAccess oeca = ownerEnvContentAccessCurator\n+            .getContentAccess(consumer.getOwnerId(), env == null ? null : env.getId());\n+\n+        return oeca == null ||\n+            consumer.getContentAccessCert() == null ||\n+            oeca.getUpdated().getTime() > date.getTime();\n+    }\n+\n+    @Transactional\n+    public void removeContentAccessCert(Consumer consumer) {\n+        if (consumer.getContentAccessCert() == null) {\n+            return;\n+        }\n+        contentAccessCertificateCurator.delete(consumer.getContentAccessCert());\n+        consumer.setContentAccessCert(null);\n+    }\n+\n+\n+    /**\n+     * Updates the content access mode state for the given owner using the updated content access mode\n+     * list and content access mode provided.\n+     *\n+     * @param owner\n+     *  The owner to refresh\n+     *\n+     * @param updatedList\n+     *  the updated content access mode list to apply, or an empty string to restore the default value\n+     *\n+     * @param updatedMode\n+     *  the updated content access mode to apply, or an empty string to restore the default value\n+     *\n+     * @throws IllegalStateException\n+     *  if the requested content access mode is not in the provided content access mode list\n+     *\n+     * @return\n+     *  the refreshed owner; may be a different instance than the input owner\n+     */\n+    @Transactional\n+    public Owner updateOwnerContentAccess(Owner owner, String updatedList, String updatedMode) {\n+        if (owner == null) {\n+            throw new IllegalArgumentException(\"owner is null\");\n+        }\n+\n+        boolean listUpdated = false;\n+        boolean modeUpdated = false;\n+\n+        this.ownerCurator.lock(owner);\n+\n+        final String defaultMode = ContentAccessMode.getDefault().toDatabaseValue();\n+\n+        // Grab the current list and mode\n+        String currentList = this.resolveContentAccessValue(owner.getContentAccessModeList(), true);\n+        String currentMode = this.resolveContentAccessValue(owner.getContentAccessMode(), true);\n+\n+        // Resolve the updated list and mode\n+        updatedList = this.resolveContentAccessValue(updatedList, false);\n+        updatedMode = this.resolveContentAccessValue(updatedMode, false);\n+\n+        if (updatedList != null) {\n+            String[] modes = updatedList.split(\",\");\n+\n+            // We're not interested in storing access modes that we don't support\n+            for (String mode : modes) {\n+                // This will throw an IAE if the mode isn't one we support.\n+                ContentAccessMode.resolveModeName(mode);\n+            }\n+\n+            listUpdated = !updatedList.equals(currentList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg0NzYwNA=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 391}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI4MjIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/model/ConsumerCurator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozMzowMlrOGCGgUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxNDo0NlrOGCUX8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NjkxMw==", "bodyText": "incomplete comment", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r404856913", "createdAt": "2020-04-07T14:33:02Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/model/ConsumerCurator.java", "diffHunk": "@@ -1287,4 +1290,32 @@ public int getConsumerEntitlementCount(Owner owner, ConsumerType type) {\n             .list();\n     }\n \n+    /**\n+     * Clears (nulls) the content access mode for any consumer belonging to the given owner, that is\n+     * using a mode which is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDE0Nw==", "bodyText": "Yikes. Looks like my brain just kinda gave up here. I've fixed this all up and added some additional input validation.", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405084147", "createdAt": "2020-04-07T20:14:46Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/model/ConsumerCurator.java", "diffHunk": "@@ -1287,4 +1290,32 @@ public int getConsumerEntitlementCount(Owner owner, ConsumerType type) {\n             .list();\n     }\n \n+    /**\n+     * Clears (nulls) the content access mode for any consumer belonging to the given owner, that is\n+     * using a mode which is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NjkxMw=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjI4NTM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/model/ConsumerCurator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDozMzo0NFrOGCGiPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxNDo1MVrOGCUYHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NzQwNw==", "bodyText": "This is the @param existingModes, not the @return", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r404857407", "createdAt": "2020-04-07T14:33:44Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/model/ConsumerCurator.java", "diffHunk": "@@ -1287,4 +1290,32 @@ public int getConsumerEntitlementCount(Owner owner, ConsumerType type) {\n             .list();\n     }\n \n+    /**\n+     * Clears (nulls) the content access mode for any consumer belonging to the given owner, that is\n+     * using a mode which is\n+     *\n+     * @param owner\n+     *  the owner for which to fetch active consumer content access modes\n+     *\n+     * @throws IllegalArgumentException\n+     *  if owner is null\n+     *\n+     * @return\n+     *  a list of all active consumer content access modes for consumers of the given owner", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDE5MQ==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405084191", "createdAt": "2020-04-07T20:14:51Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/model/ConsumerCurator.java", "diffHunk": "@@ -1287,4 +1290,32 @@ public int getConsumerEntitlementCount(Owner owner, ConsumerType type) {\n             .list();\n     }\n \n+    /**\n+     * Clears (nulls) the content access mode for any consumer belonging to the given owner, that is\n+     * using a mode which is\n+     *\n+     * @param owner\n+     *  the owner for which to fetch active consumer content access modes\n+     *\n+     * @throws IllegalArgumentException\n+     *  if owner is null\n+     *\n+     * @return\n+     *  a list of all active consumer content access modes for consumers of the given owner", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg1NzQwNw=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzQ1MjM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/resource/OwnerResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTowNTozNFrOGCSCZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxODo0MFrOGCUgVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA0NTg2MA==", "bodyText": "I see this was not a restriction on the create owner call before (both the mode and the list could be set). Was that an omission? Also, I assume this has something to do with the implementation note below about pre-existing expected behaviours; what are those?\nAlso, if we're adding this restriction here now, we should add a test case about it (best place is probably OwnerResourceTest.java)", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405045860", "createdAt": "2020-04-07T19:05:34Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/OwnerResource.java", "diffHunk": "@@ -879,35 +886,54 @@ public OwnerDTO createOwner(@ApiParam(name = \"owner\", required = true) OwnerDTO\n             throw new BadRequestException(i18n.tr(\"Owners must be created with a valid key\"));\n         }\n \n-        // Validate and set content access mode list & content access mode\n-        if (StringUtils.isBlank(dto.getContentAccessModeList())) {\n-            dto.setContentAccessModeList(ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE);\n-        }\n+        Owner owner = new Owner();\n+        owner.setKey(dto.getKey());\n \n-        if (StringUtils.isBlank(dto.getContentAccessMode())) {\n-            dto.setContentAccessMode(ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE);\n+        // Check that the default service level is *not* set at this point\n+        if (!StringUtils.isBlank(dto.getDefaultServiceLevel())) {\n+            throw new BadRequestException(\n+                i18n.tr(\"The default service level cannot be specified during owner creation\"));\n         }\n \n-        if (!containsContentAccessMode(dto.getContentAccessModeList(), dto.getContentAccessMode())) {\n-            throw new BadRequestException(\n-                i18n.tr(\"The content access mode \\\"{1}\\\" is not allowed for this owner.\",\n-                    dto.getContentAccessMode()));\n+        // Validate and set content access mode list & content access mode\n+        boolean configureContentAccess = false;\n+\n+        final String defaultContentAccess = ContentAccessMode.getDefault().toDatabaseValue();\n+        String contentAccessModeList = dto.getContentAccessModeList();\n+        String contentAccessMode = dto.getContentAccessMode();\n+\n+        if (!StringUtils.isBlank(contentAccessMode) && !contentAccessMode.equals(defaultContentAccess)) {\n+            if (config.getBoolean(ConfigProperties.STANDALONE)) {\n+                throw new BadRequestException(\n+                    i18n.tr(\"The owner content access mode and content access mode list cannot be set \" +\n+                        \"directly in standalone mode.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjI5Mw==", "bodyText": "It looked to be an omission, and from the bit of discussion I had with people who remembered the original design, it seemed like an oversight. Prior, we could set the content access mode and list during creation, but it would not result in an actual change in state or cert generation at all. So you could get into a situation where an owner was already in org_environment but it wouldn't be functional, and the only way to fix it would be to do two updates to flip to entitlement and then back to org_environment so the updateOwnerContentAccess call (previously refreshContentAccess) would get hit.\nThis got added to prevent that from happening, but I quickly found that we have a lot of behavior that's expecting some parts of this to be allowed -- i.e. explicitly setting the default values during creation, and specifying the existing values during update (such as when a client fetches an org, makes changes to the received json and then sends it back up).\nThere were a few tests which broke by adding this restriction, and those were updated or skipped in standalone mode where it either didn't make sense or didn't seem to be reconcilable.", "url": "https://github.com/candlepin/candlepin/pull/2645#discussion_r405086293", "createdAt": "2020-04-07T20:18:40Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/resource/OwnerResource.java", "diffHunk": "@@ -879,35 +886,54 @@ public OwnerDTO createOwner(@ApiParam(name = \"owner\", required = true) OwnerDTO\n             throw new BadRequestException(i18n.tr(\"Owners must be created with a valid key\"));\n         }\n \n-        // Validate and set content access mode list & content access mode\n-        if (StringUtils.isBlank(dto.getContentAccessModeList())) {\n-            dto.setContentAccessModeList(ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE);\n-        }\n+        Owner owner = new Owner();\n+        owner.setKey(dto.getKey());\n \n-        if (StringUtils.isBlank(dto.getContentAccessMode())) {\n-            dto.setContentAccessMode(ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE);\n+        // Check that the default service level is *not* set at this point\n+        if (!StringUtils.isBlank(dto.getDefaultServiceLevel())) {\n+            throw new BadRequestException(\n+                i18n.tr(\"The default service level cannot be specified during owner creation\"));\n         }\n \n-        if (!containsContentAccessMode(dto.getContentAccessModeList(), dto.getContentAccessMode())) {\n-            throw new BadRequestException(\n-                i18n.tr(\"The content access mode \\\"{1}\\\" is not allowed for this owner.\",\n-                    dto.getContentAccessMode()));\n+        // Validate and set content access mode list & content access mode\n+        boolean configureContentAccess = false;\n+\n+        final String defaultContentAccess = ContentAccessMode.getDefault().toDatabaseValue();\n+        String contentAccessModeList = dto.getContentAccessModeList();\n+        String contentAccessMode = dto.getContentAccessMode();\n+\n+        if (!StringUtils.isBlank(contentAccessMode) && !contentAccessMode.equals(defaultContentAccess)) {\n+            if (config.getBoolean(ConfigProperties.STANDALONE)) {\n+                throw new BadRequestException(\n+                    i18n.tr(\"The owner content access mode and content access mode list cannot be set \" +\n+                        \"directly in standalone mode.\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA0NTg2MA=="}, "originalCommit": {"oid": "49b856684952fd79ca79ea6d011d5f602c62d241"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4111, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}