{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyMjcxODcy", "number": 2780, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwODo0NDozMlrOEb95JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzowOToyOFrOEcD5rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NzYxMDYwOnYy", "diffSide": "RIGHT", "path": "server/spec/content_access_spec.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwODo0NDozMlrOHGN6pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjowMDo0OFrOHG8_dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI4MTUwOA==", "bodyText": "we should not use the .should statement because it's deprecated. let's use expect().to/to_not eq()\nSame thing for the few places further down that .should is used", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476281508", "createdAt": "2020-08-25T08:44:32Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1Mjc4OQ==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477052789", "createdAt": "2020-08-26T06:00:48Z", "author": {"login": "wolfdale"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI4MTUwOA=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODE0MTIyOnYy", "diffSide": "RIGHT", "path": "server/spec/content_access_spec.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTowNzoyNFrOHGS_pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjowMDo1MVrOHG8_iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2NDcwOA==", "bodyText": "Let's add a length check here in addition to this loop, that will make sure there's 3 contents, because this test might silently pass if (for whatever reason) the 2 contents you created explicitly are not present in the certificate", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476364708", "createdAt": "2020-08-25T11:07:24Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1MjgwOQ==", "bodyText": "Right. Added length check.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477052809", "createdAt": "2020-08-26T06:00:51Z", "author": {"login": "wolfdale"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2NDcwOA=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODMxODAzOnYy", "diffSide": "RIGHT", "path": "server/spec/content_access_spec.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTo1NzoyOVrOHGUqKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjoxNDozMVrOHG9SPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTk3OQ==", "bodyText": "Is that an actual use case?? Can't imagine why we would want to do that.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476391979", "createdAt": "2020-08-25T11:57:29Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzU5OA==", "bodyText": "This was suppose to be a test for mixed content enablement. I have made some modification to make sure in such cases enabled content wins out even if its disabled in rest of the associated products.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477057598", "createdAt": "2020-08-26T06:14:31Z", "author": {"login": "wolfdale"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTk3OQ=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODM4NDM1OnYy", "diffSide": "RIGHT", "path": "server/spec/content_access_spec.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjoxNjozMVrOHGVRZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjowMDo1NFrOHG8_mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjAyMw==", "bodyText": "Same here, we should check there's at least 2 contents", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476402023", "createdAt": "2020-08-25T12:16:31Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do\n+    product_1 = create_product('test-product-p1', 'some product-p1')\n+    product_2 = create_product('test-product-p2', 'some product-p2')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+\n+    @cp.add_content_to_product(@owner['key'], product_1['id'], content_c1['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product_2['id'], content_c1['id'], true)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+\n+    json_body['products'][0]['content'].each do |content|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1MjgyNw==", "bodyText": "Added.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477052827", "createdAt": "2020-08-26T06:00:54Z", "author": {"login": "wolfdale"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do\n+    product_1 = create_product('test-product-p1', 'some product-p1')\n+    product_2 = create_product('test-product-p2', 'some product-p2')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+\n+    @cp.add_content_to_product(@owner['key'], product_1['id'], content_c1['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product_2['id'], content_c1['id'], true)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+\n+    json_body['products'][0]['content'].each do |content|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjAyMw=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODU1NTkxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjo1OTo0NlrOHGW6qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDoxMDoyNVrOHHb-TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA==", "bodyText": "If we're adding content with the same ID to a given product twice, it will overwrite the previous instance with the new one. I would expect that this results in the enabled flag being set to whatever comes in last, rather than both existing on the product.\nAside from that, I don't understand the intent behind adding it as a disabled content if it's already present. In this case, the resultant behavior we want is for the content to be available if something has enabled it. Adding a disabled version of the content as well will only serve as a stumbling block for any processing that occurs after this step.\nIn the event we have an organization that has multiple sources of a given content with mixed enablement, I would expect the \"enabled\" version to win out. We could even fetch that set of content pretty easily with a new query that only fetches enabled content for a given owner.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476428970", "createdAt": "2020-08-25T12:59:46Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NDM0Nw==", "bodyText": "I was not sure what should be the expected behavior with mix content enablement, I have already asked PM's about it\nand waiting for a reply. Modified the code to make sure that the \"enabled\" version win out.\nI noticed that content can exist without product, when we query owner-content we get unwanted content, so decided to go via owner-product (and ideally it should be content of product with active pool, there was some work in that area with ENT-2352, not sure if it is there in master branch)", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477054347", "createdAt": "2020-08-26T06:05:21Z", "author": {"login": "wolfdale"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzODcxMQ==", "bodyText": "In non-SCA mode, we simply return duplicates (or more) of the same content that might be enabled or disabled, but that's because they come from different entitlement certs. I wonder what happens on the client side in that case (the client tools guys can help here). Do we actually end up with duplicate entries in redhat.repo?", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477238711", "createdAt": "2020-08-26T11:47:39Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1OTMwNg==", "bodyText": "@cnsnyder @jirihnidek ^^\nI think I recall seeing discussion that it ends up being that if duplicates exist, then the first found is what is used; which is probably not desired overall (undefined behavior is bad behavior). If that's the case, then I think we should get some PMs involved, figure out what they expect, and then determine where the new behavior should be. I expect that it'll mostly fall to CP to generate something a tad more sane, since subman is already implementing a contingency plan, even if that implementation isn't optimal or deterministic.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477559306", "createdAt": "2020-08-26T20:08:08Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU2MDM5Nw==", "bodyText": "Also, regardless, this branch is a bit special, since everything is being added to a single product. That in itself is causing deduplication work done elsewhere to keep the last update received (Product.addContent -> Product.addProductContent).\nSo really, the ask here is what PMs expect in the case of multiple entitlements providing a given content in different states of enablement.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477560397", "createdAt": "2020-08-26T20:10:25Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODU5NTAxOnYy", "diffSide": "RIGHT", "path": "server/spec/content_access_spec.rb", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzowOToyOFrOHGXSQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzowOToyOFrOHGXSQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQzNTAwOQ==", "bodyText": "This is weird. If a content is enabled, we should expect true here, not false, but it doesn't look like this is caused by your changes. I'll look more into this", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476435009", "createdAt": "2020-08-25T13:09:28Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4064, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}