{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MTI1MDc5", "number": 2815, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjowNzo0MlrOEzXwSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjoyMDo0MVrOE-uwjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzAyMDI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/model/ProductEntitlements.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjowNzo0MlrOHqjVjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjowOToyOVrOHu_FzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4MTE5OQ==", "bodyText": "Looks like this class is no longer used. We should probably delete it.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r514381199", "createdAt": "2020-10-29T16:07:42Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/model/ProductEntitlements.java", "diffHunk": "@@ -33,18 +33,25 @@\n \n     public ProductEntitlements(Collection<Entitlement> entitlements, ProductCurator productCurator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16411c2bb725aff507025ab91906d743ff263907"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMDIyMA==", "bodyText": "Removed", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r519030220", "createdAt": "2020-11-06T22:09:29Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/model/ProductEntitlements.java", "diffHunk": "@@ -33,18 +33,25 @@\n \n     public ProductEntitlements(Collection<Entitlement> entitlements, ProductCurator productCurator) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4MTE5OQ=="}, "originalCommit": {"oid": "16411c2bb725aff507025ab91906d743ff263907"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzA4NDQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjoyMToxMVrOHqj9jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjowOToyMVrOHu_FqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MTQzNg==", "bodyText": "You can use Objects::nonNull", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r514391436", "createdAt": "2020-10-29T16:21:11Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -952,85 +608,86 @@ public static boolean isChangedBy(Product entity, ProductDTO dto) {\n         // case-insensitive key/value comparison and similiarities (i.e. management_enabled: 1 is\n         // functionally identical to Management_Enabled: true, but it will be detected as a change\n         // in attributes.\n-        Map<String, String> attributes = dto.getAttributes();\n+        Map<String, String> attributes = update.getAttributes();\n         if (attributes != null && !attributes.equals(entity.getAttributes())) {\n             return true;\n         }\n \n-        Collection<ProductContentDTO> productContent = dto.getProductContent();\n-        if (productContent != null) {\n-            Comparator comparator = (lhs, rhs) -> {\n-                ProductContent existing = (ProductContent) lhs;\n-                ProductContentDTO update = (ProductContentDTO) rhs;\n-\n-                if (existing != null && update != null) {\n-                    Content content = existing.getContent();\n-                    ContentDTO cdto = update.getContent();\n-\n-                    if (content != null && cdto != null) {\n-                        if (cdto.getUuid() != null ?\n-                            cdto.getUuid().equals(content.getUuid()) :\n-                            (cdto.getId() != null && cdto.getId().equals(content.getId()))) {\n-                            // At this point, we've either matched the UUIDs (which means we're\n-                            // referencing identical products) or the UUID isn't present on the DTO, but\n-                            // the IDs match (which means we're pointing toward the same product).\n-\n-                            return (update.isEnabled() != null &&\n-                                !update.isEnabled().equals(existing.isEnabled())) ||\n-                                ContentManager.isChangedBy(content, cdto) ? 1 : 0;\n-                        }\n-                    }\n-                }\n+        Collection<String> dependentProductIds = update.getDependentProductIds();\n+        if (dependentProductIds != null &&\n+            !Util.collectionsAreEqual(entity.getDependentProductIds(), dependentProductIds)) {\n+            return true;\n+        }\n \n-                return 1;\n-            };\n+        // Complex stuff\n+        // product content\n+        if (update.getProductContent() != null) {\n+            Map<String, Boolean> entityContentMap = entity.getProductContent().stream()\n+                .filter(pc -> pc != null && pc.getContent() != null)\n+                .collect(Collectors.toMap(pc -> pc.getContent().getId(), pc -> pc.isEnabled()));\n \n-            if (!Util.collectionsAreEqual((Collection) entity.getProductContent(),\n-                (Collection) productContent, comparator)) {\n+            Map<String, Boolean> updateContentMap = update.getProductContent().stream()\n+                .filter(pc -> pc != null && pc.getContent() != null)\n+                .collect(Collectors.toMap(pc -> pc.getContent().getId(), pc -> pc.isEnabled()));\n \n+            if (!entityContentMap.equals(updateContentMap)) {\n                 return true;\n             }\n         }\n \n-        Collection<BrandingDTO> brandingDTOs = dto.getBranding();\n-        if (brandingDTOs != null) {\n-            Comparator<BrandingInfo> comparator = BrandingInfo.getBrandingInfoComparator();\n-            if (!Util.collectionsAreEqual((Collection) entity.getBranding(), (Collection) brandingDTOs,\n-                comparator)) {\n+        // derived product\n+        ProductInfo derivedProduct = update.getDerivedProduct();\n+        Product existingDerived = entity.getDerivedProduct();\n+\n+        if (derivedProduct != null) {\n+            if (existingDerived == null || !existingDerived.getId().equals(derivedProduct.getId())) {\n                 return true;\n             }\n         }\n+        else if (existingDerived != null) {\n+            return true;\n+        }\n \n-        Collection<ProductDTO> providedProducts = dto.getProvidedProducts();\n-\n-        if (providedProducts != null) {\n-            // Quick Id Check\n-            if (!Util.collectionsAreEqual(entity.getProvidedProducts().stream()\n+        // provided products\n+        Collection<? extends ProductInfo> updateProvidedProducts = update.getProvidedProducts();\n+        if (updateProvidedProducts != null) {\n+            Set<String> entityProvidedPids = entity.getProvidedProducts().stream()\n+                .filter(pp -> pp != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16411c2bb725aff507025ab91906d743ff263907"}, "originalPosition": 1341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMDE4NQ==", "bodyText": "Done", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r519030185", "createdAt": "2020-11-06T22:09:21Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -952,85 +608,86 @@ public static boolean isChangedBy(Product entity, ProductDTO dto) {\n         // case-insensitive key/value comparison and similiarities (i.e. management_enabled: 1 is\n         // functionally identical to Management_Enabled: true, but it will be detected as a change\n         // in attributes.\n-        Map<String, String> attributes = dto.getAttributes();\n+        Map<String, String> attributes = update.getAttributes();\n         if (attributes != null && !attributes.equals(entity.getAttributes())) {\n             return true;\n         }\n \n-        Collection<ProductContentDTO> productContent = dto.getProductContent();\n-        if (productContent != null) {\n-            Comparator comparator = (lhs, rhs) -> {\n-                ProductContent existing = (ProductContent) lhs;\n-                ProductContentDTO update = (ProductContentDTO) rhs;\n-\n-                if (existing != null && update != null) {\n-                    Content content = existing.getContent();\n-                    ContentDTO cdto = update.getContent();\n-\n-                    if (content != null && cdto != null) {\n-                        if (cdto.getUuid() != null ?\n-                            cdto.getUuid().equals(content.getUuid()) :\n-                            (cdto.getId() != null && cdto.getId().equals(content.getId()))) {\n-                            // At this point, we've either matched the UUIDs (which means we're\n-                            // referencing identical products) or the UUID isn't present on the DTO, but\n-                            // the IDs match (which means we're pointing toward the same product).\n-\n-                            return (update.isEnabled() != null &&\n-                                !update.isEnabled().equals(existing.isEnabled())) ||\n-                                ContentManager.isChangedBy(content, cdto) ? 1 : 0;\n-                        }\n-                    }\n-                }\n+        Collection<String> dependentProductIds = update.getDependentProductIds();\n+        if (dependentProductIds != null &&\n+            !Util.collectionsAreEqual(entity.getDependentProductIds(), dependentProductIds)) {\n+            return true;\n+        }\n \n-                return 1;\n-            };\n+        // Complex stuff\n+        // product content\n+        if (update.getProductContent() != null) {\n+            Map<String, Boolean> entityContentMap = entity.getProductContent().stream()\n+                .filter(pc -> pc != null && pc.getContent() != null)\n+                .collect(Collectors.toMap(pc -> pc.getContent().getId(), pc -> pc.isEnabled()));\n \n-            if (!Util.collectionsAreEqual((Collection) entity.getProductContent(),\n-                (Collection) productContent, comparator)) {\n+            Map<String, Boolean> updateContentMap = update.getProductContent().stream()\n+                .filter(pc -> pc != null && pc.getContent() != null)\n+                .collect(Collectors.toMap(pc -> pc.getContent().getId(), pc -> pc.isEnabled()));\n \n+            if (!entityContentMap.equals(updateContentMap)) {\n                 return true;\n             }\n         }\n \n-        Collection<BrandingDTO> brandingDTOs = dto.getBranding();\n-        if (brandingDTOs != null) {\n-            Comparator<BrandingInfo> comparator = BrandingInfo.getBrandingInfoComparator();\n-            if (!Util.collectionsAreEqual((Collection) entity.getBranding(), (Collection) brandingDTOs,\n-                comparator)) {\n+        // derived product\n+        ProductInfo derivedProduct = update.getDerivedProduct();\n+        Product existingDerived = entity.getDerivedProduct();\n+\n+        if (derivedProduct != null) {\n+            if (existingDerived == null || !existingDerived.getId().equals(derivedProduct.getId())) {\n                 return true;\n             }\n         }\n+        else if (existingDerived != null) {\n+            return true;\n+        }\n \n-        Collection<ProductDTO> providedProducts = dto.getProvidedProducts();\n-\n-        if (providedProducts != null) {\n-            // Quick Id Check\n-            if (!Util.collectionsAreEqual(entity.getProvidedProducts().stream()\n+        // provided products\n+        Collection<? extends ProductInfo> updateProvidedProducts = update.getProvidedProducts();\n+        if (updateProvidedProducts != null) {\n+            Set<String> entityProvidedPids = entity.getProvidedProducts().stream()\n+                .filter(pp -> pp != null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MTQzNg=="}, "originalCommit": {"oid": "16411c2bb725aff507025ab91906d743ff263907"}, "originalPosition": 1341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzExNTE1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjoyNzo1NFrOHqkQsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoxMDowNFrOHu_GtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NjMzNw==", "bodyText": "+1 ... We should do something similar for the IllegalStateException that's scattered around here.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r514396337", "createdAt": "2020-10-29T16:27:54Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -84,121 +74,255 @@ public ProductManager(EntitlementCertificateGenerator entitlementCertGenerator,\n     }\n \n     /**\n-     * Creates a new Product for the given owner, potentially using a different version than the\n-     * entity provided if a matching entity has already been registered for another owner.\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n      *\n-     * @param dto\n-     *  A product DTO instance representing the product to create\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n-     * @param owner\n-     *  The owner for which to create the product\n+     * @throws IllegalArgumentException\n+     *  if the product provided references a product which cannot be resolved\n+     *\n+     * @return\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n+     */\n+    private Map<String, Product> resolveProductRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> pids = new HashSet<>();\n+        Map<String, Product> output;\n+\n+        ProductInfo derived = pinfo.getDerivedProduct();\n+        if (derived != null) {\n+            if (derived.getId() == null || derived.getId().isEmpty()) {\n+                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                throw new IllegalArgumentException(\"product reference lacks a valid ID\");\n+            }\n+\n+            pids.add(derived.getId());\n+        }\n+\n+        Collection<? extends ProductInfo> provided = pinfo.getProvidedProducts();\n+        if (provided != null) {\n+            for (ProductInfo pp : provided) {\n+                if (pp == null) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                    throw new IllegalArgumentException(\"product contains null provided product reference\");\n+                }\n+\n+                if (pp.getId() == null || pp.getId().isEmpty()) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                    throw new IllegalArgumentException(\"product references a product that lacks a valid ID\");\n+                }\n+\n+                pids.add(pp.getId());\n+            }\n+        }\n+\n+        if (!pids.isEmpty()) {\n+            output = this.ownerProductCurator.getProductsByIds(owner, pids).list().stream()\n+                .collect(Collectors.toMap(Product::getId, Function.identity()));\n+\n+            pids.removeAll(output.keySet());\n+            if (!pids.isEmpty()) {\n+                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                throw new IllegalArgumentException(\n+                    \"product references one or more non-existent products: \" + pids);\n+            }\n+        }\n+        else {\n+            output = new HashMap<>();\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n+     *\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n      * @throws IllegalArgumentException\n-     *  if dto is null or incomplete, or owner is null\n+     *  if the product provided references a product which cannot be resolved\n      *\n      * @return\n-     *  a new Product instance representing the specified product for the given owner\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n      */\n-    public Product createProduct(ProductDTO dto, Owner owner) {\n-        if (dto == null) {\n-            throw new IllegalArgumentException(\"dto is null\");\n+    private Map<String, Content> resolveContentRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> cids = new HashSet<>();\n+        Map<String, Content> output;\n+\n+        Collection<? extends ProductContentInfo> productContent = pinfo.getProductContent();\n+        if (productContent != null) {\n+            for (ProductContentInfo pcinfo : productContent) {\n+                ContentInfo cinfo = pcinfo != null ? pcinfo.getContent() : null;\n+\n+                if (cinfo == null) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16411c2bb725aff507025ab91906d743ff263907"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMDQ1Mg==", "bodyText": "I didn't touch the ISEs since I feel that's still a decent enough fit, but the TODOs have been addressed with the new MalformedEntityReferenceException.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r519030452", "createdAt": "2020-11-06T22:10:04Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -84,121 +74,255 @@ public ProductManager(EntitlementCertificateGenerator entitlementCertGenerator,\n     }\n \n     /**\n-     * Creates a new Product for the given owner, potentially using a different version than the\n-     * entity provided if a matching entity has already been registered for another owner.\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n      *\n-     * @param dto\n-     *  A product DTO instance representing the product to create\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n-     * @param owner\n-     *  The owner for which to create the product\n+     * @throws IllegalArgumentException\n+     *  if the product provided references a product which cannot be resolved\n+     *\n+     * @return\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n+     */\n+    private Map<String, Product> resolveProductRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> pids = new HashSet<>();\n+        Map<String, Product> output;\n+\n+        ProductInfo derived = pinfo.getDerivedProduct();\n+        if (derived != null) {\n+            if (derived.getId() == null || derived.getId().isEmpty()) {\n+                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                throw new IllegalArgumentException(\"product reference lacks a valid ID\");\n+            }\n+\n+            pids.add(derived.getId());\n+        }\n+\n+        Collection<? extends ProductInfo> provided = pinfo.getProvidedProducts();\n+        if (provided != null) {\n+            for (ProductInfo pp : provided) {\n+                if (pp == null) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                    throw new IllegalArgumentException(\"product contains null provided product reference\");\n+                }\n+\n+                if (pp.getId() == null || pp.getId().isEmpty()) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                    throw new IllegalArgumentException(\"product references a product that lacks a valid ID\");\n+                }\n+\n+                pids.add(pp.getId());\n+            }\n+        }\n+\n+        if (!pids.isEmpty()) {\n+            output = this.ownerProductCurator.getProductsByIds(owner, pids).list().stream()\n+                .collect(Collectors.toMap(Product::getId, Function.identity()));\n+\n+            pids.removeAll(output.keySet());\n+            if (!pids.isEmpty()) {\n+                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                throw new IllegalArgumentException(\n+                    \"product references one or more non-existent products: \" + pids);\n+            }\n+        }\n+        else {\n+            output = new HashMap<>();\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n+     *\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n      * @throws IllegalArgumentException\n-     *  if dto is null or incomplete, or owner is null\n+     *  if the product provided references a product which cannot be resolved\n      *\n      * @return\n-     *  a new Product instance representing the specified product for the given owner\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n      */\n-    public Product createProduct(ProductDTO dto, Owner owner) {\n-        if (dto == null) {\n-            throw new IllegalArgumentException(\"dto is null\");\n+    private Map<String, Content> resolveContentRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> cids = new HashSet<>();\n+        Map<String, Content> output;\n+\n+        Collection<? extends ProductContentInfo> productContent = pinfo.getProductContent();\n+        if (productContent != null) {\n+            for (ProductContentInfo pcinfo : productContent) {\n+                ContentInfo cinfo = pcinfo != null ? pcinfo.getContent() : null;\n+\n+                if (cinfo == null) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NjMzNw=="}, "originalCommit": {"oid": "16411c2bb725aff507025ab91906d743ff263907"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTI5NTM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNjoxNzoxM1rOH6himg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDoxNjozMFrOH8ujlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyODk4Ng==", "bodyText": "I don't think that's needed, since they are recursively added by addProducts", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531128986", "createdAt": "2020-11-26T16:17:13Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "diffHunk": "@@ -162,7 +162,10 @@ public RefreshWorker addSubscriptions(Collection<? extends SubscriptionInfo> sub\n                 this.poolMapper.addImportedEntity(subscription);\n \n                 // Add any products attached to this subscription...\n-                this.addProducts(subscription.getProduct(), subscription.getDerivedProduct());\n+                this.addProducts(subscription.getProduct());\n+\n+                // Should we still add derivedProduct and the provided/derived provided collections here\n+                // for backward compatibility?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzOTM4MA==", "bodyText": "Removed", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533439380", "createdAt": "2020-12-01T14:16:30Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "diffHunk": "@@ -162,7 +162,10 @@ public RefreshWorker addSubscriptions(Collection<? extends SubscriptionInfo> sub\n                 this.poolMapper.addImportedEntity(subscription);\n \n                 // Add any products attached to this subscription...\n-                this.addProducts(subscription.getProduct(), subscription.getDerivedProduct());\n+                this.addProducts(subscription.getProduct());\n+\n+                // Should we still add derivedProduct and the provided/derived provided collections here\n+                // for backward compatibility?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyODk4Ng=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDQ2MDIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozNjowOFrOH6-qew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDoxNTo0OFrOH8uhiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNjEzOQ==", "bodyText": "the derived product was appended twice here", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531606139", "createdAt": "2020-11-27T13:36:08Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java", "diffHunk": "@@ -1064,10 +1096,12 @@ public int hashCode() {\n             .append(this.getMultiplier())\n             .append(this.getHref())\n             .append(this.getAttributes())\n+            .append(this.getDerivedProduct())\n+            .append(this.getProvidedProducts())\n+            .append(this.getDerivedProduct())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzODg1Nw==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533438857", "createdAt": "2020-12-01T14:15:48Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java", "diffHunk": "@@ -1064,10 +1096,12 @@ public int hashCode() {\n             .append(this.getMultiplier())\n             .append(this.getHref())\n             .append(this.getAttributes())\n+            .append(this.getDerivedProduct())\n+            .append(this.getProvidedProducts())\n+            .append(this.getDerivedProduct())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNjEzOQ=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDgxMjczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductTranslator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNToyNDoxNFrOH7B83Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjo1ODozOVrOH9ZvoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1OTk5Nw==", "bodyText": "Not something to change, but just an observation: We'll now be exporting more product data than before. We currently export a flat structure: 1 json file for each product, no matter which type it is, e.g. provided, derived, derived provided, while with this, each product json file will also include all of the product hierarchy below it.\nA good question is, how/when (if ever) can we finally update the manifest API, by removing these redundant json files, and only exporting every top-level (root) product?", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531659997", "createdAt": "2020-11-27T15:24:14Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductTranslator.java", "diffHunk": "@@ -69,17 +71,37 @@ public ProductDTO populate(ModelTranslator modelTranslator, Product source, Prod\n         destination.setAttributes(source.getAttributes());\n         destination.setDependentProductIds(source.getDependentProductIds());\n \n-        if (modelTranslator != null) {\n+        // Translate children products (recursive op)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NjgyMg==", "bodyText": "That's a very good question -- one we should answer eventually. The manifest API is ancient, and is at the root of a lot of awkward bits of code surrounding import and, to a lesser extent, export.\nWe should do something where we specify the version in the manifest somehow (manifest file, perhaps), and if it's not present or doesn't match what we expect, we drop down to this current method. That should at least lay the groundwork for removing the current API and supporting code.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533456822", "createdAt": "2020-12-01T14:39:39Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductTranslator.java", "diffHunk": "@@ -69,17 +71,37 @@ public ProductDTO populate(ModelTranslator modelTranslator, Product source, Prod\n         destination.setAttributes(source.getAttributes());\n         destination.setDependentProductIds(source.getDependentProductIds());\n \n-        if (modelTranslator != null) {\n+        // Translate children products (recursive op)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1OTk5Nw=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0Njk3Ng==", "bodyText": "Using a version variable in the manifest for an if/else flow would mean that we would still have to export all the now-redundant data, because some candlepin-0.9 doing an import still has to do it the old way. The genuine question I have is, is there a limit to how old candlepin imports we need to support?\nIf we knew for example, that in 4 years time our manifest api does not need to support importing below candlepin-4.0 or whatever the provided products epic will be released in, then the manifest version makes sense. Otherwise, if we have to support all candlepins no matter how old, there is no point.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r534146976", "createdAt": "2020-12-02T12:58:39Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductTranslator.java", "diffHunk": "@@ -69,17 +71,37 @@ public ProductDTO populate(ModelTranslator modelTranslator, Product source, Prod\n         destination.setAttributes(source.getAttributes());\n         destination.setDependentProductIds(source.getDependentProductIds());\n \n-        if (modelTranslator != null) {\n+        // Translate children products (recursive op)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1OTk5Nw=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAwMTU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoyODo1OVrOH7Ds7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo1OToxM1rOH9OgQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA==", "bodyText": "This method, and the clone method itself is not cloning the Red Hat product ID, but the method javadoc implies it does. Was this missed?", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531688684", "createdAt": "2020-11-27T16:28:59Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "diffHunk": "@@ -297,11 +294,28 @@ else if (!StringUtils.equals(update.getId(), productId)) {\n             throw new ForbiddenException(i18n.tr(\"product \\\"{0}\\\" is locked\", existing.getId()));\n         }\n \n-        Product updated = this.productManager.updateProduct(update, owner, true);\n+        Product updated = this.productManager.updateProduct(owner, update, true);\n \n         return this.translator.translate(updated, ProductDTO.class);\n     }\n \n+    /**\n+     * Creates an new, unmanaged product instance using the Red Hat product ID and content of the\n+     * given product entity.\n+     *\n+     * @param entity\n+     *  the product instance from which to copy the Red Hat product ID and content\n+     *\n+     * @return\n+     *  an unmanaged product instance\n+     */\n+    private Product buildProductForBatchContentChange(Product entity) {\n+        // Impl note: we need to fully clone the object to ensure we don't make any changes to any\n+        // other fields; or we need to create a new product implementation that returns the correct\n+        // no-change value for every other field.\n+        return (Product) entity.clone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzODE4NA==", "bodyText": "Cloning the product does all of the above, in a rather heavy-handed way.\nIn the first implementation, this did little more than exactly what the javadoc said; but I ran into an issue where adding the content to the new product actually made changes to the original product and caused a lot of headaches tracking it down.\nAdditionally, default field values started overwriting other areas that were not intended to be changed by the operation.\nThe other option I had considered here, and noted in the comment, is adding a custom pass-through Product interface that only passes through or stores the RHID and content references.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533438184", "createdAt": "2020-12-01T14:15:00Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "diffHunk": "@@ -297,11 +294,28 @@ else if (!StringUtils.equals(update.getId(), productId)) {\n             throw new ForbiddenException(i18n.tr(\"product \\\"{0}\\\" is locked\", existing.getId()));\n         }\n \n-        Product updated = this.productManager.updateProduct(update, owner, true);\n+        Product updated = this.productManager.updateProduct(owner, update, true);\n \n         return this.translator.translate(updated, ProductDTO.class);\n     }\n \n+    /**\n+     * Creates an new, unmanaged product instance using the Red Hat product ID and content of the\n+     * given product entity.\n+     *\n+     * @param entity\n+     *  the product instance from which to copy the Red Hat product ID and content\n+     *\n+     * @return\n+     *  an unmanaged product instance\n+     */\n+    private Product buildProductForBatchContentChange(Product entity) {\n+        // Impl note: we need to fully clone the object to ensure we don't make any changes to any\n+        // other fields; or we need to create a new product implementation that returns the correct\n+        // no-change value for every other field.\n+        return (Product) entity.clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzOTA2OQ==", "bodyText": "Ok, if the current solution is to just clone the entity, which is a single line, do we need to wrap it in a method?", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533539069", "createdAt": "2020-12-01T16:15:28Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "diffHunk": "@@ -297,11 +294,28 @@ else if (!StringUtils.equals(update.getId(), productId)) {\n             throw new ForbiddenException(i18n.tr(\"product \\\"{0}\\\" is locked\", existing.getId()));\n         }\n \n-        Product updated = this.productManager.updateProduct(update, owner, true);\n+        Product updated = this.productManager.updateProduct(owner, update, true);\n \n         return this.translator.translate(updated, ProductDTO.class);\n     }\n \n+    /**\n+     * Creates an new, unmanaged product instance using the Red Hat product ID and content of the\n+     * given product entity.\n+     *\n+     * @param entity\n+     *  the product instance from which to copy the Red Hat product ID and content\n+     *\n+     * @return\n+     *  an unmanaged product instance\n+     */\n+    private Product buildProductForBatchContentChange(Product entity) {\n+        // Impl note: we need to fully clone the object to ensure we don't make any changes to any\n+        // other fields; or we need to create a new product implementation that returns the correct\n+        // no-change value for every other field.\n+        return (Product) entity.clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2OTg4Mg==", "bodyText": "I suppose not. The intent here is to eventually revisit it and do something better -- most of the data we're copying doesn't need to be copied.\nI could go either way on this. What's your stance on it?", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533569882", "createdAt": "2020-12-01T16:56:47Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "diffHunk": "@@ -297,11 +294,28 @@ else if (!StringUtils.equals(update.getId(), productId)) {\n             throw new ForbiddenException(i18n.tr(\"product \\\"{0}\\\" is locked\", existing.getId()));\n         }\n \n-        Product updated = this.productManager.updateProduct(update, owner, true);\n+        Product updated = this.productManager.updateProduct(owner, update, true);\n \n         return this.translator.translate(updated, ProductDTO.class);\n     }\n \n+    /**\n+     * Creates an new, unmanaged product instance using the Red Hat product ID and content of the\n+     * given product entity.\n+     *\n+     * @param entity\n+     *  the product instance from which to copy the Red Hat product ID and content\n+     *\n+     * @return\n+     *  an unmanaged product instance\n+     */\n+    private Product buildProductForBatchContentChange(Product entity) {\n+        // Impl note: we need to fully clone the object to ensure we don't make any changes to any\n+        // other fields; or we need to create a new product implementation that returns the correct\n+        // no-change value for every other field.\n+        return (Product) entity.clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MjgxNw==", "bodyText": "If we want to do more with it, then the method & comments on it have some value, so its fine if we leave it", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533962817", "createdAt": "2020-12-02T07:59:13Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "diffHunk": "@@ -297,11 +294,28 @@ else if (!StringUtils.equals(update.getId(), productId)) {\n             throw new ForbiddenException(i18n.tr(\"product \\\"{0}\\\" is locked\", existing.getId()));\n         }\n \n-        Product updated = this.productManager.updateProduct(update, owner, true);\n+        Product updated = this.productManager.updateProduct(owner, update, true);\n \n         return this.translator.translate(updated, ProductDTO.class);\n     }\n \n+    /**\n+     * Creates an new, unmanaged product instance using the Red Hat product ID and content of the\n+     * given product entity.\n+     *\n+     * @param entity\n+     *  the product instance from which to copy the Red Hat product ID and content\n+     *\n+     * @return\n+     *  an unmanaged product instance\n+     */\n+    private Product buildProductForBatchContentChange(Product entity) {\n+        // Impl note: we need to fully clone the object to ensure we don't make any changes to any\n+        // other fields; or we need to create a new product implementation that returns the correct\n+        // no-change value for every other field.\n+        return (Product) entity.clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTMyNzc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzoyOTo1NVrOH77IHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNjozNVrOH8uHLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njc2Nw==", "bodyText": "Method signature & javadoc comment don't match", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r532596767", "createdAt": "2020-11-30T13:29:55Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -84,121 +75,252 @@ public ProductManager(EntitlementCertificateGenerator entitlementCertGenerator,\n     }\n \n     /**\n-     * Creates a new Product for the given owner, potentially using a different version than the\n-     * entity provided if a matching entity has already been registered for another owner.\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n      *\n-     * @param dto\n-     *  A product DTO instance representing the product to create\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n-     * @param owner\n-     *  The owner for which to create the product\n+     * @throws IllegalArgumentException\n+     *  if the product provided references a product which cannot be resolved\n+     *\n+     * @return\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n+     */\n+    private Map<String, Product> resolveProductRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> pids = new HashSet<>();\n+        Map<String, Product> output;\n+\n+        ProductInfo derived = pinfo.getDerivedProduct();\n+        if (derived != null) {\n+            if (derived.getId() == null || derived.getId().isEmpty()) {\n+                throw new MalformedEntityReferenceException(\"product reference lacks a valid ID\");\n+            }\n+\n+            pids.add(derived.getId());\n+        }\n+\n+        Collection<? extends ProductInfo> provided = pinfo.getProvidedProducts();\n+        if (provided != null) {\n+            for (ProductInfo pp : provided) {\n+                if (pp == null) {\n+                    throw new MalformedEntityReferenceException(\n+                        \"product contains null provided product reference\");\n+                }\n+\n+                if (pp.getId() == null || pp.getId().isEmpty()) {\n+                    throw new MalformedEntityReferenceException(\n+                        \"product references a product that lacks a valid ID\");\n+                }\n+\n+                pids.add(pp.getId());\n+            }\n+        }\n+\n+        if (!pids.isEmpty()) {\n+            output = this.ownerProductCurator.getProductsByIds(owner, pids).list().stream()\n+                .collect(Collectors.toMap(Product::getId, Function.identity()));\n+\n+            pids.removeAll(output.keySet());\n+            if (!pids.isEmpty()) {\n+                throw new MalformedEntityReferenceException(\n+                    \"product references one or more non-existent products: \" + pids);\n+            }\n+        }\n+        else {\n+            output = new HashMap<>();\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n+     *\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n      * @throws IllegalArgumentException\n-     *  if dto is null or incomplete, or owner is null\n+     *  if the product provided references a product which cannot be resolved\n      *\n      * @return\n-     *  a new Product instance representing the specified product for the given owner\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n      */\n-    public Product createProduct(ProductDTO dto, Owner owner) {\n-        if (dto == null) {\n-            throw new IllegalArgumentException(\"dto is null\");\n+    private Map<String, Content> resolveContentRefs(Owner owner, ProductInfo pinfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMjEwOQ==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533432109", "createdAt": "2020-12-01T14:06:35Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -84,121 +75,252 @@ public ProductManager(EntitlementCertificateGenerator entitlementCertGenerator,\n     }\n \n     /**\n-     * Creates a new Product for the given owner, potentially using a different version than the\n-     * entity provided if a matching entity has already been registered for another owner.\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n      *\n-     * @param dto\n-     *  A product DTO instance representing the product to create\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n-     * @param owner\n-     *  The owner for which to create the product\n+     * @throws IllegalArgumentException\n+     *  if the product provided references a product which cannot be resolved\n+     *\n+     * @return\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n+     */\n+    private Map<String, Product> resolveProductRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> pids = new HashSet<>();\n+        Map<String, Product> output;\n+\n+        ProductInfo derived = pinfo.getDerivedProduct();\n+        if (derived != null) {\n+            if (derived.getId() == null || derived.getId().isEmpty()) {\n+                throw new MalformedEntityReferenceException(\"product reference lacks a valid ID\");\n+            }\n+\n+            pids.add(derived.getId());\n+        }\n+\n+        Collection<? extends ProductInfo> provided = pinfo.getProvidedProducts();\n+        if (provided != null) {\n+            for (ProductInfo pp : provided) {\n+                if (pp == null) {\n+                    throw new MalformedEntityReferenceException(\n+                        \"product contains null provided product reference\");\n+                }\n+\n+                if (pp.getId() == null || pp.getId().isEmpty()) {\n+                    throw new MalformedEntityReferenceException(\n+                        \"product references a product that lacks a valid ID\");\n+                }\n+\n+                pids.add(pp.getId());\n+            }\n+        }\n+\n+        if (!pids.isEmpty()) {\n+            output = this.ownerProductCurator.getProductsByIds(owner, pids).list().stream()\n+                .collect(Collectors.toMap(Product::getId, Function.identity()));\n+\n+            pids.removeAll(output.keySet());\n+            if (!pids.isEmpty()) {\n+                throw new MalformedEntityReferenceException(\n+                    \"product references one or more non-existent products: \" + pids);\n+            }\n+        }\n+        else {\n+            output = new HashMap<>();\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n+     *\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n      * @throws IllegalArgumentException\n-     *  if dto is null or incomplete, or owner is null\n+     *  if the product provided references a product which cannot be resolved\n      *\n      * @return\n-     *  a new Product instance representing the specified product for the given owner\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n      */\n-    public Product createProduct(ProductDTO dto, Owner owner) {\n-        if (dto == null) {\n-            throw new IllegalArgumentException(\"dto is null\");\n+    private Map<String, Content> resolveContentRefs(Owner owner, ProductInfo pinfo) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njc2Nw=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjEzMjYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/policy/js/pool/PoolHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjoyMDo0MVrOH8CwwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNToyNVrOH8uD3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcyMTg1Ng==", "bodyText": "Shouldn't this be pool.getProduct().getDerivedProduct()? (or are we leaving this change for the other jira task which is about removing the derived product field from Pool all together?)", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r532721856", "createdAt": "2020-11-30T16:20:41Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/policy/js/pool/PoolHelper.java", "diffHunk": "@@ -83,11 +83,13 @@ public static PoolOperationCallback createHostRestrictedPools(PoolManager poolMa\n         List<Pool> poolsToUpdateFromStack = new ArrayList<>();\n         for (Pool pool : pools) {\n             Product product = pool.getProduct();\n-            Pool consumerSpecificPool = null;\n+            Product derivedProduct = pool.getDerivedProduct();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTI2MA==", "bodyText": "pool.getDerivedProduct() does what you suggested. A lot of those ended up being way too tedious to change and it seemed apt to update the methods on pool to be helper methods.", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533431260", "createdAt": "2020-12-01T14:05:25Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/policy/js/pool/PoolHelper.java", "diffHunk": "@@ -83,11 +83,13 @@ public static PoolOperationCallback createHostRestrictedPools(PoolManager poolMa\n         List<Pool> poolsToUpdateFromStack = new ArrayList<>();\n         for (Pool pool : pools) {\n             Product product = pool.getProduct();\n-            Pool consumerSpecificPool = null;\n+            Product derivedProduct = pool.getDerivedProduct();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcyMTg1Ng=="}, "originalCommit": {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4092, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}