{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyMjcxODcy", "number": 2780, "title": "1868383: Default repositories are not enabled, after registering a client with an Activation Key, to an org with Simple Content Access Mode in Red Hat Satellite 6 (ENT - 2742)", "bodyText": "Content default for Owner in SCA mode.", "createdAt": "2020-08-24T05:41:18Z", "url": "https://github.com/candlepin/candlepin/pull/2780", "merged": true, "mergeCommit": {"oid": "793341018c2ed0264f07f8ebce79583be544db11"}, "closed": true, "closedAt": "2020-08-27T15:09:35Z", "author": {"login": "wolfdale"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCW6kVAFqTQ3NDQ1NTM1NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDAgYxgBqjM2OTk2NjgzOTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDU1MzU0", "url": "https://github.com/candlepin/candlepin/pull/2780#pullrequestreview-474455354", "createdAt": "2020-08-25T12:59:46Z", "commit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjo1OTo0NlrOHGW6qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjo1OTo0NlrOHGW6qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA==", "bodyText": "If we're adding content with the same ID to a given product twice, it will overwrite the previous instance with the new one. I would expect that this results in the enabled flag being set to whatever comes in last, rather than both existing on the product.\nAside from that, I don't understand the intent behind adding it as a disabled content if it's already present. In this case, the resultant behavior we want is for the content to be available if something has enabled it. Adding a disabled version of the content as well will only serve as a stumbling block for any processing that occurs after this step.\nIn the event we have an organization that has multiple sources of a given content with mixed enablement, I would expect the \"enabled\" version to win out. We could even fetch that set of content pretty easily with a new query that only fetches enabled content for a given owner.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476428970", "createdAt": "2020-08-25T12:59:46Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MjY1MzM5", "url": "https://github.com/candlepin/candlepin/pull/2780#pullrequestreview-474265339", "createdAt": "2020-08-25T08:44:32Z", "commit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwODo0NDozMlrOHGN6pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzowOToyOFrOHGXSQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI4MTUwOA==", "bodyText": "we should not use the .should statement because it's deprecated. let's use expect().to/to_not eq()\nSame thing for the few places further down that .should is used", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476281508", "createdAt": "2020-08-25T08:44:32Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2NDcwOA==", "bodyText": "Let's add a length check here in addition to this loop, that will make sure there's 3 contents, because this test might silently pass if (for whatever reason) the 2 contents you created explicitly are not present in the certificate", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476364708", "createdAt": "2020-08-25T11:07:24Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTk3OQ==", "bodyText": "Is that an actual use case?? Can't imagine why we would want to do that.", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476391979", "createdAt": "2020-08-25T11:57:29Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjAyMw==", "bodyText": "Same here, we should check there's at least 2 contents", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476402023", "createdAt": "2020-08-25T12:16:31Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do\n+    product_1 = create_product('test-product-p1', 'some product-p1')\n+    product_2 = create_product('test-product-p2', 'some product-p2')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+\n+    @cp.add_content_to_product(@owner['key'], product_1['id'], content_c1['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product_2['id'], content_c1['id'], true)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+\n+    json_body['products'][0]['content'].each do |content|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQzNTAwOQ==", "bodyText": "This is weird. If a content is enabled, we should expect true here, not false, but it doesn't look like this is caused by your changes. I'll look more into this", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476435009", "createdAt": "2020-08-25T13:09:28Z", "author": {"login": "nikosmoum"}, "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344"}, "originalPosition": 44}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "564c4d608e24e8461a2f838e2aaeea5170692344", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/564c4d608e24e8461a2f838e2aaeea5170692344", "committedDate": "2020-08-24T05:38:48Z", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)"}, "afterCommit": {"oid": "aebc6f66daf3698b3172185155d848fda61d1319", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/aebc6f66daf3698b3172185155d848fda61d1319", "committedDate": "2020-08-26T05:55:09Z", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aebc6f66daf3698b3172185155d848fda61d1319", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/aebc6f66daf3698b3172185155d848fda61d1319", "committedDate": "2020-08-26T05:55:09Z", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)"}, "afterCommit": {"oid": "65c692aa826c69d13c45d2d3feae9dda915c2676", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/65c692aa826c69d13c45d2d3feae9dda915c2676", "committedDate": "2020-08-26T06:34:41Z", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "committedDate": "2020-08-27T13:33:09Z", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)\n  - When more than one product provides the same content with different\n    enablement values,deduplicate them by keeping the enabled content only."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c42f81117978ba187237392dd2168f3b8932e11", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/0c42f81117978ba187237392dd2168f3b8932e11", "committedDate": "2020-08-26T11:33:32Z", "message": "Updated logic in ContentAccess manager"}, "afterCommit": {"oid": "88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "author": {"user": {"login": "wolfdale", "name": "Prakhar Gupta"}}, "url": "https://github.com/candlepin/candlepin/commit/88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "committedDate": "2020-08-27T13:33:09Z", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)\n  - When more than one product provides the same content with different\n    enablement values,deduplicate them by keeping the enabled content only."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2299, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}