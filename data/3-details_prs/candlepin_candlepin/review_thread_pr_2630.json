{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMzg3OTQw", "number": 2630, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzowMTo0NVrODkpACA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo1MToyOFrODkrsxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzQ3MDgwOnYy", "diffSide": "RIGHT", "path": "api/candlepin-api-spec.yaml", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzowMTo0NVrOFxE0ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDo0MTozOVrOFxoPQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwMzQ5Mw==", "bodyText": "Just an idea. We could add pattern: \"^[a-zA-Z0-9_-]+$\" so that we don't have to validate the name manually.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387003493", "createdAt": "2020-03-03T13:01:45Z", "author": {"login": "Januson"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMTM4MQ==", "bodyText": "Does the pattern method basically add a regex validator on this field? Does it also handle nulls?", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387031381", "createdAt": "2020-03-03T13:51:56Z", "author": {"login": "Ceiu"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwMzQ5Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzOTgzMw==", "bodyText": "I just realized that the resource is also doing this:\n        if (StringUtils.isBlank(dto.getName())) {\n            throw new BadRequestException(i18n.tr(\"Must provide a name for activation key.\"));\n        }\n\nso I can simply add name to the list of required properties (which will generate a @NotNull annotation) and will validate automatically\nEdit: but that is only on the create resource, not on the update. so we might want to keep it as is", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387039833", "createdAt": "2020-03-03T14:05:37Z", "author": {"login": "nikosmoum"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwMzQ5Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA1NDQ5Nw==", "bodyText": "Exactly. It just adds @pattern annotation. @pattern is not validated if the value is null.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387054497", "createdAt": "2020-03-03T14:27:41Z", "author": {"login": "Januson"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwMzQ5Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4MzgwOA==", "bodyText": "I decided not to do this because it will change the current error message we send back to this one, which is less user friendly.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387583808", "createdAt": "2020-03-04T10:41:39Z", "author": {"login": "nikosmoum"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwMzQ5Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzY1NDc4OnYy", "diffSide": "RIGHT", "path": "api/candlepin-api-spec.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzo1Mjo0MVrOFxGjJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDowMTozN1rOFxG5BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMTg0NQ==", "bodyText": "I assume this is the replacement for owner + hateoas filtering?", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387031845", "createdAt": "2020-03-03T13:52:41Z", "author": {"login": "Ceiu"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string\n+            description:\n+              type: string\n+            owner:\n+              $ref: '#/components/schemas/NestedOwnerDTO'\n+            releaseVer:\n+              $ref: '#/components/schemas/ReleaseVerDTO'\n+            serviceLevel:\n+              type: string\n+            usage:\n+              type: string\n+            role:\n+              type: string\n+            addOns:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                type: string\n+            autoAttach:\n+              type: boolean\n+            pools:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                $ref: '#/components/schemas/ActivationKeyPoolDTO'\n+            products:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                $ref: '#/components/schemas/ActivationKeyProductDTO'\n+            contentOverrides:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                $ref: '#/components/schemas/ContentOverrideDTO'\n+\n+    ActivationKeyProductDTO:\n+      required:\n+        - productId\n+      properties:\n+        productId:\n+          type: string\n+          minLength: 1\n+\n+    ActivationKeyPoolDTO:\n+      required:\n+        - poolId\n+      properties:\n+        poolId:\n+          type: string\n+          minLength: 1\n+        quantity:\n+          type: integer\n+          format: int64\n+\n+    ReleaseVerDTO:\n+      properties:\n+        releaseVer:\n+          type: string\n+\n+    NestedOwnerDTO:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzNzQ0NA==", "bodyText": "Correct. Other DTOs that reference OwnerDTO will be using this", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387037444", "createdAt": "2020-03-03T14:01:37Z", "author": {"login": "nikosmoum"}, "path": "api/candlepin-api-spec.yaml", "diffHunk": "@@ -284,6 +284,86 @@ components:\n         href:\n           type: string\n \n+    ActivationKeyDTO:\n+      description: A token that allows registration without username/password and sets subscription and content related properties at registration.\n+      allOf:\n+        - $ref: '#/components/schemas/TimestampedEntity'\n+        - type: object\n+          properties:\n+            id:\n+              type: string\n+            name:\n+              type: string\n+            description:\n+              type: string\n+            owner:\n+              $ref: '#/components/schemas/NestedOwnerDTO'\n+            releaseVer:\n+              $ref: '#/components/schemas/ReleaseVerDTO'\n+            serviceLevel:\n+              type: string\n+            usage:\n+              type: string\n+            role:\n+              type: string\n+            addOns:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                type: string\n+            autoAttach:\n+              type: boolean\n+            pools:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                $ref: '#/components/schemas/ActivationKeyPoolDTO'\n+            products:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                $ref: '#/components/schemas/ActivationKeyProductDTO'\n+            contentOverrides:\n+              type: array\n+              uniqueItems: true\n+              items:\n+                $ref: '#/components/schemas/ContentOverrideDTO'\n+\n+    ActivationKeyProductDTO:\n+      required:\n+        - productId\n+      properties:\n+        productId:\n+          type: string\n+          minLength: 1\n+\n+    ActivationKeyPoolDTO:\n+      required:\n+        - poolId\n+      properties:\n+        poolId:\n+          type: string\n+          minLength: 1\n+        quantity:\n+          type: integer\n+          format: int64\n+\n+    ReleaseVerDTO:\n+      properties:\n+        releaseVer:\n+          type: string\n+\n+    NestedOwnerDTO:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMTg0NQ=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzY2NjA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzo1NTozM1rOFxGp5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1Njo0MlrOFxmsLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMzU3Mw==", "bodyText": "We should be passing these through and letting the model translator deal with this if we're going to have a translator for it.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387033573", "createdAt": "2020-03-03T13:55:33Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -101,27 +124,37 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n         }\n         dest.setAddOns(addOns);\n \n-        // Process nested DTO objects if we have a model translator to use to the translation...\n-        if (modelTranslator != null) {\n-            dest.setOwner(modelTranslator.translate(source.getOwner(), OwnerDTO.class));\n+        Owner owner = source.getOwner();\n+        if (source.getOwner() != null) {\n+            NestedOwnerDTO ownerDTO = new NestedOwnerDTO()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3NTk0OQ==", "bodyText": "Ah, I forgot to use the translator here because initially wrote this as if we might not need it.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387075949", "createdAt": "2020-03-03T14:57:38Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -101,27 +124,37 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n         }\n         dest.setAddOns(addOns);\n \n-        // Process nested DTO objects if we have a model translator to use to the translation...\n-        if (modelTranslator != null) {\n-            dest.setOwner(modelTranslator.translate(source.getOwner(), OwnerDTO.class));\n+        Owner owner = source.getOwner();\n+        if (source.getOwner() != null) {\n+            NestedOwnerDTO ownerDTO = new NestedOwnerDTO()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMzU3Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODQ0Ng==", "bodyText": "Done", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558446", "createdAt": "2020-03-04T09:56:42Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -101,27 +124,37 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n         }\n         dest.setAddOns(addOns);\n \n-        // Process nested DTO objects if we have a model translator to use to the translation...\n-        if (modelTranslator != null) {\n-            dest.setOwner(modelTranslator.translate(source.getOwner(), OwnerDTO.class));\n+        Owner owner = source.getOwner();\n+        if (source.getOwner() != null) {\n+            NestedOwnerDTO ownerDTO = new NestedOwnerDTO()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzMzU3Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzY3Mzg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzo1NzoyNlrOFxGumw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1NjozOVrOFxmr_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzNDc3OQ==", "bodyText": "This can fit on the previous line", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387034779", "createdAt": "2020-03-03T13:57:26Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -83,16 +98,24 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n                     productIds.add(prod.getId());\n                 }\n             }\n-\n-            dest.setProductIds(productIds);\n+            Set<ActivationKeyProductDTO> productIdObjects = productIds.stream().map(productId ->  {\n+                ActivationKeyProductDTO newProduct =\n+                    new ActivationKeyProductDTO();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODM5Nw==", "bodyText": "Done", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558397", "createdAt": "2020-03-04T09:56:39Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/ActivationKeyTranslator.java", "diffHunk": "@@ -83,16 +98,24 @@ public ActivationKeyDTO populate(ModelTranslator modelTranslator,\n                     productIds.add(prod.getId());\n                 }\n             }\n-\n-            dest.setProductIds(productIds);\n+            Set<ActivationKeyProductDTO> productIdObjects = productIds.stream().map(productId ->  {\n+                ActivationKeyProductDTO newProduct =\n+                    new ActivationKeyProductDTO();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzNDc3OQ=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzcwODYxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/jackson/ReleaseVersionWrapDeserializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDowNjowN1rOFxHDog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1Njo0N1rOFxmsXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MDE2Mg==", "bodyText": "Indentation", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387040162", "createdAt": "2020-03-03T14:06:07Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/jackson/ReleaseVersionWrapDeserializer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.jackson;\n+\n+import org.candlepin.common.exceptions.CandlepinJsonProcessingException;\n+import org.candlepin.dto.api.v1.ReleaseVerDTO;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * Handles the deserialization of the \"releaseVer\" field by wrapping it in a {@link ReleaseVerDTO} object,\n+ * by handling both of the following formats: <pre> {@code \"releaseVer\":\"value\" } </pre> and\n+ * <pre> {@code \"releaseVer\":{\"releaseVer \":\"value\"} } </pre>.\n+ */\n+public class ReleaseVersionWrapDeserializer extends JsonDeserializer<ReleaseVerDTO> {\n+\n+    private static Logger log = LoggerFactory.getLogger(ReleaseVersionWrapDeserializer.class);\n+\n+    private static String fieldName = \"releaseVer\";\n+\n+    @Override\n+    public ReleaseVerDTO deserialize(JsonParser parser, DeserializationContext context)\n+        throws IOException {\n+\n+        TreeNode node = parser.readValueAsTree();\n+\n+        if (node.isValueNode()) {\n+            log.debug(\"Processing {} as a value node.\", fieldName);\n+\n+            return parseValueNode(node);\n+        }\n+        else if (node.isObject()) {\n+            log.debug(\"Processing {} as a containing object node.\", fieldName);\n+\n+            TreeNode valueNode = node.path(fieldName);\n+            if (valueNode.isMissingNode()) {\n+                throw new CandlepinJsonProcessingException(\n+                        \"The field \" + fieldName + \" is missing from: \" + node.asToken(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODQ5Mw==", "bodyText": "Done", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558493", "createdAt": "2020-03-04T09:56:47Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/jackson/ReleaseVersionWrapDeserializer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.jackson;\n+\n+import org.candlepin.common.exceptions.CandlepinJsonProcessingException;\n+import org.candlepin.dto.api.v1.ReleaseVerDTO;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * Handles the deserialization of the \"releaseVer\" field by wrapping it in a {@link ReleaseVerDTO} object,\n+ * by handling both of the following formats: <pre> {@code \"releaseVer\":\"value\" } </pre> and\n+ * <pre> {@code \"releaseVer\":{\"releaseVer \":\"value\"} } </pre>.\n+ */\n+public class ReleaseVersionWrapDeserializer extends JsonDeserializer<ReleaseVerDTO> {\n+\n+    private static Logger log = LoggerFactory.getLogger(ReleaseVersionWrapDeserializer.class);\n+\n+    private static String fieldName = \"releaseVer\";\n+\n+    @Override\n+    public ReleaseVerDTO deserialize(JsonParser parser, DeserializationContext context)\n+        throws IOException {\n+\n+        TreeNode node = parser.readValueAsTree();\n+\n+        if (node.isValueNode()) {\n+            log.debug(\"Processing {} as a value node.\", fieldName);\n+\n+            return parseValueNode(node);\n+        }\n+        else if (node.isObject()) {\n+            log.debug(\"Processing {} as a containing object node.\", fieldName);\n+\n+            TreeNode valueNode = node.path(fieldName);\n+            if (valueNode.isMissingNode()) {\n+                throw new CandlepinJsonProcessingException(\n+                        \"The field \" + fieldName + \" is missing from: \" + node.asToken(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MDE2Mg=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Nzc0NTk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNToxM1rOFxHaiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1Njo1MVrOFxmsiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjAyNw==", "bodyText": "I'm mostly alright with the microoptimization here around the avoidance of the implicit array creation, however, I feel these should be structured with code minimization in mind -- especially since we're offloading the work to a worker method to begin with.\nAnyway, since we have a private method which validates a collection, and the single-param version does nothing more than unpack the collection from its supplier, it feels like the cleanest way to do all of this is to declare the single-param version as the base, and then have the various variadic overloads call it with each supplier. For example:\n    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n        Collection<?> collection = getter.get();\n        if (collection == null || collection.stream().anyMatch(Objects::isNull)) {\n            throw new IllegalArgumentException(\"collection contains null elements\");\n        }\n    }\n\n    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n        Supplier<? extends Collection<?>> getter2) {\n\n        this.validateCollectionElementsNonNull(getter1);\n        this.validateCollectionElementsNonNull(getter2);\n    }\n\n    // and so on", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387046027", "createdAt": "2020-03-03T14:15:13Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3NjQ5NA==", "bodyText": "Good idea", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387076494", "createdAt": "2020-03-03T14:58:21Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjAyNw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODUzNw==", "bodyText": "Done", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558537", "createdAt": "2020-03-04T09:56:51Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjAyNw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Nzc1MTc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNjozMVrOFxHeDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1Njo1NlrOFxmstQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjkyNQ==", "bodyText": "Same deal here: use this version as the base, and have the extended versions just call into it with each arg.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387046925", "createdAt": "2020-03-03T14:16:31Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        Collection<?> collection3 = getter3.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2) ||\n+            isCollectionInvalid(collection3)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    private boolean isCollectionInvalid(Collection<?> collection) {\n+        return collection != null && collection.stream().anyMatch(Objects::isNull);\n+    }\n+\n+\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Maps of elements, and\n+     * validates that none of the elements (keys and values) contained in them are null. When at least one\n+     * key or value of any of the Maps is null, an exception is thrown.\n+     *\n+     * If the map returned by the getter itself is null, no exception is thrown (null map is considered\n+     * valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateMapElementsNotNull(dto::getAttributes, dto::getProductAttributes);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Maps of items\n+     * @throws IllegalArgumentException when any of the maps returned from the specified getters contains at\n+     * least one null key or value\n+     */\n+    @SafeVarargs\n+    public final void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3,\n+        Supplier<? extends Map<?, ?>>... getters) {\n+\n+        validateMapElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Map<?, ?>> getter : getters) {\n+            Map<?, ?> map = getter.get();\n+            if (isMapInvalid(map)) {\n+                throw new IllegalArgumentException(\"map contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateMapElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three maps that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 maps at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODU4MQ==", "bodyText": "Done", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387558581", "createdAt": "2020-03-04T09:56:56Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        Collection<?> collection3 = getter3.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2) ||\n+            isCollectionInvalid(collection3)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    private boolean isCollectionInvalid(Collection<?> collection) {\n+        return collection != null && collection.stream().anyMatch(Objects::isNull);\n+    }\n+\n+\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Maps of elements, and\n+     * validates that none of the elements (keys and values) contained in them are null. When at least one\n+     * key or value of any of the Maps is null, an exception is thrown.\n+     *\n+     * If the map returned by the getter itself is null, no exception is thrown (null map is considered\n+     * valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateMapElementsNotNull(dto::getAttributes, dto::getProductAttributes);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Maps of items\n+     * @throws IllegalArgumentException when any of the maps returned from the specified getters contains at\n+     * least one null key or value\n+     */\n+    @SafeVarargs\n+    public final void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3,\n+        Supplier<? extends Map<?, ?>>... getters) {\n+\n+        validateMapElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Map<?, ?>> getter : getters) {\n+            Map<?, ?> map = getter.get();\n+            if (isMapInvalid(map)) {\n+                throw new IllegalArgumentException(\"map contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateMapElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three maps that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 maps at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjkyNQ=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Nzg3MjA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo0Mzo0MFrOFxIm-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo0MDo0M1rOFxmIGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2NTU5NQ==", "bodyText": "Map has methods map.containsKey(null) and map.containsValue(null). We could use those.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387065595", "createdAt": "2020-03-03T14:43:40Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        Collection<?> collection3 = getter3.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2) ||\n+            isCollectionInvalid(collection3)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    private boolean isCollectionInvalid(Collection<?> collection) {\n+        return collection != null && collection.stream().anyMatch(Objects::isNull);\n+    }\n+\n+\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Maps of elements, and\n+     * validates that none of the elements (keys and values) contained in them are null. When at least one\n+     * key or value of any of the Maps is null, an exception is thrown.\n+     *\n+     * If the map returned by the getter itself is null, no exception is thrown (null map is considered\n+     * valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateMapElementsNotNull(dto::getAttributes, dto::getProductAttributes);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Maps of items\n+     * @throws IllegalArgumentException when any of the maps returned from the specified getters contains at\n+     * least one null key or value\n+     */\n+    @SafeVarargs\n+    public final void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3,\n+        Supplier<? extends Map<?, ?>>... getters) {\n+\n+        validateMapElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Map<?, ?>> getter : getters) {\n+            Map<?, ?> map = getter.get();\n+            if (isMapInvalid(map)) {\n+                throw new IllegalArgumentException(\"map contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateMapElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three maps that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 maps at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter) {\n+        Map<?, ?> map = getter.get();\n+        if (isMapInvalid(map)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2) {\n+        Map<?, ?> map1 = getter1.get();\n+        Map<?, ?> map2 = getter2.get();\n+        if (isMapInvalid(map1) ||\n+            isMapInvalid(map2)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3) {\n+        Map<?, ?> map1 = getter1.get();\n+        Map<?, ?> map2 = getter2.get();\n+        Map<?, ?> map3 = getter3.get();\n+        if (isMapInvalid(map1) ||\n+            isMapInvalid(map2) ||\n+            isMapInvalid(map3)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    private boolean isMapInvalid(Map<?, ?> map) {\n+        return map != null &&\n+            (map.values().stream().anyMatch(Objects::isNull) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0OTIxMA==", "bodyText": "Apparently, some implementations of Map such as ConcurrentHashMap will throw an NPE if you pass null to containsValue, so I'll keep this as is", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387549210", "createdAt": "2020-03-04T09:40:43Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/resource/validation/DTOValidator.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import com.google.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.Validator;\n+import javax.validation.ValidatorFactory;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+\n+/**\n+ * Provides utility methods that perform various types of validations on DTO objects.\n+ * Recommended usage: Use as early as possible in PUT/POST Resource endpoint methods to validate incoming\n+ * DTO objects.\n+ */\n+public class DTOValidator {\n+\n+    private Validator validator;\n+\n+    @Inject\n+    public DTOValidator(ValidatorFactory validatorFactory) {\n+        this.validator = validatorFactory.getValidator();\n+    }\n+\n+    /**\n+     * Performs validation of the DTO's fields (and their fields, thus validating the whole DTO tree) based\n+     * on the {@link javax.validation.constraints} annotations set on the them (such as {@link NotNull} and\n+     *  {@link Size}).\n+     *\n+     * @param dto the DTO object to validate\n+     * @throws ConstraintViolationException when a constraint validation has failed\n+     */\n+    public void validateConstraints(Object dto) {\n+        Set<ConstraintViolation<Object>> violations = validator.validate(dto);\n+        if (!violations.isEmpty()) {\n+            throw new ConstraintViolationException(violations);\n+        }\n+        this.validator.validate(dto);\n+    }\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Collections of elements, and\n+     * validates that none of the elements contained in them are null. When at least one element of any of\n+     * the Collections is null, an exception is thrown.\n+     *\n+     * If the collection returned by the getter itself is null, no exception is thrown (null collection\n+     * is considered valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateCollectionElementsNotNull(dto::getProductIds, dto::getEntitlements);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Collections of items\n+     * @throws IllegalArgumentException when any of the collections returned from the specified getters\n+     * contains at least one null element\n+     */\n+    @SafeVarargs\n+    public final void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3,\n+        Supplier<? extends Collection<?>>... getters) {\n+\n+        validateCollectionElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Collection<?>> getter : getters) {\n+            Collection<?> collection = getter.get();\n+            if (isCollectionInvalid(collection)) {\n+                throw new IllegalArgumentException(\"collection contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateCollectionElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three collections that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 collections at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter) {\n+        Collection<?> collection = getter.get();\n+        if (isCollectionInvalid(collection)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateCollectionElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateCollectionElementsNotNull(Supplier<? extends Collection<?>> getter1,\n+        Supplier<? extends Collection<?>> getter2, Supplier<? extends Collection<?>> getter3) {\n+        Collection<?> collection1 = getter1.get();\n+        Collection<?> collection2 = getter2.get();\n+        Collection<?> collection3 = getter3.get();\n+        if (isCollectionInvalid(collection1) ||\n+            isCollectionInvalid(collection2) ||\n+            isCollectionInvalid(collection3)) {\n+            throw new IllegalArgumentException(\"collection contains null elements\");\n+        }\n+    }\n+\n+    private boolean isCollectionInvalid(Collection<?> collection) {\n+        return collection != null && collection.stream().anyMatch(Objects::isNull);\n+    }\n+\n+\n+\n+    /**\n+     * Accepts a variable amount of method references to getters that return Maps of elements, and\n+     * validates that none of the elements (keys and values) contained in them are null. When at least one\n+     * key or value of any of the Maps is null, an exception is thrown.\n+     *\n+     * If the map returned by the getter itself is null, no exception is thrown (null map is considered\n+     * valid).\n+     *\n+     * Usage example:\n+     * <pre>\n+     * {@code\n+     * validator.validateMapElementsNotNull(dto::getAttributes, dto::getProductAttributes);\n+     * }\n+     * </pre>\n+     *\n+     * @param getters a variable amount of method references to getters that return Maps of items\n+     * @throws IllegalArgumentException when any of the maps returned from the specified getters contains at\n+     * least one null key or value\n+     */\n+    @SafeVarargs\n+    public final void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3,\n+        Supplier<? extends Map<?, ?>>... getters) {\n+\n+        validateMapElementsNotNull(getter1, getter2, getter3);\n+\n+        for (Supplier<? extends Map<?, ?>> getter : getters) {\n+            Map<?, ?> map = getter.get();\n+            if (isMapInvalid(map)) {\n+                throw new IllegalArgumentException(\"map contains null elements\");\n+            }\n+        }\n+    }\n+\n+    /*\n+     * ======================================================================================================\n+     * The following methods are overloaded versions of validateMapElementsNotNull for one, two and\n+     * three getters respectively, as a performance optimization to avoid the implicit creation of an array\n+     * object that happens during the vararg method call. There are currently no DTOs that contain more than\n+     * three maps that require null element validation, so this optimisation would cover 100% of cases\n+     * for now, while allowing us to validate more than 3 maps at a time in the future.\n+     * ======================================================================================================\n+     */\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter) {\n+        Map<?, ?> map = getter.get();\n+        if (isMapInvalid(map)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2) {\n+        Map<?, ?> map1 = getter1.get();\n+        Map<?, ?> map2 = getter2.get();\n+        if (isMapInvalid(map1) ||\n+            isMapInvalid(map2)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    /**\n+     * Works the same as {@link #validateMapElementsNotNull(Supplier, Supplier, Supplier, Supplier...)}\n+     */\n+    public void validateMapElementsNotNull(Supplier<? extends Map<?, ?>> getter1,\n+        Supplier<? extends Map<?, ?>> getter2, Supplier<? extends Map<?, ?>> getter3) {\n+        Map<?, ?> map1 = getter1.get();\n+        Map<?, ?> map2 = getter2.get();\n+        Map<?, ?> map3 = getter3.get();\n+        if (isMapInvalid(map1) ||\n+            isMapInvalid(map2) ||\n+            isMapInvalid(map3)) {\n+            throw new IllegalArgumentException(\"map contains null elements\");\n+        }\n+    }\n+\n+    private boolean isMapInvalid(Map<?, ?> map) {\n+        return map != null &&\n+            (map.values().stream().anyMatch(Objects::isNull) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2NTU5NQ=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzkxMzAwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/candlepin/resource/validation/DTOValidatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo1MToyOFrOFxI-Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1Nzo0M1rOFxmujw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MTU2Mw==", "bodyText": "We could use Validation.buildDefaultValidatorFactory() instead of extending the whole DB fixture.", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387071563", "createdAt": "2020-03-03T14:51:28Z", "author": {"login": "Januson"}, "path": "server/src/test/java/org/candlepin/resource/validation/DTOValidatorTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import org.candlepin.test.DatabaseTestFixture;\n+\n+import com.google.inject.Inject;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+/**\n+ * Test suite for the DTOValidator class\n+ */\n+public class DTOValidatorTest extends DatabaseTestFixture {\n+\n+    @Inject DTOValidator validator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1OTA1NQ==", "bodyText": "Done. I had to add the javax.el library, but it saves us ~8 seconds of execution", "url": "https://github.com/candlepin/candlepin/pull/2630#discussion_r387559055", "createdAt": "2020-03-04T09:57:43Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/resource/validation/DTOValidatorTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resource.validation;\n+\n+import org.candlepin.test.DatabaseTestFixture;\n+\n+import com.google.inject.Inject;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.validation.ConstraintViolationException;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Size;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+/**\n+ * Test suite for the DTOValidator class\n+ */\n+public class DTOValidatorTest extends DatabaseTestFixture {\n+\n+    @Inject DTOValidator validator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MTU2Mw=="}, "originalCommit": {"oid": "7f125ada3c3cbeeb205cc81e634be4d5bdaf234d"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4314, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}