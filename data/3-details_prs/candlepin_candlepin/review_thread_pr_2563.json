{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNDgzOTMw", "number": 2563, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDoyNjo0OFrODX3Y5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo1MTo0OFrODY5Ilw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzUxMzMzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/candlepin/resource/util/InstalledProductStatusCalculatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDoyNjo0OFrOFdZS0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzo1NTo1MFrOFeQoGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM2NzQ0MQ==", "bodyText": "For blocks like this, either follow the existing formatting (each new param on a new line), or update the formatting for the whole statement. This occurs a number of times throughout this PR.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366367441", "createdAt": "2020-01-14T14:26:48Z", "author": {"login": "Ceiu"}, "path": "server/src/test/java/org/candlepin/resource/util/InstalledProductStatusCalculatorTest.java", "diffHunk": "@@ -117,7 +118,7 @@ public void setUp() {\n \n         translator = new StandardTranslator(this.consumerTypeCurator,\n             this.environmentCurator,\n-            this.ownerCurator);\n+            this.ownerCurator, this.entitlementCurator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3NDAxMQ==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367274011", "createdAt": "2020-01-16T07:55:50Z", "author": {"login": "abhiskum"}, "path": "server/src/test/java/org/candlepin/resource/util/InstalledProductStatusCalculatorTest.java", "diffHunk": "@@ -117,7 +118,7 @@ public void setUp() {\n \n         translator = new StandardTranslator(this.consumerTypeCurator,\n             this.environmentCurator,\n-            this.ownerCurator);\n+            this.ownerCurator, this.entitlementCurator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM2NzQ0MQ=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzUxODA0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/candlepin/sync/ImporterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDoyODoxM1rOFdZV1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzo1NTo1OVrOFeQoVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM2ODIxMg==", "bodyText": "Trailing punctuation goes on the previous line. If it cannot fit, bring the last chunk of code down. In this case, I'm guessing this.oc, should be on 171.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366368212", "createdAt": "2020-01-14T14:28:13Z", "author": {"login": "Ceiu"}, "path": "server/src/test/java/org/candlepin/sync/ImporterTest.java", "diffHunk": "@@ -163,8 +164,11 @@ public void init() throws URISyntaxException, IOException {\n         this.mockSubReconciler = Mockito.mock(SubscriptionReconciler.class);\n         this.consumerTypeCurator = Mockito.mock(ConsumerTypeCurator.class);\n         oc = mock(OwnerCurator.class);\n+        entitlementCurator = mock(EntitlementCurator.class);\n \n-        this.translator = new StandardTranslator(this.consumerTypeCurator, this.environmentCurator, this.oc);\n+\n+        this.translator = new StandardTranslator(this.consumerTypeCurator, this.environmentCurator, this.oc\n+            , this.entitlementCurator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3NDA2OA==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367274068", "createdAt": "2020-01-16T07:55:59Z", "author": {"login": "abhiskum"}, "path": "server/src/test/java/org/candlepin/sync/ImporterTest.java", "diffHunk": "@@ -163,8 +164,11 @@ public void init() throws URISyntaxException, IOException {\n         this.mockSubReconciler = Mockito.mock(SubscriptionReconciler.class);\n         this.consumerTypeCurator = Mockito.mock(ConsumerTypeCurator.class);\n         oc = mock(OwnerCurator.class);\n+        entitlementCurator = mock(EntitlementCurator.class);\n \n-        this.translator = new StandardTranslator(this.consumerTypeCurator, this.environmentCurator, this.oc);\n+\n+        this.translator = new StandardTranslator(this.consumerTypeCurator, this.environmentCurator, this.oc\n+            , this.entitlementCurator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM2ODIxMg=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzYwMjc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDo1MDo1NlrOFdaI0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzo1Mzo1NFrOFeQlvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM4MTI2NA==", "bodyText": "There are a number of ways to format these blocks, and for the most part that's fine; but try to be consistent in which you choose. Elsewhere in the PR there is a nearly identical block which is formatted with different breakage.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366381264", "createdAt": "2020-01-14T14:50:56Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -122,20 +132,22 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n             if (products != null && !products.isEmpty()) {\n                 for (Product prod : products) {\n                     if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+                        dest.addProvidedProduct(new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n                     }\n                 }\n+\n             }\n             else {\n                 dest.setProvidedProducts(Collections.<PoolDTO.ProvidedProductDTO>emptySet());\n             }\n \n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3MzQwNQ==", "bodyText": "fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367273405", "createdAt": "2020-01-16T07:53:54Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -122,20 +132,22 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n             if (products != null && !products.isEmpty()) {\n                 for (Product prod : products) {\n                     if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+                        dest.addProvidedProduct(new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n                     }\n                 }\n+\n             }\n             else {\n                 dest.setProvidedProducts(Collections.<PoolDTO.ProvidedProductDTO>emptySet());\n             }\n \n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM4MTI2NA=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzYwNTEzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDo1MToyMFrOFdaKAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzo1NjoxN1rOFeQowg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM4MTU2OQ==", "bodyText": "Whitespace missing between the // and TODO", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366381569", "createdAt": "2020-01-14T14:51:20Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "diffHunk": "@@ -974,6 +974,11 @@ private Pool convertToMasterPoolImpl(SubscriptionInfo sub, Owner owner, Map<Stri\n             }\n \n             pool.setProvidedProducts(products);\n+            //TODO: workaround to pass import spec tests. we will revisit and update this in import and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3NDE3OA==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367274178", "createdAt": "2020-01-16T07:56:17Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "diffHunk": "@@ -974,6 +974,11 @@ private Pool convertToMasterPoolImpl(SubscriptionInfo sub, Owner owner, Map<Stri\n             }\n \n             pool.setProvidedProducts(products);\n+            //TODO: workaround to pass import spec tests. we will revisit and update this in import and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM4MTU2OQ=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzY5OTY0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/sync/Exporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNToxNjoxN1rOFdbEUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzo1NjoyNlrOFeQo-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM5NjQ5Nw==", "bodyText": "Product model translation needs to be n-tier aware during the conversion to a flat list here and below.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366396497", "createdAt": "2020-01-14T15:16:17Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/sync/Exporter.java", "diffHunk": "@@ -492,12 +492,18 @@ private void exportProducts(File baseDir, Consumer consumer) throws IOException\n             Product product = pool.getProduct();\n             products.put(product.getId(), product);\n \n+            for (Product providedProduct : product.getProvidedProducts()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3NDIzNQ==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367274235", "createdAt": "2020-01-16T07:56:26Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/sync/Exporter.java", "diffHunk": "@@ -492,12 +492,18 @@ private void exportProducts(File baseDir, Consumer consumer) throws IOException\n             Product product = pool.getProduct();\n             products.put(product.getId(), product);\n \n+            for (Product providedProduct : product.getProvidedProducts()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM5NjQ5Nw=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzcwNjA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNToxODowNFrOFdbIfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOToxOTo1OVrOFeSslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM5NzU2NA==", "bodyText": "These need to be n-tier aware translations", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366397564", "createdAt": "2020-01-14T15:18:04Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -150,8 +162,47 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n             else {\n                 dest.setDerivedProvidedProducts(Collections.emptySet());\n             }\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Collection<Product> providedProducts = accumulateStackDerivedPoolProvidedProducts(source);\n+                if (source.getDerivedProduct() != null) {\n+                    for (Product providedProduct : providedProducts) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwNzkyNg==", "bodyText": "Done.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367307926", "createdAt": "2020-01-16T09:19:59Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -150,8 +162,47 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n             else {\n                 dest.setDerivedProvidedProducts(Collections.emptySet());\n             }\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Collection<Product> providedProducts = accumulateStackDerivedPoolProvidedProducts(source);\n+                if (source.getDerivedProduct() != null) {\n+                    for (Product providedProduct : providedProducts) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM5NzU2NA=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MzcwNzQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNToxODozMFrOFdbJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOToxOTo1M1rOFeSsdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM5Nzc5NA==", "bodyText": "These need to be n-tier aware translations", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r366397794", "createdAt": "2020-01-14T15:18:30Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -147,8 +159,48 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n             else {\n                 dest.setDerivedProvidedProducts(Collections.<PoolDTO.ProvidedProductDTO>emptySet());\n             }\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Collection<Product> providedProducts = accumulateStackDerivedPoolProvidedProducts(source);\n+                if (source.getDerivedProduct() != null) {\n+                    for (Product providedProduct : providedProducts) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwNzg5Mg==", "bodyText": "Done.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367307892", "createdAt": "2020-01-16T09:19:53Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -147,8 +159,48 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n             else {\n                 dest.setDerivedProvidedProducts(Collections.<PoolDTO.ProvidedProductDTO>emptySet());\n             }\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Collection<Product> providedProducts = accumulateStackDerivedPoolProvidedProducts(source);\n+                if (source.getDerivedProduct() != null) {\n+                    for (Product providedProduct : providedProducts) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM5Nzc5NA=="}, "originalCommit": {"oid": "1070f83a4e0c5ba5c5cd10e7467c85ec54790877"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTk0NjQ3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMTo1Njo0OFrOFeW_5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMTo1Njo0OFrOFeW_5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3ODQwNQ==", "bodyText": "\ud83d\udc4d Yep, it would be easier to get the refresh changes done first", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367378405", "createdAt": "2020-01-16T11:56:48Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "diffHunk": "@@ -974,6 +974,11 @@ private Pool convertToMasterPoolImpl(SubscriptionInfo sub, Owner owner, Map<Stri\n             }\n \n             pool.setProvidedProducts(products);\n+            // TODO: workaround to pass import spec tests. we will revisit and update this in import and\n+            // refresh code changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTk4MTMzOnYy", "diffSide": "RIGHT", "path": "server/bin/import_test_data.rb", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMjoxMDowMVrOFeXUcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMjoxMDowMVrOFeXUcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzY2Ng==", "bodyText": "This is something also found in Sonali's PR, which we discussed, and decided it is part if a separate task (ENT-1834), since the import_test_data.rb file has nothing to do with spec tests, and is only invoked by the deploy script to load test_data.json, so it should probably be reverted from this PR.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367383666", "createdAt": "2020-01-16T12:10:01Z", "author": {"login": "nikosmoum"}, "path": "server/bin/import_test_data.rb", "diffHunk": "@@ -202,12 +202,14 @@ def create_product(cp, owner, product)\n   attrs['variant'] = variant\n   attrs['arch'] = arch\n   attrs['type'] = type\n+\n   product_ret = cp.create_product(owner['name'], id, name, {\n     :multiplier => multiplier,\n     :attributes => attrs,\n     :dependentProductIds => dependent_products,\n     :relies_on => relies_on,\n-    :branding => branding\n+    :branding => branding,\n+    :providedProducts => provided_products", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzM0OTI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMjozMTozOVrOFe3pGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzo0MDoyN1rOFfwsPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMzI0Mw==", "bodyText": "This is something we discussed for a bit before, and it didn't seem right to me. I wasn't familiar with the code in StackedSubPoolValueAccumulator and how it's used, and it's hard to go through, but I tried to look into it a bit, and from what I understand this is what happens:\nWhen we want to update sub-pools (stack derived pools) of a master pool, we find the entitlements from the same stack of that sub-pool, then find the pools off of those entitlements, and see if any of their provided products changed, and if they did change, we set those provided products on that sub-pool here, and eventually persist it.\nI assume the problem that arose that prompted you to add this change in the Translator is that those updated provided products are not reflected in the pool's marketing product, so we add them in the DTO here due to possible spec test failures? Would it not be preferable to change the code in PoolRules instead, to add those updated provided products on the marketing product directly and make sure our model data is consistent? Then we wouldn't need to do this on the DTO?\n@abhiskum Maybe I'm misunderstanding something since I'm not familiar with this part of the application? @Ceiu do you happen to know more about this?", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367913243", "createdAt": "2020-01-17T12:31:39Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -122,33 +132,74 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTY1NA==", "bodyText": "This probably isn't something we want to change internally in pool rules. As far as I understood the intent of this particular block, it's that we want to maintain the old flat representation of provided products on a given pool at the API level. But apparently stacks share provided products? That bit seems wrong to me, but will require some investigation to verify. If that's truly how stacks work, then this logic is fine (though maybe some other details need to be sorted out).", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368051654", "createdAt": "2020-01-17T17:29:30Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -122,33 +132,74 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMzI0Mw=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUwNzg5OQ==", "bodyText": "This is something we should discuss. @abhiskum will set up a meeting.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368507899", "createdAt": "2020-01-20T11:50:57Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -122,33 +132,74 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMzI0Mw=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0NzkzMg==", "bodyText": "As per discussion with @barnabycourt, @Ceiu, @nikosmoum and @wolfdale, we came up with the conclusion that we do not need to accumulate provided products in case of stacked entitlement as marketing product and stack id has one to one relationship i.e. different marketing product will not have the same stacking id and all the required provided products will be available in marketing product itself from adapter.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368847932", "createdAt": "2020-01-21T07:40:27Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/dto/api/v1/PoolTranslator.java", "diffHunk": "@@ -122,33 +132,74 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMzI0Mw=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzM2MTY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMjozNzoyMVrOFe3woA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNToxNjowMVrOFf9sWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNTE2OA==", "bodyText": "Are these recursive calls what is meant by \"n-tier aware\"? Are we sure that this is how we're going to be handling this in the future; as a marketing product that has provided products and each provided product has its own provided products etc.? Last I checked we were not going to be doing the N-tier stuff, because we don't yet know how the product management people are going to design that stuff.\n@abhiskum @Ceiu", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r367915168", "createdAt": "2020-01-17T12:37:21Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -125,33 +135,73 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds = new HashSet<>();\n+\n+                accumulateStackDerivedPoolProvidedProducts(source, expectedProvidedProds);\n+\n+                if (source.getDerivedProduct() != null) {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addDerivedProvidedProduct(providedProductDTO);\n                     }\n                 }\n-            }\n-            else {\n-                dest.setProvidedProducts(Collections.emptySet());\n-            }\n-\n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n-            if (derivedProducts != null && !derivedProducts.isEmpty()) {\n-                for (Product derivedProd : derivedProducts) {\n-                    if (derivedProd != null) {\n-                        dest.addDerivedProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(derivedProd.getId(), derivedProd.getName()));\n+                else {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addProvidedProduct(providedProductDTO);\n                     }\n                 }\n             }\n+        }\n+\n+        return dest;\n+    }\n+\n+    /**\n+     *\n+     * @param pool\n+     * @return\n+     *   accumulated provided products collection from the same stack entitlements\n+     */\n+    private void accumulateStackDerivedPoolProvidedProducts(Pool pool,\n+        Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds) {\n+        List<Entitlement> stackedEntitlements = this.entitlementCurator\n+            .findByStackId(pool.getSourceStack().getSourceConsumer(), pool.getSourceStackId()).list();\n+        for (Entitlement nextStacked : stackedEntitlements) {\n+            Pool nextStackedPool = nextStacked.getPool();\n+            if (nextStackedPool.getDerivedProduct() == null) {\n+                addProvidedProducts(nextStackedPool.getProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n+            }\n             else {\n-                dest.setDerivedProvidedProducts(Collections.emptySet());\n+                addProvidedProducts(nextStackedPool.getDerivedProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n             }\n         }\n+    }\n \n-        return dest;\n+    private void addProvidedProducts(Collection<Product> providedProducts,\n+        Set<PoolDTO.ProvidedProductDTO> providedProductDTOs) {\n+        if (providedProducts == null || providedProducts.isEmpty()) {\n+            return;\n+        }\n+        for (Product product : providedProducts) {\n+            if (product != null) {\n+                providedProductDTOs.add(new PoolDTO.ProvidedProductDTO(product.getId(), product.getName()));\n+                addProvidedProducts(product.getProvidedProducts(), providedProductDTOs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NzMyNw==", "bodyText": "\"N-tier\" the project name and n-tier as the thing I've been saying here are two different things (I think).\nI've stated this in another PR already, but for the sake of github comment history, I'll reiterate here:\nI posed this question during a post scrum, as I wasn't sure if we should be ignoring the provided products of provided products or not. The discussion ended with \"yes, we should handle those\" and that's what lead to my (perhaps poorly summarized) comment about n-tier handling.\nWhether or not that's something that is or will be used on the business side... who knows. Personally, I feel the effort to write it now and not worry about whether or not they'll use it is so low that I see no reason to skip it, and if it never gets utilized, it's almost free as far as processing time goes. We've probably spent more effort discussing the value than just doing it straight away.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368047327", "createdAt": "2020-01-17T17:18:56Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -125,33 +135,73 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds = new HashSet<>();\n+\n+                accumulateStackDerivedPoolProvidedProducts(source, expectedProvidedProds);\n+\n+                if (source.getDerivedProduct() != null) {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addDerivedProvidedProduct(providedProductDTO);\n                     }\n                 }\n-            }\n-            else {\n-                dest.setProvidedProducts(Collections.emptySet());\n-            }\n-\n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n-            if (derivedProducts != null && !derivedProducts.isEmpty()) {\n-                for (Product derivedProd : derivedProducts) {\n-                    if (derivedProd != null) {\n-                        dest.addDerivedProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(derivedProd.getId(), derivedProd.getName()));\n+                else {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addProvidedProduct(providedProductDTO);\n                     }\n                 }\n             }\n+        }\n+\n+        return dest;\n+    }\n+\n+    /**\n+     *\n+     * @param pool\n+     * @return\n+     *   accumulated provided products collection from the same stack entitlements\n+     */\n+    private void accumulateStackDerivedPoolProvidedProducts(Pool pool,\n+        Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds) {\n+        List<Entitlement> stackedEntitlements = this.entitlementCurator\n+            .findByStackId(pool.getSourceStack().getSourceConsumer(), pool.getSourceStackId()).list();\n+        for (Entitlement nextStacked : stackedEntitlements) {\n+            Pool nextStackedPool = nextStacked.getPool();\n+            if (nextStackedPool.getDerivedProduct() == null) {\n+                addProvidedProducts(nextStackedPool.getProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n+            }\n             else {\n-                dest.setDerivedProvidedProducts(Collections.emptySet());\n+                addProvidedProducts(nextStackedPool.getDerivedProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n             }\n         }\n+    }\n \n-        return dest;\n+    private void addProvidedProducts(Collection<Product> providedProducts,\n+        Set<PoolDTO.ProvidedProductDTO> providedProductDTOs) {\n+        if (providedProducts == null || providedProducts.isEmpty()) {\n+            return;\n+        }\n+        for (Product product : providedProducts) {\n+            if (product != null) {\n+                providedProductDTOs.add(new PoolDTO.ProvidedProductDTO(product.getId(), product.getName()));\n+                addProvidedProducts(product.getProvidedProducts(), providedProductDTOs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNTE2OA=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAzNjAzNg==", "bodyText": "While re-reviewing this earlier today, I noticed that the way we handle n-tier here, is that we set all provided products of the hierarchy to the top marketing object.\nSo if ProductA has ProvidedProductB, and ProvidedProductB itself has ProvidedProductC, then we end up with this DTO structure:\nProductA {\n    providedProducts: [ ProvidedProductB, ProvidedProductC ]\n} \n\nShouldn't it instead be like this?:\nProductA {\n    providedProducts: [ \n        ProvidedProductB { \n            providedProducts: [ ProvidedProductC ]\n        }\n    ]\n}\n\nAgain, sorry if this was already discussed in more detail and I missed it!", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r369036036", "createdAt": "2020-01-21T14:35:35Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -125,33 +135,73 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds = new HashSet<>();\n+\n+                accumulateStackDerivedPoolProvidedProducts(source, expectedProvidedProds);\n+\n+                if (source.getDerivedProduct() != null) {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addDerivedProvidedProduct(providedProductDTO);\n                     }\n                 }\n-            }\n-            else {\n-                dest.setProvidedProducts(Collections.emptySet());\n-            }\n-\n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n-            if (derivedProducts != null && !derivedProducts.isEmpty()) {\n-                for (Product derivedProd : derivedProducts) {\n-                    if (derivedProd != null) {\n-                        dest.addDerivedProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(derivedProd.getId(), derivedProd.getName()));\n+                else {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addProvidedProduct(providedProductDTO);\n                     }\n                 }\n             }\n+        }\n+\n+        return dest;\n+    }\n+\n+    /**\n+     *\n+     * @param pool\n+     * @return\n+     *   accumulated provided products collection from the same stack entitlements\n+     */\n+    private void accumulateStackDerivedPoolProvidedProducts(Pool pool,\n+        Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds) {\n+        List<Entitlement> stackedEntitlements = this.entitlementCurator\n+            .findByStackId(pool.getSourceStack().getSourceConsumer(), pool.getSourceStackId()).list();\n+        for (Entitlement nextStacked : stackedEntitlements) {\n+            Pool nextStackedPool = nextStacked.getPool();\n+            if (nextStackedPool.getDerivedProduct() == null) {\n+                addProvidedProducts(nextStackedPool.getProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n+            }\n             else {\n-                dest.setDerivedProvidedProducts(Collections.emptySet());\n+                addProvidedProducts(nextStackedPool.getDerivedProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n             }\n         }\n+    }\n \n-        return dest;\n+    private void addProvidedProducts(Collection<Product> providedProducts,\n+        Set<PoolDTO.ProvidedProductDTO> providedProductDTOs) {\n+        if (providedProducts == null || providedProducts.isEmpty()) {\n+            return;\n+        }\n+        for (Product product : providedProducts) {\n+            if (product != null) {\n+                providedProductDTOs.add(new PoolDTO.ProvidedProductDTO(product.getId(), product.getName()));\n+                addProvidedProducts(product.getProvidedProducts(), providedProductDTOs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNTE2OA=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA1NjQ0MQ==", "bodyText": "That should be correct, since this whole remapping is done to simulate the old flat structure we had before.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r369056441", "createdAt": "2020-01-21T15:08:37Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -125,33 +135,73 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds = new HashSet<>();\n+\n+                accumulateStackDerivedPoolProvidedProducts(source, expectedProvidedProds);\n+\n+                if (source.getDerivedProduct() != null) {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addDerivedProvidedProduct(providedProductDTO);\n                     }\n                 }\n-            }\n-            else {\n-                dest.setProvidedProducts(Collections.emptySet());\n-            }\n-\n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n-            if (derivedProducts != null && !derivedProducts.isEmpty()) {\n-                for (Product derivedProd : derivedProducts) {\n-                    if (derivedProd != null) {\n-                        dest.addDerivedProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(derivedProd.getId(), derivedProd.getName()));\n+                else {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addProvidedProduct(providedProductDTO);\n                     }\n                 }\n             }\n+        }\n+\n+        return dest;\n+    }\n+\n+    /**\n+     *\n+     * @param pool\n+     * @return\n+     *   accumulated provided products collection from the same stack entitlements\n+     */\n+    private void accumulateStackDerivedPoolProvidedProducts(Pool pool,\n+        Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds) {\n+        List<Entitlement> stackedEntitlements = this.entitlementCurator\n+            .findByStackId(pool.getSourceStack().getSourceConsumer(), pool.getSourceStackId()).list();\n+        for (Entitlement nextStacked : stackedEntitlements) {\n+            Pool nextStackedPool = nextStacked.getPool();\n+            if (nextStackedPool.getDerivedProduct() == null) {\n+                addProvidedProducts(nextStackedPool.getProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n+            }\n             else {\n-                dest.setDerivedProvidedProducts(Collections.emptySet());\n+                addProvidedProducts(nextStackedPool.getDerivedProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n             }\n         }\n+    }\n \n-        return dest;\n+    private void addProvidedProducts(Collection<Product> providedProducts,\n+        Set<PoolDTO.ProvidedProductDTO> providedProductDTOs) {\n+        if (providedProducts == null || providedProducts.isEmpty()) {\n+            return;\n+        }\n+        for (Product product : providedProducts) {\n+            if (product != null) {\n+                providedProductDTOs.add(new PoolDTO.ProvidedProductDTO(product.getId(), product.getName()));\n+                addProvidedProducts(product.getProvidedProducts(), providedProductDTOs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNTE2OA=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA2MDk1Mg==", "bodyText": "I see, disregard my comment then!", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r369060952", "createdAt": "2020-01-21T15:16:01Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/dto/manifest/v1/PoolTranslator.java", "diffHunk": "@@ -125,33 +135,73 @@ public PoolDTO populate(ModelTranslator modelTranslator, Pool source, PoolDTO de\n                 dest.setBranding(Collections.emptySet());\n             }\n \n-            Set<Product> products = source.getProvidedProducts();\n-            if (products != null && !products.isEmpty()) {\n-                for (Product prod : products) {\n-                    if (prod != null) {\n-                        dest.addProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(prod.getId(), prod.getName()));\n+            Collection<Product> products =\n+                source.getProduct() != null ? source.getProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> providedProductDTOs = new HashSet<>();\n+            addProvidedProducts(products, providedProductDTOs);\n+            dest.setProvidedProducts(providedProductDTOs);\n+\n+            Collection<Product> derivedProducts =\n+                source.getDerivedProduct() != null ? source.getDerivedProduct().getProvidedProducts() : null;\n+            Set<PoolDTO.ProvidedProductDTO> derivedProvidedProductDTOs = new HashSet<>();\n+            addProvidedProducts(derivedProducts, derivedProvidedProductDTOs);\n+            dest.setDerivedProvidedProducts(derivedProvidedProductDTOs);\n+\n+            // accumulate provided products for stacked entitlements\n+            if (PoolType.STACK_DERIVED.equals(source.getType())) {\n+                Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds = new HashSet<>();\n+\n+                accumulateStackDerivedPoolProvidedProducts(source, expectedProvidedProds);\n+\n+                if (source.getDerivedProduct() != null) {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addDerivedProvidedProduct(providedProductDTO);\n                     }\n                 }\n-            }\n-            else {\n-                dest.setProvidedProducts(Collections.emptySet());\n-            }\n-\n-            Set<Product> derivedProducts = source.getDerivedProvidedProducts();\n-            if (derivedProducts != null && !derivedProducts.isEmpty()) {\n-                for (Product derivedProd : derivedProducts) {\n-                    if (derivedProd != null) {\n-                        dest.addDerivedProvidedProduct(\n-                            new PoolDTO.ProvidedProductDTO(derivedProd.getId(), derivedProd.getName()));\n+                else {\n+                    for (PoolDTO.ProvidedProductDTO providedProductDTO : expectedProvidedProds) {\n+                        dest.addProvidedProduct(providedProductDTO);\n                     }\n                 }\n             }\n+        }\n+\n+        return dest;\n+    }\n+\n+    /**\n+     *\n+     * @param pool\n+     * @return\n+     *   accumulated provided products collection from the same stack entitlements\n+     */\n+    private void accumulateStackDerivedPoolProvidedProducts(Pool pool,\n+        Set<PoolDTO.ProvidedProductDTO> expectedProvidedProds) {\n+        List<Entitlement> stackedEntitlements = this.entitlementCurator\n+            .findByStackId(pool.getSourceStack().getSourceConsumer(), pool.getSourceStackId()).list();\n+        for (Entitlement nextStacked : stackedEntitlements) {\n+            Pool nextStackedPool = nextStacked.getPool();\n+            if (nextStackedPool.getDerivedProduct() == null) {\n+                addProvidedProducts(nextStackedPool.getProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n+            }\n             else {\n-                dest.setDerivedProvidedProducts(Collections.emptySet());\n+                addProvidedProducts(nextStackedPool.getDerivedProduct().getProvidedProducts(),\n+                    expectedProvidedProds);\n             }\n         }\n+    }\n \n-        return dest;\n+    private void addProvidedProducts(Collection<Product> providedProducts,\n+        Set<PoolDTO.ProvidedProductDTO> providedProductDTOs) {\n+        if (providedProducts == null || providedProducts.isEmpty()) {\n+            return;\n+        }\n+        for (Product product : providedProducts) {\n+            if (product != null) {\n+                providedProductDTOs.add(new PoolDTO.ProvidedProductDTO(product.getId(), product.getName()));\n+                addProvidedProducts(product.getProvidedProducts(), providedProductDTOs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNTE2OA=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI4MTg1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/candlepin/sync/EntitlementImporterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo1MDozNFrOFfAljQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjo0NToyNVrOFfdOzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1OTc4OQ==", "bodyText": "Missed formatting correction", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368059789", "createdAt": "2020-01-17T17:50:34Z", "author": {"login": "Ceiu"}, "path": "server/src/test/java/org/candlepin/sync/EntitlementImporterTest.java", "diffHunk": "@@ -101,7 +102,7 @@ public void init() {\n \n         this.translator = new StandardTranslator(mockConsumerTypeCurator,\n             mockEnvironmentCurator,\n-            ownerCurator);\n+            ownerCurator, entitlementCurator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUyOTEwMQ==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368529101", "createdAt": "2020-01-20T12:45:25Z", "author": {"login": "abhiskum"}, "path": "server/src/test/java/org/candlepin/sync/EntitlementImporterTest.java", "diffHunk": "@@ -101,7 +102,7 @@ public void init() {\n \n         this.translator = new StandardTranslator(mockConsumerTypeCurator,\n             mockEnvironmentCurator,\n-            ownerCurator);\n+            ownerCurator, entitlementCurator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1OTc4OQ=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDI4NTAzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo1MTo0OFrOFfAnbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjo0NToxNFrOFfdOcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MDI3MQ==", "bodyText": "Missed whitespace correction", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368060271", "createdAt": "2020-01-17T17:51:48Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "diffHunk": "@@ -993,6 +998,11 @@ private Pool convertToMasterPoolImpl(SubscriptionInfo sub, Owner owner, Map<Stri\n             }\n \n             pool.setDerivedProvidedProducts(products);\n+            //TODO: workaround to pass import spec tests. we will revisit and update this in import and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUyOTAxMQ==", "bodyText": "Fixed.", "url": "https://github.com/candlepin/candlepin/pull/2563#discussion_r368529011", "createdAt": "2020-01-20T12:45:14Z", "author": {"login": "abhiskum"}, "path": "server/src/main/java/org/candlepin/controller/CandlepinPoolManager.java", "diffHunk": "@@ -993,6 +998,11 @@ private Pool convertToMasterPoolImpl(SubscriptionInfo sub, Owner owner, Map<Stri\n             }\n \n             pool.setDerivedProvidedProducts(products);\n+            //TODO: workaround to pass import spec tests. we will revisit and update this in import and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MDI3MQ=="}, "originalCommit": {"oid": "2f6a855952c85fa4f40c6909e2bb7f461a7df346"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4237, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}