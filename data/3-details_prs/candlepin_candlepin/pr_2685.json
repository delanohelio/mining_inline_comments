{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NjY0NDQy", "number": 2685, "title": "[F] Product + Content Refresh Refactor (ENT-2207)", "bodyText": "Several changes from the PoC, and more to come. Feel free to give suggestions on the implementation of the node builders, processors (visitors), and mappers. Those are still somewhat malleable at this point and I'm open to suggestions on improvements.\nI think the biggest gotcha here is that the visitors are not stateless as one may expect. I don't think it's a huge issue, but it's abnormal from what I've seen in the past.", "createdAt": "2020-04-23T03:54:21Z", "url": "https://github.com/candlepin/candlepin/pull/2685", "merged": true, "mergeCommit": {"oid": "1986aff28c4c058f9c77df4d95e35d581d4d2ee6"}, "closed": true, "closedAt": "2020-05-12T14:43:33Z", "author": {"login": "Ceiu"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceTRTDAFqTQwNDg5NzUxMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgjimsABqjMzMjcyNzg4ODY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0ODk3NTEw", "url": "https://github.com/candlepin/candlepin/pull/2685#pullrequestreview-404897510", "createdAt": "2020-05-04T11:18:52Z", "commit": {"oid": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMToxODo1MlrOGP8CVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMjoxOTo0NVrOGQmu8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw==", "bodyText": "Not something for this PR/task, but we should add a card in the epic to add a documentation page on candlepinproject.org on how the algorithm works", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r419365463", "createdAt": "2020-05-04T11:18:52Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher;\n+\n+import org.candlepin.controller.refresher.builders.ContentNodeBuilder;\n+import org.candlepin.controller.refresher.builders.NodeFactory;\n+import org.candlepin.controller.refresher.builders.ProductNodeBuilder;\n+import org.candlepin.controller.refresher.mappers.ContentMapper;\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.mappers.PoolMapper;\n+import org.candlepin.controller.refresher.mappers.ProductMapper;\n+import org.candlepin.controller.refresher.visitors.ContentNodeVisitor;\n+import org.candlepin.controller.refresher.visitors.NodeProcessor;\n+import org.candlepin.controller.refresher.visitors.ProductNodeVisitor;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.ContentCurator;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerContentCurator;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.service.model.ProductContentInfo;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.service.model.SubscriptionInfo;\n+\n+import com.google.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+\n+/**\n+ * The RefreshWorker gathers upstream objects to refresh, and then performs the actual work to\n+ * update their local representations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3ODg0Mw==", "bodyText": "This mentions one of the two effects of this method (that it returns the node), but we should also mention the other, maybe even more important effect: that the node is added to the NodeMapper (which is the whole point of NodeFactory, to build up a NodeMapper data structure so that we can then process it)", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r419978843", "createdAt": "2020-05-05T09:30:55Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.AbstractHibernateObject;\n+import org.candlepin.model.Owner;\n+import org.candlepin.service.model.ServiceAdapterModel;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+\n+/**\n+ * The NodeFactory is responsible for orchestrating the complete creation and mapping of a node and\n+ * any children nodes it may create.\n+ * <p></p>\n+ * The tasks that make up the creation and mapping of a node may be performed by other objects, but\n+ * those objects must be provided before a node creation request is made.\n+ */\n+public class NodeFactory {\n+\n+    private NodeMapper mapper;\n+    private Map<Class, NodeBuilder> builders;\n+\n+    /**\n+     * Creates a new NodeFactory without any mappers or builders\n+     */\n+    public NodeFactory() {\n+        this.builders = new HashMap<>();\n+    }\n+\n+    /**\n+     * Adds a builder to this factory. The builder will be used to create nodes for the class\n+     * returned by the builder's <tt>getEntityClass</tt> method.\n+     *\n+     * @param builder\n+     *  the builder to add to this factory\n+     *\n+     * @throws IllegalArgumentException\n+     *  if the provided builder is null\n+     *\n+     * @return\n+     *  a reference to this node factory\n+     */\n+    public NodeFactory addBuilder(NodeBuilder builder) {\n+        if (builder == null) {\n+            throw new IllegalArgumentException(\"builder is null\");\n+        }\n+\n+        this.builders.put(builder.getEntityClass(), builder);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the mapper to use for mapping nodes created by this factory.\n+     *\n+     * @param mapper\n+     *  the mapper to use for mapping nodes\n+     *\n+     * @throws IllegalArgumentException\n+     *  if the provided mapper is null\n+     *\n+     * @return\n+     *  a reference to this node factory\n+     */\n+    public NodeFactory setNodeMapper(NodeMapper mapper) {\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"mapper is null\");\n+        }\n+\n+        this.mapper = mapper;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns an entity node for the given entity class and ID, creating it as necessary.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA==", "bodyText": "The ProductManager did flush when saving the core products, then again when saving the owner-products. Here it seems we're deferring flushing for when? Shouldn't we flush before CandlepinPoolManager starts processing the pools? (same question applies for ContentNodeVisitor.complete)", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420065010", "createdAt": "2020-05-05T12:19:45Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ProductNodeVisitor.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.visitors;\n+\n+import org.candlepin.controller.ProductManager;\n+import org.candlepin.controller.refresher.RefreshResult;\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.Branding;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerProduct;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.BrandingInfo;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.service.model.ProductContentInfo;\n+import org.candlepin.service.model.ProductInfo;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+\n+/**\n+ * A NodeVisitor implementation that supports product entity nodes\n+ */\n+public class ProductNodeVisitor implements NodeVisitor<Product, ProductInfo> {\n+    private final ProductCurator productCurator;\n+    private final OwnerProductCurator ownerProductCurator;\n+\n+    private Set<OwnerProduct> ownerProductEntities;\n+    private Map<Owner, Map<String, String>> ownerProductUuidMap;\n+\n+    /**\n+     * Creates a new ProductNodeVisitor that uses the provided curators for performing database\n+     * operations.\n+     *\n+     * @param productCurator\n+     *  the ProductCurator to use for product database operations\n+     *\n+     * @param ownerProductCurator\n+     *  the OwnerProductCurator to use for owner-product database operations\n+     *\n+     * @throws IllegalArgumentException\n+     *  if any of the provided curators are null\n+     */\n+    public ProductNodeVisitor(ProductCurator productCurator, OwnerProductCurator ownerProductCurator) {\n+        if (productCurator == null) {\n+            throw new IllegalArgumentException(\"productCurator is null\");\n+        }\n+\n+        if (ownerProductCurator == null) {\n+            throw new IllegalArgumentException(\"ownerProductCurator is null\");\n+        }\n+\n+        this.productCurator = productCurator;\n+        this.ownerProductCurator = ownerProductCurator;\n+\n+        this.ownerProductEntities = new HashSet<>();\n+        this.ownerProductUuidMap = new HashMap<>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Class<Product> getEntityClass() {\n+        return Product.class;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void processNode(NodeProcessor processor, NodeMapper mapper,\n+        EntityNode<Product, ProductInfo> node) {\n+\n+        boolean childrenUpdated = false;\n+        boolean nodeChanged = false;\n+\n+        if (node.visited()) {\n+            return;\n+        }\n+\n+        // Process children nodes first (depth-first), so we can update references and avoid\n+        // rework; also check if we need to make reference updates on this entity.\n+        for (EntityNode child : (Set<EntityNode>) node.getChildrenNodes()) {\n+            processor.processNode(child);\n+            childrenUpdated |= child.changed();\n+        }\n+\n+        Product existingEntity = node.getExistingEntity();\n+        ProductInfo importedEntity = node.getImportedEntity();\n+\n+        if (existingEntity != null) {\n+            if (importedEntity != null) {\n+                nodeChanged = ProductManager.isChangedBy(existingEntity, importedEntity);\n+            }\n+\n+            if (nodeChanged || childrenUpdated) {\n+                Product updatedEntity = this.createEntity(mapper, node);\n+                node.setUpdatedEntity(updatedEntity);\n+\n+                // Store the mapping to be updated later\n+                Map<String, String> productUuidMap = this.ownerProductUuidMap.get(node.getOwner());\n+                if (productUuidMap == null) {\n+                    productUuidMap = new HashMap<>();\n+                    this.ownerProductUuidMap.put(node.getOwner(), productUuidMap);\n+                }\n+                productUuidMap.put(existingEntity.getUuid(), updatedEntity.getUuid());\n+\n+                node.markChanged();\n+            }\n+        }\n+        else {\n+            // Node is new\n+            Product updatedEntity = this.createEntity(mapper, node);\n+            node.setUpdatedEntity(updatedEntity);\n+\n+            // Create a new owner-product mapping for this entity. This will get persisted\n+            // later during completion\n+            this.ownerProductEntities.add(new OwnerProduct(node.getOwner(), updatedEntity));\n+\n+            node.markChanged();\n+        }\n+\n+        node.markVisited();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void complete() {\n+        this.ownerProductCurator.saveAll(this.ownerProductEntities, false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDUwMzE0", "url": "https://github.com/candlepin/candlepin/pull/2685#pullrequestreview-406450314", "createdAt": "2020-05-06T09:37:27Z", "commit": {"oid": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTozNzoyN1rOGRLOyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMTowNToyM1rOGRN-xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY2Mjk4Ng==", "bodyText": "What kind of file is that? Where does it come/get generated from? It might be useful to add this info to the 'usage/help' output", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420662986", "createdAt": "2020-05-06T09:37:27Z", "author": {"login": "nikosmoum"}, "path": "server/bin/upstream_subscription_injector.rb", "diffHunk": "@@ -0,0 +1,214 @@\n+#!/usr/bin/env ruby\n+# Candlepin consumer generator\n+# Generates consumers and entitlements for a Candlepin database\n+\n+require 'optparse'\n+require 'set'\n+require 'thread'\n+\n+require_relative \"../client/ruby/candlepin_api\"\n+\n+\n+\n+class ThreadPool\n+  def initialize(size)\n+    @size = size\n+    @jobs = Queue.new\n+    @pool = Array.new(@size) do |i|\n+      Thread.new do\n+        Thread.current[:id] = i\n+        catch(:exit) do\n+          loop do\n+            job, args = @jobs.pop\n+            job.call(*args)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  def schedule(*args, &block)\n+    @jobs << [block, args]\n+  end\n+\n+  def shutdown\n+    @size.times do\n+      schedule { throw :exit }\n+    end\n+\n+    @pool.map(&:join)\n+  end\n+end\n+\n+@options = {}\n+\n+def log(level, message)\n+  puts \"#{level}: #{message}\" unless @options[:silent]\n+end\n+\n+def terminate(message)\n+  puts \"ERROR: #{message}\"\n+  exit\n+end\n+\n+def is_hosted(candlepin)\n+  return !candlepin.get_status()['standalone']\n+end\n+\n+def clear_upstream_data(candlepin)\n+  candlepin.delete('/hostedtest', {}, nil, true)\n+end\n+\n+def create_upstream_subscription(candlepin, subscription_id, owner_key, params = {})\n+  start_date = params.delete(:start_date) || Date.today\n+  end_date = params.delete(:end_date) || start_date + 365\n+\n+  # Define subscription with defaults & specified params\n+  subscription = {\n+    'startDate' => start_date,\n+    'endDate'   => end_date,\n+    'quantity'  => 1\n+  }\n+\n+  # Do not copy these with the rest of the merged keys\n+  filter = ['id', 'owner', 'ownerId']\n+\n+  params.each do |key, value|\n+    # Convert the key to snake case so we can support whatever is thrown at us\n+    key = key.to_s.gsub(/_(\\w)/){$1.upcase}\n+\n+    if !filter.include?(key)\n+      subscription[key] = value\n+    end\n+  end\n+\n+  # Forcefully set critical identifiers\n+  subscription['id'] = subscription_id\n+  subscription['owner'] = { :key => owner_key }\n+\n+  return candlepin.post('hostedtest/subscriptions', {}, subscription)\n+end\n+\n+\n+# Set up the options\n+optparse = OptionParser.new do |opts|\n+  file = File.basename(__FILE__)\n+  opts.banner = \"Usage: #{file} [options] org file\\n\\nOptions:\"\n+\n+  @options[:user] = 'admin'\n+  opts.on('--username [USER]', 'Username to connect as; defaults to \"admin\".') do |opt|\n+    @options[:user] = opt\n+  end\n+\n+  @options[:password] = 'admin'\n+  opts.on('--password [PASSWORD]', 'Password to authenticate the user as; defaults to \"admin\".') do |opt|\n+    @options[:password] = opt\n+  end\n+\n+  @options[:server] = 'localhost'\n+  opts.on('--server [SERVERNAME]', String, 'Server name FQDN; defaults to \"localhost\"') do |opt|\n+    @options[:server] = opt\n+  end\n+\n+  @options[:port] = 8443\n+  opts.on('--port [PORTNUM]', 'Port number for the Candlepin server; defaults to 8443') do |opt|\n+    @options[:port] = opt.to_i\n+  end\n+\n+  @options[:context] = 'candlepin'\n+  opts.on('--context [CONTEXT]', 'Context to use; defaults to \"candlepin\"') do |opt|\n+    @options[:context] = opt\n+  end\n+\n+  @options[:uuid] = nil\n+  opts.on('--uuid [UUID]', 'UUID to use; defaults to nil') do |opt|\n+    @options[:uuid] = opt\n+  end\n+\n+  @options[:ssl] = true\n+  opts.on('--nossl', 'Do not use SSL; defaults to false') do\n+    @options[:ssl] = false\n+  end\n+\n+  @options[:clean] = false\n+  opts.on('--clean', 'Cleans the upstream subscription data before injecting the new data') do\n+    @options[:clean] = true\n+  end\n+\n+  @options[:silent] = false\n+  opts.on( '--silent', 'Disable output while generating consumers' ) do\n+    @options[:silent] = true\n+  end\n+\n+  opts.on('-?', '--help', 'Displays command and option information') do\n+    puts opts\n+    exit\n+  end\n+end\n+\n+optparse.parse!\n+\n+####################################################################################################\n+\n+# At present we do not have any required parameters\n+\n+candlepin = Candlepin.new(\n+    @options[:user], @options[:password], nil, nil, @options[:server], @options[:port], nil,\n+    @options[:uuid], @options[:trused_user], @options[:context], @options[:ssl]\n+)\n+\n+# Check that the targeted CP is running in hosted mode\n+terminate(\"Targeted Candlepin deployment is not running in hosted mode\") if !is_hosted(candlepin)\n+\n+# Fetch known orgs...\n+owners = []\n+candlepin.list_owners().each do |owner|\n+  owners << owner['key']\n+end\n+\n+# Ensure an owner was specified and exists\n+terminate(\"An owner to receive the subscription data must be specified\") if ARGV.empty?\n+\n+owner_key = ARGV.shift\n+\n+if owners.empty? || !owners.include?(owner_key)\n+  log(\"INFO\", \"Owner \\\"#{owner_key}\\\" does not exist; creating it\")\n+  candlepin.create_owner(owner_key)\n+end\n+\n+# Ensure that the subscription data file was specified and exists\n+terminate(\"A subscription data file must be specified\") if ARGV.empty?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwMzc1MQ==", "bodyText": "All the commented out code in this class should be removed, since it looks like it has already been replaced by the mockRefresh call", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420703751", "createdAt": "2020-05-06T10:56:43Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/controller/PoolManagerTest.java", "diffHunk": "@@ -545,75 +556,98 @@ private void mockProducts(Owner owner, Product... products) {\n         this.mockProducts(owner, productMap);\n     }\n \n-    private void mockProductImport(Owner owner, final Map<String, Product> products) {\n-        when(mockProductManager.importProducts(eq(owner), any(Map.class), any(Map.class)))\n-            .thenAnswer(new Answer<ImportResult<Product>>() {\n-                @Override\n-                public ImportResult<Product> answer(InvocationOnMock invocation) throws Throwable {\n-                    Object[] args = invocation.getArguments();\n-                    Map<String, ProductData> productData = (Map<String, ProductData>) args[1];\n-                    ImportResult<Product> importResult = new ImportResult<>();\n-                    Map<String, Product> output = importResult.getCreatedEntities();\n-\n-                    if (productData != null) {\n-                        for (String pid : productData.keySet()) {\n-                            Product product = products.get(pid);\n+    private void mockRefresh(Owner owner, Collection<Product> products, Collection<Content> contents) {\n+        doAnswer(new Answer<RefreshResult>() {\n+            @Override\n+            public RefreshResult answer(InvocationOnMock iom) throws Throwable {\n+                RefreshResult output = new RefreshResult();\n \n-                            if (product != null) {\n-                                output.put(product.getId(), product);\n-                            }\n-                        }\n+                if (products != null) {\n+                    for (Product product : products) {\n+                        output.addCreatedProduct(product);\n                     }\n-\n-                    return importResult;\n                 }\n-            });\n-    }\n-\n-    private void mockProductImport(Owner owner, Product... products) {\n-        Map<String, Product> productMap = new HashMap<>();\n \n-        for (Product product : products) {\n-            productMap.put(product.getId(), product);\n-        }\n-\n-        this.mockProductImport(owner, productMap);\n-    }\n-\n-    private void mockContentImport(Owner owner, final Map<String, Content> contents) {\n-        when(mockContentManager.importContent(eq(owner), any(Map.class), any(Set.class)))\n-            .thenAnswer(new Answer<ImportResult<Content>>() {\n-                @Override\n-                public ImportResult<Content> answer(InvocationOnMock invocation) throws Throwable {\n-                    Object[] args = invocation.getArguments();\n-                    Map<String, ContentData> contentData = (Map<String, ContentData>) args[1];\n-                    ImportResult<Content> importResult = new ImportResult<>();\n-                    Map<String, Content> output = importResult.getCreatedEntities();\n-\n-                    if (contentData != null) {\n-                        for (String pid : contentData.keySet()) {\n-                            Content content = contents.get(pid);\n-\n-                            if (content != null) {\n-                                output.put(content.getId(), content);\n-                            }\n-                        }\n+                if (contents != null) {\n+                    for (Content content : contents) {\n+                        output.addCreatedContent(content);\n                     }\n-\n-                    return importResult;\n                 }\n-            });\n-    }\n \n-    private void mockContentImport(Owner owner, Content... contents) {\n-        Map<String, Content> contentMap = new HashMap<>();\n-\n-        for (Content content : contents) {\n-            contentMap.put(content.getId(), content);\n-        }\n-\n-        this.mockContentImport(owner, contentMap);\n-    }\n+                return output;\n+            }})\n+        .when(this.refreshWorker).execute(eq(owner));\n+    }\n+\n+    // private void mockProductImport(Owner owner, final Map<String, Product> products) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjA1Mw==", "bodyText": "irrelevant comment for the test", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420706053", "createdAt": "2020-05-06T11:01:19Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/controller/refresher/builders/ContentNodeBuilderTest.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.ContentMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ContentNodeBuilder class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ContentNodeBuilderTest {\n+\n+    private NodeFactory mockNodeFactory;\n+    private ContentMapper contentMapper;\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.mockNodeFactory = mock(NodeFactory.class);\n+        this.contentMapper = new ContentMapper();\n+    }\n+\n+    private ContentNodeBuilder buildNodeBuilder() {\n+        return new ContentNodeBuilder(this.contentMapper);\n+    }\n+\n+    private Set<Content> createCandidateEntitiesSet(String id) {\n+        Set<Content> candidates = new HashSet<>();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            Content candidate = TestUtil.createContent(id, TestUtil.randomString());\n+            candidates.add(candidate);\n+        }\n+\n+        return candidates;\n+    }\n+\n+    private void addDummyCandidateEntitiesToMap(Map<String, Set<Content>> candidateEntitiesMap) {\n+        for (int i = 0; i < 5; ++i) {\n+            String id = TestUtil.randomString();\n+            candidateEntitiesMap.put(id, this.createCandidateEntitiesSet(id));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ContentNodeBuilder builder = this.buildNodeBuilder();\n+\n+        Class output = builder.getEntityClass();\n+\n+        assertNotNull(output);\n+        assertEquals(Content.class, output);\n+    }\n+\n+\n+    /**\n+     * Builds a new entity node owned by the given owner, using the specified entity ID. The\n+     * provided node factory should be used when performing construction of children nodes to ensure\n+     * proper mapping and avoiding code duplication.\n+     *\n+     * @param factory\n+     *  the node factory to use for performing construction of children nodes\n+     *\n+     * @param owner\n+     *  the organization that will own the entity represented by the new entity node\n+     *\n+     * @param id\n+     *  the ID of the entity represented by the new entity node\n+     *\n+     * @throws IllegalStateException\n+     *  if an entity node representing the given ID cannot be created\n+     *\n+     * @return\n+     *  a new EntityNode instance representing the entity with the provided ID\n+     */\n+    // EntityNode<E, I> buildNode(NodeFactory factory, Owner owner, String id);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwODAzNw==", "bodyText": "out of place comment", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420708037", "createdAt": "2020-05-06T11:05:23Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/controller/refresher/builders/ProductNodeBuilderTest.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.ProductMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.AbstractHibernateObject;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.Product;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.service.model.ServiceAdapterModel;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ProductNodeBuilder class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ProductNodeBuilderTest {\n+\n+    private NodeFactory mockNodeFactory;\n+    private ProductMapper productMapper;\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.mockNodeFactory = mock(NodeFactory.class);\n+        this.productMapper = new ProductMapper();\n+    }\n+\n+    private ProductNodeBuilder buildNodeBuilder() {\n+        return new ProductNodeBuilder(this.productMapper);\n+    }\n+\n+    private Set<Product> createCandidateEntitiesSet(String id) {\n+        Set<Product> candidates = new HashSet<>();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            Product candidate = TestUtil.createProduct(id, TestUtil.randomString());\n+            candidates.add(candidate);\n+        }\n+\n+        return candidates;\n+    }\n+\n+    private void addDummyCandidateEntitiesToMap(Map<String, Set<Product>> candidateEntitiesMap) {\n+        for (int i = 0; i < 5; ++i) {\n+            String id = TestUtil.randomString();\n+            candidateEntitiesMap.put(id, this.createCandidateEntitiesSet(id));\n+        }\n+    }\n+\n+    private EntityNode mockEntityNode(Owner owner, Class cls, String id,\n+        AbstractHibernateObject existingEntity, ServiceAdapterModel importedEntity) {\n+\n+        EntityNode node = mock(EntityNode.class);\n+\n+        doReturn(owner).when(node).getOwner();\n+        doReturn(cls).when(node).getEntityClass();\n+        doReturn(id).when(node).getEntityId();\n+\n+        doReturn(existingEntity).when(node).getExistingEntity();\n+        doReturn(importedEntity).when(node).getImportedEntity();\n+\n+        doReturn(node).when(this.mockNodeFactory).buildNode(eq(owner), eq(cls), eq(id));\n+\n+        return node;\n+    }\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ProductNodeBuilder builder = this.buildNodeBuilder();\n+\n+        Class output = builder.getEntityClass();\n+\n+        assertNotNull(output);\n+        assertEquals(Product.class, output);\n+    }\n+\n+\n+    /**\n+     * Builds a new entity node owned by the given owner, using the specified entity ID. The\n+     * provided node factory should be used when performing construction of children nodes to ensure\n+     * proper mapping and avoiding code duplication.\n+     *\n+     * @param factory\n+     *  the node factory to use for performing construction of children nodes\n+     *\n+     * @param owner\n+     *  the organization that will own the entity represented by the new entity node\n+     *\n+     * @param id\n+     *  the ID of the entity represented by the new entity node\n+     *\n+     * @throws IllegalStateException\n+     *  if an entity node representing the given ID cannot be created\n+     *\n+     * @return\n+     *  a new EntityNode instance representing the entity with the provided ID\n+     */\n+    // EntityNode<E, I> buildNode(NodeFactory factory, Owner owner, String id);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MzE3MDE5", "url": "https://github.com/candlepin/candlepin/pull/2685#pullrequestreview-407317019", "createdAt": "2020-05-07T09:49:02Z", "commit": {"oid": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0OTowMlrOGR3ALQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDowNTowN1rOGR3lSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDE0MQ==", "bodyText": "\ud83d\udc4d Recursing on the NodeProcessor directly is much clearer than going through the visitors", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421380141", "createdAt": "2020-05-07T09:49:02Z", "author": {"login": "nikosmoum"}, "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/NodeProcessor.java", "diffHunk": "@@ -110,38 +111,26 @@ public void processNodes() {\n         }\n     }\n \n-    /**\n-     * Processes the specified node. If a node mapper has not yet been set, or a visitor has not\n-     * been provided for the node, or one or more of its children, this method throws an exception.\n-     * If the provided node is null, this method will silently return.\n-     *\n-     * @param node\n-     *  the entity node to process\n-     *\n-     * @throws IllegalStateException\n-     *  if a node mapper has not been set, or a visitor has not been provided for the class of\n-     *  node provided, or one or more of its children.\n-     */\n-    public void processNode(EntityNode node) {\n-        if (this.mapper == null) {\n-            throw new IllegalStateException(\"node mapper has not been set\");\n-        }\n-\n-        this.processNodeImpl(node);\n-    }\n-\n     /**\n      * Internal implementation that avoids repeating unnecessary input and state validation\n      */\n     private void processNodeImpl(EntityNode node) {\n         if (node != null) {\n-            NodeVisitor visitor = this.visitors.get(node.getEntityClass());\n+            // Process children nodes first (depth-first), so we can update references and avoid\n+            // rework\n+            for (EntityNode childNode : (Collection<EntityNode>) node.getChildrenNodes()) {\n+                this.processNodeImpl(childNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4Njk2MQ==", "bodyText": "It doesn't look like this one line is needed (the validator isn't used thereafter)", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421386961", "createdAt": "2020-05-07T10:00:26Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitorTest.java", "diffHunk": "@@ -332,8 +277,10 @@ public void testProcessNodeForUnchangedEntity(String key, Object base, Object up\n         Owner owner = TestUtil.createOwner();\n         String id = TestUtil.randomString(\"test_id\");\n \n-        Content existing = this.createPopulatedEntity(id, key, base);\n-        ContentInfo imported = this.createPopulatedEntity(id, key, base);\n+        Content existing = this.createPopulatedExistingEntity(id, key, base);\n+        ContentInfo imported = this.createPopulatedImportedEntity(id, key, base);\n+\n+        MergeValidator<ContentInfo> validator = this.validators.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTAxMg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421389012", "createdAt": "2020-05-07T10:04:03Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitorTest.java", "diffHunk": "@@ -60,79 +55,9 @@\n @MockitoSettings(strictness = Strictness.LENIENT)\n public class ContentNodeVisitorTest {\n \n-    @FunctionalInterface\n-    private static interface Mutator {\n-\n-        void mutate(Content content, Object value);\n-\n-    }\n-\n-    @FunctionalInterface\n-    private static interface Validator {\n-        default void validate(ContentInfo existing, ContentInfo imported, ContentInfo merged) {\n-            if (this.access(merged) != null) {\n-                if (imported != null && this.access(imported) != null) {\n-                    assertEquals(this.access(imported), this.access(merged));\n-                }\n-                else {\n-                    assertNotNull(existing);\n-                    assertEquals(this.access(existing), this.access(merged));\n-                }\n-            }\n-            else {\n-                if (imported != null) {\n-                    assertNull(this.access(imported));\n-                }\n-\n-                if (existing != null) {\n-                    assertNull(this.access(existing));\n-                }\n-            }\n-        }\n-\n-        Object access(ContentInfo content);\n-    }\n-\n-    @FunctionalInterface\n-    private static interface CollectionValidator extends Validator {\n-        @Override\n-        default void validate(ContentInfo existing, ContentInfo imported, ContentInfo merged) {\n-            if (this.access(merged) != null) {\n-                Collection<Object> actual = this.access(merged);\n-                Collection<Object> expected = null;\n-\n-                if (imported != null && this.access(imported) != null) {\n-                    expected = this.access(imported);\n-                }\n-                else {\n-                    assertNotNull(existing);\n-                    expected = this.access(existing);\n-                }\n-\n-                assertNotNull(expected);\n-                assertEquals(expected.size(), actual.size());\n-\n-                for (Object item : expected) {\n-                    assertThat(actual, hasItem(item));\n-                }\n-            }\n-            else {\n-                if (imported != null) {\n-                    assertNull(this.access(imported));\n-                }\n-\n-                if (existing != null) {\n-                    assertNull(this.access(existing));\n-                }\n-            }\n-        }\n-\n-        @Override\n-        Collection access(ContentInfo content);\n-    }\n-\n-    private Map<String, Mutator> mutators;\n-    private Map<String, Validator> validators;\n+    private Map<String, Mutator<Content>> contentMutators;\n+    private Map<String, Mutator<ContentInfo>> cinfoMutators;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTY0MA==", "bodyText": "Same here, validator not used after retrieving here", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421389640", "createdAt": "2020-05-07T10:05:07Z", "author": {"login": "nikosmoum"}, "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ProductNodeVisitorTest.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.visitors;\n+\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.controller.refresher.nodes.ProductNode;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerProduct;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.AdditionalAnswers.returnsFirstArg;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ProductNodeVisitor class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ProductNodeVisitorTest {\n+\n+    private Map<String, Mutator<Product>> productMutators;\n+    private Map<String, Mutator<ProductInfo>> pinfoMutators;\n+    private Map<String, MergeValidator<ProductInfo>> validators;\n+\n+    private ProductCurator mockProductCurator;\n+    private OwnerProductCurator mockOwnerProductCurator;\n+    private NodeProcessor mockNodeProcessor;\n+    private NodeMapper mockNodeMapper;\n+\n+    @BeforeEach\n+    public void init() {\n+        this.productMutators = new HashMap<>();\n+        this.productMutators.put(\"name\", (c, v) -> c.setName((String) v));\n+        this.productMutators.put(\"multiplier\", (c, v) -> c.setMultiplier((Long) v));\n+        this.productMutators.put(\"dependent_product_ids\", (c, v) -> c.setDependentProductIds((Collection) v));\n+        this.productMutators.put(\"attributes\", (c, v) -> c.setAttributes((Map) v));\n+        this.productMutators.put(\"product_content\", (c, v) -> c.setProductContent((Collection) v));\n+        this.productMutators.put(\"branding\", (c, v) -> c.setBranding((Collection) v));\n+        this.productMutators.put(\"provided_products\", (c, v) -> c.setProvidedProducts((Collection) v));\n+\n+        this.pinfoMutators = new HashMap<>();\n+        this.pinfoMutators.put(\"name\", (c, v) -> doReturn(v).when(c).getName());\n+        this.pinfoMutators.put(\"multiplier\", (c, v) -> doReturn(v).when(c).getMultiplier());\n+        this.pinfoMutators.put(\"dependent_product_ids\",\n+            (c, v) -> doReturn(v).when(c).getDependentProductIds());\n+        this.pinfoMutators.put(\"attributes\", (c, v) -> doReturn(v).when(c).getAttributes());\n+        this.pinfoMutators.put(\"product_content\", (c, v) -> doReturn(v).when(c).getProductContent());\n+        this.pinfoMutators.put(\"branding\", (c, v) -> doReturn(v).when(c).getBranding());\n+        this.pinfoMutators.put(\"provided_products\", (c, v) -> doReturn(v).when(c).getProvidedProducts());\n+\n+        this.validators = new HashMap<>();\n+        this.validators.put(\"name\", c -> c.getName());\n+        this.validators.put(\"multiplier\", c -> c.getMultiplier());\n+        this.validators.put(\"dependent_product_ids\", (CollectionMergeValidator<ProductInfo>)\n+            c -> c.getDependentProductIds());\n+        this.validators.put(\"attributes\", (MapMergeValidator<ProductInfo>) c -> c.getAttributes());\n+\n+\n+        this.mockProductCurator = mock(ProductCurator.class);\n+        this.mockOwnerProductCurator = mock(OwnerProductCurator.class);\n+        this.mockNodeProcessor = mock(NodeProcessor.class);\n+        this.mockNodeMapper = mock(NodeMapper.class);\n+\n+        doAnswer(returnsFirstArg())\n+            .when(this.mockProductCurator)\n+            .saveOrUpdate(Mockito.any(Product.class));\n+\n+        doAnswer(returnsFirstArg())\n+            .when(this.mockOwnerProductCurator)\n+            .saveOrUpdate(Mockito.any(OwnerProduct.class));\n+    }\n+\n+    public static List<Arguments> productDataProvider() {\n+        Map<String, String> baseAttribs = new HashMap<>();\n+        baseAttribs.put(\"A\", \"1\");\n+        baseAttribs.put(\"B\", \"2\");\n+        baseAttribs.put(\"C\", \"3\");\n+\n+        Map<String, String> updatedAttribs = new HashMap<>();\n+        baseAttribs.put(\"C\", \"3\");\n+        baseAttribs.put(\"D\", \"4\");\n+        baseAttribs.put(\"E\", \"5\");\n+\n+        return Arrays.asList(\n+            Arguments.of(\"name\", \"base_name\", \"updated_name\"),\n+            Arguments.of(\"multiplier\", 12345L, 67890L),\n+            Arguments.of(\"dependent_product_ids\", Arrays.asList(\"1\", \"2\", \"3\"), Arrays.asList(\"A\", \"B\", \"C\")),\n+            Arguments.of(\"attributes\", baseAttribs, updatedAttribs));\n+    }\n+\n+    private ProductNodeVisitor buildProductNodeVisitor() {\n+        return new ProductNodeVisitor(this.mockProductCurator, this.mockOwnerProductCurator);\n+    }\n+\n+    private Product createPopulatedExistingEntity(String id, String key, Object value) {\n+        Product entity = new Product();\n+        entity.setId(id);\n+\n+        Mutator mutator = this.productMutators.get(key);\n+        if (mutator == null) {\n+            throw new IllegalStateException(\"No mutator for key: \" + key);\n+        }\n+\n+        mutator.mutate(entity, value);\n+\n+        return entity;\n+    }\n+\n+    private ProductInfo createPopulatedImportedEntity(String id, String key, Object value) {\n+        ProductInfo entity = mock(ProductInfo.class);\n+        doReturn(id).when(entity).getId();\n+\n+        // Impl note:\n+        // This is necessary, since the default behavior for mocked methods that return primitive\n+        // containers is to return a wrapped default primitive value, *NOT* null as one might\n+        // expect.\n+        doReturn(null).when(entity).getMultiplier();\n+\n+        Mutator mutator = this.pinfoMutators.get(key);\n+        if (mutator == null) {\n+            throw new IllegalStateException(\"No mutator for key: \" + key);\n+        }\n+\n+        mutator.mutate(entity, value);\n+\n+        return entity;\n+    }\n+\n+    private void validateMergedEntity(Product existing, ProductInfo imported, Product merged) {\n+        // Assert that we actually have a merged entity\n+        assertNotNull(merged);\n+\n+        // Ensure the ID is set properly\n+        assertNotNull(merged.getId());\n+\n+        if (existing != null) {\n+            assertNotNull(existing.getId());\n+            assertEquals(existing.getId(), merged.getId());\n+        }\n+\n+        if (imported != null) {\n+            assertNotNull(imported.getId());\n+            assertEquals(imported.getId(), merged.getId());\n+        }\n+\n+        // Check that the product is locked properly\n+        if (existing != null) {\n+            assertEquals(existing.isLocked(), merged.isLocked());\n+        }\n+        else {\n+            assertNotNull(imported);\n+            assertTrue(merged.isLocked());\n+        }\n+\n+        // Check other attributes\n+        for (MergeValidator validator : this.validators.values()) {\n+            validator.validate(existing, imported, merged);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        assertEquals(Product.class, visitor.getEntityClass());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForSkippedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+\n+        EntityNode<Product, ProductInfo> node = new ProductNode(owner, id)\n+            .setExistingEntity(existing);\n+\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        // Ensure initial node state\n+        assertFalse(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+\n+        // Visit/process the node\n+        visitor.processNode(this.mockNodeProcessor, this.mockNodeMapper, node);\n+        visitor.complete();\n+\n+        // Validate \"processed\" state\n+        assertTrue(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForUnmodifiedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+        ProductInfo imported = this.createPopulatedImportedEntity(id, key, null);\n+\n+        EntityNode<Product, ProductInfo> node = new ProductNode(owner, id)\n+            .setExistingEntity(existing)\n+            .setImportedEntity(imported);\n+\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        // Ensure initial node state\n+        assertFalse(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+\n+        // Visit/process the node\n+        visitor.processNode(this.mockNodeProcessor, this.mockNodeMapper, node);\n+        visitor.complete();\n+\n+        // Validate \"processed\" state\n+        assertTrue(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForUnchangedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+        ProductInfo imported = this.createPopulatedImportedEntity(id, key, base);\n+\n+        MergeValidator<ProductInfo> validator = this.validators.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf"}, "originalPosition": 273}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc113ad419548857e2f8f029fe5a7e8566ade49a", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/bc113ad419548857e2f8f029fe5a7e8566ade49a", "committedDate": "2020-05-11T19:51:18Z", "message": "(SQUASH ME) Added tests for the RefreshResult and RefreshWorker classes"}, "afterCommit": {"oid": "3006213a170f9e614fb0554698a88f5354ec2750", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/3006213a170f9e614fb0554698a88f5354ec2750", "committedDate": "2020-05-11T20:52:10Z", "message": "(SQUASH ME) Added tests for the RefreshResult and RefreshWorker classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fdb8357fbbbc3a83de7b57d691808b9cc682078", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/0fdb8357fbbbc3a83de7b57d691808b9cc682078", "committedDate": "2020-05-11T20:56:28Z", "message": "Added the RefreshWorker framework and refactored the refresh process\n\n- Added the RefreshWorker and the org.candlepin.controller.refresher.*\n  package containing the new framework for performing refresh\n- Updated the CandlepinPoolManager to use the new refresh framework\n- Added the upstream_subscription_injector tool for setting up a\n  Candlepin instance for repeatable upstream testing\n- Fixed the test data setup in the tests for OwnerProductResource\n- Fixed a NPE bug in Subscription when calling isStacked without\n  a product\n- Added additional validation to the hosted-test subscription\n  adapter to ensure subscriptions cannot be created without a\n  product\n- Improved several API methods in the hosted test spec resources\n- Fixed refresh spec tests broken by changes to the hosted test APIs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5OTQyNjQy", "url": "https://github.com/candlepin/candlepin/pull/2685#pullrequestreview-409942642", "createdAt": "2020-05-12T11:21:16Z", "commit": {"oid": "3006213a170f9e614fb0554698a88f5354ec2750"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3006213a170f9e614fb0554698a88f5354ec2750", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/3006213a170f9e614fb0554698a88f5354ec2750", "committedDate": "2020-05-11T20:52:10Z", "message": "(SQUASH ME) Added tests for the RefreshResult and RefreshWorker classes"}, "afterCommit": {"oid": "0fdb8357fbbbc3a83de7b57d691808b9cc682078", "author": {"user": {"login": "Ceiu", "name": "Chris \"Ceiu\" Rog"}}, "url": "https://github.com/candlepin/candlepin/commit/0fdb8357fbbbc3a83de7b57d691808b9cc682078", "committedDate": "2020-05-11T20:56:28Z", "message": "Added the RefreshWorker framework and refactored the refresh process\n\n- Added the RefreshWorker and the org.candlepin.controller.refresher.*\n  package containing the new framework for performing refresh\n- Updated the CandlepinPoolManager to use the new refresh framework\n- Added the upstream_subscription_injector tool for setting up a\n  Candlepin instance for repeatable upstream testing\n- Fixed the test data setup in the tests for OwnerProductResource\n- Fixed a NPE bug in Subscription when calling isStacked without\n  a product\n- Added additional validation to the hosted-test subscription\n  adapter to ensure subscriptions cannot be created without a\n  product\n- Improved several API methods in the hosted test spec resources\n- Fixed refresh spec tests broken by changes to the hosted test APIs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2379, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}