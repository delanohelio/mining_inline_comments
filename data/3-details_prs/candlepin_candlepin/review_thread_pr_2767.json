{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MDY2MTkx", "number": 2767, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyMTo1MlrOETOocA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyODo1MVrOETOx-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTk4MTI4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/candlepin/async/JobMessageDispatcherTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyMTo1MlrOG415GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMzoxODoyOVrOG43_QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1NjQwOA==", "bodyText": "Redundant try-catch", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462256408", "createdAt": "2020-07-29T12:21:52Z", "author": {"login": "Januson"}, "path": "server/src/test/java/org/candlepin/async/JobMessageDispatcherTest.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.async;\n+\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.anyBoolean;\n+import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import org.candlepin.common.config.Configuration;\n+import org.candlepin.config.CandlepinCommonTestConfig;\n+import org.candlepin.messaging.CPMMessage;\n+import org.candlepin.messaging.CPMProducer;\n+import org.candlepin.messaging.CPMProducerConfig;\n+import org.candlepin.messaging.CPMSession;\n+import org.candlepin.messaging.CPMSessionConfig;\n+import org.candlepin.messaging.CPMSessionFactory;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+\n+\n+/**\n+ * Test suite for the JobMessageDispatcher class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class JobMessageDispatcherTest {\n+\n+    /**\n+     * Functional interface that lets us pass exceptions back through to the test\n+     */\n+    @FunctionalInterface\n+    private interface NoisyRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    /**\n+     * Utility class to allow async scheduling of tasks in a targetable thread\n+     */\n+    private static class TaskExecutor extends Thread {\n+        private boolean shutdown;\n+        private NoisyRunnable runnable;\n+\n+        public TaskExecutor() {\n+            this.shutdown = false;\n+            this.runnable = null;\n+\n+            this.setDaemon(true);\n+            this.start();\n+\n+            try {\n+                synchronized (this) {\n+                    this.wait(1000);\n+                }\n+            }\n+            catch (InterruptedException e) {\n+                // Hrmm...\n+            }\n+        }\n+\n+        public synchronized void run() {\n+            while (!this.shutdown) {\n+                try {\n+                    this.notifyAll();\n+                    this.wait();\n+\n+                    if (this.runnable != null) {\n+                        this.runnable.run();\n+                    }\n+                }\n+                catch (InterruptedException e) {\n+                    // Wake up\n+                }\n+                catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        public synchronized TaskExecutor execute(NoisyRunnable runnable) throws InterruptedException {\n+            this.runnable = runnable;\n+\n+            this.notifyAll();\n+            this.wait();\n+\n+            return this;\n+        }\n+\n+        public synchronized TaskExecutor shutdown() throws InterruptedException {\n+            this.shutdown = true;\n+            this.runnable = null;\n+\n+            this.notifyAll();\n+            this.join();\n+\n+            return this;\n+        }\n+    }\n+\n+\n+    private Configuration config;\n+    private ObjectMapper mapper;\n+\n+    private CPMSessionFactory sessionFactory;\n+    private CPMSessionConfig sessionConfig;\n+    private CPMProducerConfig producerConfig;\n+\n+\n+    @BeforeEach\n+    public void init() {\n+        this.config = new CandlepinCommonTestConfig();\n+        this.mapper = new ObjectMapper();\n+\n+        this.sessionFactory = mock(CPMSessionFactory.class);\n+        this.sessionConfig = spy(new CPMSessionConfig());\n+        this.producerConfig = spy(new CPMProducerConfig());\n+\n+        doReturn(this.sessionConfig).when(this.sessionFactory).createSessionConfig();\n+    }\n+\n+    private JobMessageDispatcher buildJobMessageDispatcher() {\n+        return new JobMessageDispatcher(this.config, this.sessionFactory, this.mapper);\n+    }\n+\n+    private CPMSession mockCPMSession() throws Exception {\n+        CPMSession session = mock(CPMSession.class);\n+        CPMMessage message = this.mockCPMMessage();\n+\n+        doReturn(this.producerConfig).when(session).createProducerConfig();\n+        doReturn(false).when(session).isClosed();\n+        doReturn(message).when(session).createMessage();\n+\n+        return session;\n+    }\n+\n+    private CPMMessage mockCPMMessage() throws Exception {\n+        CPMMessage message = mock(CPMMessage.class);\n+\n+        doReturn(message).when(message).setDurable(anyBoolean());\n+        doReturn(message).when(message).setBody(anyString());\n+        doReturn(message).when(message).setProperty(anyString(), anyString());\n+\n+        return message;\n+    }\n+\n+    @Test\n+    public void testThreadsReuseSessions() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session = this.mockCPMSession();\n+        CPMProducer producer = mock(CPMProducer.class);\n+\n+        doReturn(session).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+        doReturn(producer).when(session).createProducer(any(CPMProducerConfig.class));\n+\n+        dispatcher.postJobMessage(new JobMessage(\"job_id-1\", \"job_key-1\"));\n+        dispatcher.commit();\n+\n+        dispatcher.postJobMessage(new JobMessage(\"job_id-2\", \"job_key-2\"));\n+        dispatcher.rollback();\n+\n+        verify(this.sessionFactory, times(1)).createSession(any(CPMSessionConfig.class));\n+        verify(session, times(1)).createProducer(any(CPMProducerConfig.class));\n+\n+        verify(producer, times(2)).send(anyString(), any(CPMMessage.class));\n+        verify(session, times(1)).commit();\n+        verify(session, times(1)).rollback();\n+    }\n+\n+    @Test\n+    public void testThreadsDontShareSessions() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session1 = this.mockCPMSession();\n+        CPMSession session2 = this.mockCPMSession();\n+        CPMProducer producer1 = mock(CPMProducer.class);\n+        CPMProducer producer2 = mock(CPMProducer.class);\n+\n+        doReturn(producer1).when(session1).createProducer(any(CPMProducerConfig.class));\n+        doReturn(producer2).when(session2).createProducer(any(CPMProducerConfig.class));\n+\n+        doReturn(session1, session2).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+\n+        TaskExecutor executor1 = new TaskExecutor();\n+        TaskExecutor executor2 = new TaskExecutor();\n+\n+        executor1.execute(() -> dispatcher.postJobMessage(new JobMessage(\"job_id-1\", \"job_key-1\")));\n+        executor2.execute(() -> dispatcher.postJobMessage(new JobMessage(\"job_id-2\", \"job_key-2\")));\n+        executor1.execute(() -> dispatcher.commit());\n+        executor2.execute(() -> dispatcher.commit());\n+\n+        executor1.shutdown();\n+        executor2.shutdown();\n+\n+        verify(this.sessionFactory, times(2)).createSession(any(CPMSessionConfig.class));\n+\n+        verify(session1, times(1)).createProducer(any(CPMProducerConfig.class));\n+        verify(session2, times(1)).createProducer(any(CPMProducerConfig.class));\n+        verify(producer1, times(1)).send(anyString(), any(CPMMessage.class));\n+        verify(producer2, times(1)).send(anyString(), any(CPMMessage.class));\n+        verify(session1, times(1)).commit();\n+        verify(session2, times(1)).commit();\n+    }\n+\n+    @Test\n+    public void testAbandonedSessionsAreClosed() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session = this.mockCPMSession();\n+        CPMProducer producer = mock(CPMProducer.class);\n+\n+        doReturn(session).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+        doReturn(producer).when(session).createProducer(any(CPMProducerConfig.class));\n+\n+        TaskExecutor executor = new TaskExecutor();\n+\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ca72efa1f9f04eeede24b917cf14446efde481"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MDc1Mg==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462290752", "createdAt": "2020-07-29T13:18:29Z", "author": {"login": "Ceiu"}, "path": "server/src/test/java/org/candlepin/async/JobMessageDispatcherTest.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.async;\n+\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.anyBoolean;\n+import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import org.candlepin.common.config.Configuration;\n+import org.candlepin.config.CandlepinCommonTestConfig;\n+import org.candlepin.messaging.CPMMessage;\n+import org.candlepin.messaging.CPMProducer;\n+import org.candlepin.messaging.CPMProducerConfig;\n+import org.candlepin.messaging.CPMSession;\n+import org.candlepin.messaging.CPMSessionConfig;\n+import org.candlepin.messaging.CPMSessionFactory;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+\n+\n+/**\n+ * Test suite for the JobMessageDispatcher class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class JobMessageDispatcherTest {\n+\n+    /**\n+     * Functional interface that lets us pass exceptions back through to the test\n+     */\n+    @FunctionalInterface\n+    private interface NoisyRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    /**\n+     * Utility class to allow async scheduling of tasks in a targetable thread\n+     */\n+    private static class TaskExecutor extends Thread {\n+        private boolean shutdown;\n+        private NoisyRunnable runnable;\n+\n+        public TaskExecutor() {\n+            this.shutdown = false;\n+            this.runnable = null;\n+\n+            this.setDaemon(true);\n+            this.start();\n+\n+            try {\n+                synchronized (this) {\n+                    this.wait(1000);\n+                }\n+            }\n+            catch (InterruptedException e) {\n+                // Hrmm...\n+            }\n+        }\n+\n+        public synchronized void run() {\n+            while (!this.shutdown) {\n+                try {\n+                    this.notifyAll();\n+                    this.wait();\n+\n+                    if (this.runnable != null) {\n+                        this.runnable.run();\n+                    }\n+                }\n+                catch (InterruptedException e) {\n+                    // Wake up\n+                }\n+                catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        public synchronized TaskExecutor execute(NoisyRunnable runnable) throws InterruptedException {\n+            this.runnable = runnable;\n+\n+            this.notifyAll();\n+            this.wait();\n+\n+            return this;\n+        }\n+\n+        public synchronized TaskExecutor shutdown() throws InterruptedException {\n+            this.shutdown = true;\n+            this.runnable = null;\n+\n+            this.notifyAll();\n+            this.join();\n+\n+            return this;\n+        }\n+    }\n+\n+\n+    private Configuration config;\n+    private ObjectMapper mapper;\n+\n+    private CPMSessionFactory sessionFactory;\n+    private CPMSessionConfig sessionConfig;\n+    private CPMProducerConfig producerConfig;\n+\n+\n+    @BeforeEach\n+    public void init() {\n+        this.config = new CandlepinCommonTestConfig();\n+        this.mapper = new ObjectMapper();\n+\n+        this.sessionFactory = mock(CPMSessionFactory.class);\n+        this.sessionConfig = spy(new CPMSessionConfig());\n+        this.producerConfig = spy(new CPMProducerConfig());\n+\n+        doReturn(this.sessionConfig).when(this.sessionFactory).createSessionConfig();\n+    }\n+\n+    private JobMessageDispatcher buildJobMessageDispatcher() {\n+        return new JobMessageDispatcher(this.config, this.sessionFactory, this.mapper);\n+    }\n+\n+    private CPMSession mockCPMSession() throws Exception {\n+        CPMSession session = mock(CPMSession.class);\n+        CPMMessage message = this.mockCPMMessage();\n+\n+        doReturn(this.producerConfig).when(session).createProducerConfig();\n+        doReturn(false).when(session).isClosed();\n+        doReturn(message).when(session).createMessage();\n+\n+        return session;\n+    }\n+\n+    private CPMMessage mockCPMMessage() throws Exception {\n+        CPMMessage message = mock(CPMMessage.class);\n+\n+        doReturn(message).when(message).setDurable(anyBoolean());\n+        doReturn(message).when(message).setBody(anyString());\n+        doReturn(message).when(message).setProperty(anyString(), anyString());\n+\n+        return message;\n+    }\n+\n+    @Test\n+    public void testThreadsReuseSessions() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session = this.mockCPMSession();\n+        CPMProducer producer = mock(CPMProducer.class);\n+\n+        doReturn(session).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+        doReturn(producer).when(session).createProducer(any(CPMProducerConfig.class));\n+\n+        dispatcher.postJobMessage(new JobMessage(\"job_id-1\", \"job_key-1\"));\n+        dispatcher.commit();\n+\n+        dispatcher.postJobMessage(new JobMessage(\"job_id-2\", \"job_key-2\"));\n+        dispatcher.rollback();\n+\n+        verify(this.sessionFactory, times(1)).createSession(any(CPMSessionConfig.class));\n+        verify(session, times(1)).createProducer(any(CPMProducerConfig.class));\n+\n+        verify(producer, times(2)).send(anyString(), any(CPMMessage.class));\n+        verify(session, times(1)).commit();\n+        verify(session, times(1)).rollback();\n+    }\n+\n+    @Test\n+    public void testThreadsDontShareSessions() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session1 = this.mockCPMSession();\n+        CPMSession session2 = this.mockCPMSession();\n+        CPMProducer producer1 = mock(CPMProducer.class);\n+        CPMProducer producer2 = mock(CPMProducer.class);\n+\n+        doReturn(producer1).when(session1).createProducer(any(CPMProducerConfig.class));\n+        doReturn(producer2).when(session2).createProducer(any(CPMProducerConfig.class));\n+\n+        doReturn(session1, session2).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+\n+        TaskExecutor executor1 = new TaskExecutor();\n+        TaskExecutor executor2 = new TaskExecutor();\n+\n+        executor1.execute(() -> dispatcher.postJobMessage(new JobMessage(\"job_id-1\", \"job_key-1\")));\n+        executor2.execute(() -> dispatcher.postJobMessage(new JobMessage(\"job_id-2\", \"job_key-2\")));\n+        executor1.execute(() -> dispatcher.commit());\n+        executor2.execute(() -> dispatcher.commit());\n+\n+        executor1.shutdown();\n+        executor2.shutdown();\n+\n+        verify(this.sessionFactory, times(2)).createSession(any(CPMSessionConfig.class));\n+\n+        verify(session1, times(1)).createProducer(any(CPMProducerConfig.class));\n+        verify(session2, times(1)).createProducer(any(CPMProducerConfig.class));\n+        verify(producer1, times(1)).send(anyString(), any(CPMMessage.class));\n+        verify(producer2, times(1)).send(anyString(), any(CPMMessage.class));\n+        verify(session1, times(1)).commit();\n+        verify(session2, times(1)).commit();\n+    }\n+\n+    @Test\n+    public void testAbandonedSessionsAreClosed() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session = this.mockCPMSession();\n+        CPMProducer producer = mock(CPMProducer.class);\n+\n+        doReturn(session).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+        doReturn(producer).when(session).createProducer(any(CPMProducerConfig.class));\n+\n+        TaskExecutor executor = new TaskExecutor();\n+\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1NjQwOA=="}, "originalCommit": {"oid": "55ca72efa1f9f04eeede24b917cf14446efde481"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NjAwNDU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyODozMVrOG42HIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMzoxODozMFrOG43_Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDAwMw==", "bodyText": "Not a part of your changes but there is an unused dependency.", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462260003", "createdAt": "2020-07-29T12:28:31Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "diffHunk": "@@ -44,12 +49,158 @@\n     private static final String JOB_KEY_MESSAGE_PROPERTY = \"job_key\";\n     private static final String JOB_MESSAGE_ADDRESS = \"job\";\n \n+    /**\n+     * The ThreadSessionStore is used to store session information per thread.\n+     */\n+    private static final class ThreadSessionStore {\n+        private final CPMSessionFactory sessionFactory;\n+\n+        private CPMSession session;\n+        private CPMProducer producer;\n+\n+        /**\n+         * Creates a new ThreadSessionStore which will use the given session factory to create new\n+         * sessions as necessary.\n+         *\n+         * @param sessionFactory\n+         *  the CPMSessionFactory instance to use to create new sessions\n+         *\n+         * @throws IllegalArgumentException\n+         *  if sessionFactory is null\n+         */\n+        public ThreadSessionStore(CPMSessionFactory sessionFactory) {\n+            if (sessionFactory == null) {\n+                throw new IllegalArgumentException(\"sessionFactory is null\");\n+            }\n+\n+            this.sessionFactory = sessionFactory;\n+        }\n+\n+        /**\n+         * Fetches the current CPM session, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMSession instance\n+         */\n+        public CPMSession getSession() throws CPMException {\n+            if (this.session == null || this.session.isClosed()) {\n+                log.debug(\"Creating new CPM session for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSessionConfig config = this.sessionFactory.createSessionConfig()\n+                    .setTransactional(true);\n+\n+                // Add any other job-system-specific session configuration here\n+\n+                this.session = this.sessionFactory.createSession(config);\n+                this.session.start();\n+\n+                log.debug(\"Created new CPM session: {}\", this.session);\n+            }\n+\n+            return this.session;\n+        }\n+\n+        /**\n+         * Fetches the current CPM producer, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMProducer instance\n+         */\n+        public CPMProducer getProducer() throws CPMException {\n+            if (this.producer == null || this.producer.isClosed()) {\n+                log.debug(\"Creating new CPM producer for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSession session = this.getSession();\n+                CPMProducerConfig config = session.createProducerConfig();\n+\n+                // Add any other job-system-specific producer configuration here\n+\n+                this.producer = session.createProducer(config);\n+\n+                log.debug(\"Created new CPM producer: {}\", this.producer);\n+            }\n+\n+            return this.producer;\n+        }\n+\n+        /**\n+         * Closes any session resources this session store may have open\n+         */\n+        private void close() throws CPMException {\n+            if (this.producer != null) {\n+                this.producer.close();\n+                this.producer = null;\n+            }\n+\n+            if (this.session != null) {\n+                this.session.close();\n+                this.session = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return String.format(\"ThreadSessionStore [session: %s, producer: %s]\",\n+                this.session, this.producer);\n+        }\n+    }\n+\n+    /**\n+     * The ThreadReference class is a WeakReference implementation with stable equals and hashCode\n+     * methods, allowing it to be used as a key in maps and in sets.\n+     */\n+    private class ThreadReference extends WeakReference<Thread> {\n+        private final int hashCode;\n+\n+        public ThreadReference(Thread thread, ReferenceQueue<? super Thread> queue) {\n+            super(thread, queue);\n+\n+            this.hashCode = thread != null ? thread.hashCode() : 0;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object cmp) {\n+            if (cmp == this) {\n+                return true;\n+            }\n+\n+            if (cmp instanceof ThreadReference) {\n+                Thread lhs = this.get();\n+                Thread rhs = ((ThreadReference) cmp).get();\n+\n+                return lhs != null ?\n+                    lhs.equals(rhs) :\n+                    rhs == null && this.hashCode() == ((ThreadReference) cmp).hashCode();\n+            }\n+\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return this.hashCode;\n+        }\n+    }\n+\n+\n+\n     private final Configuration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ca72efa1f9f04eeede24b917cf14446efde481"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MDc3OA==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462290778", "createdAt": "2020-07-29T13:18:30Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "diffHunk": "@@ -44,12 +49,158 @@\n     private static final String JOB_KEY_MESSAGE_PROPERTY = \"job_key\";\n     private static final String JOB_MESSAGE_ADDRESS = \"job\";\n \n+    /**\n+     * The ThreadSessionStore is used to store session information per thread.\n+     */\n+    private static final class ThreadSessionStore {\n+        private final CPMSessionFactory sessionFactory;\n+\n+        private CPMSession session;\n+        private CPMProducer producer;\n+\n+        /**\n+         * Creates a new ThreadSessionStore which will use the given session factory to create new\n+         * sessions as necessary.\n+         *\n+         * @param sessionFactory\n+         *  the CPMSessionFactory instance to use to create new sessions\n+         *\n+         * @throws IllegalArgumentException\n+         *  if sessionFactory is null\n+         */\n+        public ThreadSessionStore(CPMSessionFactory sessionFactory) {\n+            if (sessionFactory == null) {\n+                throw new IllegalArgumentException(\"sessionFactory is null\");\n+            }\n+\n+            this.sessionFactory = sessionFactory;\n+        }\n+\n+        /**\n+         * Fetches the current CPM session, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMSession instance\n+         */\n+        public CPMSession getSession() throws CPMException {\n+            if (this.session == null || this.session.isClosed()) {\n+                log.debug(\"Creating new CPM session for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSessionConfig config = this.sessionFactory.createSessionConfig()\n+                    .setTransactional(true);\n+\n+                // Add any other job-system-specific session configuration here\n+\n+                this.session = this.sessionFactory.createSession(config);\n+                this.session.start();\n+\n+                log.debug(\"Created new CPM session: {}\", this.session);\n+            }\n+\n+            return this.session;\n+        }\n+\n+        /**\n+         * Fetches the current CPM producer, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMProducer instance\n+         */\n+        public CPMProducer getProducer() throws CPMException {\n+            if (this.producer == null || this.producer.isClosed()) {\n+                log.debug(\"Creating new CPM producer for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSession session = this.getSession();\n+                CPMProducerConfig config = session.createProducerConfig();\n+\n+                // Add any other job-system-specific producer configuration here\n+\n+                this.producer = session.createProducer(config);\n+\n+                log.debug(\"Created new CPM producer: {}\", this.producer);\n+            }\n+\n+            return this.producer;\n+        }\n+\n+        /**\n+         * Closes any session resources this session store may have open\n+         */\n+        private void close() throws CPMException {\n+            if (this.producer != null) {\n+                this.producer.close();\n+                this.producer = null;\n+            }\n+\n+            if (this.session != null) {\n+                this.session.close();\n+                this.session = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return String.format(\"ThreadSessionStore [session: %s, producer: %s]\",\n+                this.session, this.producer);\n+        }\n+    }\n+\n+    /**\n+     * The ThreadReference class is a WeakReference implementation with stable equals and hashCode\n+     * methods, allowing it to be used as a key in maps and in sets.\n+     */\n+    private class ThreadReference extends WeakReference<Thread> {\n+        private final int hashCode;\n+\n+        public ThreadReference(Thread thread, ReferenceQueue<? super Thread> queue) {\n+            super(thread, queue);\n+\n+            this.hashCode = thread != null ? thread.hashCode() : 0;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object cmp) {\n+            if (cmp == this) {\n+                return true;\n+            }\n+\n+            if (cmp instanceof ThreadReference) {\n+                Thread lhs = this.get();\n+                Thread rhs = ((ThreadReference) cmp).get();\n+\n+                return lhs != null ?\n+                    lhs.equals(rhs) :\n+                    rhs == null && this.hashCode() == ((ThreadReference) cmp).hashCode();\n+            }\n+\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return this.hashCode;\n+        }\n+    }\n+\n+\n+\n     private final Configuration config;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDAwMw=="}, "originalCommit": {"oid": "55ca72efa1f9f04eeede24b917cf14446efde481"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NjAwNTY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyODo1MVrOG42H3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMzoxODozM1rOG43_bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDE4OA==", "bodyText": "Redundant cast", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462260188", "createdAt": "2020-07-29T12:28:51Z", "author": {"login": "Januson"}, "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "diffHunk": "@@ -44,12 +49,158 @@\n     private static final String JOB_KEY_MESSAGE_PROPERTY = \"job_key\";\n     private static final String JOB_MESSAGE_ADDRESS = \"job\";\n \n+    /**\n+     * The ThreadSessionStore is used to store session information per thread.\n+     */\n+    private static final class ThreadSessionStore {\n+        private final CPMSessionFactory sessionFactory;\n+\n+        private CPMSession session;\n+        private CPMProducer producer;\n+\n+        /**\n+         * Creates a new ThreadSessionStore which will use the given session factory to create new\n+         * sessions as necessary.\n+         *\n+         * @param sessionFactory\n+         *  the CPMSessionFactory instance to use to create new sessions\n+         *\n+         * @throws IllegalArgumentException\n+         *  if sessionFactory is null\n+         */\n+        public ThreadSessionStore(CPMSessionFactory sessionFactory) {\n+            if (sessionFactory == null) {\n+                throw new IllegalArgumentException(\"sessionFactory is null\");\n+            }\n+\n+            this.sessionFactory = sessionFactory;\n+        }\n+\n+        /**\n+         * Fetches the current CPM session, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMSession instance\n+         */\n+        public CPMSession getSession() throws CPMException {\n+            if (this.session == null || this.session.isClosed()) {\n+                log.debug(\"Creating new CPM session for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSessionConfig config = this.sessionFactory.createSessionConfig()\n+                    .setTransactional(true);\n+\n+                // Add any other job-system-specific session configuration here\n+\n+                this.session = this.sessionFactory.createSession(config);\n+                this.session.start();\n+\n+                log.debug(\"Created new CPM session: {}\", this.session);\n+            }\n+\n+            return this.session;\n+        }\n+\n+        /**\n+         * Fetches the current CPM producer, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMProducer instance\n+         */\n+        public CPMProducer getProducer() throws CPMException {\n+            if (this.producer == null || this.producer.isClosed()) {\n+                log.debug(\"Creating new CPM producer for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSession session = this.getSession();\n+                CPMProducerConfig config = session.createProducerConfig();\n+\n+                // Add any other job-system-specific producer configuration here\n+\n+                this.producer = session.createProducer(config);\n+\n+                log.debug(\"Created new CPM producer: {}\", this.producer);\n+            }\n+\n+            return this.producer;\n+        }\n+\n+        /**\n+         * Closes any session resources this session store may have open\n+         */\n+        private void close() throws CPMException {\n+            if (this.producer != null) {\n+                this.producer.close();\n+                this.producer = null;\n+            }\n+\n+            if (this.session != null) {\n+                this.session.close();\n+                this.session = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return String.format(\"ThreadSessionStore [session: %s, producer: %s]\",\n+                this.session, this.producer);\n+        }\n+    }\n+\n+    /**\n+     * The ThreadReference class is a WeakReference implementation with stable equals and hashCode\n+     * methods, allowing it to be used as a key in maps and in sets.\n+     */\n+    private class ThreadReference extends WeakReference<Thread> {\n+        private final int hashCode;\n+\n+        public ThreadReference(Thread thread, ReferenceQueue<? super Thread> queue) {\n+            super(thread, queue);\n+\n+            this.hashCode = thread != null ? thread.hashCode() : 0;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object cmp) {\n+            if (cmp == this) {\n+                return true;\n+            }\n+\n+            if (cmp instanceof ThreadReference) {\n+                Thread lhs = this.get();\n+                Thread rhs = ((ThreadReference) cmp).get();\n+\n+                return lhs != null ?\n+                    lhs.equals(rhs) :\n+                    rhs == null && this.hashCode() == ((ThreadReference) cmp).hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55ca72efa1f9f04eeede24b917cf14446efde481"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MDc5OA==", "bodyText": "Fixed", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462290798", "createdAt": "2020-07-29T13:18:33Z", "author": {"login": "Ceiu"}, "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "diffHunk": "@@ -44,12 +49,158 @@\n     private static final String JOB_KEY_MESSAGE_PROPERTY = \"job_key\";\n     private static final String JOB_MESSAGE_ADDRESS = \"job\";\n \n+    /**\n+     * The ThreadSessionStore is used to store session information per thread.\n+     */\n+    private static final class ThreadSessionStore {\n+        private final CPMSessionFactory sessionFactory;\n+\n+        private CPMSession session;\n+        private CPMProducer producer;\n+\n+        /**\n+         * Creates a new ThreadSessionStore which will use the given session factory to create new\n+         * sessions as necessary.\n+         *\n+         * @param sessionFactory\n+         *  the CPMSessionFactory instance to use to create new sessions\n+         *\n+         * @throws IllegalArgumentException\n+         *  if sessionFactory is null\n+         */\n+        public ThreadSessionStore(CPMSessionFactory sessionFactory) {\n+            if (sessionFactory == null) {\n+                throw new IllegalArgumentException(\"sessionFactory is null\");\n+            }\n+\n+            this.sessionFactory = sessionFactory;\n+        }\n+\n+        /**\n+         * Fetches the current CPM session, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMSession instance\n+         */\n+        public CPMSession getSession() throws CPMException {\n+            if (this.session == null || this.session.isClosed()) {\n+                log.debug(\"Creating new CPM session for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSessionConfig config = this.sessionFactory.createSessionConfig()\n+                    .setTransactional(true);\n+\n+                // Add any other job-system-specific session configuration here\n+\n+                this.session = this.sessionFactory.createSession(config);\n+                this.session.start();\n+\n+                log.debug(\"Created new CPM session: {}\", this.session);\n+            }\n+\n+            return this.session;\n+        }\n+\n+        /**\n+         * Fetches the current CPM producer, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMProducer instance\n+         */\n+        public CPMProducer getProducer() throws CPMException {\n+            if (this.producer == null || this.producer.isClosed()) {\n+                log.debug(\"Creating new CPM producer for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSession session = this.getSession();\n+                CPMProducerConfig config = session.createProducerConfig();\n+\n+                // Add any other job-system-specific producer configuration here\n+\n+                this.producer = session.createProducer(config);\n+\n+                log.debug(\"Created new CPM producer: {}\", this.producer);\n+            }\n+\n+            return this.producer;\n+        }\n+\n+        /**\n+         * Closes any session resources this session store may have open\n+         */\n+        private void close() throws CPMException {\n+            if (this.producer != null) {\n+                this.producer.close();\n+                this.producer = null;\n+            }\n+\n+            if (this.session != null) {\n+                this.session.close();\n+                this.session = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return String.format(\"ThreadSessionStore [session: %s, producer: %s]\",\n+                this.session, this.producer);\n+        }\n+    }\n+\n+    /**\n+     * The ThreadReference class is a WeakReference implementation with stable equals and hashCode\n+     * methods, allowing it to be used as a key in maps and in sets.\n+     */\n+    private class ThreadReference extends WeakReference<Thread> {\n+        private final int hashCode;\n+\n+        public ThreadReference(Thread thread, ReferenceQueue<? super Thread> queue) {\n+            super(thread, queue);\n+\n+            this.hashCode = thread != null ? thread.hashCode() : 0;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object cmp) {\n+            if (cmp == this) {\n+                return true;\n+            }\n+\n+            if (cmp instanceof ThreadReference) {\n+                Thread lhs = this.get();\n+                Thread rhs = ((ThreadReference) cmp).get();\n+\n+                return lhs != null ?\n+                    lhs.equals(rhs) :\n+                    rhs == null && this.hashCode() == ((ThreadReference) cmp).hashCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDE4OA=="}, "originalCommit": {"oid": "55ca72efa1f9f04eeede24b917cf14446efde481"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4055, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}