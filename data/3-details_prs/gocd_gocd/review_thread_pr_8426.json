{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMjA2OTUw", "number": 8426, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNjozM1rOEVfJiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoyMDozMFrOEVhonw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTY1ODk5OnYy", "diffSide": "RIGHT", "path": "api/api-base/src/main/java/com/thoughtworks/go/api/HistoryMethods.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNjozM1rOG8RRyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNjozM1rOG8RRyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MDgyNw==", "bodyText": "I would probably add these methods to ApiController over creating this new interface.", "url": "https://github.com/gocd/gocd/pull/8426#discussion_r465850827", "createdAt": "2020-08-05T16:26:33Z", "author": {"login": "maheshp"}, "path": "api/api-base/src/main/java/com/thoughtworks/go/api/HistoryMethods.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.thoughtworks.go.api;\n+\n+import com.thoughtworks.go.config.exceptions.BadRequestException;\n+import spark.Request;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+public interface HistoryMethods {\n+    String BAD_PAGE_SIZE_MSG = \"The query parameter 'page_size', if specified must be a number between 10 and 100.\";\n+    String BAD_CURSOR_MSG = \"The query parameter '%s', if specified, must be a positive integer.\";\n+\n+    default Integer getPageSize(Request request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3ce163418dd6e4352b6e8df66e2c291a288867"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDA2MTEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/thoughtworks/go/server/service/MaterialService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxOTowM1rOG8VQjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDo1OTo0OVrOG83dKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNjA0Nw==", "bodyText": "Is the lookup for MaterialInstance required, we get the material fingerprint as part of the request, can't we just fire a single query to fetch modifications and join on materials which matches the fingerprint?", "url": "https://github.com/gocd/gocd/pull/8426#discussion_r465916047", "createdAt": "2020-08-05T18:19:03Z", "author": {"login": "maheshp"}, "path": "server/src/main/java/com/thoughtworks/go/server/service/MaterialService.java", "diffHunk": "@@ -169,4 +172,44 @@ private void resolveSecretParams(Material material) {\n                 .stream()\n                 .collect(toMap(mod -> mod.getMaterialInstance().getFingerprint(), mod -> mod));\n     }\n+\n+    public List<Modification> getModificationsFor(MaterialConfig materialConfig, long afterCursor, long beforeCursor, Integer pageSize) {\n+        MaterialInstance materialInstance = materialRepository.findMaterialInstance(materialConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3ce163418dd6e4352b6e8df66e2c291a288867"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NTg1OQ==", "bodyText": "This query is cached. Also, IMO, join would be an expensive operation. Will deploy this as is on build.gocd. Based on the response there - we can later on raise another PR for performance improvement. WDYT?", "url": "https://github.com/gocd/gocd/pull/8426#discussion_r466155859", "createdAt": "2020-08-06T05:32:53Z", "author": {"login": "kritika-singh3"}, "path": "server/src/main/java/com/thoughtworks/go/server/service/MaterialService.java", "diffHunk": "@@ -169,4 +172,44 @@ private void resolveSecretParams(Material material) {\n                 .stream()\n                 .collect(toMap(mod -> mod.getMaterialInstance().getFingerprint(), mod -> mod));\n     }\n+\n+    public List<Modification> getModificationsFor(MaterialConfig materialConfig, long afterCursor, long beforeCursor, Integer pageSize) {\n+        MaterialInstance materialInstance = materialRepository.findMaterialInstance(materialConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNjA0Nw=="}, "originalCommit": {"oid": "ab3ce163418dd6e4352b6e8df66e2c291a288867"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3NjMyOQ==", "bodyText": "Previously I had seen 3 queries fired to fetch the modifications, hence I suggested we use joins. Since MaterialInstance lookup is cached a query to fetch modifications should be fine. Either way we should benchmark  these queries before taking a decision.", "url": "https://github.com/gocd/gocd/pull/8426#discussion_r466476329", "createdAt": "2020-08-06T14:59:49Z", "author": {"login": "maheshp"}, "path": "server/src/main/java/com/thoughtworks/go/server/service/MaterialService.java", "diffHunk": "@@ -169,4 +172,44 @@ private void resolveSecretParams(Material material) {\n                 .stream()\n                 .collect(toMap(mod -> mod.getMaterialInstance().getFingerprint(), mod -> mod));\n     }\n+\n+    public List<Modification> getModificationsFor(MaterialConfig materialConfig, long afterCursor, long beforeCursor, Integer pageSize) {\n+        MaterialInstance materialInstance = materialRepository.findMaterialInstance(materialConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNjA0Nw=="}, "originalCommit": {"oid": "ab3ce163418dd6e4352b6e8df66e2c291a288867"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDA2NjIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/thoughtworks/go/server/persistence/MaterialRepository.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoyMDozMFrOG8VTyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNTozMzoyMVrOG8j57g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNjg3Mg==", "bodyText": "Why do we need a exactMatchQuery, are we expecting users to provide the complete material revision?", "url": "https://github.com/gocd/gocd/pull/8426#discussion_r465916872", "createdAt": "2020-08-05T18:20:30Z", "author": {"login": "maheshp"}, "path": "server/src/main/java/com/thoughtworks/go/server/persistence/MaterialRepository.java", "diffHunk": "@@ -1040,4 +1042,172 @@ public File folderFor(Material material) {\n                     .list();\n         });\n     }\n+\n+    public List<Modification> loadHistory(long materialId, FeedModifier modifier, long cursor, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        String queryString = null;\n+        switch (modifier) {\n+            case Latest:\n+                queryString = \"SELECT * \" +\n+                        \"FROM modifications \" +\n+                        \"WHERE materialid = :materialId \" +\n+                        \"ORDER BY id DESC \" +\n+                        \"LIMIT :size \";\n+                params.put(\"materialId\", materialId);\n+                params.put(\"size\", pageSize);\n+                break;\n+            case After:\n+                queryString = \"SELECT * \" +\n+                        \"FROM modifications \" +\n+                        \"WHERE materialid = :materialId \" +\n+                        \"  and id < :cursor \" +\n+                        \"ORDER BY id DESC \" +\n+                        \"LIMIT :size \";\n+                params.put(\"materialId\", materialId);\n+                params.put(\"size\", pageSize);\n+                params.put(\"cursor\", cursor);\n+                break;\n+            case Before:\n+                queryString = \"SELECT * \" +\n+                        \"FROM (SELECT * \" +\n+                        \"      FROM modifications \" +\n+                        \"      WHERE materialid = :materialId \" +\n+                        \"        and id > :cursor \" +\n+                        \"      ORDER BY id ASC \" +\n+                        \"      LIMIT :size ) as HistoryBeforeSpecifiedId \" +\n+                        \"ORDER BY id DESC\";\n+                params.put(\"materialId\", materialId);\n+                params.put(\"size\", pageSize);\n+                params.put(\"cursor\", cursor);\n+                break;\n+        }\n+        String finalQueryString = queryString;\n+        List<Modification> mods = (List<Modification>) getHibernateTemplate().execute((HibernateCallback) session -> {\n+            SQLQuery query = session.createSQLQuery(finalQueryString);\n+            query.setProperties(params);\n+            return query.addEntity(\"mods\", Modification.class)\n+                    .list();\n+        });\n+        return mods;\n+    }\n+\n+    public PipelineRunIdInfo getOldestAndLatestModificationId(long materialId, String pattern) {\n+        String queryString = \"SELECT MAX(modifications.id) as latestRunId, MIN(modifications.id) as oldestRunId \" +\n+                \"FROM modifications \" +\n+                \"WHERE modifications.materialid = :materialId \";\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        if (isNotBlank(pattern)) {\n+            queryString = queryString +\n+                    \"  AND (LOWER(modifications.comment) LIKE :pattern \" +\n+                    \"  OR LOWER(modifications.userName) LIKE :pattern \" +\n+                    \"  OR LOWER(modifications.revision) LIKE :pattern ) \";\n+\n+            params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        }\n+        String finalQueryString = queryString;\n+        Object[] info = (Object[]) getHibernateTemplate().execute((HibernateCallback) session -> {\n+            SQLQuery query = session.createSQLQuery(finalQueryString);\n+            query.setProperties(params);\n+            return query.addScalar(\"latestRunId\", new LongType())\n+                    .addScalar(\"oldestRunId\", new LongType())\n+                    .uniqueResult();\n+        });\n+        if (info == null || info[0] == null || info[1] == null) {\n+            return null;\n+        }\n+        return new PipelineRunIdInfo((long) info[0], (long) info[1]);\n+    }\n+\n+    public List<Modification> findLatestMatchingModifications(long materialId, String pattern, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        params.put(\"rawPattern\", pattern.toLowerCase());\n+        params.put(\"size\", pageSize);\n+        String exactMatchQuery = \"SELECT * \" +\n+                \"FROM modifications \" +\n+                \"WHERE materialid = :materialId \" +\n+                \"  AND LOWER(revision) = :rawPattern \" +\n+                \"ORDER BY id DESC \" +\n+                \"LIMIT :size\";\n+        String likeMatchQuery = \"SELECT * \" +\n+                \"FROM modifications \" +\n+                \"WHERE materialid = :materialId \" +\n+                \"  AND (LOWER(modifications.comment) LIKE :pattern \" +\n+                \"  OR LOWER(userName) LIKE :pattern \" +\n+                \"  OR LOWER(revision) LIKE :pattern ) \" +\n+                \"ORDER BY id DESC \" +\n+                \"LIMIT :size\";\n+        return getMatchingModifications(exactMatchQuery, likeMatchQuery, params);\n+    }\n+\n+    public List<Modification> findMatchingModificationsBeforeCursor(long materialId, String pattern, long cursor, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        params.put(\"rawPattern\", pattern.toLowerCase());\n+        params.put(\"size\", pageSize);\n+        params.put(\"cursor\", cursor);\n+        String exactMatchQuery = \"SELECT * \" +\n+                \"FROM ( SELECT * \" +\n+                \"    FROM modifications \" +\n+                \"    WHERE materialid = :materialId AND id > :cursor \" +\n+                \"      AND LOWER(revision) = :rawPattern \" +\n+                \"    ORDER BY id DESC \" +\n+                \"    LIMIT :size ) as MatchBeforeSpecifiedCursor \" +\n+                \"ORDER BY id DESC\";\n+        String likeMatchQuery = \"SELECT * \" +\n+                \"FROM ( SELECT * \" +\n+                \"    FROM modifications \" +\n+                \"    WHERE materialid = :materialId AND id > :cursor \" +\n+                \"      AND (LOWER(modifications.comment) LIKE :pattern \" +\n+                \"      OR LOWER(userName) LIKE :pattern \" +\n+                \"      OR LOWER(revision) LIKE :pattern ) \" +\n+                \"    ORDER BY id DESC \" +\n+                \"    LIMIT :size) as LikeMatchBeforeSpecifiedCursor \" +\n+                \"ORDER BY id DESC\";\n+        return getMatchingModifications(exactMatchQuery, likeMatchQuery, params);\n+    }\n+\n+    public List<Modification> findMatchingModificationsAfterCursor(long materialId, String pattern, long cursor, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        params.put(\"rawPattern\", pattern.toLowerCase());\n+        params.put(\"size\", pageSize);\n+        params.put(\"cursor\", cursor);\n+        String exactMatchQuery = \"SELECT * \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3ce163418dd6e4352b6e8df66e2c291a288867"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NjAxNA==", "bodyText": "No we explicitly don't have any usecase as of now. Will remove this.", "url": "https://github.com/gocd/gocd/pull/8426#discussion_r466156014", "createdAt": "2020-08-06T05:33:21Z", "author": {"login": "kritika-singh3"}, "path": "server/src/main/java/com/thoughtworks/go/server/persistence/MaterialRepository.java", "diffHunk": "@@ -1040,4 +1042,172 @@ public File folderFor(Material material) {\n                     .list();\n         });\n     }\n+\n+    public List<Modification> loadHistory(long materialId, FeedModifier modifier, long cursor, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        String queryString = null;\n+        switch (modifier) {\n+            case Latest:\n+                queryString = \"SELECT * \" +\n+                        \"FROM modifications \" +\n+                        \"WHERE materialid = :materialId \" +\n+                        \"ORDER BY id DESC \" +\n+                        \"LIMIT :size \";\n+                params.put(\"materialId\", materialId);\n+                params.put(\"size\", pageSize);\n+                break;\n+            case After:\n+                queryString = \"SELECT * \" +\n+                        \"FROM modifications \" +\n+                        \"WHERE materialid = :materialId \" +\n+                        \"  and id < :cursor \" +\n+                        \"ORDER BY id DESC \" +\n+                        \"LIMIT :size \";\n+                params.put(\"materialId\", materialId);\n+                params.put(\"size\", pageSize);\n+                params.put(\"cursor\", cursor);\n+                break;\n+            case Before:\n+                queryString = \"SELECT * \" +\n+                        \"FROM (SELECT * \" +\n+                        \"      FROM modifications \" +\n+                        \"      WHERE materialid = :materialId \" +\n+                        \"        and id > :cursor \" +\n+                        \"      ORDER BY id ASC \" +\n+                        \"      LIMIT :size ) as HistoryBeforeSpecifiedId \" +\n+                        \"ORDER BY id DESC\";\n+                params.put(\"materialId\", materialId);\n+                params.put(\"size\", pageSize);\n+                params.put(\"cursor\", cursor);\n+                break;\n+        }\n+        String finalQueryString = queryString;\n+        List<Modification> mods = (List<Modification>) getHibernateTemplate().execute((HibernateCallback) session -> {\n+            SQLQuery query = session.createSQLQuery(finalQueryString);\n+            query.setProperties(params);\n+            return query.addEntity(\"mods\", Modification.class)\n+                    .list();\n+        });\n+        return mods;\n+    }\n+\n+    public PipelineRunIdInfo getOldestAndLatestModificationId(long materialId, String pattern) {\n+        String queryString = \"SELECT MAX(modifications.id) as latestRunId, MIN(modifications.id) as oldestRunId \" +\n+                \"FROM modifications \" +\n+                \"WHERE modifications.materialid = :materialId \";\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        if (isNotBlank(pattern)) {\n+            queryString = queryString +\n+                    \"  AND (LOWER(modifications.comment) LIKE :pattern \" +\n+                    \"  OR LOWER(modifications.userName) LIKE :pattern \" +\n+                    \"  OR LOWER(modifications.revision) LIKE :pattern ) \";\n+\n+            params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        }\n+        String finalQueryString = queryString;\n+        Object[] info = (Object[]) getHibernateTemplate().execute((HibernateCallback) session -> {\n+            SQLQuery query = session.createSQLQuery(finalQueryString);\n+            query.setProperties(params);\n+            return query.addScalar(\"latestRunId\", new LongType())\n+                    .addScalar(\"oldestRunId\", new LongType())\n+                    .uniqueResult();\n+        });\n+        if (info == null || info[0] == null || info[1] == null) {\n+            return null;\n+        }\n+        return new PipelineRunIdInfo((long) info[0], (long) info[1]);\n+    }\n+\n+    public List<Modification> findLatestMatchingModifications(long materialId, String pattern, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        params.put(\"rawPattern\", pattern.toLowerCase());\n+        params.put(\"size\", pageSize);\n+        String exactMatchQuery = \"SELECT * \" +\n+                \"FROM modifications \" +\n+                \"WHERE materialid = :materialId \" +\n+                \"  AND LOWER(revision) = :rawPattern \" +\n+                \"ORDER BY id DESC \" +\n+                \"LIMIT :size\";\n+        String likeMatchQuery = \"SELECT * \" +\n+                \"FROM modifications \" +\n+                \"WHERE materialid = :materialId \" +\n+                \"  AND (LOWER(modifications.comment) LIKE :pattern \" +\n+                \"  OR LOWER(userName) LIKE :pattern \" +\n+                \"  OR LOWER(revision) LIKE :pattern ) \" +\n+                \"ORDER BY id DESC \" +\n+                \"LIMIT :size\";\n+        return getMatchingModifications(exactMatchQuery, likeMatchQuery, params);\n+    }\n+\n+    public List<Modification> findMatchingModificationsBeforeCursor(long materialId, String pattern, long cursor, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        params.put(\"rawPattern\", pattern.toLowerCase());\n+        params.put(\"size\", pageSize);\n+        params.put(\"cursor\", cursor);\n+        String exactMatchQuery = \"SELECT * \" +\n+                \"FROM ( SELECT * \" +\n+                \"    FROM modifications \" +\n+                \"    WHERE materialid = :materialId AND id > :cursor \" +\n+                \"      AND LOWER(revision) = :rawPattern \" +\n+                \"    ORDER BY id DESC \" +\n+                \"    LIMIT :size ) as MatchBeforeSpecifiedCursor \" +\n+                \"ORDER BY id DESC\";\n+        String likeMatchQuery = \"SELECT * \" +\n+                \"FROM ( SELECT * \" +\n+                \"    FROM modifications \" +\n+                \"    WHERE materialid = :materialId AND id > :cursor \" +\n+                \"      AND (LOWER(modifications.comment) LIKE :pattern \" +\n+                \"      OR LOWER(userName) LIKE :pattern \" +\n+                \"      OR LOWER(revision) LIKE :pattern ) \" +\n+                \"    ORDER BY id DESC \" +\n+                \"    LIMIT :size) as LikeMatchBeforeSpecifiedCursor \" +\n+                \"ORDER BY id DESC\";\n+        return getMatchingModifications(exactMatchQuery, likeMatchQuery, params);\n+    }\n+\n+    public List<Modification> findMatchingModificationsAfterCursor(long materialId, String pattern, long cursor, Integer pageSize) {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"materialId\", materialId);\n+        params.put(\"pattern\", \"%\" + pattern.toLowerCase() + \"%\");\n+        params.put(\"rawPattern\", pattern.toLowerCase());\n+        params.put(\"size\", pageSize);\n+        params.put(\"cursor\", cursor);\n+        String exactMatchQuery = \"SELECT * \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNjg3Mg=="}, "originalCommit": {"oid": "ab3ce163418dd6e4352b6e8df66e2c291a288867"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2818, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}