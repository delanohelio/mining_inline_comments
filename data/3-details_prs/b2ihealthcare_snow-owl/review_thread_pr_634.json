{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MzM0MDEz", "number": 634, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNjowMlrOEXhIIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyOTozOVrOEXhqcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDk1NDU2OnYy", "diffSide": "RIGHT", "path": "commons/com.b2international.index/src/com/b2international/index/revision/RevisionCompareDetail.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNjowMlrOG_WYEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNjowMlrOG_WYEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MDA4MA==", "bodyText": "This is now a separator, not a String template. Please rename the constant", "url": "https://github.com/b2ihealthcare/snow-owl/pull/634#discussion_r469080080", "createdAt": "2020-08-12T08:06:02Z", "author": {"login": "apeteri"}, "path": "commons/com.b2international.index/src/com/b2international/index/revision/RevisionCompareDetail.java", "diffHunk": "@@ -27,6 +27,8 @@\n  */\n public final class RevisionCompareDetail {\n \n+\tprivate static final String PROPERTY_CHANGE_KEY_TEMPLATE = \"_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b41cdc8dd81e236afff1c1938625c74dbf68ec9"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDk1OTA3OnYy", "diffSide": "RIGHT", "path": "commons/com.b2international.index/src/com/b2international/index/revision/RevisionCompareDetail.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNzozMFrOG_Wa3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODowNzozMFrOG_Wa3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MDc5OA==", "bodyText": "The property also has a @JsonIgnore annotation.", "url": "https://github.com/b2ihealthcare/snow-owl/pull/634#discussion_r469080798", "createdAt": "2020-08-12T08:07:30Z", "author": {"login": "apeteri"}, "path": "commons/com.b2international.index/src/com/b2international/index/revision/RevisionCompareDetail.java", "diffHunk": "@@ -40,6 +42,9 @@\n \tprivate final String fromValue;\n \tprivate final String value;\n \t\n+\t@JsonIgnore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b41cdc8dd81e236afff1c1938625c74dbf68ec9"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTAzMjM4OnYy", "diffSide": "RIGHT", "path": "commons/com.b2international.index/src/com/b2international/index/revision/StagingArea.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyNjo1MFrOG_XIug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyNjo1MFrOG_XIug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5MjUzOA==", "bodyText": "It no longer seems to be necessary to consume Map entries here \ud83e\udd14 We're not doing anything with any leftover entries in sourcePropertyChanges (or indirectly via sourcePropertyChangesByObject).", "url": "https://github.com/b2ihealthcare/snow-owl/pull/634#discussion_r469092538", "createdAt": "2020-08-12T08:26:50Z", "author": {"login": "apeteri"}, "path": "commons/com.b2international.index/src/com/b2international/index/revision/StagingArea.java", "diffHunk": "@@ -673,43 +673,41 @@ void merge(RevisionBranchRef fromRef, RevisionBranchRef toRef, boolean squash, R\n \t\t\t// then handle changed vs. changed with the conflict processor\n \t\t\tSet<String> changedInSourceAndTargetIds = Sets.intersection(changedRevisionIdsToMerge, changedRevisionIdsToCheck);\n \t\t\tif (!changedInSourceAndTargetIds.isEmpty()) {\n+\t\t\t\tfinal Map<String, Map<String, RevisionCompareDetail>> sourcePropertyChangesByObject = indexPropertyChangesByObject(fromChangeDetails);\n+\t\t\t\tfinal Map<String, Map<String, RevisionCompareDetail>> targetPropertyChangesByObject = indexPropertyChangesByObject(toChangeDetails);\n \t\t\t\tfor (String changedInSourceAndTargetId : changedInSourceAndTargetIds) {\n-\t\t\t\t\tMap<String, RevisionCompareDetail> sourcePropertyChanges = fromChangeDetails.stream()\n-\t\t\t\t\t\t\t.filter(detail -> detail.getObject().id().equals(changedInSourceAndTargetId))\n-\t\t\t\t\t\t\t.filter(detail -> !detail.isComponentChange())\n-\t\t\t\t\t\t\t.collect(Collectors.toMap(RevisionCompareDetail::getProperty, d -> d));\n-\t\t\t\t\tMap<String, RevisionCompareDetail> targetPropertyChanges = toChangeDetails.stream()\n-\t\t\t\t\t\t\t.filter(detail -> detail.getObject().id().equals(changedInSourceAndTargetId))\n-\t\t\t\t\t\t\t.filter(detail -> !detail.isComponentChange())\n-\t\t\t\t\t\t\t.collect(Collectors.toMap(RevisionCompareDetail::getProperty, d -> d));\n+\t\t\t\t\tfinal Map<String, RevisionCompareDetail> sourcePropertyChanges = sourcePropertyChangesByObject.get(changedInSourceAndTargetId);\n+\t\t\t\t\tfinal Map<String, RevisionCompareDetail> targetPropertyChanges = targetPropertyChangesByObject.get(changedInSourceAndTargetId);\n \t\t\t\t\t\n-\t\t\t\t\tfor (Entry<String, RevisionCompareDetail> sourceChange : Iterables.consumingIterable(sourcePropertyChanges.entrySet())) {\n-\t\t\t\t\t\tfinal RevisionPropertyDiff sourceChangeDiff = new RevisionPropertyDiff(sourceChange.getValue().getProperty(), sourceChange.getValue().getFromValue(), sourceChange.getValue().getValue());\n-\t\t\t\t\t\tfinal RevisionCompareDetail targetPropertyChange = targetPropertyChanges.remove(sourceChange.getKey());\n-\t\t\t\t\t\tif (targetPropertyChange == null) {\n-\t\t\t\t\t\t\t// this property did not change in target, just apply directly on the target object via\n-\t\t\t\t\t\t\tif (!propertyUpdatesToApply.containsKey(type)) {\n-\t\t\t\t\t\t\t\tpropertyUpdatesToApply.put(type, HashMultimap.create());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tpropertyUpdatesToApply.get(type).put(changedInSourceAndTargetId, sourceChangeDiff);\n-\t\t\t\t\t\t\tfromChangeSet.removeChanged(type, changedInSourceAndTargetId);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tRevisionPropertyDiff targetChangeDiff = new RevisionPropertyDiff(targetPropertyChange.getProperty(), targetPropertyChange.getFromValue(), targetPropertyChange.getValue());\n-\t\t\t\t\t\t\t// changed on both sides, ask conflict processor to resolve the issue or raise conflict error\n-\t\t\t\t\t\t\tRevisionPropertyDiff resolution = conflictProcessor.handleChangedInSourceAndTarget(\n-\t\t\t\t\t\t\t\tchangedInSourceAndTargetId, \n-\t\t\t\t\t\t\t\tsourceChangeDiff,\n-\t\t\t\t\t\t\t\ttargetChangeDiff\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\tif (resolution == null) {\n-\t\t\t\t\t\t\t\tconflicts.add(new ChangedInSourceAndTargetConflict(sourceChange.getValue().getObject(), sourceChangeDiff.convert(conflictProcessor), targetChangeDiff.convert(conflictProcessor)));\n-\t\t\t\t\t\t\t} else {\n+\t\t\t\t\tif (sourcePropertyChanges != null) {\n+\t\t\t\t\t\tfor (Entry<String, RevisionCompareDetail> sourceChange : Iterables.consumingIterable(sourcePropertyChanges.entrySet())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b41cdc8dd81e236afff1c1938625c74dbf68ec9"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTA0MjQwOnYy", "diffSide": "RIGHT", "path": "commons/com.b2international.index/src/com/b2international/index/revision/StagingArea.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyOTozOVrOG_XO_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODoyOTozOVrOG_XO_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5NDE0Mg==", "bodyText": "Same here.", "url": "https://github.com/b2ihealthcare/snow-owl/pull/634#discussion_r469094142", "createdAt": "2020-08-12T08:29:39Z", "author": {"login": "apeteri"}, "path": "commons/com.b2international.index/src/com/b2international/index/revision/StagingArea.java", "diffHunk": "@@ -673,43 +673,41 @@ void merge(RevisionBranchRef fromRef, RevisionBranchRef toRef, boolean squash, R\n \t\t\t// then handle changed vs. changed with the conflict processor\n \t\t\tSet<String> changedInSourceAndTargetIds = Sets.intersection(changedRevisionIdsToMerge, changedRevisionIdsToCheck);\n \t\t\tif (!changedInSourceAndTargetIds.isEmpty()) {\n+\t\t\t\tfinal Map<String, Map<String, RevisionCompareDetail>> sourcePropertyChangesByObject = indexPropertyChangesByObject(fromChangeDetails);\n+\t\t\t\tfinal Map<String, Map<String, RevisionCompareDetail>> targetPropertyChangesByObject = indexPropertyChangesByObject(toChangeDetails);\n \t\t\t\tfor (String changedInSourceAndTargetId : changedInSourceAndTargetIds) {\n-\t\t\t\t\tMap<String, RevisionCompareDetail> sourcePropertyChanges = fromChangeDetails.stream()\n-\t\t\t\t\t\t\t.filter(detail -> detail.getObject().id().equals(changedInSourceAndTargetId))\n-\t\t\t\t\t\t\t.filter(detail -> !detail.isComponentChange())\n-\t\t\t\t\t\t\t.collect(Collectors.toMap(RevisionCompareDetail::getProperty, d -> d));\n-\t\t\t\t\tMap<String, RevisionCompareDetail> targetPropertyChanges = toChangeDetails.stream()\n-\t\t\t\t\t\t\t.filter(detail -> detail.getObject().id().equals(changedInSourceAndTargetId))\n-\t\t\t\t\t\t\t.filter(detail -> !detail.isComponentChange())\n-\t\t\t\t\t\t\t.collect(Collectors.toMap(RevisionCompareDetail::getProperty, d -> d));\n+\t\t\t\t\tfinal Map<String, RevisionCompareDetail> sourcePropertyChanges = sourcePropertyChangesByObject.get(changedInSourceAndTargetId);\n+\t\t\t\t\tfinal Map<String, RevisionCompareDetail> targetPropertyChanges = targetPropertyChangesByObject.get(changedInSourceAndTargetId);\n \t\t\t\t\t\n-\t\t\t\t\tfor (Entry<String, RevisionCompareDetail> sourceChange : Iterables.consumingIterable(sourcePropertyChanges.entrySet())) {\n-\t\t\t\t\t\tfinal RevisionPropertyDiff sourceChangeDiff = new RevisionPropertyDiff(sourceChange.getValue().getProperty(), sourceChange.getValue().getFromValue(), sourceChange.getValue().getValue());\n-\t\t\t\t\t\tfinal RevisionCompareDetail targetPropertyChange = targetPropertyChanges.remove(sourceChange.getKey());\n-\t\t\t\t\t\tif (targetPropertyChange == null) {\n-\t\t\t\t\t\t\t// this property did not change in target, just apply directly on the target object via\n-\t\t\t\t\t\t\tif (!propertyUpdatesToApply.containsKey(type)) {\n-\t\t\t\t\t\t\t\tpropertyUpdatesToApply.put(type, HashMultimap.create());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tpropertyUpdatesToApply.get(type).put(changedInSourceAndTargetId, sourceChangeDiff);\n-\t\t\t\t\t\t\tfromChangeSet.removeChanged(type, changedInSourceAndTargetId);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tRevisionPropertyDiff targetChangeDiff = new RevisionPropertyDiff(targetPropertyChange.getProperty(), targetPropertyChange.getFromValue(), targetPropertyChange.getValue());\n-\t\t\t\t\t\t\t// changed on both sides, ask conflict processor to resolve the issue or raise conflict error\n-\t\t\t\t\t\t\tRevisionPropertyDiff resolution = conflictProcessor.handleChangedInSourceAndTarget(\n-\t\t\t\t\t\t\t\tchangedInSourceAndTargetId, \n-\t\t\t\t\t\t\t\tsourceChangeDiff,\n-\t\t\t\t\t\t\t\ttargetChangeDiff\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\tif (resolution == null) {\n-\t\t\t\t\t\t\t\tconflicts.add(new ChangedInSourceAndTargetConflict(sourceChange.getValue().getObject(), sourceChangeDiff.convert(conflictProcessor), targetChangeDiff.convert(conflictProcessor)));\n-\t\t\t\t\t\t\t} else {\n+\t\t\t\t\tif (sourcePropertyChanges != null) {\n+\t\t\t\t\t\tfor (Entry<String, RevisionCompareDetail> sourceChange : Iterables.consumingIterable(sourcePropertyChanges.entrySet())) {\n+\t\t\t\t\t\t\tfinal RevisionPropertyDiff sourceChangeDiff = new RevisionPropertyDiff(sourceChange.getValue().getProperty(), sourceChange.getValue().getFromValue(), sourceChange.getValue().getValue());\n+\t\t\t\t\t\t\tfinal RevisionCompareDetail targetPropertyChange = targetPropertyChanges.remove(sourceChange.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b41cdc8dd81e236afff1c1938625c74dbf68ec9"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1649, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}