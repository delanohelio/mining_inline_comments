{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2MDY3ODc3", "number": 301, "title": "Integration test framework to test RCAs and decision Makers ", "bodyText": "fixes: #337\nDescription of changes:\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provides a way to query the\nSQLite data-store file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clusters work over\nhttp only. For more details, I would point you here\nTests:\nThere is a POC test to check the working of the framework.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-07-24T04:26:37Z", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301", "merged": true, "mergeCommit": {"oid": "e358f20ea171d2cd3ceb2ed1c213bfa7c1861f59"}, "closed": true, "closedAt": "2020-08-11T18:22:51Z", "author": {"login": "yojs"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7WSQcABqjM2MTcwOTk0MzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc962g5AFqTQ2NTMwOTI5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "962031dcd4ed38fdbd678a1e51b53e35635d6780", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/962031dcd4ed38fdbd678a1e51b53e35635d6780", "committedDate": "2020-07-24T04:25:47Z", "message": "rca it first cut, after removing the refactoring changes in the existing code"}, "afterCommit": {"oid": "9ad007c5ea8eb5d30f129aa30c39d4c845d25563", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9ad007c5ea8eb5d30f129aa30c39d4c845d25563", "committedDate": "2020-08-03T18:24:45Z", "message": "rebasing changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ad007c5ea8eb5d30f129aa30c39d4c845d25563", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9ad007c5ea8eb5d30f129aa30c39d4c845d25563", "committedDate": "2020-08-03T18:24:45Z", "message": "rebasing changes"}, "afterCommit": {"oid": "c43eab49ba40a6ca875c2ba0a30afa263b2356ca", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/c43eab49ba40a6ca875c2ba0a30afa263b2356ca", "committedDate": "2020-08-04T18:25:35Z", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1e9ee84026917af62be49a90ddab332065a8b54", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/a1e9ee84026917af62be49a90ddab332065a8b54", "committedDate": "2020-08-05T19:13:50Z", "message": "More documentation"}, "afterCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8ac14bfe465c2a87105aded687745ab165d9de55", "committedDate": "2020-08-05T19:17:30Z", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8ac14bfe465c2a87105aded687745ab165d9de55", "committedDate": "2020-08-05T19:17:30Z", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only."}, "afterCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d5f98c1af5304377226d18f19b52d00b9e98ea5f", "committedDate": "2020-08-07T00:10:59Z", "message": "Fixed a bug where the database was being corrupted because of multiple scheduler initializations."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjgwMzcx", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#pullrequestreview-463680371", "createdAt": "2020-08-07T23:01:37Z", "commit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMzowMTozN1rOG9q-vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMzo0NToxMFrOG9riiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMDUwOQ==", "bodyText": "Result and Record are closely coupled with SQL. Do we want to expose that level of details in Persistable interface ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467320509", "createdAt": "2020-08-07T23:01:37Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/Persistable.java", "diffHunk": "@@ -54,4 +56,10 @@\n   <T extends ResourceFlowUnit> void write(Node<?> node, T flowUnit) throws SQLException, IOException;\n \n   void close() throws SQLException;\n+\n+  List<Result<Record>> getRecordsForAllTables();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMTU2OA==", "bodyText": "Maybe I am wrong. but since we've already added synchronized keyword in the parent function which calls this private function, do we still need to add another synchronized keyword here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467321568", "createdAt": "2020-08-07T23:06:08Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/PersistorBase.java", "diffHunk": "@@ -245,14 +249,14 @@ private synchronized void rotateRegisterGarbageThenCreateNewDB(RotationType type\n   }\n \n   /** recursively insert nested summary to sql tables */\n-  private void writeSummary(\n+  private synchronized void writeSummary(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNzY5MA==", "bodyText": "should we print an error log if otherwise", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467327690", "createdAt": "2020-08-07T23:34:57Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -321,8 +376,10 @@ private synchronized JsonElement getNonTemperatureRcas(String rca) {\n         }\n       }\n     } catch (DataAccessException de) {\n-      // it is totally fine if we fail to read some certain tables.\n-      LOG.warn(\"Fail to read RCA : {}, query = {},  exceptions : {}\", rca, rcaQuery.toString(), de.getStackTrace());\n+      if (!de.getMessage().contains(\"no such table\")) {\n+        // it is totally fine if we fail to read some certain tables.\n+        LOG.warn(\"Fail to read RCA : {}.\", rca, de);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODQxOA==", "bodyText": "this will contain RCAs that are not cluster level RCAs. Do we also want to expose node level RCAs on local master node to user ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467328418", "createdAt": "2020-08-07T23:38:48Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rest/QueryRcaRequestHandler.java", "diffHunk": "@@ -162,13 +162,20 @@ public void handle(HttpExchange exchange) throws IOException {\n \n   private void handleClusterRcaRequest(Map<String, String> params, HttpExchange exchange)\n       throws IOException {\n+    //check if we are querying from elected master\n+    if (!validNodeRole()) {\n+      JsonObject errResponse = new JsonObject();\n+      errResponse.addProperty(\"error\", \"Node being queried is not elected master.\");\n+      sendResponse(exchange, errResponse.toString(),\n+              HttpURLConnection.HTTP_BAD_REQUEST);\n+      return;\n+    }\n     List<String> rcaList = metricsRestUtil.parseArrayParam(params, NAME_PARAM, true);\n     // query all cluster level RCAs if no RCA is specified in name.\n     if (rcaList.isEmpty()) {\n-      rcaList = SQLiteQueryUtils.getClusterLevelRca();\n-    }\n-    //check if RCA is valid\n-    if (!validParams(rcaList)) {\n+      // rcaList = SQLiteQueryUtils.getClusterLevelRca();\n+      rcaList = persistable.getAllPersistedRcas();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODU2Mw==", "bodyText": "same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467328563", "createdAt": "2020-08-07T23:39:34Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rest/QueryRcaRequestHandler.java", "diffHunk": "@@ -178,14 +185,6 @@ private void handleClusterRcaRequest(Map<String, String> params, HttpExchange ex\n           HttpURLConnection.HTTP_BAD_REQUEST);\n       return;\n     }\n-    //check if we are querying from elected master", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyOTY3NQ==", "bodyText": "Can we simply pass the Cluster object into Host object ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467329675", "createdAt": "2020-08-07T23:45:10Z", "author": {"login": "rguo-aws"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "759cd64fdfd0ed028b017940f14b52b3871c60f2", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/759cd64fdfd0ed028b017940f14b52b3871c60f2", "committedDate": "2020-08-10T23:00:00Z", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "209e36f6f6087924b7e834f02c4aaa0ce938a45e", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/209e36f6f6087924b7e834f02c4aaa0ce938a45e", "committedDate": "2020-08-10T23:00:00Z", "message": "Fixed a bug where the database was being corrupted because of multiple scheduler initializations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccf1ebdf02645e945d9513047f82259a5d1901f3", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/ccf1ebdf02645e945d9513047f82259a5d1901f3", "committedDate": "2020-08-10T23:00:00Z", "message": "Fix the POC graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d43965d5e687b61ba81553042ce50f836b6ec76", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/0d43965d5e687b61ba81553042ce50f836b6ec76", "committedDate": "2020-08-10T23:00:00Z", "message": "Removing unused methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "547b9993aa95e159fd89fe671366ac24323c7a29", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/547b9993aa95e159fd89fe671366ac24323c7a29", "committedDate": "2020-08-10T21:25:17Z", "message": "Fix the POC graph"}, "afterCommit": {"oid": "0d43965d5e687b61ba81553042ce50f836b6ec76", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/0d43965d5e687b61ba81553042ce50f836b6ec76", "committedDate": "2020-08-10T23:00:00Z", "message": "Removing unused methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "committedDate": "2020-08-11T00:47:52Z", "message": "Name the validation checks that failed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzI5NTg5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#pullrequestreview-462729589", "createdAt": "2020-08-06T17:26:32Z", "commit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyNjozMlrOG89QTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwOTowNTozN1rOG-vA-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MTM0Mg==", "bodyText": "For my own curiosity, why did this method need to be synchronized?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466571342", "createdAt": "2020-08-06T17:26:32Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -187,6 +192,35 @@ synchronized String readTables() {\n     return tablesObject.toString();\n   }\n \n+  public synchronized List<Result<Record>> getRecordsForAllTables() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MzIzMQ==", "bodyText": "Why did you wrap this method call instead of just making getRecords public?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466573231", "createdAt": "2020-08-06T17:29:51Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -187,6 +192,35 @@ synchronized String readTables() {\n     return tablesObject.toString();\n   }\n \n+  public synchronized List<Result<Record>> getRecordsForAllTables() {\n+    List<Result<Record>> results = new ArrayList<>();\n+    super.tableNames.forEach(\n+            table -> results.add(getRecords(table))\n+    );\n+    return results;\n+  }\n+\n+  @Override\n+  public Result<Record> getRecordsForTable(String tableName) {\n+    return getRecords(tableName);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODgxNw==", "bodyText": "nit: slightly misleading, this isn't a list of tables, but a list of rcaNames right?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466578817", "createdAt": "2020-08-06T17:39:32Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -187,6 +192,35 @@ synchronized String readTables() {\n     return tablesObject.toString();\n   }\n \n+  public synchronized List<Result<Record>> getRecordsForAllTables() {\n+    List<Result<Record>> results = new ArrayList<>();\n+    super.tableNames.forEach(\n+            table -> results.add(getRecords(table))\n+    );\n+    return results;\n+  }\n+\n+  @Override\n+  public Result<Record> getRecordsForTable(String tableName) {\n+    return getRecords(tableName);\n+  }\n+\n+\n+  @Override\n+  public List<String> getAllPersistedRcas() {\n+    List<String> tables = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MDQyNQ==", "bodyText": "Remove the exceptions: {} portion of the message.  Passing a throwable as the final argument to a Logger call prints the message and the stacktrace.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466580425", "createdAt": "2020-08-06T17:42:29Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -287,7 +339,7 @@ private synchronized void readSummary(GenericSummary upperLevelSummary, int uppe\n       } catch (DataAccessException de) {\n         // it is totally fine if we fail to read some certain tables as some types of summaries might be missing\n         LOG.warn(\"Fail to read Summary table : {}, query = {},  exceptions : {}\",\n-            nestedTableName, rcaQuery.toString(), de.getStackTrace());\n+            nestedTableName, rcaQuery.toString(), de);\n       } catch (IllegalArgumentException ie) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MDU5NQ==", "bodyText": "Same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466580595", "createdAt": "2020-08-06T17:42:48Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -322,7 +374,7 @@ private synchronized JsonElement getNonTemperatureRcas(String rca) {\n       }\n     } catch (DataAccessException de) {\n       // it is totally fine if we fail to read some certain tables.\n-      LOG.warn(\"Fail to read RCA : {}, query = {},  exceptions : {}\", rca, rcaQuery.toString(), de.getStackTrace());\n+      LOG.warn(\"Fail to read RCA : {}, query = {},  exceptions : {}\", rca, rcaQuery.toString(), de);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MzA3Nw==", "bodyText": "nit: This file didn't need to be changed as part of this commit", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466583077", "createdAt": "2020-08-06T17:47:18Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ClusterDetailsEventProcessor.java", "diffHunk": "@@ -184,6 +176,14 @@ public NodeDetails(final NodeDetails other) {\n       }\n     }\n \n+    public NodeDetails(AllMetrics.NodeRole role, String id, String hostAddress, boolean isMaster, int grpcPort) {\n+      this.role = role.toString();\n+      this.id = id;\n+      this.hostAddress = hostAddress;\n+      this.isMasterNode = isMaster;\n+      this.grpcPort = grpcPort;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5Mzk5MQ==", "bodyText": "nit: delete extra tab", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466593991", "createdAt": "2020-08-06T18:06:25Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/RcaControllerTest.java", "diffHunk": "@@ -129,7 +127,8 @@ public void setUp() throws Exception {\n             rcaEnabledFileLoc.toString(),\n             100,\n             200,\n-            appContext\n+            appContext,\n+                new MetricsDBProviderTestHelper()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NTI4Mg==", "bodyText": "Thanks for removing this. Do you know why we were doing this Whitebox stuff in the first place?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466595282", "createdAt": "2020-08-06T18:08:47Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/RcaControllerTest.java", "diffHunk": "@@ -203,14 +202,14 @@ public void readAndUpdateMutedRcasBeforeGraphCreation() throws Exception {\n     Field mutedGraphNodesField = Stats.class.getDeclaredField(\"mutedGraphNodes\");\n     mutedGraphNodesField.setAccessible(true);\n     mutedGraphNodesField.set(Stats.getInstance(), null);\n-    Set<String> initialComponentSet = ConnectedComponent.getNodeNames();\n-    Whitebox.setInternalState(ConnectedComponent.class, \"nodeNames\", new HashSet<>());\n+    Set<String> initialComponentSet = ConnectedComponent.getNodesForAllComponents(rcaController.getConnectedComponents());\n+    // Whitebox.setInternalState(ConnectedComponent.class, \"nodeNames\", new HashSet<>());\n \n     readAndUpdateMutesRcas.invoke(rcaController);\n     Assert.assertNull(Stats.getInstance().getMutedGraphNodes());\n \n     // Re-set back to initialComponentSet\n-    Whitebox.setInternalState(ConnectedComponent.class, \"nodeNames\", initialComponentSet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNTc3Mw==", "bodyText": "LOG.error(\"netOE failed to terminate\", e);", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466615773", "createdAt": "2020-08-06T18:47:12Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) throws Exception {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNjAwMQ==", "bodyText": "Just LOG.error(ie);", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466616001", "createdAt": "2020-08-06T18:47:35Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) throws Exception {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    clientServers.getHttpServer().stop(10);\n+    clientServers.getNetClient().stop();\n+    clientServers.getNetServer().shutdown();\n+\n+    connectionManager.shutdown();\n+\n+    try {\n+      Thread.sleep(1000);\n+    } catch (InterruptedException ie) {\n+      ie.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1ODUyNg==", "bodyText": "Should be https if httpsEnabled", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466658526", "createdAt": "2020-08-06T20:09:59Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) throws Exception {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    clientServers.getHttpServer().stop(10);\n+    clientServers.getNetClient().stop();\n+    clientServers.getNetServer().shutdown();\n+\n+    connectionManager.shutdown();\n+\n+    try {\n+      Thread.sleep(1000);\n+    } catch (InterruptedException ie) {\n+      ie.printStackTrace();\n+    }\n+\n+    webServerThread.interrupt();\n+\n+    clientServers.getNetServer().setAttemptedShutdown();\n+    grpcThread.interrupt();\n+\n+    rcaController.setDeliberateInterrupt();\n+\n+    LOG.info(\"RCA Controller thread for host {} is being interrupted.\" + hostId);\n+    rcaControllerThread.interrupt();\n+    deleteHostDir();\n+    LOG.info(\"Host '{} with role '{}' cleaned up.\", hostId, rcaController.getCurrentRole());\n+  }\n+\n+  public void deleteHostDir() throws IOException {\n+    FileUtils.deleteDirectory(hostDir);\n+  }\n+\n+  public void stopRcaScheduler() throws Exception {\n+    setRcaState(RcaSchedulerState.STATE_STOPPED);\n+    rcaController.waitForRcaState(RcaSchedulerState.STATE_STOPPED);\n+    LOG.info(\"RCA Scheduler STOPPED\");\n+  }\n+\n+  public void startRcaControllerThread() {\n+    this.rcaControllerThread = PerformanceAnalyzerApp.startRcaTopLevelThread(rcaController, threadProvider);\n+  }\n+\n+  public void startRcaScheduler() throws Exception {\n+    setRcaState(RcaSchedulerState.STATE_STARTED);\n+    rcaController.waitForRcaState(RcaSchedulerState.STATE_STARTED);\n+    LOG.info(\"RCA scheduler STARTED successfully on host: {}.\", myTag);\n+  }\n+\n+  public void updateRcaGraph(final Class rcaGraphClass)\n+      throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    rcaController.setRcaGraphComponents(rcaGraphClass);\n+  }\n+\n+  public void updateMetricsDB(AMetric[] metricAnnotations) throws Exception {\n+    RcaItMetricsDBProvider dbProvider =\n+        new RcaItMetricsDBProvider(Paths.get(hostDir.getPath(), \"metricsdb\").toString());\n+    for (AMetric metric : metricAnnotations) {\n+      boolean foundDataForHost = false;\n+      // Each metric can have only one data table that can be associated to a host.\n+      // Which one is determined by the hostTag. The first matching is added to the host\n+      // for the current metric.\n+      dataLoop:\n+      for (ATable table : metric.tables()) {\n+        for (HostTag dataTag : table.hostTag()) {\n+          if (myTag == dataTag) {\n+            // First data-tag to match the hostTags is considered to be a match\n+            for (ATuple tuple : table.tuple()) {\n+              String metricName;\n+              try {\n+                metricName = (String) metric.name().getField(\"NAME\").get(null);\n+              } catch (Exception ex) {\n+                LOG.error(\"Error getting metric name.\", ex);\n+                throw ex;\n+              }\n+              dbProvider.insertRow(\n+                  metricName,\n+                  metric.dimensionNames(),\n+                  tuple.dimensionValues(),\n+                  tuple.min(),\n+                  tuple.max(),\n+                  tuple.avg(),\n+                  tuple.sum());\n+            }\n+            foundDataForHost = true;\n+            // We found a data table matching the tags of the host. Let's move to the\n+            // next metric.\n+            break dataLoop;\n+          }\n+        }\n+      }\n+      if (!foundDataForHost) {\n+        // This is not an error though. For example, a dedicated master node cannot emit\n+        // a shard related metric.\n+        System.out.println(\"No data found for host \" + hostId + \" for metric \" + metric.name());\n+      }\n+    }\n+    rcaController.setDbProvider(dbProvider);\n+  }\n+\n+  public JsonObject getAllRcaData() {\n+    JsonParser parser = new JsonParser();\n+    JsonElement data = parser.parse(this.rcaController.getPersistenceProvider().read());\n+    JsonObject obj = new JsonObject();\n+    obj.addProperty(Consts.HOST_ID_KEY, myTag.toString());\n+    obj.addProperty(Consts.HOST_ROLE_KEY, role.toString());\n+    obj.add(Consts.DATA_KEY, data);\n+    return obj;\n+  }\n+\n+  public JsonElement getDataForRca(String rcaName) {\n+    JsonElement data = this.rcaController.getPersistenceProvider().read(rcaName);\n+    JsonObject obj = new JsonObject();\n+    obj.addProperty(Consts.HOST_ID_KEY, hostId);\n+    obj.addProperty(Consts.HOST_ROLE_KEY, role.toString());\n+    obj.add(Consts.DATA_KEY, data);\n+    return obj;\n+  }\n+\n+  public List<Result<Record>> getRecordsForAllTables() {\n+    return this.rcaController.getPersistenceProvider().getRecordsForAllTables();\n+  }\n+\n+  Result<Record> getRecordsForTable(String tableName) {\n+    return this.rcaController.getPersistenceProvider().getRecordsForTable(tableName);\n+  }\n+\n+  public String makeRestRequest(final Map<String, String> kvRequestParams) {\n+    StringBuilder queryString = new StringBuilder();\n+\n+    String appender = \"\";\n+    for (Map.Entry<String, String> entry : kvRequestParams.entrySet()) {\n+      queryString.append(appender).append(entry.getKey()).append(\"=\").append(entry.getValue());\n+      appender = \"&\";\n+    }\n+    StringBuilder uri =\n+        new StringBuilder(\"http://localhost:\" + webServerPort + Util.RCA_QUERY_URL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTU0Mw==", "bodyText": "See above, computing annotationsPresent seems superfluous", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466661543", "createdAt": "2020-08-06T20:16:14Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/TestEnvironment.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaControllerHelper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaGraph;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestEnvironment {\n+  private final Cluster cluster;\n+  private final Env classLevelEnv;\n+\n+  private Env currentEnv;\n+\n+  public TestEnvironment(final Cluster cluster, final Class testClass) throws Exception {\n+    this.cluster = cluster;\n+    this.classLevelEnv = updateEnvironment(testClass);\n+  }\n+\n+  private Env updateEnvironment(final Class testClass) throws Exception {\n+    boolean annotationsPresent = testClass.isAnnotationPresent(ARcaConf.class)\n+        | testClass.isAnnotationPresent(ARcaGraph.class)\n+        | testClass.isAnnotationPresent(ARcaConf.class);\n+\n+    Env env = new Env();\n+\n+    if (annotationsPresent) {\n+      if (testClass.isAnnotationPresent(ARcaConf.class)) {\n+        updateRcaConf((ARcaConf) testClass.getAnnotation(ARcaConf.class), env);\n+      }\n+      if (testClass.isAnnotationPresent(ARcaGraph.class)) {\n+        updateRcaGraph((ARcaGraph) testClass.getAnnotation(ARcaGraph.class), env);\n+      }\n+\n+      if (testClass.isAnnotationPresent(AMetric.Metrics.class)\n+          || testClass.isAnnotationPresent(AMetric.class)) {\n+        updateMetricsDB((AMetric[]) testClass.getAnnotationsByType(AMetric.class), env);\n+      }\n+    }\n+    if (env.rcaConfMap.isEmpty()) {\n+      updateWithDefaultRcaConfAnnotation(env);\n+    }\n+    return env;\n+  }\n+\n+  public void updateEnvironment(final Method method) throws Exception {\n+    boolean annotationsPresent = method.isAnnotationPresent(ARcaConf.class)\n+        | method.isAnnotationPresent(ARcaGraph.class)\n+        | method.isAnnotationPresent(ARcaConf.class);\n+\n+    this.currentEnv = new Env(this.classLevelEnv);\n+\n+    if (annotationsPresent) {\n+      if (method.isAnnotationPresent(ARcaConf.class)) {\n+        updateRcaConf(method.getAnnotation(ARcaConf.class), currentEnv);\n+      }\n+      if (method.isAnnotationPresent(ARcaGraph.class)) {\n+        updateRcaGraph(method.getAnnotation(ARcaGraph.class), currentEnv);\n+      }\n+\n+      if (method.isAnnotationPresent(AMetric.Metrics.class)) {\n+        updateMetricsDB(method.getAnnotationsByType(AMetric.class), currentEnv);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjE4Nw==", "bodyText": "Is there a reason we don't throw after this?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468362187", "createdAt": "2020-08-11T06:49:04Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/RcaController.java", "diffHunk": "@@ -221,9 +229,21 @@ private void start() {\n           new SubscribeServerHandler(subscriptionManager, networkThreadPoolReference));\n \n       Thread rcaSchedulerThread = threadProvider.createThreadForRunnable(() -> rcaScheduler.start(),\n-          PerformanceAnalyzerThreads.RCA_SCHEDULER);\n+          PerformanceAnalyzerThreads.RCA_SCHEDULER,\n+          copyAppContext.getMyInstanceDetails().getInstanceId().toString());\n \n+      CountDownLatch schedulerStartLatch = new CountDownLatch(1);\n+      rcaScheduler.setSchedulerTrackingLatch(schedulerStartLatch);\n       rcaSchedulerThread.start();\n+      if (!schedulerStartLatch.await(WAIT_FOR_SCHED_START_SECS, TimeUnit.SECONDS)) {\n+        LOG.error(\"Failed to start RcaScheduler.\");\n+        throw new IllegalStateException(\n+            \"Failed to start RcaScheduler within \" + WAIT_FOR_SCHED_START_SECS + \" seconds.\");\n+      }\n+\n+      if (rcaScheduler.getState() != RcaSchedulerState.STATE_STARTED) {\n+        LOG.error(\"RCA scheduler didn't start within {} seconds\", WAIT_FOR_SCHED_START_SECS);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjgwNw==", "bodyText": "Are these imports still needed?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468362807", "createdAt": "2020-08-11T06:50:34Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/Persistable.java", "diffHunk": "@@ -22,6 +22,8 @@\n import java.io.IOException;\n import java.sql.SQLException;\n import java.util.List;\n+import org.jooq.Record;\n+import org.jooq.Result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3ODQ3NA==", "bodyText": "nullCheck or @NotNull", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468378474", "createdAt": "2020-08-11T07:24:48Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/threads/ThreadProvider.java", "diffHunk": "@@ -41,7 +41,13 @@\n    * @return The thread with the wrapped runnable.\n    */\n   public Thread createThreadForRunnable(final Runnable innerRunnable,\n-      final PerformanceAnalyzerThreads paThread) {\n+      final PerformanceAnalyzerThreads paThread, String threadNameAppender) {\n+    StringBuilder threadName = new StringBuilder(paThread.toString());\n+    if (!threadNameAppender.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3ODk1NQ==", "bodyText": "this would be good for paThread as well just for sanity", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468378955", "createdAt": "2020-08-11T07:25:40Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/threads/ThreadProvider.java", "diffHunk": "@@ -41,7 +41,13 @@\n    * @return The thread with the wrapped runnable.\n    */\n   public Thread createThreadForRunnable(final Runnable innerRunnable,\n-      final PerformanceAnalyzerThreads paThread) {\n+      final PerformanceAnalyzerThreads paThread, String threadNameAppender) {\n+    StringBuilder threadName = new StringBuilder(paThread.toString());\n+    if (!threadNameAppender.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3ODQ3NA=="}, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM4MTM5Ng==", "bodyText": "Can you add a TODO here? This REST logic has been independently implemented by multiple engineers and should just live in a utility class. This would simplify the https case as well.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468381396", "createdAt": "2020-08-11T07:30:27Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setExpectedRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setExpectedRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    clientServers.getHttpServer().stop(10);\n+    clientServers.getNetClient().stop();\n+    clientServers.getNetServer().shutdown();\n+\n+    connectionManager.shutdown();\n+\n+    try {\n+      Thread.sleep(1000);\n+    } catch (InterruptedException ie) {\n+      ie.printStackTrace();\n+    }\n+\n+    webServerThread.interrupt();\n+\n+    clientServers.getNetServer().setAttemptedShutdown();\n+    grpcThread.interrupt();\n+\n+    rcaController.setDeliberateInterrupt();\n+\n+    LOG.info(\"RCA Controller thread for host {} is being interrupted.\" + hostId);\n+    rcaControllerThread.interrupt();\n+    deleteHostDir();\n+    LOG.info(\"Host '{} with role '{}' cleaned up.\", hostId, rcaController.getCurrentRole());\n+  }\n+\n+  public void deleteHostDir() throws IOException {\n+    FileUtils.deleteDirectory(hostDir);\n+  }\n+\n+  public void stopRcaScheduler() throws Exception {\n+    RCAScheduler sched = rcaController.getRcaScheduler();\n+    CountDownLatch shutdownLatch = null;\n+    if (sched != null) {\n+      shutdownLatch = new CountDownLatch(1);\n+      sched.setSchedulerTrackingLatch(shutdownLatch);\n+    }\n+    setExpectedRcaState(RcaSchedulerState.STATE_STOPPED);\n+    if (shutdownLatch != null) {\n+      shutdownLatch.await(10, TimeUnit.SECONDS);\n+    }\n+    LOG.info(\"RCA Scheduler is STOPPED by TestRunner on node: {}\", myTag);\n+  }\n+\n+  public void startRcaControllerThread() {\n+    this.rcaControllerThread = PerformanceAnalyzerApp.startRcaTopLevelThread(\n+        rcaController,\n+        threadProvider,\n+        appContext.getMyInstanceDetails().getInstanceId().toString());\n+  }\n+\n+  public void startRcaScheduler() throws Exception {\n+    setExpectedRcaState(RcaSchedulerState.STATE_STARTED);\n+    rcaController.waitForRcaState(RcaSchedulerState.STATE_STARTED);\n+  }\n+\n+  public void updateRcaGraph(final Class rcaGraphClass)\n+      throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    rcaController.setRcaGraphComponents(rcaGraphClass);\n+  }\n+\n+  public void updateMetricsDB(AMetric[] metricAnnotations) throws Exception {\n+    RcaItMetricsDBProvider dbProvider =\n+        new RcaItMetricsDBProvider(Paths.get(hostDir.getPath(), \"metricsdb\").toString());\n+    for (AMetric metric : metricAnnotations) {\n+      boolean foundDataForHost = false;\n+      // Each metric can have only one data table that can be associated to a host.\n+      // Which one is determined by the hostTag. The first matching is added to the host\n+      // for the current metric.\n+      dataLoop:\n+      for (ATable table : metric.tables()) {\n+        for (HostTag dataTag : table.hostTag()) {\n+          if (myTag == dataTag) {\n+            // First data-tag to match the hostTags is considered to be a match\n+            for (ATuple tuple : table.tuple()) {\n+              String metricName;\n+              try {\n+                metricName = (String) metric.name().getField(\"NAME\").get(null);\n+              } catch (Exception ex) {\n+                LOG.error(\"Error getting metric name.\", ex);\n+                throw ex;\n+              }\n+              dbProvider.insertRow(\n+                  metricName,\n+                  metric.dimensionNames(),\n+                  tuple.dimensionValues(),\n+                  tuple.min(),\n+                  tuple.max(),\n+                  tuple.avg(),\n+                  tuple.sum());\n+            }\n+            foundDataForHost = true;\n+            // We found a data table matching the tags of the host. Let's move to the\n+            // next metric.\n+            break dataLoop;\n+          }\n+        }\n+      }\n+      if (!foundDataForHost) {\n+        // This is not an error though. For example, a dedicated master node cannot emit\n+        // a shard related metric.\n+        System.out.println(\"No data found for host \" + hostId + \" for metric \" + metric.name());\n+      }\n+    }\n+    rcaController.setDbProvider(dbProvider);\n+  }\n+\n+  public JsonElement getDataForRca(String rcaName) {\n+    JsonElement data = this.rcaController.getPersistenceProvider().read(rcaName);\n+    JsonObject obj = new JsonObject();\n+    obj.addProperty(Consts.HOST_ID_KEY, hostId);\n+    obj.addProperty(Consts.HOST_ROLE_KEY, role.toString());\n+    obj.add(Consts.DATA_KEY, data);\n+    return obj;\n+  }\n+\n+  public String makeRestRequest(final Map<String, String> kvRequestParams) {\n+    StringBuilder queryString = new StringBuilder();\n+\n+    String appender = \"\";\n+    for (Map.Entry<String, String> entry : kvRequestParams.entrySet()) {\n+      queryString.append(appender).append(entry.getKey()).append(\"=\").append(entry.getValue());\n+      appender = \"&\";\n+    }\n+    StringBuilder uri =\n+        new StringBuilder(\"http://localhost:\" + webServerPort + Util.RCA_QUERY_URL);\n+    uri.append(\"?\").append(queryString);\n+\n+    URL url = null;\n+    try {\n+      url = new URL(uri.toString());\n+    } catch (MalformedURLException e) {\n+      e.printStackTrace();\n+      Assert.fail();\n+    }\n+\n+    String response = \"\";\n+    HttpURLConnection connection = null;\n+\n+    try {\n+      connection = (HttpURLConnection) url.openConnection();\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      Assert.fail();\n+    }\n+\n+    try {\n+      connection.setRequestMethod(\"GET\");\n+    } catch (ProtocolException e) {\n+      e.printStackTrace();\n+      connection.disconnect();\n+      Assert.fail();\n+    }\n+\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM4Njg1OA==", "bodyText": "nit: should be metric", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468386858", "createdAt": "2020-08-11T07:41:16Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/annotations/AMetric.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * This annotation can be used to specify the metrics that will be poured onto the RCA Graph. Under the covers,\n+ * the framework will try to simulate a DBProvider that will respond with these metrics when the RCA Metrics\n+ * nodes query for one. This annotation lets you specify one or more metric tables, similar to the 5 second\n+ * metric snapshots of the metricsdb files, and also specify a table for one or a group of cluster hosts.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Repeatable(value = AMetric.Metrics.class)\n+@Target({ElementType.TYPE, ElementType.METHOD})\n+public @interface AMetric {\n+  // The metric this data is emulating.\n+  Class name();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5NTEyMw==", "bodyText": "Curious, why is this Class instead of AnalysisGraph if it's cast to AnalysisGraph anyway? Does reflection not support polymorphism?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468395123", "createdAt": "2020-08-11T07:56:52Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/overrides/RcaControllerIt.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.AnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.ConnectedComponent;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Queryable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.util.WaitFor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+public class RcaControllerIt extends RcaController {\n+  private final String rcaPath;\n+  private List<ConnectedComponent> rcaGraphComponents;\n+\n+  public RcaControllerIt(ThreadProvider threadProvider,\n+                         ScheduledExecutorService netOpsExecutorService,\n+                         GRPCConnectionManager grpcConnectionManager,\n+                         ClientServers clientServers,\n+                         String rca_enabled_conf_location,\n+                         long rcaStateCheckIntervalMillis,\n+                         long nodeRoleCheckPeriodicityMillis,\n+                         AllMetrics.NodeRole nodeRole,\n+                         final AppContext appContext,\n+                         final Queryable dbProvider) {\n+    super(threadProvider,\n+        netOpsExecutorService,\n+        grpcConnectionManager,\n+        clientServers,\n+        rca_enabled_conf_location,\n+        rcaStateCheckIntervalMillis,\n+        nodeRoleCheckPeriodicityMillis,\n+        appContext,\n+        dbProvider);\n+    this.currentRole = nodeRole;\n+    this.rcaPath = rca_enabled_conf_location;\n+  }\n+\n+  @Override\n+  protected List<ConnectedComponent> getRcaGraphComponents(RcaConf rcaConf) throws\n+      ClassNotFoundException,\n+      NoSuchMethodException,\n+      InvocationTargetException,\n+      InstantiationException,\n+      IllegalAccessException {\n+    if (rcaGraphComponents != null) {\n+      return rcaGraphComponents;\n+    } else {\n+      return super.getRcaGraphComponents(rcaConf);\n+    }\n+  }\n+\n+  @Override\n+  protected RcaConf getRcaConfForMyRole(AllMetrics.NodeRole nodeRole) {\n+    RcaConfIt rcaConfIt = new RcaConfIt(super.getRcaConfForMyRole(nodeRole));\n+    rcaConfIt.setRcaDataStorePath(rcaPath);\n+    return rcaConfIt;\n+  }\n+\n+  public void setDbProvider(final Queryable db) {\n+    dbProvider = db;\n+  }\n+\n+  public void setRcaGraphComponents(Class rcaGraphClass)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5OTU0OQ==", "bodyText": "nit: isn't computing this a waste given that we redo the checks below anyway?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468399549", "createdAt": "2020-08-11T08:04:58Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/TestEnvironment.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaControllerHelper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaGraph;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestEnvironment {\n+  private final Cluster cluster;\n+  private final Env classLevelEnv;\n+\n+  private Env currentEnv;\n+\n+  public TestEnvironment(final Cluster cluster, final Class testClass) throws Exception {\n+    this.cluster = cluster;\n+    this.classLevelEnv = updateEnvironment(testClass);\n+  }\n+\n+  private Env updateEnvironment(final Class testClass) throws Exception {\n+    boolean annotationsPresent = testClass.isAnnotationPresent(ARcaConf.class)\n+        | testClass.isAnnotationPresent(ARcaGraph.class)\n+        | testClass.isAnnotationPresent(ARcaConf.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQwNTgyMw==", "bodyText": "nit: SET_API_METHOD?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468405823", "createdAt": "2020-08-11T08:16:22Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/IRcaItRunner.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Timestamp;\n+import java.text.SimpleDateFormat;\n+import org.apache.commons.io.FileUtils;\n+\n+public interface IRcaItRunner {\n+  String SET_CLUSTER_METHOD = \"setTestApi\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxNzYwMw==", "bodyText": "nit: delete startMillis", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468417603", "createdAt": "2020-08-11T08:35:55Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.TestEnvironment;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.Runner;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunNotifier;\n+\n+/**\n+ * This is the main runner class that is used by the RCA-IT.\n+ */\n+public abstract class RcaItRunnerBase extends Runner implements IRcaItRunner {\n+  private static final Logger LOG = LogManager.getLogger(RcaItRunnerBase.class);\n+\n+  // The class whose tests the runner is currently executing.\n+  private final Class testClass;\n+\n+  // An instance of the test class the runner is executing.\n+  private final Object testObject;\n+\n+  // This is used to set up the environment. An environment for running RCA graph would be to push the RCA graph itself,\n+  // the metrics, the rca.conf if that needs to be changed. It reads them from the annotations and sets them up for the\n+  // cluster object.\n+  private final TestEnvironment testEnvironment;\n+\n+  // An instance of the cluster where tests are running.\n+  private final Cluster cluster;\n+\n+  // This is wrapper on top of the cluster object that is passed on to the testClass to get access to the cluster.\n+  private final TestApi testApi;\n+\n+  public RcaItRunnerBase(Class testClass, boolean useHttps) throws Exception {\n+    super();\n+    this.testClass = testClass;\n+    ClusterType clusterType = getClusterTypeFromAnnotation(testClass);\n+    this.cluster = createCluster(clusterType, useHttps);\n+    this.testApi = new TestApi(cluster);\n+    this.testObject = testClass.getDeclaredConstructor().newInstance();\n+\n+    try {\n+      Method setClusterMethod = testClass.getMethod(SET_CLUSTER_METHOD, TestApi.class);\n+      setClusterMethod.setAccessible(true);\n+      setClusterMethod.invoke(testObject, testApi);\n+    } catch (NoSuchMethodException ex) {\n+      // This test class hasn't defined a method setCluster(Cluster). SO probably it does not need\n+      // access to the cluster object. Which is fine. We move on to the method execution.\n+    }\n+\n+    cluster.createServersAndThreads();\n+    try {\n+      this.testEnvironment = new TestEnvironment(cluster, testClass);\n+    } catch (Exception ex) {\n+      cluster.deleteClusterDir();\n+      ex.printStackTrace();\n+      throw ex;\n+    }\n+    cluster.startRcaControllerThread();\n+  }\n+\n+  private static ClusterType getClusterTypeFromAnnotation(Class testClass) {\n+    if (!testClass.isAnnotationPresent(AClusterType.class)) {\n+      throw new IllegalArgumentException(\n+          testClass.getSimpleName() + \" does not have the mandatory annotation: \" + AClusterType.class.getSimpleName());\n+    }\n+    return ((AClusterType) testClass.getAnnotation(AClusterType.class)).value();\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    return Description.createTestDescription(testClass, \"A custom runner for RcaIt\");\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    try {\n+      for (Method method : testClass.getMethods()) {\n+        if (method.isAnnotationPresent(Test.class)) {\n+          notifier.fireTestStarted(Description\n+              .createTestDescription(testClass, method.getName()));\n+\n+          try {\n+            this.testEnvironment.updateEnvironment(method);\n+            this.testEnvironment.verifyEnvironmentSetup();\n+          } catch (Exception ex) {\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), ex));\n+          }\n+          cluster.startRcaScheduler();\n+\n+          try {\n+            method.invoke(testObject);\n+            List<Class> failedChecks = validate(method);\n+\n+            if (!failedChecks.isEmpty()) {\n+              StringBuilder sb = new StringBuilder(\"Failed validations for:\");\n+              for (Class failed: failedChecks) {\n+                sb.append(System.lineSeparator()).append(failed);\n+              }\n+\n+              notifier.fireTestFailure(\n+                  new Failure(\n+                      Description.createTestDescription(testClass.getClass(), method.getName()),\n+                      new AssertionError(sb.toString())));\n+            }\n+          } catch (Exception exception) {\n+            LOG.error(\"** ERR: While running method: '{}'\", method.getName(), exception);\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), exception));\n+          }\n+\n+          cluster.stopRcaScheduler();\n+          this.testEnvironment.clearUpMethodLevelEnvOverride();\n+\n+          notifier.fireTestFinished(Description.createTestDescription(testClass, method.getName()));\n+        }\n+      }\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      throw new RuntimeException(e);\n+    } finally {\n+      try {\n+        cluster.deleteCluster();\n+      } catch (IOException e) {\n+        e.printStackTrace();\n+      }\n+    }\n+  }\n+\n+  private List<Class> validate(Method method)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    List<Class> failedValidations = new ArrayList<>();\n+    if (method.isAnnotationPresent(AExpect.Expectations.class) || method.isAnnotationPresent(AExpect.class)) {\n+      AExpect[] expectations = method.getDeclaredAnnotationsByType(AExpect.class);\n+\n+      IValidator[] validators = new IValidator[expectations.length];\n+      long maxWaitMillis = 0;\n+\n+      // Initialization loop for validation and the maximum wait time for the checks to pass.\n+      for (int i = 0; i < expectations.length; i++) {\n+        AExpect expect = expectations[i];\n+        validators[i] = (IValidator) expect.validator().getDeclaredConstructor().newInstance();\n+        long timeOutMillis = TimeUnit.MILLISECONDS.convert(expect.timeoutSeconds(), TimeUnit.SECONDS);\n+        if (timeOutMillis > maxWaitMillis) {\n+          maxWaitMillis = timeOutMillis;\n+        }\n+      }\n+\n+      long startMillis = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyMTEyMg==", "bodyText": "Most of these classes need preamble. You'll get even more lines on this PR!", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468421122", "createdAt": "2020-08-11T08:41:56Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyMjkyMQ==", "bodyText": "Misleading, we might have exceeded our max wait time and returned the failed validations", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468422921", "createdAt": "2020-08-11T08:44:51Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.TestEnvironment;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.Runner;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunNotifier;\n+\n+/**\n+ * This is the main runner class that is used by the RCA-IT.\n+ */\n+public abstract class RcaItRunnerBase extends Runner implements IRcaItRunner {\n+  private static final Logger LOG = LogManager.getLogger(RcaItRunnerBase.class);\n+\n+  // The class whose tests the runner is currently executing.\n+  private final Class testClass;\n+\n+  // An instance of the test class the runner is executing.\n+  private final Object testObject;\n+\n+  // This is used to set up the environment. An environment for running RCA graph would be to push the RCA graph itself,\n+  // the metrics, the rca.conf if that needs to be changed. It reads them from the annotations and sets them up for the\n+  // cluster object.\n+  private final TestEnvironment testEnvironment;\n+\n+  // An instance of the cluster where tests are running.\n+  private final Cluster cluster;\n+\n+  // This is wrapper on top of the cluster object that is passed on to the testClass to get access to the cluster.\n+  private final TestApi testApi;\n+\n+  public RcaItRunnerBase(Class testClass, boolean useHttps) throws Exception {\n+    super();\n+    this.testClass = testClass;\n+    ClusterType clusterType = getClusterTypeFromAnnotation(testClass);\n+    this.cluster = createCluster(clusterType, useHttps);\n+    this.testApi = new TestApi(cluster);\n+    this.testObject = testClass.getDeclaredConstructor().newInstance();\n+\n+    try {\n+      Method setClusterMethod = testClass.getMethod(SET_CLUSTER_METHOD, TestApi.class);\n+      setClusterMethod.setAccessible(true);\n+      setClusterMethod.invoke(testObject, testApi);\n+    } catch (NoSuchMethodException ex) {\n+      // This test class hasn't defined a method setCluster(Cluster). SO probably it does not need\n+      // access to the cluster object. Which is fine. We move on to the method execution.\n+    }\n+\n+    cluster.createServersAndThreads();\n+    try {\n+      this.testEnvironment = new TestEnvironment(cluster, testClass);\n+    } catch (Exception ex) {\n+      cluster.deleteClusterDir();\n+      ex.printStackTrace();\n+      throw ex;\n+    }\n+    cluster.startRcaControllerThread();\n+  }\n+\n+  private static ClusterType getClusterTypeFromAnnotation(Class testClass) {\n+    if (!testClass.isAnnotationPresent(AClusterType.class)) {\n+      throw new IllegalArgumentException(\n+          testClass.getSimpleName() + \" does not have the mandatory annotation: \" + AClusterType.class.getSimpleName());\n+    }\n+    return ((AClusterType) testClass.getAnnotation(AClusterType.class)).value();\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    return Description.createTestDescription(testClass, \"A custom runner for RcaIt\");\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    try {\n+      for (Method method : testClass.getMethods()) {\n+        if (method.isAnnotationPresent(Test.class)) {\n+          notifier.fireTestStarted(Description\n+              .createTestDescription(testClass, method.getName()));\n+\n+          try {\n+            this.testEnvironment.updateEnvironment(method);\n+            this.testEnvironment.verifyEnvironmentSetup();\n+          } catch (Exception ex) {\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), ex));\n+          }\n+          cluster.startRcaScheduler();\n+\n+          try {\n+            method.invoke(testObject);\n+            List<Class> failedChecks = validate(method);\n+\n+            if (!failedChecks.isEmpty()) {\n+              StringBuilder sb = new StringBuilder(\"Failed validations for:\");\n+              for (Class failed: failedChecks) {\n+                sb.append(System.lineSeparator()).append(failed);\n+              }\n+\n+              notifier.fireTestFailure(\n+                  new Failure(\n+                      Description.createTestDescription(testClass.getClass(), method.getName()),\n+                      new AssertionError(sb.toString())));\n+            }\n+          } catch (Exception exception) {\n+            LOG.error(\"** ERR: While running method: '{}'\", method.getName(), exception);\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), exception));\n+          }\n+\n+          cluster.stopRcaScheduler();\n+          this.testEnvironment.clearUpMethodLevelEnvOverride();\n+\n+          notifier.fireTestFinished(Description.createTestDescription(testClass, method.getName()));\n+        }\n+      }\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      throw new RuntimeException(e);\n+    } finally {\n+      try {\n+        cluster.deleteCluster();\n+      } catch (IOException e) {\n+        e.printStackTrace();\n+      }\n+    }\n+  }\n+\n+  private List<Class> validate(Method method)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    List<Class> failedValidations = new ArrayList<>();\n+    if (method.isAnnotationPresent(AExpect.Expectations.class) || method.isAnnotationPresent(AExpect.class)) {\n+      AExpect[] expectations = method.getDeclaredAnnotationsByType(AExpect.class);\n+\n+      IValidator[] validators = new IValidator[expectations.length];\n+      long maxWaitMillis = 0;\n+\n+      // Initialization loop for validation and the maximum wait time for the checks to pass.\n+      for (int i = 0; i < expectations.length; i++) {\n+        AExpect expect = expectations[i];\n+        validators[i] = (IValidator) expect.validator().getDeclaredConstructor().newInstance();\n+        long timeOutMillis = TimeUnit.MILLISECONDS.convert(expect.timeoutSeconds(), TimeUnit.SECONDS);\n+        if (timeOutMillis > maxWaitMillis) {\n+          maxWaitMillis = timeOutMillis;\n+        }\n+      }\n+\n+      long startMillis = System.currentTimeMillis();\n+      long endTimeMillis = startMillis + maxWaitMillis;\n+\n+\n+      while (System.currentTimeMillis() <= endTimeMillis) {\n+        failedValidations.clear();\n+        int passedCount = 0;\n+        // All checks must pass for one run for the validations to succeed. It's not valid if\n+        // different checks pass for different runs.\n+        for (int i = 0; i < expectations.length; i++) {\n+          // This is already initialized. Cannot be null.\n+          IValidator validator = validators[i];\n+          AExpect expect = expectations[i];\n+          AExpect.Type what = expect.what();\n+          boolean successful = false;\n+\n+          Class rca = expect.forRca();\n+\n+          switch (what) {\n+            case REST_API:\n+              successful = validator.check(testApi.getRcaDataOnHost(expect.on(), rca.getSimpleName()));\n+              if (!successful) {\n+                failedValidations.add(validator.getClass());\n+              }\n+              break;\n+          }\n+          if (successful) {\n+            passedCount += 1;\n+          }\n+        }\n+\n+        if (passedCount == expectations.length) {\n+          break;\n+        }\n+      }\n+    }\n+    // The test writer asked for no validations to be performed by the framework. So, we return success.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyNDYyMQ==", "bodyText": "random thought: it's weird that Java has a method invoke an object instead of the other way around", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468424621", "createdAt": "2020-08-11T08:47:46Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.TestEnvironment;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.Runner;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunNotifier;\n+\n+/**\n+ * This is the main runner class that is used by the RCA-IT.\n+ */\n+public abstract class RcaItRunnerBase extends Runner implements IRcaItRunner {\n+  private static final Logger LOG = LogManager.getLogger(RcaItRunnerBase.class);\n+\n+  // The class whose tests the runner is currently executing.\n+  private final Class testClass;\n+\n+  // An instance of the test class the runner is executing.\n+  private final Object testObject;\n+\n+  // This is used to set up the environment. An environment for running RCA graph would be to push the RCA graph itself,\n+  // the metrics, the rca.conf if that needs to be changed. It reads them from the annotations and sets them up for the\n+  // cluster object.\n+  private final TestEnvironment testEnvironment;\n+\n+  // An instance of the cluster where tests are running.\n+  private final Cluster cluster;\n+\n+  // This is wrapper on top of the cluster object that is passed on to the testClass to get access to the cluster.\n+  private final TestApi testApi;\n+\n+  public RcaItRunnerBase(Class testClass, boolean useHttps) throws Exception {\n+    super();\n+    this.testClass = testClass;\n+    ClusterType clusterType = getClusterTypeFromAnnotation(testClass);\n+    this.cluster = createCluster(clusterType, useHttps);\n+    this.testApi = new TestApi(cluster);\n+    this.testObject = testClass.getDeclaredConstructor().newInstance();\n+\n+    try {\n+      Method setClusterMethod = testClass.getMethod(SET_CLUSTER_METHOD, TestApi.class);\n+      setClusterMethod.setAccessible(true);\n+      setClusterMethod.invoke(testObject, testApi);\n+    } catch (NoSuchMethodException ex) {\n+      // This test class hasn't defined a method setCluster(Cluster). SO probably it does not need\n+      // access to the cluster object. Which is fine. We move on to the method execution.\n+    }\n+\n+    cluster.createServersAndThreads();\n+    try {\n+      this.testEnvironment = new TestEnvironment(cluster, testClass);\n+    } catch (Exception ex) {\n+      cluster.deleteClusterDir();\n+      ex.printStackTrace();\n+      throw ex;\n+    }\n+    cluster.startRcaControllerThread();\n+  }\n+\n+  private static ClusterType getClusterTypeFromAnnotation(Class testClass) {\n+    if (!testClass.isAnnotationPresent(AClusterType.class)) {\n+      throw new IllegalArgumentException(\n+          testClass.getSimpleName() + \" does not have the mandatory annotation: \" + AClusterType.class.getSimpleName());\n+    }\n+    return ((AClusterType) testClass.getAnnotation(AClusterType.class)).value();\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    return Description.createTestDescription(testClass, \"A custom runner for RcaIt\");\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    try {\n+      for (Method method : testClass.getMethods()) {\n+        if (method.isAnnotationPresent(Test.class)) {\n+          notifier.fireTestStarted(Description\n+              .createTestDescription(testClass, method.getName()));\n+\n+          try {\n+            this.testEnvironment.updateEnvironment(method);\n+            this.testEnvironment.verifyEnvironmentSetup();\n+          } catch (Exception ex) {\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), ex));\n+          }\n+          cluster.startRcaScheduler();\n+\n+          try {\n+            method.invoke(testObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzMTE4NA==", "bodyText": "Curious, how do we know there's only a single shard, or is this by design, or does this mean something else entirely?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468431184", "createdAt": "2020-08-11T08:58:35Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/tests/poc/SimpleAnalysisGraph.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.INDEX_NAME;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.SHARD_ID;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.CPU_Utilization;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotShardSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.ElasticSearchAnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.hotshard.IndexShardKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.jooq.Record;\n+\n+public class SimpleAnalysisGraph extends ElasticSearchAnalysisGraph {\n+  public static class NodeRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private final CPU_Utilization cpuUtilization;\n+\n+    public NodeRca(CPU_Utilization cpu_utilization) {\n+      super(1);\n+      this.cpuUtilization = cpu_utilization;\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+      final List<FlowUnitMessage> flowUnitMessages =\n+          args.getWireHopper().readFromWire(args.getNode());\n+      List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+      for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+        flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+      }\n+      setFlowUnits(flowUnitList);\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+      double maxCpu = 0;\n+      IndexShardKey indexShardKey = null;\n+      for (MetricFlowUnit metricFlowUnit : cpuUtilization.getFlowUnits()) {\n+        if (metricFlowUnit.getData() != null) {\n+          // Go through all the entries and find out the shard with the highest CPU\n+          // utilization.\n+          for (Record record : metricFlowUnit.getData()) {\n+            try {\n+              String indexName = record.getValue(INDEX_NAME.toString(), String.class);\n+              // System.out.println(record);\n+              Integer shardId = record.getValue(SHARD_ID.toString(), Integer.class);\n+              if (indexName != null && shardId != null) {\n+                double usage = record.getValue(MetricsDB.MAX, Double.class);\n+                if (usage > maxCpu) {\n+                  maxCpu = usage;\n+                  indexShardKey = IndexShardKey.buildIndexShardKey(record);\n+                }\n+              }\n+            } catch (IllegalArgumentException ex) {\n+\n+            }\n+          }\n+        }\n+      }\n+      InstanceDetails instanceDetails = getInstanceDetails();\n+      HotNodeSummary nodeSummary = new HotNodeSummary(instanceDetails.getInstanceId(),\n+          instanceDetails.getInstanceIp());\n+      ResourceFlowUnit rfu;\n+      if (indexShardKey != null) {\n+        //System.out.println(\"NodeRca running on \" + instanceDetails.getInstanceId());\n+\n+        HotShardSummary summary = new HotShardSummary(\n+            indexShardKey.getIndexName(),\n+            String.valueOf(indexShardKey.getShardId()),\n+            instanceDetails.getInstanceId().toString(),\n+            0);\n+        summary.setcpuUtilization(maxCpu);\n+        nodeSummary.appendNestedSummary(summary);\n+        rfu = new ResourceFlowUnit<>(\n+            System.currentTimeMillis(),\n+            new ResourceContext(Resources.State.UNHEALTHY),\n+            nodeSummary,\n+            true);\n+\n+        //System.out.println(\"NODE RCA: \" + rfu);\n+      } else {\n+        rfu = new ResourceFlowUnit<>(System.currentTimeMillis());\n+      }\n+      return rfu;\n+    }\n+  }\n+\n+  public static class ClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+    private final NodeRca nodeRca;\n+\n+    public ClusterRca(NodeRca nodeRca) {\n+      super(1);\n+      this.nodeRca = nodeRca;\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+      throw new IllegalArgumentException(name() + \"'s generateFlowUnitListFromWire() should not \"\n+          + \"be required.\");\n+    }\n+\n+    // The cluster level RCA goes through all the nodeLevel summaries and then picks the node\n+    // with the highest CPU and states which shard it is the highest for.\n+    @Override\n+    public ResourceFlowUnit<HotClusterSummary> operate() {\n+      final List<ResourceFlowUnit<HotNodeSummary>> resourceFlowUnits = nodeRca.getFlowUnits();\n+      HotClusterSummary summary = new HotClusterSummary(\n+          getAllClusterInstances().size(), 1);\n+\n+      final InstanceDetails.Id defaultId = new InstanceDetails.Id(\"default-id\");\n+      final InstanceDetails.Ip defaultIp = new InstanceDetails.Ip(\"1.1.1.1\");\n+\n+      InstanceDetails.Id hotNodeId = defaultId;\n+      InstanceDetails.Ip hotsNodeAddr = defaultIp;\n+      String hotShard = \"\";\n+      String hotShardIndex = \"\";\n+      double cpuUtilization = 0.0;\n+\n+      for (final ResourceFlowUnit<HotNodeSummary> resourceFlowUnit : resourceFlowUnits) {\n+        if (resourceFlowUnit.isEmpty()) {\n+          continue;\n+        }\n+        HotNodeSummary nodeSummary = resourceFlowUnit.getSummary();\n+        HotShardSummary hotShardSummary = nodeSummary.getHotShardSummaryList().get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzMzg2MA==", "bodyText": "What does this mean? I get that cluster level RCA's must be computed on the master, but what's TAG_AGGREGATE_UPSTREAM? And does a DATA_MASTER count as a MASTER?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468433860", "createdAt": "2020-08-11T09:03:17Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/tests/poc/RcaItPocSingleNode.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.INDEX_NAME_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.OPERATION_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.SHARDID_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.SHARD_ROLE_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.LOCUS_DATA_MASTER_NODE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.LOCUS_DATA_NODE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.LOCUS_MASTER_NODE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.TAG_AGGREGATE_UPSTREAM;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.TAG_LOCUS;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.CPU_Utilization;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners.RcaItNotEncryptedRunner;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc.validator.PocValidator;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(RcaItNotEncryptedRunner.class)\n+\n+@AClusterType(ClusterType.SINGLE_NODE)\n+@ARcaGraph(RcaItPocSingleNode.SimpleAnalysisGraphForCoLocated.class)\n+@AMetric(name = CPU_Utilization.class,\n+    dimensionNames = {SHARDID_VALUE, INDEX_NAME_VALUE, OPERATION_VALUE, SHARD_ROLE_VALUE},\n+    tables = {\n+        @ATable(hostTag = HostTag.DATA_0,\n+            tuple = {\n+                @ATuple(dimensionValues = {\"0\", \"logs\", \"bulk\", \"p\"},\n+                    sum = 0.0, avg = 0.0, min = 0.0, max = 0.0),\n+                @ATuple(dimensionValues = {\"1\", \"logs\", \"bulk\", \"r\"},\n+                    sum = 0.0, avg = 0.0, min = 0.0, max = 80.0),\n+                @ATuple(dimensionValues = {\"2\", \"logs\", \"bulk\", \"p\"},\n+                    sum = 0.0, avg = 0.0, min = 0.0, max = 10.0)\n+            }\n+        )\n+    }\n+)\n+public class RcaItPocSingleNode {\n+  private TestApi api;\n+\n+  @Test\n+  @AExpect(\n+      what = AExpect.Type.REST_API,\n+      on = HostTag.DATA_0,\n+      validator = PocValidator.class,\n+      forRca = SimpleAnalysisGraphForCoLocated.ClusterRca.class)\n+  public void simple() {\n+  }\n+\n+  public void setTestApi(final TestApi api) {\n+    this.api = api;\n+  }\n+\n+\n+  public static class SimpleAnalysisGraphForCoLocated extends SimpleAnalysisGraph {\n+\n+    @Override\n+    public void construct() {\n+      CPU_Utilization cpuUtilization = new CPU_Utilization(1);\n+      cpuUtilization.addTag(TAG_LOCUS, LOCUS_DATA_MASTER_NODE);\n+      addLeaf(cpuUtilization);\n+\n+      SimpleAnalysisGraph.NodeRca nodeRca = new SimpleAnalysisGraph.NodeRca(cpuUtilization);\n+      nodeRca.addTag(TAG_LOCUS, LOCUS_DATA_MASTER_NODE);\n+      nodeRca.addAllUpstreams(Arrays.asList(cpuUtilization));\n+\n+      SimpleAnalysisGraph.ClusterRca clusterRca = new SimpleAnalysisGraph.ClusterRca(nodeRca);\n+      clusterRca.addTag(TAG_LOCUS, LOCUS_MASTER_NODE);\n+      clusterRca.addAllUpstreams(Collections.singletonList(nodeRca));\n+      clusterRca.addTag(TAG_AGGREGATE_UPSTREAM, LOCUS_DATA_NODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzNTE5NA==", "bodyText": "Either this comment is incorrect or the call to object.get(\"state\") down below is incorrect", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468435194", "createdAt": "2020-08-11T09:05:37Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/tests/poc/validator/PocValidator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc.validator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import java.util.List;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+// Validators are only initialized once to evaluate a test method.\n+public class PocValidator implements IValidator {\n+  long startTime;\n+\n+  public PocValidator() {\n+    startTime = System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * {\"rca_name\":\"ClusterRca\",\n+   * \"timestamp\":1596557050522,\n+   * \"state\":\"unhealthy\",\n+   * \"HotClusterSummary\":[\n+   * {\"number_of_nodes\":1,\"number_of_unhealthy_nodes\":1}\n+   * ]}\n+   */\n+  @Override\n+  public boolean check(JsonElement response) {\n+    JsonArray array = response.getAsJsonObject().get(\"data\").getAsJsonArray();\n+    if (array.size() == 0) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < array.size(); i++) {\n+      JsonObject object = array.get(i).getAsJsonObject();\n+      if (object.get(\"rca_name\").getAsString().equals(\"ClusterRca\")) {\n+        return checkClusterRca(object);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * \"HotClusterSummary\":[{\"number_of_nodes\":1,\"number_of_unhealthy_nodes\":1}]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjY3NzMz", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#pullrequestreview-465267733", "createdAt": "2020-08-11T17:12:36Z", "commit": {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "086cdb4ef6db738c4d3c06d605bee2b324211eb9", "author": {"user": {"login": "yojs", "name": "Joydeep Sinha"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/086cdb4ef6db738c4d3c06d605bee2b324211eb9", "committedDate": "2020-08-11T17:40:51Z", "message": "Addressing PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzA5Mjkx", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#pullrequestreview-465309291", "createdAt": "2020-08-11T18:09:30Z", "commit": {"oid": "086cdb4ef6db738c4d3c06d605bee2b324211eb9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1107, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}