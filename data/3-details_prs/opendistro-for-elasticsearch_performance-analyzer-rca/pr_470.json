{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMzE1NjI1", "number": 470, "title": "Publish fault detection metrics", "bodyText": "*Fixes #:*#471\nDescription of changes: WIth this change we will start publishing metrics like Latency and failure for follower check and leader check.\nTests:\n\nTested using Docker\nTmp file\n\n^fault_detection/follower_check/6544/start\ncurrent_time:1602234524352\nSourceNodeID:c765a93a762cd59dda8d3379b09a752a\nTargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\nStartTime:1566413973072$\n^fault_detection/follower_check/7627/finish\ncurrent_time:1602234524400\nSourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\nTargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\nFinishTime:1566413986732\nerror:1$\n\nTable created\nsqlite> .tables\nLatency_FollowerCheck     \nLatency_LeaderCheck\nFailure_FollowerCheck     \nFailure_LeaderCheck     \n\nContents of the table\nsqlite> select * from Latency_FollowerCheck;\nc765a93a762cd59dda8d3379b09a752a|b2a5a93a762cd59dda8d3379b09a752a|14914.0|14914.0|14914.0|14914.0\ng52i9a93a762cd59dda8d3379b09a752a|b2a5a93a762cd59dda8d3379b09a752a|13660.0|13660.0|13660.0|13660.0\nsqlite> select * from Failure_FollowerCheck;\nc765a93a762cd59dda8d3379b09a752a|b2a5a93a762cd59dda8d3379b09a752a|0.0|0.0|0.0|0.0\ng52i9a93a762cd59dda8d3379b09a752a|b2a5a93a762cd59dda8d3379b09a752a|1.0|1.0|1.0|1.0\n\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-10-14T11:47:56Z", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470", "merged": true, "mergeCommit": {"oid": "4fbbbce7800241db1226b4105336b9ca10ac75df"}, "closed": true, "closedAt": "2020-10-22T20:28:17Z", "author": {"login": "amathur1893"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSbB9dgH2gAyNTAzMzE1NjI1OjhmZGJlYTA5NmQyYTQ0ZTI4NGRiMjYxMjI0YmRiYTIxMjcxYTcwYTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVH-n_gFqTUxNTA5Mjk3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8fdbea096d2a44e284db261224bdba21271a70a5", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8fdbea096d2a44e284db261224bdba21271a70a5", "committedDate": "2020-10-14T10:57:27Z", "message": "Publish Fault Detection Metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "867752f4de0fa7a9c1a14b21b401e0a0d808d90a", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/867752f4de0fa7a9c1a14b21b401e0a0d808d90a", "committedDate": "2020-10-14T11:12:32Z", "message": "Publish Fault Detection Metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d1f587f4950141fe228fcc86c97ab3e46523e14e", "committedDate": "2020-10-14T11:37:45Z", "message": "Publish Fault Detection Metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk0ODkw", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#pullrequestreview-510794890", "createdAt": "2020-10-16T20:59:05Z", "commit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDo1OTowNVrOHjPpDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMDozMjoyOVrOHjS56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng==", "bodyText": "we can make it error as everything else starts with a small case ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506718476", "createdAt": "2020-10-16T20:59:05Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTY2Nw==", "bodyText": "Can you help me understand why this is an error log ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506771667", "createdAt": "2020-10-17T00:30:19Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");\n+\n+        private final String fieldValue;\n+\n+        Fields(String fieldValue) {\n+            this.fieldValue = fieldValue;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return fieldValue;\n+        }\n+\n+    }\n+\n+    public FaultDetectionMetricsSnapshot(Connection conn, Long windowStartTime) {\n+        this.create = DSL.using(conn, SQLDialect.SQLITE);\n+        this.windowStartTime = windowStartTime;\n+        this.tableName = \"fault_detection_\" + windowStartTime;\n+\n+        this.columns =\n+                new ArrayList<Field<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ST.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ET.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class));\n+                    }\n+                };\n+        create.createTable(this.tableName).columns(columns).execute();\n+    }\n+\n+    public BatchBindStep startBatchPut() {\n+\n+        List<Object> dummyValues = new ArrayList<>();\n+        for (int i = 0; i < columns.size(); i++) {\n+            dummyValues.add(null);\n+        }\n+        return create.batch(create.insertInto(DSL.table(this.tableName)).values(dummyValues));\n+    }\n+\n+    @VisibleForTesting\n+    public void putStartMetric(Long startTime, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ST.toString()), Long.class), startTime)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    @VisibleForTesting\n+    public void putEndMetric(Long endTime, int error, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ET.toString()), Long.class), endTime)\n+                .set(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class), error)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    public Result<Record> fetchAll() {\n+        return create.select().from(DSL.table(this.tableName)).fetch();\n+    }\n+\n+    @Override\n+    public void remove() throws Exception {\n+        create.dropTable(DSL.table(this.tableName)).execute();\n+    }\n+\n+    public void rolloverInFlightRequests(FaultDetectionMetricsSnapshot prevSnap) {\n+        // Fetch all entries that have not ended and write to current table.\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .select(create.select().from(prevSnap.fetchInFlightRequests()))\n+                .execute();\n+    }\n+\n+    public SelectHavingStep<Record> fetchInFlightRequests() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                    }\n+                };\n+\n+        return create\n+                .select(fields)\n+                .from(groupByRidAndTypeSelect())\n+                .where(\n+                        DSL.field(Fields.ST.toString())\n+                                .isNotNull()\n+                                .and(DSL.field(Fields.ET.toString()).isNull())\n+                                .and(DSL.field(Fields.ST.toString()).gt(this.windowStartTime - EXPIRE_AFTER)));\n+    }\n+\n+    public SelectHavingStep<Record> groupByRidAndTypeSelect() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ST.toString(), Long.class)).as(DSL.name(Fields.ST.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ET.toString(), Long.class)).as(DSL.name(Fields.ET.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ERROR.toString(), Integer.class)).as(DSL.name(Fields.ERROR.toString())));\n+        LOG.error(\"Initial - \" + fetchAll().size());\n+        LOG.error(\"Breakdown 1 - \" + create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString())).fetch().size());\n+        return create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString()));\n+    }\n+\n+    public SelectHavingStep<Record> fetchLatencyTable() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ERROR.toString(), Integer.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.field(Fields.ET.toString())\n+                        .minus(DSL.field(Fields.ST.toString()))\n+                        .as(DSL.name(Fields.LAT.toString())));\n+        LOG.error(\"Breakdown 2 - \" + create", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTk0NQ==", "bodyText": "Do we need to add a new snapshot type or we can re-use the MASTER_EVENT_SNAPSHOTS here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506771945", "createdAt": "2020-10-17T00:32:29Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTgxODg5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#pullrequestreview-512181889", "createdAt": "2020-10-19T21:44:22Z", "commit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NDoyMlrOHkixrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjo0MTowOVrOHkkNaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDU1Ng==", "bodyText": "Minor naming suggestion. Can we use FOLLOWER_CHECK_LATENCY and similarly LATENCY and FAILURE as suffix instead of prefix ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508080556", "createdAt": "2020-10-19T21:44:22Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDk2MQ==", "bodyText": "An extension of above comment, use FollowerCheck_Latency ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508080961", "createdAt": "2020-10-19T21:45:13Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+\n+    private final String value;\n+\n+    FaultDetectionMetric(String value) {\n+      this.value = value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return value;\n+    }\n+\n+    public static class Constants {\n+      public static final String LATENCY_FOLLOWER_CHECK = \"Latency_FollowerCheck\";\n+      public static final String LATENCY_LEADER_CHECK = \"Latency_LeaderCheck\";\n+      public static final String FAILURE_FOLLOWER_CHECK = \"Failure_FollowerCheck\";\n+      public static final String FAILURE_LEADER_CHECK = \"Failure_LeaderCheck\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTI5Mg==", "bodyText": "Generic variable name, where do we intend to use this ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081292", "createdAt": "2020-10-19T21:45:54Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java", "diffHunk": "@@ -60,6 +61,9 @@\n   public static final String MASTER_CURRENT = \"current\";\n   public static final String MASTER_META_DATA = \"metadata\";\n   public static final String METRIC_CURRENT_TIME = \"current_time\";\n+  public static final String FAULT_DETECTION_FOLLOWER_CHECK = \"follower_check\";\n+  public static final String FAULT_DETECTION_LEADER_CHECK = \"leader_check\";\n+  public static final String ERROR = \"error\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTYxOA==", "bodyText": "Can we fix the indentation here?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081618", "createdAt": "2020-10-19T21:46:37Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java", "diffHunk": "@@ -340,6 +340,26 @@\n         new MetricAttributes(\n             MetricUnits.MILLISECOND.toString(), AllMetrics.MasterMetricDimensions.values()));\n \n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTg1Mg==", "bodyText": "Missing License information.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081852", "createdAt": "2020-10-19T21:47:06Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MjA4Mw==", "bodyText": "nit: Let's move faultDetectionMetricsMap to next line.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508082083", "createdAt": "2020-10-19T21:47:36Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4NzY4OQ==", "bodyText": "I assume the keyItems or event.key will always have the expected values an index 0 and 3 here ?\nWhat happens if keyItems[3] throws an ArrayIndexOutOfBounds Exception?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508087689", "createdAt": "2020-10-19T22:00:07Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4OTYzNA==", "bodyText": "Let us either make this a java doc string or movie this multi-line comment to inside the function.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508089634", "createdAt": "2020-10-19T22:04:41Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDIzNw==", "bodyText": "Import AllMetrics.FaultDetectionDimension instead of AllMetrics ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508090237", "createdAt": "2020-10-19T22:06:10Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDcxOA==", "bodyText": "Let's movie this line to within the try block, after line 103", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508090718", "createdAt": "2020-10-19T22:07:13Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTQ0Nw==", "bodyText": "similar, move this to within try block after line 133", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091447", "createdAt": "2020-10-19T22:09:00Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];\n+        try {\n+            long st = Long.parseLong(startTimeVal);\n+            // A keyItem is of the form : [fault_detection, follower_check, 76543, start]\n+            String rid = keyItems[2];\n+            handle.bind(rid, sourceNodeId, targetNodeId, fault_detection_type, st, null, 0);\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Unable to parse string. StartTime:{}\", startTimeVal);\n+            StatsCollector.instance().logException(StatExceptionCode.READER_PARSER_ERROR);\n+            throw e;\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, finish]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // FinishTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // Error:0\n+    // $\n+    private void emitFinishMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String finishTimeVal = keyValueMap.get(AllMetrics.CommonMetric.FINISH_TIME.toString());\n+        String errorString = keyValueMap.get(PerformanceAnalyzerMetrics.ERROR);\n+        String fault_detection_type = keyItems[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUzMw==", "bodyText": "Missing License information.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091533", "createdAt": "2020-10-19T22:09:11Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTg3MA==", "bodyText": "Missing License information.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091870", "createdAt": "2020-10-19T22:09:57Z", "author": {"login": "khushbr"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjEyNA==", "bodyText": "nit: Can we fix the Indentation here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092124", "createdAt": "2020-10-19T22:10:38Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -119,6 +121,7 @@ public ReaderMetricsProcessor(String rootLocation, boolean processNewFormat, fin\n     shardRqMetricsMap = new TreeMap<>();\n     httpRqMetricsMap = new TreeMap<>();\n     masterEventMetricsMap = new TreeMap<>();\n+\tfaultDetectionMetricsMap = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjM4Ng==", "bodyText": "nit: Can we fix the Indentation here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092386", "createdAt": "2020-10-19T22:11:16Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjY1MQ==", "bodyText": "nit: Can we fix the Indentation here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092651", "createdAt": "2020-10-19T22:11:54Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -540,6 +559,7 @@ is ready so it starts to read that file (go back two windows and\n     eventDispatcher.registerEventProcessor(nodeEventsProcessor);\n     eventDispatcher.registerEventProcessor(masterEventsProcessor);\n     eventDispatcher.registerEventProcessor(clusterDetailsEventsProcessor);\n+\teventDispatcher.registerEventProcessor(faultDetectionProcessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Mjk2OQ==", "bodyText": "Is this required ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092969", "createdAt": "2020-10-19T22:12:45Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MzQ1NA==", "bodyText": "Let's import AllMetrics.FaultDetectionDimension explicitly here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508093454", "createdAt": "2020-10-19T22:14:01Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -22,6 +22,7 @@\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoValue;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.OSMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDc4NA==", "bodyText": "Replace this with List<String> dimensionNames = snap.getDimensionNames(); ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508100784", "createdAt": "2020-10-19T22:32:27Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTM4Mw==", "bodyText": "Redundant ? We can use the dimensions defined on line 855", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508101383", "createdAt": "2020-10-19T22:34:05Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTUzMw==", "bodyText": "Replace dims with dimensions ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508101533", "createdAt": "2020-10-19T22:34:29Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };\n+\n+      db.createMetric(\n+              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+              dims);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwNDA0MQ==", "bodyText": "Are the latest set of changes pushed ?  I do not see fault here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508104041", "createdAt": "2020-10-19T22:41:09Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/c4bd77f5ef2fb00f7c675c5042b5c680d420fbab", "committedDate": "2020-10-21T16:27:10Z", "message": "Taking upstream changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e01f059f96038d2cab40090cab653175271e9d7f", "author": {"user": null}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/e01f059f96038d2cab40090cab653175271e9d7f", "committedDate": "2020-10-21T17:46:36Z", "message": "Publish Fault Detection Metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDM3MDM5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#pullrequestreview-514037039", "createdAt": "2020-10-21T18:00:46Z", "commit": {"oid": "e01f059f96038d2cab40090cab653175271e9d7f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDkyOTc0", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#pullrequestreview-515092974", "createdAt": "2020-10-22T20:27:23Z", "commit": {"oid": "e01f059f96038d2cab40090cab653175271e9d7f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 787, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}