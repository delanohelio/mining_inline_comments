{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MDE1ODA1", "number": 366, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTozODoyMFrOEXzvvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0ODowMlrOEYMDEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAwNTA5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/store/collector/NodeConfigCollectorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTozODoyMFrOG_zxgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo1ODowMVrOG_0SFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTczMA==", "bodyText": "let's read node key from getInstanceDetails instead of hardcoding it", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r469561730", "createdAt": "2020-08-12T21:38:20Z", "author": {"login": "rguo-aws"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/store/collector/NodeConfigCollectorTest.java", "diffHunk": "@@ -53,12 +56,14 @@ public void init() {\n     cacheMaxSize = new Cache_Max_Size(5);\n     heapMax = new Heap_Max(5);\n     nodeConfigCollector = new NodeConfigCollector(1, threadPool_QueueCapacity, cacheMaxSize, heapMax);\n+    nodeKey = new NodeKey(new InstanceDetails.Id(\"node1\"), new InstanceDetails.Ip(\"127.0.0.0\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "304b32c7431ab4bca0521cdb7fa5cfe74709f645"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3MDA3MA==", "bodyText": "Done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r469570070", "createdAt": "2020-08-12T21:58:01Z", "author": {"login": "sruti1312"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/store/collector/NodeConfigCollectorTest.java", "diffHunk": "@@ -53,12 +56,14 @@ public void init() {\n     cacheMaxSize = new Cache_Max_Size(5);\n     heapMax = new Heap_Max(5);\n     nodeConfigCollector = new NodeConfigCollector(1, threadPool_QueueCapacity, cacheMaxSize, heapMax);\n+    nodeKey = new NodeKey(new InstanceDetails.Id(\"node1\"), new InstanceDetails.Ip(\"127.0.0.0\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTczMA=="}, "originalCommit": {"oid": "304b32c7431ab4bca0521cdb7fa5cfe74709f645"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAxODg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo0MzowNVrOG_z5yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMjowMjozMlrOG_5XVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mzg0OQ==", "bodyText": "can we update the cache once the metric is received from flowunit ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r469563849", "createdAt": "2020-08-12T21:43:05Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "diffHunk": "@@ -141,6 +146,8 @@ public NodeConfigFlowUnit operate() {\n       }\n       collectHeapMaxSize(flowUnit);\n     }\n+\n+    addConfigToNodeCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "304b32c7431ab4bca0521cdb7fa5cfe74709f645"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NDI2Mg==", "bodyText": "let us also take this opportunity to remove configResult hashmap from this collector. there is no need to store configs into both node config cache / hashmap", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r469564262", "createdAt": "2020-08-12T21:44:07Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "diffHunk": "@@ -141,6 +146,8 @@ public NodeConfigFlowUnit operate() {\n       }\n       collectHeapMaxSize(flowUnit);\n     }\n+\n+    addConfigToNodeCache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mzg0OQ=="}, "originalCommit": {"oid": "304b32c7431ab4bca0521cdb7fa5cfe74709f645"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY1MzMzMg==", "bodyText": "Updating it once the metric is received from flowunit. Makes sense to also have configMap as it can be used to collect and add to flow units", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r469653332", "createdAt": "2020-08-13T02:02:32Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "diffHunk": "@@ -141,6 +146,8 @@ public NodeConfigFlowUnit operate() {\n       }\n       collectHeapMaxSize(flowUnit);\n     }\n+\n+    addConfigToNodeCache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mzg0OQ=="}, "originalCommit": {"oid": "304b32c7431ab4bca0521cdb7fa5cfe74709f645"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzk4Njc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0ODowM1rOHAZBiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDozNTozNVrOHAcsjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MjA0Mw==", "bodyText": "can move this inside the if block.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r470172043", "createdAt": "2020-08-13T18:48:03Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "diffHunk": "@@ -65,52 +64,40 @@ public NodeConfigCollector(int rcaPeriod,\n   }\n \n   private void collectQueueCapacity(MetricFlowUnit flowUnit) {\n-    double writeQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+    final double writeQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n         THREAD_POOL_TYPE.getField(), ThreadPoolType.WRITE.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(writeQueueCapacity)) {\n-      configResult.put(ResourceUtil.WRITE_QUEUE_CAPACITY, writeQueueCapacity);\n-    }\n-    else {\n-      LOG.error(\"write queue capacity is NaN\");\n-    }\n-    double searchQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+    collectAndPublishMetric(ResourceUtil.WRITE_QUEUE_CAPACITY, writeQueueCapacity);\n+\n+    final double searchQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n         THREAD_POOL_TYPE.getField(), ThreadPoolType.SEARCH.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(searchQueueCapacity)) {\n-      configResult.put(ResourceUtil.SEARCH_QUEUE_CAPACITY, searchQueueCapacity);\n-    }\n-    else {\n-      LOG.error(\"search queue capacity is NaN\");\n-    }\n+    collectAndPublishMetric(ResourceUtil.SEARCH_QUEUE_CAPACITY, searchQueueCapacity);\n   }\n \n   private void collectCacheMaxSize(MetricFlowUnit cacheMaxSize) {\n-    double fieldDataCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n+    final double fieldDataCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n             CACHE_TYPE.getField(), CacheType.FIELD_DATA_CACHE.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(fieldDataCacheMaxSize)) {\n-      configResult.put(ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE, fieldDataCacheMaxSize);\n-    }\n-    else {\n-      LOG.error(\"Field Data cache max size is NaN\");\n-    }\n+    collectAndPublishMetric(ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE, fieldDataCacheMaxSize);\n \n-    double shardRequestCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n+    final double shardRequestCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n             CACHE_TYPE.getField(), CacheType.SHARD_REQUEST_CACHE.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(shardRequestCacheMaxSize)) {\n-      configResult.put(ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE, shardRequestCacheMaxSize);\n-    }\n-    else {\n-      LOG.error(\"Shard Request cache max size is NaN\");\n-    }\n+    collectAndPublishMetric(ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE, shardRequestCacheMaxSize);\n   }\n \n   private void collectHeapMaxSize(MetricFlowUnit heapMax) {\n-    double heapMaxSize = SQLParsingUtil.readDataFromSqlResult(heapMax.getData(),\n+    final double heapMaxSize = SQLParsingUtil.readDataFromSqlResult(heapMax.getData(),\n             MEM_TYPE.getField(), AllMetrics.GCType.HEAP.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(heapMaxSize)) {\n-      configResult.put(ResourceUtil.HEAP_MAX_SIZE, heapMaxSize);\n+    collectAndPublishMetric(ResourceUtil.HEAP_MAX_SIZE, heapMaxSize);\n+  }\n+\n+  private void collectAndPublishMetric(final Resource resource, final double metricValue) {\n+    final NodeConfigCache nodeConfigCache = getAppContext().getNodeConfigCache();\n+    final NodeKey esNode = new NodeKey(getAppContext().getMyInstanceDetails());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aeb51ca044abe0a08db6d2a41d2f2aa4696d80b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMjIwNw==", "bodyText": "Done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/366#discussion_r470232207", "createdAt": "2020-08-13T20:35:35Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCollector.java", "diffHunk": "@@ -65,52 +64,40 @@ public NodeConfigCollector(int rcaPeriod,\n   }\n \n   private void collectQueueCapacity(MetricFlowUnit flowUnit) {\n-    double writeQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+    final double writeQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n         THREAD_POOL_TYPE.getField(), ThreadPoolType.WRITE.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(writeQueueCapacity)) {\n-      configResult.put(ResourceUtil.WRITE_QUEUE_CAPACITY, writeQueueCapacity);\n-    }\n-    else {\n-      LOG.error(\"write queue capacity is NaN\");\n-    }\n-    double searchQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n+    collectAndPublishMetric(ResourceUtil.WRITE_QUEUE_CAPACITY, writeQueueCapacity);\n+\n+    final double searchQueueCapacity = SQLParsingUtil.readDataFromSqlResult(flowUnit.getData(),\n         THREAD_POOL_TYPE.getField(), ThreadPoolType.SEARCH.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(searchQueueCapacity)) {\n-      configResult.put(ResourceUtil.SEARCH_QUEUE_CAPACITY, searchQueueCapacity);\n-    }\n-    else {\n-      LOG.error(\"search queue capacity is NaN\");\n-    }\n+    collectAndPublishMetric(ResourceUtil.SEARCH_QUEUE_CAPACITY, searchQueueCapacity);\n   }\n \n   private void collectCacheMaxSize(MetricFlowUnit cacheMaxSize) {\n-    double fieldDataCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n+    final double fieldDataCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n             CACHE_TYPE.getField(), CacheType.FIELD_DATA_CACHE.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(fieldDataCacheMaxSize)) {\n-      configResult.put(ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE, fieldDataCacheMaxSize);\n-    }\n-    else {\n-      LOG.error(\"Field Data cache max size is NaN\");\n-    }\n+    collectAndPublishMetric(ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE, fieldDataCacheMaxSize);\n \n-    double shardRequestCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n+    final double shardRequestCacheMaxSize = SQLParsingUtil.readDataFromSqlResult(cacheMaxSize.getData(),\n             CACHE_TYPE.getField(), CacheType.SHARD_REQUEST_CACHE.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(shardRequestCacheMaxSize)) {\n-      configResult.put(ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE, shardRequestCacheMaxSize);\n-    }\n-    else {\n-      LOG.error(\"Shard Request cache max size is NaN\");\n-    }\n+    collectAndPublishMetric(ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE, shardRequestCacheMaxSize);\n   }\n \n   private void collectHeapMaxSize(MetricFlowUnit heapMax) {\n-    double heapMaxSize = SQLParsingUtil.readDataFromSqlResult(heapMax.getData(),\n+    final double heapMaxSize = SQLParsingUtil.readDataFromSqlResult(heapMax.getData(),\n             MEM_TYPE.getField(), AllMetrics.GCType.HEAP.toString(), MetricsDB.MAX);\n-    if (!Double.isNaN(heapMaxSize)) {\n-      configResult.put(ResourceUtil.HEAP_MAX_SIZE, heapMaxSize);\n+    collectAndPublishMetric(ResourceUtil.HEAP_MAX_SIZE, heapMaxSize);\n+  }\n+\n+  private void collectAndPublishMetric(final Resource resource, final double metricValue) {\n+    final NodeConfigCache nodeConfigCache = getAppContext().getNodeConfigCache();\n+    final NodeKey esNode = new NodeKey(getAppContext().getMyInstanceDetails());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MjA0Mw=="}, "originalCommit": {"oid": "7aeb51ca044abe0a08db6d2a41d2f2aa4696d80b"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2352, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}