{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NzczODk0", "number": 407, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjozNjoxMFrOEfGpwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzozMTozMVrOEfjy5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUwMzA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjozNjoxMFrOHLKmDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoxMTowOFrOHLLTdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTk2Ng==", "bodyText": "This read method is not added in the PersistorBase class.\nThis logic can be moved to the PersistorBase class? It can follow similar structure that write uses. read and readImpl methods. With read implemented in PersistorBase and readImpl in persistors?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481469966", "createdAt": "2020-09-01T22:36:10Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +217,345 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> T read(Class<T> clz)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fbc9362d307800ba94fc1418a5394296f16a9ac"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4MTU4OA==", "bodyText": "PersistorBase is supposed to be DB agnostic. So, tomorrow we can have a levelDB persistor instead of SQLite and even then PersistorBase would take care of file rotation and gc etc.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481481588", "createdAt": "2020-09-01T23:11:08Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +217,345 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> T read(Class<T> clz)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTk2Ng=="}, "originalCommit": {"oid": "9fbc9362d307800ba94fc1418a5394296f16a9ac"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUyODczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo0NzozNlrOHLK1Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoxMjozM1rOHLLVHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3Mzg2Mw==", "bodyText": "Is this more of an warning?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481473863", "createdAt": "2020-09-01T22:47:36Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4MjAxMw==", "bodyText": "This is error because we don't have have the chained table to completely fill up the Object. We messed up writing data. That's why it is error", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481482013", "createdAt": "2020-09-01T23:12:33Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3Mzg2Mw=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUzMzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo0OTozNFrOHLK36w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzozNzoxNFrOHLL0AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDUzOQ==", "bodyText": "Can we add a statement when throwing this. Might be more informative when debugging", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481474539", "createdAt": "2020-09-01T22:49:34Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4OTkyMA==", "bodyText": "Good point. In the latest revision, this has been removed.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481489920", "createdAt": "2020-09-01T23:37:14Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDUzOQ=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUzOTYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo1MjozN1rOHLK7vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjo1ODowMVrOHL4f9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg==", "bodyText": "Quick check if name is not empty and length is more than 1 character?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481475516", "createdAt": "2020-09-01T22:52:37Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethod(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check method: \" + method.getName());\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDMyMw==", "bodyText": "So what this intends to do is convert x to 'X' or 'camelCaseX' to 'CamelCaseX'. So capitalize the first character. Do you mean I should check for this ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481490323", "createdAt": "2020-09-01T23:38:39Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethod(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check method: \" + method.getName());\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU1MTA5OA==", "bodyText": "Check for length > 1 inorder to avoid IndexOutOfBoundsException", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481551098", "createdAt": "2020-09-02T02:05:28Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethod(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check method: \" + method.getName());\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyMjA2OA==", "bodyText": "JDk handles it but you are right, we can skip the call to that function for a single-lettered-field.\npublic String substring(int beginIndex) {\n        ..\n        if (beginIndex == 0) {\n            return this;\n        }\n        ...\n    }", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482222068", "createdAt": "2020-09-02T16:58:01Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethod(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check method: \" + method.getName());\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTUxNg=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDU0MTg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo1Mzo1MVrOHLK9Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzo0MDo0NFrOHLL4IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTg3NQ==", "bodyText": "Any reason why this is static? I might be missing something", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481475875", "createdAt": "2020-09-01T22:53:51Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MDk3Nw==", "bodyText": "This depends on no member of this class and it does not modify any member of the instance. Therefore, I kept it as static.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481490977", "createdAt": "2020-09-01T23:40:44Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +220,363 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rodID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          ParameterizedType type = (ParameterizedType) setter.getGenericParameterTypes()[0];\n+          Type[] typeArgs = type.getActualTypeArguments();\n+          if (typeArgs.length != 1) {\n+            throw new IllegalStateException();\n+          }\n+\n+          Class<?> collectionOfType = (Class<?>) typeArgs[0];\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // ReferenceObjectType\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+\n+          int nestedRowId = (int)jooqField.getValue(record);\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTg3NQ=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDU2NTQ0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzowNDoyMlrOHLLKxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDozNzozMFrOHLM30A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3OTM2Ng==", "bodyText": "Can we rename this class as say PersistorTestExample or MockPersistorInput?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481479366", "createdAt": "2020-09-01T23:04:22Z", "author": {"login": "sruti1312"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck1.TestPersist;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class SqliteObjectPersistor {\n+  private Path testLocation = null;\n+  private final String baseFilename = \"rca.test.file\";\n+\n+  @Before\n+  public void init() throws IOException {\n+    String cwd = System.getProperty(\"user.dir\");\n+    testLocation = Paths.get(cwd, \"src\", \"test\", \"resources\", \"tmp\", \"file_rotate\");\n+    Files.createDirectories(testLocation);\n+    FileUtils.cleanDirectory(testLocation.toFile());\n+  }\n+\n+  @After\n+  public void cleanup() throws IOException {\n+    FileUtils.cleanDirectory(testLocation.toFile());\n+  }\n+\n+  @Test\n+  public void testWriteObject() throws Exception {\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    Outer outer = new Outer();\n+    sqlite.write(outer);\n+\n+    Outer outerOut = sqlite.read(Outer.class);\n+\n+    Assert.assertEquals(outer.x, outerOut.x);\n+    Assert.assertEquals(outer.name, outerOut.name);\n+    Assert.assertEquals(outer.bObj.x, outerOut.bObj.x, 0.01);\n+  }\n+\n+  /**\n+   * This test checks that we get a null Object in case the Database is created but it does not contain table with the object data we are\n+   * asking for.\n+   */\n+  @Test\n+  public void testNoData()\n+      throws IOException, SQLException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    Assert.assertNull(sqlite.read(Outer.class));\n+  }\n+\n+  @Rule\n+  public ExpectedException exceptionRule = ExpectedException.none();\n+\n+  @Test\n+  public void persistTwoClassesWithSameName() throws Exception {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\"There is already a table in the Database with the same name\");\n+\n+    TestPersist testPersist1 = new TestPersist();\n+    com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck2.TestPersist testPersist2 =\n+        new com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck2.TestPersist();\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(testPersist1);\n+    sqlite.write(testPersist2);\n+  }\n+\n+  @Test\n+  public void testObjectWithNoGetters()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"Could not find 'getter' for the field 'x' of class\");\n+\n+    class NoGetter {\n+      @ValueColumn\n+      int x;\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new NoGetter());\n+  }\n+\n+  @Test\n+  public void testGetterReturnMismatch()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"The return type of the getter 'getX' (class java.lang.Integer) and field 'x' (int) don't match.\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      public Integer getX() {\n+        return x;\n+      }\n+\n+      public void setX(int x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testSetterArgTypeMismatch()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"Could not find 'setter' for the field 'x' of class\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      public int getX() {\n+        return x;\n+      }\n+\n+      public void setX(Integer x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testNonPublicGetterSetter()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\"Found 'getX'. But it is not public\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      int getX() {\n+        return x;\n+      }\n+\n+      public void setX(Integer x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testNoPersistableFields()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\n+        \"NotPersistable was asked to be persisted but there are no fields with annotations: ValueColumn or RefColumn\");\n+    class NotPersistable {\n+      int x;\n+    }\n+    \n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new NotPersistable());\n+  }\n+\n+  static class Outer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzI4MA==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r481507280", "createdAt": "2020-09-02T00:37:30Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SqliteObjectPersistor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck1.TestPersist;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class SqliteObjectPersistor {\n+  private Path testLocation = null;\n+  private final String baseFilename = \"rca.test.file\";\n+\n+  @Before\n+  public void init() throws IOException {\n+    String cwd = System.getProperty(\"user.dir\");\n+    testLocation = Paths.get(cwd, \"src\", \"test\", \"resources\", \"tmp\", \"file_rotate\");\n+    Files.createDirectories(testLocation);\n+    FileUtils.cleanDirectory(testLocation.toFile());\n+  }\n+\n+  @After\n+  public void cleanup() throws IOException {\n+    FileUtils.cleanDirectory(testLocation.toFile());\n+  }\n+\n+  @Test\n+  public void testWriteObject() throws Exception {\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    Outer outer = new Outer();\n+    sqlite.write(outer);\n+\n+    Outer outerOut = sqlite.read(Outer.class);\n+\n+    Assert.assertEquals(outer.x, outerOut.x);\n+    Assert.assertEquals(outer.name, outerOut.name);\n+    Assert.assertEquals(outer.bObj.x, outerOut.bObj.x, 0.01);\n+  }\n+\n+  /**\n+   * This test checks that we get a null Object in case the Database is created but it does not contain table with the object data we are\n+   * asking for.\n+   */\n+  @Test\n+  public void testNoData()\n+      throws IOException, SQLException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    Assert.assertNull(sqlite.read(Outer.class));\n+  }\n+\n+  @Rule\n+  public ExpectedException exceptionRule = ExpectedException.none();\n+\n+  @Test\n+  public void persistTwoClassesWithSameName() throws Exception {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\"There is already a table in the Database with the same name\");\n+\n+    TestPersist testPersist1 = new TestPersist();\n+    com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck2.TestPersist testPersist2 =\n+        new com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.persistence.pck2.TestPersist();\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(testPersist1);\n+    sqlite.write(testPersist2);\n+  }\n+\n+  @Test\n+  public void testObjectWithNoGetters()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"Could not find 'getter' for the field 'x' of class\");\n+\n+    class NoGetter {\n+      @ValueColumn\n+      int x;\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new NoGetter());\n+  }\n+\n+  @Test\n+  public void testGetterReturnMismatch()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"The return type of the getter 'getX' (class java.lang.Integer) and field 'x' (int) don't match.\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      public Integer getX() {\n+        return x;\n+      }\n+\n+      public void setX(int x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testSetterArgTypeMismatch()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(NoSuchMethodException.class);\n+    exceptionRule.expectMessage(\"Could not find 'setter' for the field 'x' of class\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      public int getX() {\n+        return x;\n+      }\n+\n+      public void setX(Integer x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testNonPublicGetterSetter()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\"Found 'getX'. But it is not public\");\n+    class TypeMismatch {\n+      @ValueColumn\n+      int x;\n+\n+      int getX() {\n+        return x;\n+      }\n+\n+      public void setX(Integer x) {\n+        this.x = x;\n+      }\n+    }\n+\n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new TypeMismatch());\n+  }\n+\n+  @Test\n+  public void testNoPersistableFields()\n+      throws IOException, SQLException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n+    exceptionRule.expect(IllegalStateException.class);\n+    exceptionRule.expectMessage(\n+        \"NotPersistable was asked to be persisted but there are no fields with annotations: ValueColumn or RefColumn\");\n+    class NotPersistable {\n+      int x;\n+    }\n+    \n+    SQLitePersistor sqlite = new SQLitePersistor(\n+        testLocation.toString(), baseFilename, String.valueOf(1), TimeUnit.SECONDS, 1);\n+    sqlite.write(new NotPersistable());\n+  }\n+\n+  static class Outer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3OTM2Ng=="}, "originalCommit": {"oid": "7b79151d413397efdeae7475be142302617526f9"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTIyNzUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxNzozNFrOHL5cjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMToyMjoxMFrOHMIi2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNzU4MA==", "bodyText": "I still think we should not use class name directly as the table name.\nFor example, if we wants to persist rca flowunit of different types, how are we going to persist them into a same table (i.e. RCA table) ?\nThis also applies to remediation actions, in that case all remediation actions (cache actions, queue actions) will be persisted into a single table\nOr should we create a base class for persister to use in that case ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482237580", "createdAt": "2020-09-02T17:17:34Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +221,426 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        // get the row with the provided rowId.\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rowID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        // If the name of the column starts with the prefix, then it is a reference Column. It means that the value contained in this\n+        // column references to a particular RowIDs in the table with name same as this column(with prefix removed).\n+        // There are two forms of this:\n+        // - It can be a reference to another table, in which case the column is an integer type.\n+        // - OR it is a collection of RowIDs from multiple tables, in which case the column type a JsonArray as String. e.g.\n+        //    [{\\\"tableName\\\":\\\"ITestImpl2\\\",\\\"rowIds\\\":[1]},{\\\"tableName\\\":\\\"ITestImpl1\\\",\\\"rowIds\\\":[1,2]}]\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // This references a row in a table.\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          if (setter.getParameterTypes().length != 1) {\n+            throw new IllegalStateException(\"A setter \" + setter.getName() + \" of class \" + clz.getSimpleName()\n+                + \" accepts more than one arguments.\");\n+          }\n+\n+          // This gives the type of the setter parameter.\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+          int nestedRowId = (int)jooqField.getValue(record);\n+\n+          // Now that we have the Type of the parameter and the rowID specifying the data the object\n+          // is to be filled with; we call the read method recursively to create the referenced Object\n+          // and then invoke the setter with it.\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethodReturn(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    return getFirstTypeFromParameterizedTypes(mtype, method.getName());\n+  }\n+\n+  private Class<?> getGenericFieldType(java.lang.reflect.Field field) {\n+    ParameterizedType mtype = (ParameterizedType) field.getGenericType();\n+    return getFirstTypeFromParameterizedTypes(mtype, field.getName());\n+  }\n+\n+  private Class<?> getFirstTypeFromParameterizedTypes(ParameterizedType mtype, String name) {\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check field/method: \" + name);\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    if (name.length() == 1) {\n+      return name.toUpperCase();\n+    }\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);\n+  }\n+\n+  private void checkValidType(java.lang.reflect.Field field, Class<?> clz) {\n+    Type type = field.getGenericType();\n+    Annotation[] annotation = field.getAnnotations();\n+    StringBuilder err = new StringBuilder();\n+    err.append(\"[class: \").append(clz.getSimpleName()).append(\":field:\").append(field.getName()).append(\"]::\");\n+\n+    if (annotation.length != 1) {\n+      err\n+          .append(\"A field can have either \")\n+          .append(ValueColumn.class.getSimpleName())\n+          .append(\" or \")\n+          .append(RefColumn.class.getSimpleName())\n+          .append(\" not both\");\n+      throw new IllegalStateException(err.toString());\n+    }\n+\n+    if (annotation[0].annotationType() == RefColumn.class) {\n+      if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Class<?> actualType = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+        if (actualType.isPrimitive() || actualType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      } else {\n+        Class<?> justType = field.getType();\n+        if (justType.isPrimitive() || justType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      }\n+    } else {\n+      if (type instanceof ParameterizedType) {\n+        // TODO: This will be added if use-cases require this.\n+        err.append(\"persisting Primitives or Strings as Parameterized Types is not supported.\");\n+        throw new IllegalStateException(err.toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Go over all the fields of the class and then filter out all that are annotated as @AColumn or @ATable. For those fields,\n+   * try to figure out the getter and setters.\n+   * @param clz The class whose field registry is to be created.\n+   * @param <T> The Generic type of the class.\n+   * @throws IllegalStateException When getters and setters are not found for the field that is required to be persisted or they exist but\n+   *     are not public.\n+   */\n+  private <T> void createFieldRegistry(Class<T> clz) throws IllegalStateException, NoSuchMethodException {\n+    fieldGetterSetterPairsMap.putIfAbsent(clz, new HashMap<>());\n+    classFieldNamesToGetterSetterMap.putIfAbsent(clz, new HashMap<>());\n+\n+    Map<java.lang.reflect.Field, GetterSetterPairs> fieldToGetterSetterMap = fieldGetterSetterPairsMap.get(clz);\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    for (java.lang.reflect.Field field : clz.getDeclaredFields()) {\n+      if (field.isAnnotationPresent(ValueColumn.class) || field.isAnnotationPresent(RefColumn.class)) {\n+        checkValidType(field, clz);\n+        // Now we try to find the corresponding Getter and Setter for this field.\n+        GetterSetterPairs pair = new GetterSetterPairs();\n+\n+        String capitalizedFieldName = capitalize(field.getName());\n+        for (String prefix: GETTER_PREFIXES) {\n+          String key = prefix + capitalizedFieldName;\n+          Method method;\n+          try {\n+            method = clz.getDeclaredMethod(key);\n+          } catch (NoSuchMethodException nom) {\n+            continue;\n+          }\n+          if (method.getReturnType() != field.getType()) {\n+            StringBuilder sb = new StringBuilder(\"The return type of the getter '\");\n+            sb.append(key)\n+                .append(\"' (\")\n+                .append(method.getReturnType())\n+                .append(\") and field '\")\n+                .append(field.getName())\n+                .append(\"' (\")\n+                .append(field.getType())\n+                .append(\") don't match.\");\n+            throw new NoSuchMethodException(sb.toString());\n+          }\n+          checkPublic(method);\n+          pair.getter = method;\n+          break;\n+        }\n+        for (String prefix: SETTER_PREFIXES) {\n+          String key = prefix + capitalizedFieldName;\n+          try {\n+            // This line will throw if no method with the name exists or if a method with such name exists\n+            // but the method argument types are not the same. Remember, int and Integer are not the same\n+            // types.\n+            Method method = clz.getDeclaredMethod(key, field.getType());\n+            checkPublic(method);\n+            pair.setter = method;\n+            break;\n+          } catch (NoSuchMethodException e) {\n+          }\n+        }\n+        if (pair.getter == null) {\n+          throw new NoSuchMethodException(getNoGetterSetterExist(clz, field, GetterOrSetter.GETTER));\n+        }\n+        if (pair.setter == null) {\n+          throw new NoSuchMethodException(getNoGetterSetterExist(clz, field, GetterOrSetter.SETTER));\n+        }\n+        fieldToGetterSetterMap.put(field, pair);\n+        fieldNameToGetterSetterMap.put(field.getName(), pair);\n+      }\n+    }\n+  }\n+\n+  private String getNoGetterSetterExist(Class<?> clz, java.lang.reflect.Field field, GetterOrSetter getterOrSetter) {\n+    String type;\n+    switch (getterOrSetter) {\n+      case GETTER:\n+        type = \"getter\";\n+        break;\n+      case SETTER:\n+        type = \"setter\";\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unrecognized type: \" + getterOrSetter);\n+    }\n+\n+    StringBuilder sb = new StringBuilder(\"Could not find '\");\n+    sb.append(type)\n+        .append(\"' for the field '\")\n+        .append(field.getName())\n+        .append(\"' of class '\")\n+        .append(clz.getName())\n+        .append(\"'. Getters are expected to start with 'get' or 'is' and setters are expected to start with 'set' and they are required to\"\n+        + \" end with the name of the field (case insensitive.)\");\n+    return sb.toString();\n+  }\n+\n+  private <T> ColumnValuePair writeCollectionReferenceColumn(java.lang.reflect.Field field, Method getter, T obj)\n+      throws InvocationTargetException, IllegalAccessException, SQLException, NoSuchMethodException {\n+    ColumnValuePair columnValuePair = new ColumnValuePair();\n+    String columnName = NESTED_OBJECT_COLUMN_PREFIX + field.getName();\n+\n+    Collection<?> collection = (Collection<?>) getter.getReturnType().cast(getter.invoke(obj));\n+    Map<String, List<Integer>> nestedPrimaryKeys = new HashMap<>();\n+    for (Object o: collection) {\n+      String myActualType = o.getClass().getSimpleName();\n+      nestedPrimaryKeys.putIfAbsent(myActualType, new ArrayList<>());\n+\n+      Class typeArgClass = getGenericParamTypeOfMethodReturn(getter);\n+\n+      int id = writeImplInner(typeArgClass.cast(o));\n+      nestedPrimaryKeys.get(myActualType).add(id);\n+    }\n+    JsonArray json = new JsonArray();\n+    // Create fields with the collectionReferenceType columns\n+    for (Map.Entry<String, List<Integer>> colNameEntry: nestedPrimaryKeys.entrySet()) {\n+      JsonObject jsonObject = new JsonObject();\n+      JsonArray jsonArrayInner = new JsonArray();\n+      colNameEntry.getValue().forEach(rowId -> jsonArrayInner.add(rowId));\n+\n+      jsonObject.addProperty(TABLE_NAME_JSON_KEY, colNameEntry.getKey());\n+      jsonObject.add(ROW_IDS_JSON_KEY, jsonArrayInner);\n+\n+      json.add(jsonObject);\n+    }\n+    columnValuePair.field = (DSL.field(DSL.name(columnName), String.class));\n+    columnValuePair.value = json.toString();\n+    return columnValuePair;\n+  }\n+\n+  private <T> int writeImplInner(T obj)\n+      throws IllegalStateException, IllegalAccessException, InvocationTargetException, SQLException, NoSuchMethodException {\n+    Class<?> clz = obj.getClass();\n+    String tableName = getTableNameFromClassName(clz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5607a226bdf2c21bfd3807acbfc210844b603ff9"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ4NDk1NA==", "bodyText": "It may not be a good idea to persist two different FLowUnits directly into the same table. These classes can have different Fields or different number of fields, that would throw a DB exception. More checks we have to do, to convert the error messages into understandable ones.\nIf we at all want to persist two different FlowUnits into the same table, then we should create an Object in both FlowUnits, and that we should ask to persist. That way, at Java level, it will be guranteed to not throw DB exceptions because of schema mismatch.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482484954", "createdAt": "2020-09-02T21:22:10Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +221,426 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        // get the row with the provided rowId.\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rowID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        // If the name of the column starts with the prefix, then it is a reference Column. It means that the value contained in this\n+        // column references to a particular RowIDs in the table with name same as this column(with prefix removed).\n+        // There are two forms of this:\n+        // - It can be a reference to another table, in which case the column is an integer type.\n+        // - OR it is a collection of RowIDs from multiple tables, in which case the column type a JsonArray as String. e.g.\n+        //    [{\\\"tableName\\\":\\\"ITestImpl2\\\",\\\"rowIds\\\":[1]},{\\\"tableName\\\":\\\"ITestImpl1\\\",\\\"rowIds\\\":[1,2]}]\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // This references a row in a table.\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          if (setter.getParameterTypes().length != 1) {\n+            throw new IllegalStateException(\"A setter \" + setter.getName() + \" of class \" + clz.getSimpleName()\n+                + \" accepts more than one arguments.\");\n+          }\n+\n+          // This gives the type of the setter parameter.\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+          int nestedRowId = (int)jooqField.getValue(record);\n+\n+          // Now that we have the Type of the parameter and the rowID specifying the data the object\n+          // is to be filled with; we call the read method recursively to create the referenced Object\n+          // and then invoke the setter with it.\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethodReturn(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    return getFirstTypeFromParameterizedTypes(mtype, method.getName());\n+  }\n+\n+  private Class<?> getGenericFieldType(java.lang.reflect.Field field) {\n+    ParameterizedType mtype = (ParameterizedType) field.getGenericType();\n+    return getFirstTypeFromParameterizedTypes(mtype, field.getName());\n+  }\n+\n+  private Class<?> getFirstTypeFromParameterizedTypes(ParameterizedType mtype, String name) {\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check field/method: \" + name);\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    if (name.length() == 1) {\n+      return name.toUpperCase();\n+    }\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);\n+  }\n+\n+  private void checkValidType(java.lang.reflect.Field field, Class<?> clz) {\n+    Type type = field.getGenericType();\n+    Annotation[] annotation = field.getAnnotations();\n+    StringBuilder err = new StringBuilder();\n+    err.append(\"[class: \").append(clz.getSimpleName()).append(\":field:\").append(field.getName()).append(\"]::\");\n+\n+    if (annotation.length != 1) {\n+      err\n+          .append(\"A field can have either \")\n+          .append(ValueColumn.class.getSimpleName())\n+          .append(\" or \")\n+          .append(RefColumn.class.getSimpleName())\n+          .append(\" not both\");\n+      throw new IllegalStateException(err.toString());\n+    }\n+\n+    if (annotation[0].annotationType() == RefColumn.class) {\n+      if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Class<?> actualType = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+        if (actualType.isPrimitive() || actualType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      } else {\n+        Class<?> justType = field.getType();\n+        if (justType.isPrimitive() || justType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      }\n+    } else {\n+      if (type instanceof ParameterizedType) {\n+        // TODO: This will be added if use-cases require this.\n+        err.append(\"persisting Primitives or Strings as Parameterized Types is not supported.\");\n+        throw new IllegalStateException(err.toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Go over all the fields of the class and then filter out all that are annotated as @AColumn or @ATable. For those fields,\n+   * try to figure out the getter and setters.\n+   * @param clz The class whose field registry is to be created.\n+   * @param <T> The Generic type of the class.\n+   * @throws IllegalStateException When getters and setters are not found for the field that is required to be persisted or they exist but\n+   *     are not public.\n+   */\n+  private <T> void createFieldRegistry(Class<T> clz) throws IllegalStateException, NoSuchMethodException {\n+    fieldGetterSetterPairsMap.putIfAbsent(clz, new HashMap<>());\n+    classFieldNamesToGetterSetterMap.putIfAbsent(clz, new HashMap<>());\n+\n+    Map<java.lang.reflect.Field, GetterSetterPairs> fieldToGetterSetterMap = fieldGetterSetterPairsMap.get(clz);\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    for (java.lang.reflect.Field field : clz.getDeclaredFields()) {\n+      if (field.isAnnotationPresent(ValueColumn.class) || field.isAnnotationPresent(RefColumn.class)) {\n+        checkValidType(field, clz);\n+        // Now we try to find the corresponding Getter and Setter for this field.\n+        GetterSetterPairs pair = new GetterSetterPairs();\n+\n+        String capitalizedFieldName = capitalize(field.getName());\n+        for (String prefix: GETTER_PREFIXES) {\n+          String key = prefix + capitalizedFieldName;\n+          Method method;\n+          try {\n+            method = clz.getDeclaredMethod(key);\n+          } catch (NoSuchMethodException nom) {\n+            continue;\n+          }\n+          if (method.getReturnType() != field.getType()) {\n+            StringBuilder sb = new StringBuilder(\"The return type of the getter '\");\n+            sb.append(key)\n+                .append(\"' (\")\n+                .append(method.getReturnType())\n+                .append(\") and field '\")\n+                .append(field.getName())\n+                .append(\"' (\")\n+                .append(field.getType())\n+                .append(\") don't match.\");\n+            throw new NoSuchMethodException(sb.toString());\n+          }\n+          checkPublic(method);\n+          pair.getter = method;\n+          break;\n+        }\n+        for (String prefix: SETTER_PREFIXES) {\n+          String key = prefix + capitalizedFieldName;\n+          try {\n+            // This line will throw if no method with the name exists or if a method with such name exists\n+            // but the method argument types are not the same. Remember, int and Integer are not the same\n+            // types.\n+            Method method = clz.getDeclaredMethod(key, field.getType());\n+            checkPublic(method);\n+            pair.setter = method;\n+            break;\n+          } catch (NoSuchMethodException e) {\n+          }\n+        }\n+        if (pair.getter == null) {\n+          throw new NoSuchMethodException(getNoGetterSetterExist(clz, field, GetterOrSetter.GETTER));\n+        }\n+        if (pair.setter == null) {\n+          throw new NoSuchMethodException(getNoGetterSetterExist(clz, field, GetterOrSetter.SETTER));\n+        }\n+        fieldToGetterSetterMap.put(field, pair);\n+        fieldNameToGetterSetterMap.put(field.getName(), pair);\n+      }\n+    }\n+  }\n+\n+  private String getNoGetterSetterExist(Class<?> clz, java.lang.reflect.Field field, GetterOrSetter getterOrSetter) {\n+    String type;\n+    switch (getterOrSetter) {\n+      case GETTER:\n+        type = \"getter\";\n+        break;\n+      case SETTER:\n+        type = \"setter\";\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unrecognized type: \" + getterOrSetter);\n+    }\n+\n+    StringBuilder sb = new StringBuilder(\"Could not find '\");\n+    sb.append(type)\n+        .append(\"' for the field '\")\n+        .append(field.getName())\n+        .append(\"' of class '\")\n+        .append(clz.getName())\n+        .append(\"'. Getters are expected to start with 'get' or 'is' and setters are expected to start with 'set' and they are required to\"\n+        + \" end with the name of the field (case insensitive.)\");\n+    return sb.toString();\n+  }\n+\n+  private <T> ColumnValuePair writeCollectionReferenceColumn(java.lang.reflect.Field field, Method getter, T obj)\n+      throws InvocationTargetException, IllegalAccessException, SQLException, NoSuchMethodException {\n+    ColumnValuePair columnValuePair = new ColumnValuePair();\n+    String columnName = NESTED_OBJECT_COLUMN_PREFIX + field.getName();\n+\n+    Collection<?> collection = (Collection<?>) getter.getReturnType().cast(getter.invoke(obj));\n+    Map<String, List<Integer>> nestedPrimaryKeys = new HashMap<>();\n+    for (Object o: collection) {\n+      String myActualType = o.getClass().getSimpleName();\n+      nestedPrimaryKeys.putIfAbsent(myActualType, new ArrayList<>());\n+\n+      Class typeArgClass = getGenericParamTypeOfMethodReturn(getter);\n+\n+      int id = writeImplInner(typeArgClass.cast(o));\n+      nestedPrimaryKeys.get(myActualType).add(id);\n+    }\n+    JsonArray json = new JsonArray();\n+    // Create fields with the collectionReferenceType columns\n+    for (Map.Entry<String, List<Integer>> colNameEntry: nestedPrimaryKeys.entrySet()) {\n+      JsonObject jsonObject = new JsonObject();\n+      JsonArray jsonArrayInner = new JsonArray();\n+      colNameEntry.getValue().forEach(rowId -> jsonArrayInner.add(rowId));\n+\n+      jsonObject.addProperty(TABLE_NAME_JSON_KEY, colNameEntry.getKey());\n+      jsonObject.add(ROW_IDS_JSON_KEY, jsonArrayInner);\n+\n+      json.add(jsonObject);\n+    }\n+    columnValuePair.field = (DSL.field(DSL.name(columnName), String.class));\n+    columnValuePair.value = json.toString();\n+    return columnValuePair;\n+  }\n+\n+  private <T> int writeImplInner(T obj)\n+      throws IllegalStateException, IllegalAccessException, InvocationTargetException, SQLException, NoSuchMethodException {\n+    Class<?> clz = obj.getClass();\n+    String tableName = getTableNameFromClassName(clz);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNzU4MA=="}, "originalCommit": {"oid": "5607a226bdf2c21bfd3807acbfc210844b603ff9"}, "originalPosition": 450}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTI3NzgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzozMTozMVrOHL58Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMToyNToxOVrOHMItyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0NTcwMg==", "bodyText": "a high level question I have for this function is, how are we going to handle Enum type ? We have resource enum in ResourceSummary. Can we override this getter / setter to serialize / de-serialize Enum based on enum value ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482245702", "createdAt": "2020-09-02T17:31:31Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +221,426 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        // get the row with the provided rowId.\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rowID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        // If the name of the column starts with the prefix, then it is a reference Column. It means that the value contained in this\n+        // column references to a particular RowIDs in the table with name same as this column(with prefix removed).\n+        // There are two forms of this:\n+        // - It can be a reference to another table, in which case the column is an integer type.\n+        // - OR it is a collection of RowIDs from multiple tables, in which case the column type a JsonArray as String. e.g.\n+        //    [{\\\"tableName\\\":\\\"ITestImpl2\\\",\\\"rowIds\\\":[1]},{\\\"tableName\\\":\\\"ITestImpl1\\\",\\\"rowIds\\\":[1,2]}]\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // This references a row in a table.\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          if (setter.getParameterTypes().length != 1) {\n+            throw new IllegalStateException(\"A setter \" + setter.getName() + \" of class \" + clz.getSimpleName()\n+                + \" accepts more than one arguments.\");\n+          }\n+\n+          // This gives the type of the setter parameter.\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+          int nestedRowId = (int)jooqField.getValue(record);\n+\n+          // Now that we have the Type of the parameter and the rowID specifying the data the object\n+          // is to be filled with; we call the read method recursively to create the referenced Object\n+          // and then invoke the setter with it.\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethodReturn(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    return getFirstTypeFromParameterizedTypes(mtype, method.getName());\n+  }\n+\n+  private Class<?> getGenericFieldType(java.lang.reflect.Field field) {\n+    ParameterizedType mtype = (ParameterizedType) field.getGenericType();\n+    return getFirstTypeFromParameterizedTypes(mtype, field.getName());\n+  }\n+\n+  private Class<?> getFirstTypeFromParameterizedTypes(ParameterizedType mtype, String name) {\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check field/method: \" + name);\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    if (name.length() == 1) {\n+      return name.toUpperCase();\n+    }\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);\n+  }\n+\n+  private void checkValidType(java.lang.reflect.Field field, Class<?> clz) {\n+    Type type = field.getGenericType();\n+    Annotation[] annotation = field.getAnnotations();\n+    StringBuilder err = new StringBuilder();\n+    err.append(\"[class: \").append(clz.getSimpleName()).append(\":field:\").append(field.getName()).append(\"]::\");\n+\n+    if (annotation.length != 1) {\n+      err\n+          .append(\"A field can have either \")\n+          .append(ValueColumn.class.getSimpleName())\n+          .append(\" or \")\n+          .append(RefColumn.class.getSimpleName())\n+          .append(\" not both\");\n+      throw new IllegalStateException(err.toString());\n+    }\n+\n+    if (annotation[0].annotationType() == RefColumn.class) {\n+      if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Class<?> actualType = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+        if (actualType.isPrimitive() || actualType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      } else {\n+        Class<?> justType = field.getType();\n+        if (justType.isPrimitive() || justType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      }\n+    } else {\n+      if (type instanceof ParameterizedType) {\n+        // TODO: This will be added if use-cases require this.\n+        err.append(\"persisting Primitives or Strings as Parameterized Types is not supported.\");\n+        throw new IllegalStateException(err.toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Go over all the fields of the class and then filter out all that are annotated as @AColumn or @ATable. For those fields,\n+   * try to figure out the getter and setters.\n+   * @param clz The class whose field registry is to be created.\n+   * @param <T> The Generic type of the class.\n+   * @throws IllegalStateException When getters and setters are not found for the field that is required to be persisted or they exist but\n+   *     are not public.\n+   */\n+  private <T> void createFieldRegistry(Class<T> clz) throws IllegalStateException, NoSuchMethodException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5607a226bdf2c21bfd3807acbfc210844b603ff9"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ4Nzc1NA==", "bodyText": "This is an excellent point. Enums are not covered. We will add support for them before we migrate Existing RCAs to be persisted using this new API.\nFor now this should unblock the persisting the deciders into DB use-case", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/407#discussion_r482487754", "createdAt": "2020-09-02T21:25:19Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -179,6 +221,426 @@ synchronized int insertRow(String tableName, List<Object> row) throws SQLExcepti\n     return lastPrimaryKey;\n   }\n \n+  @Override\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, DataAccessException {\n+    return read(clz, -1 /* To indicate this is the top level call */);\n+  }\n+\n+  public synchronized <T> @org.checkerframework.checker.nullness.qual.Nullable T read(Class<T> clz, int rowId)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    String tableName = getTableNameFromClassName(clz);\n+    String primaryKeyCol = SQLiteQueryUtils.getPrimaryKeyColumnName(tableName);\n+    Field<Integer> primaryKeyField = DSL.field(primaryKeyCol, Integer.class);\n+\n+    Map<String, GetterSetterPairs> fieldNameToGetterSetterMap = classFieldNamesToGetterSetterMap.get(clz);\n+\n+    List<Record> recordList;\n+    if (rowId == -1) {\n+      try {\n+        // Fetch the latest row.\n+        recordList = create.select().from(tableName).orderBy(primaryKeyField.desc()).limit(1).fetch();\n+      } catch (DataAccessException dex) {\n+        LOG.debug(\"Error querying table {}\", tableName, dex);\n+        return null;\n+      }\n+    } else {\n+      try {\n+        // get the row with the provided rowId.\n+        recordList = create.select().from(tableName).where(DSL.field(primaryKeyCol, Integer.class).eq(rowId)).fetch();\n+      } catch (DataAccessException dex) {\n+        // This is more severe. This would mean that the data corresponding to the outer Object were found but\n+        // the nested tables could not be accessed.\n+        LOG.error(\"Could not find data for table {}\", tableName, dex);\n+        throw dex;\n+      }\n+    }\n+\n+    if (recordList.size() != 1) {\n+      // We always expect one row whether we query for the latest row or we query for a row by the rowID.\n+      throw new IllegalStateException(\"Expected one row, found: '\" + recordList + \"'\");\n+    }\n+    Record record = recordList.get(0);\n+    Field<?>[] fields = record.fields();\n+    T obj = clz.getDeclaredConstructor().newInstance();\n+\n+    for (Field<?> jooqField : fields) {\n+      String columnName = jooqField.getName();\n+      if (columnName.equals(primaryKeyCol)) {\n+        continue;\n+      }\n+\n+      if (columnName.startsWith(NESTED_OBJECT_COLUMN_PREFIX)) {\n+        // If the name of the column starts with the prefix, then it is a reference Column. It means that the value contained in this\n+        // column references to a particular RowIDs in the table with name same as this column(with prefix removed).\n+        // There are two forms of this:\n+        // - It can be a reference to another table, in which case the column is an integer type.\n+        // - OR it is a collection of RowIDs from multiple tables, in which case the column type a JsonArray as String. e.g.\n+        //    [{\\\"tableName\\\":\\\"ITestImpl2\\\",\\\"rowIds\\\":[1]},{\\\"tableName\\\":\\\"ITestImpl1\\\",\\\"rowIds\\\":[1,2]}]\n+        String nestedTableName = columnName.replace(NESTED_OBJECT_COLUMN_PREFIX, \"\");\n+        if (jooqField.getType() == String.class) {\n+          String value = (String) jooqField.getValue(record);\n+          JsonArray array = JsonParser.parseString(value).getAsJsonArray();\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          List<Object> collection = new ArrayList<>();\n+          for (JsonElement element: array) {\n+            JsonObject jsonObject = element.getAsJsonObject();\n+            String actualTableName = jsonObject.get(TABLE_NAME_JSON_KEY).getAsString();\n+\n+            Class<?> actualTableClass = tableNameToJavaClassMap.get(actualTableName);\n+            if (actualTableClass == null) {\n+              throw new IllegalStateException(\"The table name '\" + actualTableName + \"' does not exist in the table to class mapping. But\"\n+                  + \"the database row mentions it: \" + element.toString());\n+            }\n+\n+            for (JsonElement rowIdElem: jsonObject.get(ROW_IDS_JSON_KEY).getAsJsonArray()) {\n+              int rowIdNestedTable = rowIdElem.getAsInt();\n+              Object nestedObj = read(actualTableClass, rowIdNestedTable);\n+              collection.add(nestedObj);\n+            }\n+          }\n+          setter.invoke(obj, collection);\n+        } else if (jooqField.getType() == Integer.class) {\n+          // This references a row in a table.\n+          if (fieldNameToGetterSetterMap.get(nestedTableName) == null) {\n+            throw new IllegalStateException(\"No Field Mapping exist for column name \" + jooqField.getName() + \" of table \" + tableName);\n+          }\n+          Method setter = fieldNameToGetterSetterMap.get(nestedTableName).setter;\n+\n+          if (setter.getParameterTypes().length != 1) {\n+            throw new IllegalStateException(\"A setter \" + setter.getName() + \" of class \" + clz.getSimpleName()\n+                + \" accepts more than one arguments.\");\n+          }\n+\n+          // This gives the type of the setter parameter.\n+          Class<?> setterType = setter.getParameterTypes()[0];\n+          int nestedRowId = (int)jooqField.getValue(record);\n+\n+          // Now that we have the Type of the parameter and the rowID specifying the data the object\n+          // is to be filled with; we call the read method recursively to create the referenced Object\n+          // and then invoke the setter with it.\n+          Object nestedObj = read(setterType, nestedRowId);\n+          setter.invoke(obj, nestedObj);\n+        }\n+        else {\n+          throw new IllegalStateException(\"ReferenceColumn can be either Integer or String.\");\n+        }\n+      } else {\n+        // For all the other columns, we look for the corresponding setter.\n+        Method setter = fieldNameToGetterSetterMap.get(jooqField.getName()).setter;\n+        setter.invoke(obj, jooqField.getType().cast(jooqField.getValue(record)));\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  synchronized <T> void writeImpl(T obj)\n+      throws IllegalStateException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SQLException,\n+      IllegalAccessException {\n+    writeImplInner(obj);\n+  }\n+\n+  private static String getTableNameFromClassName(Class<?> clz) {\n+    return clz.getSimpleName();\n+  }\n+\n+  private Class<?> getGenericParamTypeOfMethodReturn(Method method) {\n+    ParameterizedType mtype = (ParameterizedType) method.getGenericReturnType();\n+    return getFirstTypeFromParameterizedTypes(mtype, method.getName());\n+  }\n+\n+  private Class<?> getGenericFieldType(java.lang.reflect.Field field) {\n+    ParameterizedType mtype = (ParameterizedType) field.getGenericType();\n+    return getFirstTypeFromParameterizedTypes(mtype, field.getName());\n+  }\n+\n+  private Class<?> getFirstTypeFromParameterizedTypes(ParameterizedType mtype, String name) {\n+    Type[] mTypeArguments = mtype.getActualTypeArguments();\n+    if (mTypeArguments.length != 1) {\n+      throw new IllegalStateException(\"Expected list of a single type. Please check field/method: \" + name);\n+    }\n+    Class mTypeArgClass = (Class) mTypeArguments[0];\n+    return mTypeArgClass;\n+  }\n+\n+  private void checkPublic(Method method) {\n+    if (!Modifier.isPublic(method.getModifiers())) {\n+      throw new IllegalStateException(\"Found '\" + method.getName() + \"'. But it is not public.\");\n+    }\n+  }\n+\n+  private String capitalize(String name) {\n+    if (name.length() == 1) {\n+      return name.toUpperCase();\n+    }\n+    return name.substring(0, 1).toUpperCase() + name.substring(1);\n+  }\n+\n+  private void checkValidType(java.lang.reflect.Field field, Class<?> clz) {\n+    Type type = field.getGenericType();\n+    Annotation[] annotation = field.getAnnotations();\n+    StringBuilder err = new StringBuilder();\n+    err.append(\"[class: \").append(clz.getSimpleName()).append(\":field:\").append(field.getName()).append(\"]::\");\n+\n+    if (annotation.length != 1) {\n+      err\n+          .append(\"A field can have either \")\n+          .append(ValueColumn.class.getSimpleName())\n+          .append(\" or \")\n+          .append(RefColumn.class.getSimpleName())\n+          .append(\" not both\");\n+      throw new IllegalStateException(err.toString());\n+    }\n+\n+    if (annotation[0].annotationType() == RefColumn.class) {\n+      if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Class<?> actualType = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+        if (actualType.isPrimitive() || actualType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      } else {\n+        Class<?> justType = field.getType();\n+        if (justType.isPrimitive() || justType == String.class) {\n+          err.append(\"RefColumn can only be used for a user defined class or a Collection of user-defined class NOT \"\n+              + \"a primitive or String type\");\n+          throw new IllegalStateException(err.toString());\n+        }\n+      }\n+    } else {\n+      if (type instanceof ParameterizedType) {\n+        // TODO: This will be added if use-cases require this.\n+        err.append(\"persisting Primitives or Strings as Parameterized Types is not supported.\");\n+        throw new IllegalStateException(err.toString());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Go over all the fields of the class and then filter out all that are annotated as @AColumn or @ATable. For those fields,\n+   * try to figure out the getter and setters.\n+   * @param clz The class whose field registry is to be created.\n+   * @param <T> The Generic type of the class.\n+   * @throws IllegalStateException When getters and setters are not found for the field that is required to be persisted or they exist but\n+   *     are not public.\n+   */\n+  private <T> void createFieldRegistry(Class<T> clz) throws IllegalStateException, NoSuchMethodException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0NTcwMg=="}, "originalCommit": {"oid": "5607a226bdf2c21bfd3807acbfc210844b603ff9"}, "originalPosition": 327}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2384, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}