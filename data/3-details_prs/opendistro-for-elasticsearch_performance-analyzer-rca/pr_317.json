{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MTUyMTAw", "number": 317, "title": "Add upperbound for cache decider, Consume from NodeConfigurationRca and tune only one resource at a time", "bodyText": "Issue #:\nDescription of changes:\nAdded heap max size to node configuration collector.\nModified the cache decider to consume the node configuration rca.\nCache decider consumes cache max size and heap size from node configuration collector\nTune only one resource either the shard request cache or field data cache at a time on a node\nRenamed cache decider variables and functions.\nTests:\nAdded unit tests\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-07-29T02:17:50Z", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317", "merged": true, "mergeCommit": {"oid": "1ac07f1fedb08e19dc517359c1956ea6fd0315f9"}, "closed": true, "closedAt": "2020-08-02T17:15:49Z", "author": {"login": "sruti1312"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5hVaKgH2gAyNDU4MTUyMTAwOmRiZmFjZDZhYmU5M2E4ZGRhNzY2NThlY2Y2NmY2MjNmZGY5MTI1NmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6xkW4gH2gAyNDU4MTUyMTAwOmQzNTc4ZWIyZGM0MmJhZDMxY2U0NjY5ZDc4Yjk4MjVjODM1N2RhMWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "dbfacd6abe93a8dda76658ecf66f623fdf91256c", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/dbfacd6abe93a8dda76658ecf66f623fdf91256c", "committedDate": "2020-07-29T02:10:01Z", "message": "Add upperbound for cache decider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f57a3d1a4f4e0a2bf52ab4d4835e888424c52c2", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5f57a3d1a4f4e0a2bf52ab4d4835e888424c52c2", "committedDate": "2020-07-29T16:39:00Z", "message": "Resolve merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9785e45b9bfbc23d57f090e421e0200015ac1f66", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9785e45b9bfbc23d57f090e421e0200015ac1f66", "committedDate": "2020-07-29T17:54:52Z", "message": "Consume upperbound from rcaConf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "983ca1e8a6a10630bdd259ab6ac684d355ea9444", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/983ca1e8a6a10630bdd259ab6ac684d355ea9444", "committedDate": "2020-07-29T18:20:23Z", "message": "Fix cache health decider unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56db08b6095c8b38d9a525cb6361e039df802590", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/56db08b6095c8b38d9a525cb6361e039df802590", "committedDate": "2020-07-29T21:55:20Z", "message": "Modify cache decider to tune only one resource at a time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/989e99f151cbe5578daa0acad29a77c04337e11e", "committedDate": "2020-07-29T22:00:46Z", "message": "Format issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTQzMjQ2", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-457943246", "createdAt": "2020-07-29T22:30:56Z", "commit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjozMDo1NlrOG5MiUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjozNTo0MFrOG5Mpsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzQxMQ==", "bodyText": "should we also have lower bound for each cache ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462627411", "createdAt": "2020-07-29T22:30:56Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {\n+    private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n     public static final String NAME = \"modifyCacheCapacity\";\n     public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n \n-    private long currentCapacityInBytes;\n-    private long desiredCapacityInBytes;\n+    private long currentCacheMaxSizeInBytes;\n+    private long desiredCacheMaxSizeInBytes;\n+    private long heapMaxSizeInBytes;\n+\n+    private double fieldDataCacheSizeUpperBound;\n+    private double shardRequestCacheSizeUpperBound;\n+\n     private ResourceEnum cacheType;\n     private NodeKey esNode;\n \n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n-    public ModifyCacheCapacityAction(\n+    public ModifyCacheMaxSizeAction(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentCacheMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n+            final double fieldDataCacheSizeUpperBound,\n+            final double shardRequestCacheSizeUpperBound,\n             final boolean increase) {\n-        // TODO: Also consume NodeConfigurationRca\n+        this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzgwNg==", "bodyText": "can we also handle cache scaling down here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462627806", "createdAt": "2020-07-29T22:31:47Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {\n+    private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n     public static final String NAME = \"modifyCacheCapacity\";\n     public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n \n-    private long currentCapacityInBytes;\n-    private long desiredCapacityInBytes;\n+    private long currentCacheMaxSizeInBytes;\n+    private long desiredCacheMaxSizeInBytes;\n+    private long heapMaxSizeInBytes;\n+\n+    private double fieldDataCacheSizeUpperBound;\n+    private double shardRequestCacheSizeUpperBound;\n+\n     private ResourceEnum cacheType;\n     private NodeKey esNode;\n \n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n-    public ModifyCacheCapacityAction(\n+    public ModifyCacheMaxSizeAction(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentCacheMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n+            final double fieldDataCacheSizeUpperBound,\n+            final double shardRequestCacheSizeUpperBound,\n             final boolean increase) {\n-        // TODO: Also consume NodeConfigurationRca\n+        this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+        this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+        this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n         setBounds();\n         setStepSize();\n \n         this.esNode = esNode;\n         this.cacheType = cacheType;\n-        this.currentCapacityInBytes = currentCapacityInBytes;\n+        this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n         long desiredCapacity =\n-                increase ? currentCapacityInBytes + getStepSize(cacheType) : currentCapacityInBytes;\n-        setDesiredCapacity(desiredCapacity);\n+                increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyOTI5OA==", "bodyText": "indent space is off. please make sure that you are using the google java code formatter in IDEA", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462629298", "createdAt": "2020-07-29T22:35:40Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,41 +16,52 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n+    private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n     public static final String NAME = \"cacheHealthDecider\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73e3e402b4b1fff7a4acf3f727fe77affa28c619", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/73e3e402b4b1fff7a4acf3f727fe77affa28c619", "committedDate": "2020-07-29T23:42:18Z", "message": "Format cache decider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTc0Mzk5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-457974399", "createdAt": "2020-07-29T23:54:03Z", "commit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzo1NDowM1rOG5OM6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMDo1MDowNFrOG5PKgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NDY5Nw==", "bodyText": "Let's add a comment here that this needs to be updated as per the performance test results.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462654697", "createdAt": "2020-07-29T23:54:03Z", "author": {"login": "khushbr"}, "path": "pa_config/rca.conf", "diffHunk": "@@ -58,6 +58,10 @@\n     \"cache-config\": {\n       \"field-data-cache-size-threshold\" : 0.8,\n       \"shard-request-cache-threshold\" : 0.9\n+    },\n+    \"cache-decider-config\": {\n+      \"field-data-cache-upper-bound\" = 0.4,\n+      \"shard-request-cache-upper-bound\" = 0.05", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTIwMA==", "bodyText": "Thank you for renaming this Action to ModifyCacheMaxSizeAction. Let's add some javadoc here around the purpose of this Action class.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462655200", "createdAt": "2020-07-29T23:55:47Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NjM4NQ==", "bodyText": "You can move the lower bound addition to a TODO", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462656385", "createdAt": "2020-07-29T23:59:37Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {\n+    private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n     public static final String NAME = \"modifyCacheCapacity\";\n     public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n \n-    private long currentCapacityInBytes;\n-    private long desiredCapacityInBytes;\n+    private long currentCacheMaxSizeInBytes;\n+    private long desiredCacheMaxSizeInBytes;\n+    private long heapMaxSizeInBytes;\n+\n+    private double fieldDataCacheSizeUpperBound;\n+    private double shardRequestCacheSizeUpperBound;\n+\n     private ResourceEnum cacheType;\n     private NodeKey esNode;\n \n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n-    public ModifyCacheCapacityAction(\n+    public ModifyCacheMaxSizeAction(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentCacheMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n+            final double fieldDataCacheSizeUpperBound,\n+            final double shardRequestCacheSizeUpperBound,\n             final boolean increase) {\n-        // TODO: Also consume NodeConfigurationRca\n+        this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzQxMQ=="}, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NjY1Nw==", "bodyText": "Same comment, add a TODO and address that when the JVMDecider is available.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462656657", "createdAt": "2020-07-30T00:00:29Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -18,39 +18,54 @@\n import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModifyCacheCapacityAction implements Action {\n+public class ModifyCacheMaxSizeAction implements Action {\n+    private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n     public static final String NAME = \"modifyCacheCapacity\";\n     public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n \n-    private long currentCapacityInBytes;\n-    private long desiredCapacityInBytes;\n+    private long currentCacheMaxSizeInBytes;\n+    private long desiredCacheMaxSizeInBytes;\n+    private long heapMaxSizeInBytes;\n+\n+    private double fieldDataCacheSizeUpperBound;\n+    private double shardRequestCacheSizeUpperBound;\n+\n     private ResourceEnum cacheType;\n     private NodeKey esNode;\n \n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n-    public ModifyCacheCapacityAction(\n+    public ModifyCacheMaxSizeAction(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentCacheMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n+            final double fieldDataCacheSizeUpperBound,\n+            final double shardRequestCacheSizeUpperBound,\n             final boolean increase) {\n-        // TODO: Also consume NodeConfigurationRca\n+        this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+        this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+        this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n         setBounds();\n         setStepSize();\n \n         this.esNode = esNode;\n         this.cacheType = cacheType;\n-        this.currentCapacityInBytes = currentCapacityInBytes;\n+        this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n         long desiredCapacity =\n-                increase ? currentCapacityInBytes + getStepSize(cacheType) : currentCapacityInBytes;\n-        setDesiredCapacity(desiredCapacity);\n+                increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNzgwNg=="}, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2Mjc4NA==", "bodyText": "Two things we also need to account before increasing/decreasing the cache size :\n\nField Data Cache Circuit Breaker -  The default value for field data circuit breaker is configured at 40% of the maximum JVM heap and is managed via static setting indices.breaker.fielddata.limit. If the circuit-breaker limit is lower than the cache size, no data will ever be evicted. In order for it to work properly, the circuit breaker limit must be higher than the cache size and we should assert for it when increasing the cache size.\nExplicit Cache size set by end user. - In case customer sets the explicit static value for cache size, how do we account for them in our actions ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462662784", "createdAt": "2020-07-30T00:22:23Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -76,9 +91,9 @@ public long coolOffPeriodInMillis() {\n     @Override\n     public Map<NodeKey, ImpactVector> impact() {\n         final ImpactVector impactVector = new ImpactVector();\n-        if (desiredCapacityInBytes > currentCapacityInBytes) {\n+        if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MzM5MQ==", "bodyText": "do we need any assertion for the heapMaxSizeInBytes value ? Maybe non-null, non-zero ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462663391", "createdAt": "2020-07-30T00:24:39Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -109,12 +124,11 @@ private void setBounds() {\n         // This is intentionally not made static because different nodes can\n         // have different bounds based on instance types\n \n-        // TODO: Read the upperBound from NodeConfigurationRca.\n         // Field data cache used when sorting on or computing aggregation on the field (in Bytes)\n-        upperBoundInBytes.put(ResourceEnum.FIELD_DATA_CACHE, 12000 * 1_000_000L);\n+        upperBoundInBytes.put(ResourceEnum.FIELD_DATA_CACHE, (long) (heapMaxSizeInBytes * fieldDataCacheSizeUpperBound));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2OTA0Mw==", "bodyText": "Let's restrict this only to IlegalArgumentException .", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462669043", "createdAt": "2020-07-30T00:44:38Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -130,32 +149,80 @@ private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheT\n     private Action getAction(final String actionName,\n                              final NodeKey esNode,\n                              final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n+                             final Long currentMaxSizeInBytes,\n+                             final Long heapMaxSizeInBytes,\n                              final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n+        if (currentMaxSizeInBytes == null || heapMaxSizeInBytes == null) {\n+            return null;\n+        }\n+        if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+            return configureCacheMaxSize(esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n         }\n         return null;\n     }\n \n-    private ModifyCacheCapacityAction configureCacheCapacity(\n+    private ModifyCacheMaxSizeAction configureCacheMaxSize(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n             final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n+        final ModifyCacheMaxSizeAction action =\n+                new ModifyCacheMaxSizeAction(\n+                        esNode,\n+                        cacheType,\n+                        currentMaxSizeInBytes,\n+                        heapMaxSizeInBytes,\n+                        getFieldDataCacheUpperBound(),\n+                        getShardRequestCacheUpperBound(),\n+                        increase);\n         if (action.isActionable()) {\n             return action;\n         }\n         return null;\n     }\n \n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n+    private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n+        try {\n+            if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+                return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+            }\n+            return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+        } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2OTM5NQ==", "bodyText": "Same comment as above.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462669395", "createdAt": "2020-07-30T00:45:54Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -130,32 +149,80 @@ private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheT\n     private Action getAction(final String actionName,\n                              final NodeKey esNode,\n                              final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n+                             final Long currentMaxSizeInBytes,\n+                             final Long heapMaxSizeInBytes,\n                              final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n+        if (currentMaxSizeInBytes == null || heapMaxSizeInBytes == null) {\n+            return null;\n+        }\n+        if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+            return configureCacheMaxSize(esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n         }\n         return null;\n     }\n \n-    private ModifyCacheCapacityAction configureCacheCapacity(\n+    private ModifyCacheMaxSizeAction configureCacheMaxSize(\n             final NodeKey esNode,\n             final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n+            final long currentMaxSizeInBytes,\n+            final long heapMaxSizeInBytes,\n             final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n+        final ModifyCacheMaxSizeAction action =\n+                new ModifyCacheMaxSizeAction(\n+                        esNode,\n+                        cacheType,\n+                        currentMaxSizeInBytes,\n+                        heapMaxSizeInBytes,\n+                        getFieldDataCacheUpperBound(),\n+                        getShardRequestCacheUpperBound(),\n+                        increase);\n         if (action.isActionable()) {\n             return action;\n         }\n         return null;\n     }\n \n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n+    private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n+        try {\n+            if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+                return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+            }\n+            return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+        } catch (final Exception e) {\n+            LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n         }\n-        return 1000L;\n+        // No action if value not present in the cache.\n+        // No action will be triggered as this value was wiped out from the cache\n+        return null;\n+  }\n+\n+  private Long getHeapMaxSizeInBytes(final NodeKey esNode) {\n+      try {\n+          return (long) getAppContext().getNodeConfigCache().get(esNode, ResourceUtil.HEAP_MAX_SIZE);\n+      } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3MDQ2Nw==", "bodyText": "Let's move this to under JVM resources, will mean other will get shifted but that if okay.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r462670467", "createdAt": "2020-07-30T00:50:04Z", "author": {"login": "khushbr"}, "path": "src/main/proto/inter_node_rpc_service.proto", "diffHunk": "@@ -95,6 +95,9 @@ enum MetricEnum {\n   CACHE_EVICTION = 10 [(additional_fields).name = \"cache eviction\", (additional_fields).description = \"cache eviction count\"];\n   CACHE_HIT = 11 [(additional_fields).name = \"cache hit\", (additional_fields).description = \"cache hit count\"];\n   CACHE_MAX_SIZE = 12 [(additional_fields).name = \"cache max size\", (additional_fields).description = \"max cache size in bytes\"];\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989e99f151cbe5578daa0acad29a77c04337e11e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6378a7448cdd15a882e635e16039e35515e38602", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/6378a7448cdd15a882e635e16039e35515e38602", "committedDate": "2020-07-30T19:23:53Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5f1c5bf589ec092998867596092c947339fb7bc3", "committedDate": "2020-07-30T20:00:57Z", "message": "Add priorities for cache decider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzIzNzQx", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-458723741", "createdAt": "2020-07-30T20:14:59Z", "commit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODI2Mjg4", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-458826288", "createdAt": "2020-07-30T23:20:08Z", "commit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMzoyMDowOFrOG53BZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDoxODozMFrOG54CSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzQ5Mw==", "bodyText": "This needs to be removed now, we've removed it from the interface.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463323493", "createdAt": "2020-07-30T23:20:08Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  private ResourceEnum cacheType;\n+  private NodeKey esNode;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+  private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentCacheMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final double fieldDataCacheSizeUpperBound,\n+      final double shardRequestCacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+    this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+    this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n+    setBounds();\n+    setStepSize();\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n+    // TODO: Address cache scaling down  when JVM decider is available\n+    long desiredCapacity =\n+        increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMzkxMQ==", "bodyText": "Let us also provide a public setter for step size for different caches. Deciders may want to change step size to something more aggressive based on RCAs (like downsize aggressively when heap is extremely low)", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463323911", "createdAt": "2020-07-30T23:21:39Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  private ResourceEnum cacheType;\n+  private NodeKey esNode;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+  private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentCacheMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final double fieldDataCacheSizeUpperBound,\n+      final double shardRequestCacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    this.fieldDataCacheSizeUpperBound = fieldDataCacheSizeUpperBound;\n+    this.shardRequestCacheSizeUpperBound = shardRequestCacheSizeUpperBound;\n+    this.heapMaxSizeInBytes = heapMaxSizeInBytes;\n+\n+    setBounds();\n+    setStepSize();\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.currentCacheMaxSizeInBytes = currentCacheMaxSizeInBytes;\n+    // TODO: Address cache scaling down  when JVM decider is available\n+    long desiredCapacity =\n+        increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public void execute() {\n+    // Making this a no-op for now\n+    // TODO: Modify based on downstream CoS agent API calls\n+    assert true;\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  private void setBounds() {\n+    // This is intentionally not made static because different nodes can\n+    // have different bounds based on instance types\n+\n+    // Field data cache used when sorting on or computing aggregation on the field (in Bytes)\n+    upperBoundInBytes.put(\n+        ResourceEnum.FIELD_DATA_CACHE, (long) (heapMaxSizeInBytes * fieldDataCacheSizeUpperBound));\n+\n+    // Shard request cache (in Bytes)\n+    upperBoundInBytes.put(\n+        ResourceEnum.SHARD_REQUEST_CACHE,\n+        (long) (heapMaxSizeInBytes * shardRequestCacheSizeUpperBound));\n+  }\n+\n+  private void setStepSize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNzU5MQ==", "bodyText": "nit: i always find this code styling too vertical to read. is this enforced by our styling guide?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463327591", "createdAt": "2020-07-30T23:34:39Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);\n     }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> void getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Decision decision,\n+      final List<InstanceDetails.Id> impactedNodes) {\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode =\n+              new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action =\n+                computeBestAction(esNode, resource.getResource().getResourceEnum());\n+            if (action != null) {\n+              decision.addAction(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n+          }\n         }\n+      }\n     }\n-\n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    Action action = null;\n+    action =\n+        getAction(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyODg1OA==", "bodyText": "Can we reduce these params needed to create a cache action?\n\nAn action can only be for a particular type of cache, right? So it shouldn't need the upper bounds of all caches to initialize.\nWould be even better if these configs (upper bounds/heap size etc) can be read within this action itself, instead of passing from outside. IMHO, we want to keep the upper bound and lower bound fixed, and only vary cache size from deciders within these bounds.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463328858", "createdAt": "2020-07-30T23:38:42Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  private ResourceEnum cacheType;\n+  private NodeKey esNode;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+  private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentCacheMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final double fieldDataCacheSizeUpperBound,\n+      final double shardRequestCacheSizeUpperBound,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTI1MA==", "bodyText": "should we move this into the action instead of decider?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463329250", "createdAt": "2020-07-30T23:39:55Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);\n     }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> void getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Decision decision,\n+      final List<InstanceDetails.Id> impactedNodes) {\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode =\n+              new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action =\n+                computeBestAction(esNode, resource.getResource().getResourceEnum());\n+            if (action != null) {\n+              decision.addAction(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n+          }\n         }\n+      }\n     }\n-\n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    Action action = null;\n+    action =\n+        getAction(\n+            ModifyCacheMaxSizeAction.NAME,\n+            esNode,\n+            cacheType,\n+            getNodeCacheMaxSizeInBytes(esNode, cacheType),\n+            getHeapMaxSizeInBytes(esNode),\n+            true);\n+    return action;\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final Long currentMaxSizeInBytes,\n+      final Long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    if (currentMaxSizeInBytes == null\n+        || currentMaxSizeInBytes == 0\n+        || heapMaxSizeInBytes == null\n+        || heapMaxSizeInBytes == 0) {\n+      return null;\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n-            if (action != null) {\n-                break;\n-            }\n-        }\n-        return action;\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    final ModifyCacheMaxSizeAction action =\n+        new ModifyCacheMaxSizeAction(\n+            esNode,\n+            cacheType,\n+            currentMaxSizeInBytes,\n+            heapMaxSizeInBytes,\n+            getFieldDataCacheUpperBound(),\n+            getShardRequestCacheUpperBound(),\n+            increase);\n+    if (action.isActionable()) {\n+      return action;\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyOTc3MQ==", "bodyText": "Minor: how about we create a util class to read these common node configs?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463329771", "createdAt": "2020-07-30T23:41:32Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);\n     }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> void getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Decision decision,\n+      final List<InstanceDetails.Id> impactedNodes) {\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode =\n+              new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action =\n+                computeBestAction(esNode, resource.getResource().getResourceEnum());\n+            if (action != null) {\n+              decision.addAction(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n+          }\n         }\n+      }\n     }\n-\n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(AllMetrics.CacheType.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    Action action = null;\n+    action =\n+        getAction(\n+            ModifyCacheMaxSizeAction.NAME,\n+            esNode,\n+            cacheType,\n+            getNodeCacheMaxSizeInBytes(esNode, cacheType),\n+            getHeapMaxSizeInBytes(esNode),\n+            true);\n+    return action;\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final Long currentMaxSizeInBytes,\n+      final Long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    if (currentMaxSizeInBytes == null\n+        || currentMaxSizeInBytes == 0\n+        || heapMaxSizeInBytes == null\n+        || heapMaxSizeInBytes == 0) {\n+      return null;\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n-            if (action != null) {\n-                break;\n-            }\n-        }\n-        return action;\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, currentMaxSizeInBytes, heapMaxSizeInBytes, increase);\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final long currentMaxSizeInBytes,\n+      final long heapMaxSizeInBytes,\n+      final boolean increase) {\n+    final ModifyCacheMaxSizeAction action =\n+        new ModifyCacheMaxSizeAction(\n+            esNode,\n+            cacheType,\n+            currentMaxSizeInBytes,\n+            heapMaxSizeInBytes,\n+            getFieldDataCacheUpperBound(),\n+            getShardRequestCacheUpperBound(),\n+            increase);\n+    if (action.isActionable()) {\n+      return action;\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private Long getNodeCacheMaxSizeInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n+    try {\n+      if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+        return (long)\n+            getAppContext()\n+                .getNodeConfigCache()\n+                .get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+      }\n+      return (long)\n+          getAppContext()\n+              .getNodeConfigCache()\n+              .get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n     }\n-\n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n-        }\n-        return 1000L;\n+    // No action if value not present in the cache.\n+    // No action will be triggered as this value was wiped out from the cache\n+    return null;\n+  }\n+\n+  private Long getHeapMaxSizeInBytes(final NodeKey esNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDI3Mw==", "bodyText": "why are we tracking impactedNodes here? how is this used?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463330273", "createdAt": "2020-07-30T23:43:20Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTEwOQ==", "bodyText": "Instead of passing decision object reference and modifying it in the method, can we return an action and add it to the decision? It's more java oriented and readable", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463331109", "createdAt": "2020-07-30T23:46:09Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    @Override\n-    public String name() {\n-        return NAME;\n+    for (final AllMetrics.CacheType cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), decision, impactedNodes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTkwOA==", "bodyText": "Was this to ensure we only publish 1 action per node from this decider? I dont see it being used that way, am I missing something? Also, if that is the use case, would it make more sense to use a set instead of a list?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463331908", "createdAt": "2020-07-30T23:48:58Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,228 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<AllMetrics.CacheType, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<AllMetrics.CacheType> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<AllMetrics.CacheType, BaseClusterRca>builder()\n+            .put(AllMetrics.CacheType.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(AllMetrics.CacheType.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound =\n+        CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    List<InstanceDetails.Id> impactedNodes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDI3Mw=="}, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzODYxMQ==", "bodyText": "Do you want to consider old gen heap size or total heap size for your configurations? I think jvm has some issues  with honoring the young-old split, we should just use total heap size.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463338611", "createdAt": "2020-07-31T00:12:45Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/framework/api/summaries/ResourceUtil.java", "diffHunk": "@@ -31,8 +31,10 @@\n  * such as TOTAL_THROUGHPUT and SYS_CALL_RATE\n  */\n public class ResourceUtil {\n-\n   // JVM resource\n+  public static final Resource HEAP_MAX_SIZE = Resource.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzOTAxOQ==", "bodyText": "Is there a reason we changed older protobuf values? Changing protobufs is a breaking change and causes compatibility issues across versions.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463339019", "createdAt": "2020-07-31T00:14:24Z", "author": {"login": "vigyasharma"}, "path": "src/main/proto/inter_node_rpc_service.proto", "diffHunk": "@@ -81,20 +81,21 @@ enum MetricEnum {\n   HEAP_USAGE = 0 [(additional_fields).name = \"heap usage\", (additional_fields).description = \"memory usage in percentage\"];\n   PROMOTION_RATE = 1 [(additional_fields).name = \"promotion rate\", (additional_fields).description = \"mb/s\"];\n   MINOR_GC = 2 [(additional_fields).name = \"minor gc\", (additional_fields).description = \"time in percentage\"];\n+  HEAP_MAX = 3 [(additional_fields).name = \"heap max\", (additional_fields).description = \"max heap size in bytes\"];\n \n   // hardware\n-  CPU_USAGE = 3 [(additional_fields).name = \"cpu usage\", (additional_fields).description = \"num of cores\"];\n-  TOTAL_THROUGHPUT = 4 [(additional_fields).name = \"total throughput\", (additional_fields).description = \"number of bytes read/written per second\"];\n-  TOTAL_SYS_CALLRATE = 5 [(additional_fields).name = \"total sys callrate\", (additional_fields).description = \"read and write system calls per second\"];\n+  CPU_USAGE = 4 [(additional_fields).name = \"cpu usage\", (additional_fields).description = \"num of cores\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MDEwNA==", "bodyText": "Should decider config really be nested inside rca config ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463340104", "createdAt": "2020-07-31T00:18:30Z", "author": {"login": "vigyasharma"}, "path": "pa_config/rca.conf", "diffHunk": "@@ -58,6 +58,11 @@\n     \"cache-config\": {\n       \"field-data-cache-size-threshold\" : 0.8,\n       \"shard-request-cache-threshold\" : 0.9\n+    },\n+    // Needs to be updated as per the performance test results\n+    \"cache-decider-config\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f1c5bf589ec092998867596092c947339fb7bc3"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04c2d3f6904109e4a4cd36440c18b6f33a83af84", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/04c2d3f6904109e4a4cd36440c18b6f33a83af84", "committedDate": "2020-07-31T00:37:26Z", "message": "Merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/3cdc28dd04693904533fc0a32f21df19a2336b8c", "committedDate": "2020-07-31T20:29:31Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTE1Mzk5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-459515399", "createdAt": "2020-07-31T22:56:02Z", "commit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMjo1NjowM1rOG6Y6vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzo0MDo0M1rOG6ZeyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODg0NA==", "bodyText": "let's follow the same naming convention that Queue action uses ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463878844", "createdAt": "2020-07-31T22:56:03Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODk4Mw==", "bodyText": "remove empty line ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463878983", "createdAt": "2020-07-31T22:56:32Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3OTg3NQ==", "bodyText": "1_000_000L does not equal to 1024*1024", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463879875", "createdAt": "2020-07-31T23:00:45Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);\n+    Long heapMaxSize = NodeConfigReaderUtil.getHeapMaxSizeInBytes(nodeConfigCache, esNode);\n+\n+    if (cacheMaxSize == null || cacheMaxSize == 0 || heapMaxSize == null || heapMaxSize == 0) {\n+      return false;\n+    } else {\n+      currentCacheMaxSizeInBytes = cacheMaxSize;\n+      heapMaxSizeInBytes = heapMaxSize;\n+      return true;\n+    }\n+  }\n+\n+  private void setBounds() {\n+    // This is intentionally not made static because different nodes can\n+    // have different bounds based on instance types\n+    cacheUpperBoundInBytes = (long) (heapMaxSizeInBytes * cacheSizeUpperBound);\n+  }\n+\n+  private void setStepSize() {\n+    // TODO: Update the step size to also include percentage of heap size along with absolute value\n+    // Field data cache having step size of 512MB\n+    stepSizeInBytes.put(ResourceEnum.FIELD_DATA_CACHE, 512 * 1_000_000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw==", "bodyText": "should we decouple this reading from cache operation from the Action class and let decider to read and pass them in as inputs args? Any thought ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463880337", "createdAt": "2020-07-31T23:03:01Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MTY4Mw==", "bodyText": "same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463881683", "createdAt": "2020-07-31T23:09:35Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4ODA3Mw==", "bodyText": "does that mean that cache decider will always pick shard request cache to scale up?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463888073", "createdAt": "2020-07-31T23:40:43Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<ResourceEnum, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<ResourceEnum> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<ResourceEnum, BaseClusterRca>builder()\n+            .put(ResourceEnum.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(ResourceEnum.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    Set<InstanceDetails.Id> impactedNodes = new HashSet<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+    for (final ResourceEnum cacheType : modifyCacheActionPriorityList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f", "committedDate": "2020-07-31T23:51:35Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTI2NTU0", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-459526554", "createdAt": "2020-07-31T23:48:57Z", "commit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwMDowMToyMVrOG6ZstQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwMTozMzo0NVrOG6admA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MTYzNw==", "bodyText": "@rguo-aws That was the previous version of this PR. I suggested this model so as to enforce the upper and lower bounds defined in configs and not let deciders override these bounds. Do you think deciders should reserve the right to override upper/lower bounds? It kind of fails the purpose of defining them in configs.\nIf not, then deciders reading and passing these configs is only adding extra params to the constructor and also leaving us vulnerable to someone ignoring config values in future.\nInstead, I think we should accept stepSize as a param (or settable via a getter), to allow deciders to aggresively downsize in extreme situations.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463891637", "createdAt": "2020-08-01T00:01:21Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw=="}, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MTkxMQ==", "bodyText": "Should we enforce this with a check inside the action itself? I was thinking deciders should be careful to not set it to 0. Can we have cases later where disabling the cache entirely makes sense? We may need to set it to 0 then.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463891911", "createdAt": "2020-08-01T00:02:56Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MjA3MA==", "bodyText": "an action instance has just one cacheType right? then we dont need cacheType in this param.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463892070", "createdAt": "2020-08-01T00:03:58Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mjc4Mg==", "bodyText": "Instead of this, for clarity, we can explicitly make isActionable return false if we cannot read nodeConfigCache, i.e. currentCacheMaxSizeInBytes is set to null.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463892782", "createdAt": "2020-08-01T00:08:13Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MzQ0NQ==", "bodyText": "I also dont understand how this if-else helps. If validateAndSetNodeConfigValues returns false, then currentCacheMaxSizeInBytes is uninitialized.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463893445", "createdAt": "2020-08-01T00:11:37Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mjc4Mg=="}, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mzc4Ng==", "bodyText": "setBounds and validateAndSetNodeConfigValues can be merged into a single function", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463893786", "createdAt": "2020-08-01T00:13:41Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);\n+    Long heapMaxSize = NodeConfigReaderUtil.getHeapMaxSizeInBytes(nodeConfigCache, esNode);\n+\n+    if (cacheMaxSize == null || cacheMaxSize == 0 || heapMaxSize == null || heapMaxSize == 0) {\n+      return false;\n+    } else {\n+      currentCacheMaxSizeInBytes = cacheMaxSize;\n+      heapMaxSizeInBytes = heapMaxSize;\n+      return true;\n+    }\n+  }\n+\n+  private void setBounds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5Mzk0NQ==", "bodyText": "will this throw an NPE is validateAndSetNodeConfigValues fails and currentCacheMaxSizeInBytes is null", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463893945", "createdAt": "2020-08-01T00:14:45Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NjkxMA==", "bodyText": "Are these reversed?!", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463896910", "createdAt": "2020-08-01T00:34:10Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<ResourceEnum, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<ResourceEnum> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<ResourceEnum, BaseClusterRca>builder()\n+            .put(ResourceEnum.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(ResourceEnum.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    Set<InstanceDetails.Id> impactedNodes = new HashSet<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+    for (final ResourceEnum cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), impactedNodes)\n+          .forEach(decision::addAction);\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> List<Action> getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Set<InstanceDetails.Id> impactedNodes) {\n+    List<Action> actions = new ArrayList<>();\n+\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return actions;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode = new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action = computeBestAction(esNode, resource.getResource().getResourceEnum());\n             if (action != null) {\n-                break;\n+              actions.add(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n+          }\n         }\n-        return action;\n+      }\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return actions;\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    return getAction(ModifyCacheMaxSizeAction.NAME, esNode, cacheType, true);\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, increase);\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    final double cacheUpperBound = getCacheUpperBound(cacheType);\n+    if (cacheUpperBound != -1) {\n+      final ModifyCacheMaxSizeAction action =\n+          new ModifyCacheMaxSizeAction(\n+              esNode,\n+              cacheType,\n+              getAppContext().getNodeConfigCache(),\n+              cacheUpperBound,\n+              increase);\n+      if (action.isActionable()) {\n+        return action;\n+      }\n     }\n-\n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n-        }\n-        return 1000L;\n+    return null;\n+  }\n+\n+  private double getCacheUpperBound(final ResourceEnum cacheType) {\n+    if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+      return getFieldDataCacheUpperBound();\n+    } else if (cacheType.equals(ResourceEnum.SHARD_REQUEST_CACHE)) {\n+      return getShardRequestCacheUpperBound();\n     }\n+    return -1;\n+  }\n+\n+  private double getShardRequestCacheUpperBound() {\n+    return fieldDataCacheSizeUpperBound;\n+  }\n+\n+  private double getFieldDataCacheUpperBound() {\n+    return shardRequestCacheSizeUpperBound;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzM2NQ==", "bodyText": "Actually there is confusion with naming. We dont want to pass upper/lower bounds from deciders. It may be okay to pass currentCapacity if needed (similar to queues). However, since configs come from rca.conf which is read in Node objects, deciders have access to them.\nWe should create separate ActionConfig objects for these action configs. decider configs should hold decider related settings like enable/disable deciders or deciderPeriod. These action configs can then be passed to each action while initializing it. Also we can split the cache action into separate actions since their RCAs are already separate. (It's ok to do this in a separate PR).", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463903365", "createdAt": "2020-08-01T01:27:18Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util.NodeConfigReaderUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+  private final ResourceEnum cacheType;\n+  private final NodeKey esNode;\n+\n+  private long currentCacheMaxSizeInBytes;\n+  private long heapMaxSizeInBytes;\n+\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    long desiredCapacity;\n+    if (validateAndSetNodeConfigValues(esNode, cacheType)) {\n+\n+      setBounds();\n+      desiredCapacity =\n+          increase\n+              ? currentCacheMaxSizeInBytes + getStepSize(cacheType)\n+              : currentCacheMaxSizeInBytes;\n+    } else {\n+      desiredCapacity = currentCacheMaxSizeInBytes;\n+    }\n+\n+    setDesiredCacheMaxSize(desiredCapacity);\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    return desiredCacheMaxSizeInBytes != 0\n+        && desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+      impactVector.increasesPressure(HEAP);\n+    } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+      impactVector.decreasesPressure(HEAP);\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final ResourceEnum cacheType, final long stepSize) {\n+    stepSizeInBytes.put(cacheType, stepSize);\n+  }\n+\n+  public Long getCurrentCacheMaxSizeInBytes() {\n+    return currentCacheMaxSizeInBytes;\n+  }\n+\n+  public Long getDesiredCacheMaxSizeInBytes() {\n+    return desiredCacheMaxSizeInBytes;\n+  }\n+\n+  public ResourceEnum getCacheType() {\n+    return cacheType;\n+  }\n+\n+  private boolean validateAndSetNodeConfigValues(\n+      final NodeKey esNode, final ResourceEnum cacheType) {\n+    Long cacheMaxSize = NodeConfigReaderUtil.getCacheMaxSizeInBytes(nodeConfigCache, esNode, cacheType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4MDMzNw=="}, "originalCommit": {"oid": "3cdc28dd04693904533fc0a32f21df19a2336b8c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzk1NQ==", "bodyText": "When will we hit this? We should throw exceptions instead of overloading return values. How about an IllegalArgumentException ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463903955", "createdAt": "2020-08-01T01:32:11Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -16,146 +16,188 @@\n package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders;\n \n import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n-import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.CacheDeciderConfig;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.BaseClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.FieldDataCacheClusterRca;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.ShardRequestCacheClusterRca;\n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-// TODO: 1. Read current cache capacity, total cache capacity, upper bound, lower bound from NodeConfigurationRca\n public class CacheHealthDecider extends Decider {\n-\n-    public static final String NAME = \"cacheHealthDecider\";\n-\n-    private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n-    private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n-\n-    List<String> actionsByUserPriority = new ArrayList<>();\n-    private int counter = 0;\n-\n-    public CacheHealthDecider(final long evalIntervalSeconds,\n-                              final int decisionFrequency,\n-                              final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n-                              final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n-        // TODO: Also consume NodeConfigurationRca\n-        super(evalIntervalSeconds, decisionFrequency);\n-\n-        this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n-        this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n-\n-        configureActionPriority();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return NAME;\n-    }\n-\n-    @Override\n-    public Decision operate() {\n-        final ImmutableList<BaseClusterRca> cacheClusterRca =\n-            ImmutableList.<BaseClusterRca>builder()\n-                .add(shardRequestCacheClusterRca)\n-                .add(fieldDataCacheClusterRca)\n-                .build();\n-\n-        Decision decision = new Decision(System.currentTimeMillis(), NAME);\n-        counter += 1;\n-        if (counter < decisionFrequency) {\n-            return decision;\n-        }\n-        counter = 0;\n-\n-        // TODO: Tune only one resource at a time based on action priorities\n-        cacheClusterRca.forEach(rca -> getActionsFromRca(rca, decision));\n-        return decision;\n-    }\n-\n-    private <R extends BaseClusterRca> void getActionsFromRca(\n-            final R cacheClusterRca, final Decision decision) {\n-        if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n-            final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n-            if (!flowUnit.hasResourceSummary()) {\n-                return;\n-            }\n-\n-            final HotClusterSummary clusterSummary = flowUnit.getSummary();\n-\n-            clusterSummary\n-                    .getHotNodeSummaryList()\n-                    .forEach(\n-                            hotNodeSummary -> {\n-                                final NodeKey esNode =\n-                                        new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n-                                for (final HotResourceSummary resource :\n-                                        hotNodeSummary.getHotResourceSummaryList()) {\n-                                    decision.addAction(\n-                                            computeBestAction(esNode, resource.getResource().getResourceEnum()));\n-                                }\n-                            });\n-        }\n+  private static final Logger LOG = LogManager.getLogger(CacheHealthDecider.class);\n+  public static final String NAME = \"cacheHealthDecider\";\n+\n+  private final FieldDataCacheClusterRca fieldDataCacheClusterRca;\n+  private final ShardRequestCacheClusterRca shardRequestCacheClusterRca;\n+  private final ImmutableMap<ResourceEnum, BaseClusterRca> cacheTypeBaseClusterRcaMap;\n+\n+  private double fieldDataCacheSizeUpperBound;\n+  private double shardRequestCacheSizeUpperBound;\n+\n+  List<ResourceEnum> modifyCacheActionPriorityList = new ArrayList<>();\n+  private int counter = 0;\n+\n+  public CacheHealthDecider(\n+      final long evalIntervalSeconds,\n+      final int decisionFrequency,\n+      final FieldDataCacheClusterRca fieldDataCacheClusterRca,\n+      final ShardRequestCacheClusterRca shardRequestCacheClusterRca) {\n+    super(evalIntervalSeconds, decisionFrequency);\n+    configureModifyCacheActionPriority();\n+\n+    this.fieldDataCacheClusterRca = fieldDataCacheClusterRca;\n+    this.shardRequestCacheClusterRca = shardRequestCacheClusterRca;\n+    this.cacheTypeBaseClusterRcaMap =\n+        ImmutableMap.<ResourceEnum, BaseClusterRca>builder()\n+            .put(ResourceEnum.SHARD_REQUEST_CACHE, shardRequestCacheClusterRca)\n+            .put(ResourceEnum.FIELD_DATA_CACHE, fieldDataCacheClusterRca)\n+            .build();\n+\n+    this.fieldDataCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_FIELD_DATA_CACHE_UPPER_BOUND;\n+    this.shardRequestCacheSizeUpperBound = CacheDeciderConfig.DEFAULT_SHARD_REQUEST_CACHE_UPPER_BOUND;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public Decision operate() {\n+    Set<InstanceDetails.Id> impactedNodes = new HashSet<>();\n+\n+    Decision decision = new Decision(System.currentTimeMillis(), NAME);\n+    counter += 1;\n+    if (counter < decisionFrequency) {\n+      return decision;\n     }\n+    counter = 0;\n \n-    private void configureActionPriority() {\n-        // TODO: Input from user configured yml\n-        this.actionsByUserPriority.add(ModifyCacheCapacityAction.NAME);\n+    for (final ResourceEnum cacheType : modifyCacheActionPriorityList) {\n+      getActionsFromRca(cacheTypeBaseClusterRcaMap.get(cacheType), impactedNodes)\n+          .forEach(decision::addAction);\n     }\n-\n-    /**\n-     * Evaluate the most relevant action for a node\n-     *\n-     * <p>Action relevance decided based on user configured priorities for now, this can be modified\n-     * to consume better signals going forward.\n-     */\n-    private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n-        Action action = null;\n-        for (String actionName : actionsByUserPriority) {\n-            action =\n-                    getAction(actionName, esNode, cacheType, getNodeCacheCapacityInBytes(esNode, cacheType), true);\n+    return decision;\n+  }\n+\n+  private <R extends BaseClusterRca> List<Action> getActionsFromRca(\n+      final R cacheClusterRca,\n+      final Set<InstanceDetails.Id> impactedNodes) {\n+    List<Action> actions = new ArrayList<>();\n+\n+    if (!cacheClusterRca.getFlowUnits().isEmpty()) {\n+      final ResourceFlowUnit<HotClusterSummary> flowUnit = cacheClusterRca.getFlowUnits().get(0);\n+      if (!flowUnit.hasResourceSummary()) {\n+        return actions;\n+      }\n+\n+      final List<HotNodeSummary> clusterSummary = flowUnit.getSummary().getHotNodeSummaryList();\n+\n+      for (final HotNodeSummary hotNodeSummary : clusterSummary) {\n+        if (!impactedNodes.contains(hotNodeSummary.getNodeID())) {\n+          final NodeKey esNode = new NodeKey(hotNodeSummary.getNodeID(), hotNodeSummary.getHostAddress());\n+          for (final HotResourceSummary resource : hotNodeSummary.getHotResourceSummaryList()) {\n+            final Action action = computeBestAction(esNode, resource.getResource().getResourceEnum());\n             if (action != null) {\n-                break;\n+              actions.add(action);\n+              impactedNodes.add(hotNodeSummary.getNodeID());\n             }\n+          }\n         }\n-        return action;\n+      }\n     }\n-\n-    private Action getAction(final String actionName,\n-                             final NodeKey esNode,\n-                             final ResourceEnum cacheType,\n-                             final long currentCapacityInBytes,\n-                             final boolean increase) {\n-        if (ModifyCacheCapacityAction.NAME.equals(actionName)) {\n-            return configureCacheCapacity(esNode, cacheType, currentCapacityInBytes, increase);\n-        }\n-        return null;\n+    return actions;\n+  }\n+\n+  private void configureModifyCacheActionPriority() {\n+    // Assigning shard request cache higher priority over field data cache\n+    // TODO: Modify as per the performance test results\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    this.modifyCacheActionPriorityList.add(ResourceEnum.FIELD_DATA_CACHE);\n+  }\n+\n+  /**\n+   * Evaluate the most relevant action for a node for the specific cache type\n+   *\n+   * <p>Only ModifyCacheMaxSize Action is used for now, this can be modified to consume better\n+   * signals going forward.\n+   */\n+  private Action computeBestAction(final NodeKey esNode, final ResourceEnum cacheType) {\n+    return getAction(ModifyCacheMaxSizeAction.NAME, esNode, cacheType, true);\n+  }\n+\n+  private Action getAction(\n+      final String actionName,\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    if (ModifyCacheMaxSizeAction.NAME.equals(actionName)) {\n+      return configureCacheMaxSize(\n+          esNode, cacheType, increase);\n     }\n-\n-    private ModifyCacheCapacityAction configureCacheCapacity(\n-            final NodeKey esNode,\n-            final ResourceEnum cacheType,\n-            final long currentCapacityInBytes,\n-            final boolean increase) {\n-        final ModifyCacheCapacityAction action =\n-                new ModifyCacheCapacityAction(esNode, cacheType, currentCapacityInBytes, increase);\n-        if (action.isActionable()) {\n-            return action;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  private ModifyCacheMaxSizeAction configureCacheMaxSize(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final boolean increase) {\n+    final double cacheUpperBound = getCacheUpperBound(cacheType);\n+    if (cacheUpperBound != -1) {\n+      final ModifyCacheMaxSizeAction action =\n+          new ModifyCacheMaxSizeAction(\n+              esNode,\n+              cacheType,\n+              getAppContext().getNodeConfigCache(),\n+              cacheUpperBound,\n+              increase);\n+      if (action.isActionable()) {\n+        return action;\n+      }\n     }\n-\n-    private long getNodeCacheCapacityInBytes(final NodeKey esNode, final ResourceEnum cacheType) {\n-        // TODO: use NodeConfigurationRca to return capacity, for now returning random value in Bytes\n-        if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n-            return 1000L;\n-        }\n-        return 1000L;\n+    return null;\n+  }\n+\n+  private double getCacheUpperBound(final ResourceEnum cacheType) {\n+    if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+      return getFieldDataCacheUpperBound();\n+    } else if (cacheType.equals(ResourceEnum.SHARD_REQUEST_CACHE)) {\n+      return getShardRequestCacheUpperBound();\n     }\n+    return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNDE0NA==", "bodyText": "These comments are out of context here as the util class has no relation to actions. lets remove them", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463904144", "createdAt": "2020-08-01T01:33:39Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/util/NodeConfigReaderUtil.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+public class NodeConfigReaderUtil {\n+  private static final Logger LOG = LogManager.getLogger(NodeConfigReaderUtil.class);\n+\n+  public static Long getCacheMaxSizeInBytes(\n+      final NodeConfigCache nodeConfigCache, final NodeKey esNode, final ResourceEnum cacheType) {\n+    try {\n+      if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+        return (long) nodeConfigCache.get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+      }\n+      return (long) nodeConfigCache.get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n+    }\n+    // No action if value not present in the cache.\n+    // No action will be triggered as this value was wiped out from the cache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNDE1Mg==", "bodyText": "same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r463904152", "createdAt": "2020-08-01T01:33:45Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/util/NodeConfigReaderUtil.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.util;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+public class NodeConfigReaderUtil {\n+  private static final Logger LOG = LogManager.getLogger(NodeConfigReaderUtil.class);\n+\n+  public static Long getCacheMaxSizeInBytes(\n+      final NodeConfigCache nodeConfigCache, final NodeKey esNode, final ResourceEnum cacheType) {\n+    try {\n+      if (cacheType.equals(ResourceEnum.FIELD_DATA_CACHE)) {\n+        return (long) nodeConfigCache.get(esNode, ResourceUtil.FIELD_DATA_CACHE_MAX_SIZE);\n+      }\n+      return (long) nodeConfigCache.get(esNode, ResourceUtil.SHARD_REQUEST_CACHE_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading cache max size from Node Config Cache\", e);\n+    }\n+    // No action if value not present in the cache.\n+    // No action will be triggered as this value was wiped out from the cache\n+    return null;\n+  }\n+\n+  public static Long getHeapMaxSizeInBytes(final NodeConfigCache nodeConfigCache, final NodeKey esNode) {\n+    try {\n+      return (long) nodeConfigCache.get(esNode, ResourceUtil.HEAP_MAX_SIZE);\n+    } catch (final IllegalArgumentException e) {\n+      LOG.error(\"Exception while reading heap max size from Node Config Cache\", e);\n+    }\n+    // No action if value not present in the cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa32a0a32912d9ae02c4a4cd08f1ee6478e5369f"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72", "committedDate": "2020-08-01T19:37:39Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NjA4NzQ3", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#pullrequestreview-459608747", "createdAt": "2020-08-01T23:05:02Z", "commit": {"oid": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQyMzowNTowMlrOG6g3Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQyMzoxODo1NVrOG6g6Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwODk3OA==", "bodyText": "Rename param to stepSizeInBytes to make callers aware of expected units.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r464008978", "createdAt": "2020-08-01T23:05:02Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ImpactVector.Dimension.HEAP;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Action class is used to modify the cache's max size. It is used by cache decider and other\n+ * deciders to implement actions like increasing the cache's size. Presently, it acts on field data\n+ * cache and shard request cache.\n+ */\n+\n+// TODO: Split the cache action into separate actions for different caches.\n+\n+public class ModifyCacheMaxSizeAction implements Action {\n+  private static final Logger LOG = LogManager.getLogger(ModifyCacheMaxSizeAction.class);\n+  public static final String NAME = \"modifyCacheCapacity\";\n+  public static final long COOL_OFF_PERIOD_IN_MILLIS = 300 * 1_000;\n+\n+  private final NodeKey esNode;\n+  private final ResourceEnum cacheType;\n+  private final NodeConfigCache nodeConfigCache;\n+  private final double cacheSizeUpperBound;\n+\n+  private Long currentCacheMaxSizeInBytes;\n+  private Long heapMaxSizeInBytes;\n+  private long cacheUpperBoundInBytes;\n+  private long desiredCacheMaxSizeInBytes;\n+\n+  private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n+\n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this.esNode = esNode;\n+    this.cacheType = cacheType;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheSizeUpperBound = cacheSizeUpperBound;\n+\n+    setStepSize();\n+\n+    if (validateAndSetConfigValues()) {\n+      long desiredCapacity =\n+              increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+      setDesiredCacheMaxSize(desiredCapacity);\n+    }\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean isActionable() {\n+    if (currentCacheMaxSizeInBytes == null) {\n+      return false;\n+    }\n+    return desiredCacheMaxSizeInBytes != currentCacheMaxSizeInBytes;\n+  }\n+\n+  @Override\n+  public long coolOffPeriodInMillis() {\n+    return COOL_OFF_PERIOD_IN_MILLIS;\n+  }\n+\n+  @Override\n+  public List<NodeKey> impactedNodes() {\n+    return Collections.singletonList(esNode);\n+  }\n+\n+  @Override\n+  public Map<NodeKey, ImpactVector> impact() {\n+    final ImpactVector impactVector = new ImpactVector();\n+    if (currentCacheMaxSizeInBytes != null) {\n+      if (desiredCacheMaxSizeInBytes > currentCacheMaxSizeInBytes) {\n+        impactVector.increasesPressure(HEAP);\n+      } else if (desiredCacheMaxSizeInBytes < currentCacheMaxSizeInBytes) {\n+        impactVector.decreasesPressure(HEAP);\n+      }\n+    }\n+    return Collections.singletonMap(esNode, impactVector);\n+  }\n+\n+  @Override\n+  public String summary() {\n+    if (!isActionable()) {\n+      return String.format(\"No action to take for: [%s]\", NAME);\n+    }\n+    return String.format(\n+        \"Update [%s] capacity from [%d] to [%d] on node [%s]\",\n+        cacheType.toString(),\n+        currentCacheMaxSizeInBytes,\n+        desiredCacheMaxSizeInBytes,\n+        esNode.getNodeId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return summary();\n+  }\n+\n+  public void setStepSizeForCache(final long stepSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwOTc4OQ==", "bodyText": "Was there a reason for changing these old values? We try not to change old protobuf values. I think 8-10 were intentionally left unused to add more queue metrics later.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r464009789", "createdAt": "2020-08-01T23:17:55Z", "author": {"login": "vigyasharma"}, "path": "src/main/proto/inter_node_rpc_service.proto", "diffHunk": "@@ -92,9 +95,12 @@ enum MetricEnum {\n   QUEUE_CAPACITY = 7 [(additional_fields).name = \"queue capacity\", (additional_fields).description = \"max capacity of the queue\"];\n   \n   // cache\n-  CACHE_EVICTION = 10 [(additional_fields).name = \"cache eviction\", (additional_fields).description = \"cache eviction count\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwOTgyMw==", "bodyText": "Let's leave some values for more cache metrics. We can start heap metrics from 16.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/317#discussion_r464009823", "createdAt": "2020-08-01T23:18:55Z", "author": {"login": "vigyasharma"}, "path": "src/main/proto/inter_node_rpc_service.proto", "diffHunk": "@@ -92,9 +95,12 @@ enum MetricEnum {\n   QUEUE_CAPACITY = 7 [(additional_fields).name = \"queue capacity\", (additional_fields).description = \"max capacity of the queue\"];\n   \n   // cache\n-  CACHE_EVICTION = 10 [(additional_fields).name = \"cache eviction\", (additional_fields).description = \"cache eviction count\"];\n-  CACHE_HIT = 11 [(additional_fields).name = \"cache hit\", (additional_fields).description = \"cache hit count\"];\n-  CACHE_MAX_SIZE = 12 [(additional_fields).name = \"cache max size\", (additional_fields).description = \"max cache size in bytes\"];\n+  CACHE_EVICTION = 8 [(additional_fields).name = \"cache eviction\", (additional_fields).description = \"cache eviction count\"];\n+  CACHE_HIT = 9 [(additional_fields).name = \"cache hit\", (additional_fields).description = \"cache hit count\"];\n+  CACHE_MAX_SIZE = 10 [(additional_fields).name = \"cache max size\", (additional_fields).description = \"max cache size in bytes\"];\n+\n+  // Heap\n+  HEAP_MAX = 11 [(additional_fields).name = \"heap max\", (additional_fields).description = \"max heap size in bytes\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1556ec09bd8d2f1fa5435da2c865bc66ef0a5d72"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a69dedf75bc374631e11d17ac0d7daaae05f8f1", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/7a69dedf75bc374631e11d17ac0d7daaae05f8f1", "committedDate": "2020-08-01T23:33:16Z", "message": "Fixed changes to protobuf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3578eb2dc42bad31ce4669d78b9825c8357da1c", "author": {"user": {"login": "sruti1312", "name": "Sruti Parthiban"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d3578eb2dc42bad31ce4669d78b9825c8357da1c", "committedDate": "2020-08-01T23:38:45Z", "message": "Address PR comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 837, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}