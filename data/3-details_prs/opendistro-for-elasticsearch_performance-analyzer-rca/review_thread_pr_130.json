{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MzQ1Njg1", "number": 130, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxOToyNjozN1rODuio6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDo1MTo1MFrOD094-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMTI4NjE4OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscriptionManagerTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxOToyNjozN1rOGAlLRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMjo1MjoxMFrOGOX7jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2MjI3Nw==", "bodyText": "Can someone comment on this behavior? Should we always terminate remote connections for passed host parameters regardless of whether the subscription manager is aware of the given graphNode?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r403262277", "createdAt": "2020-04-03T19:26:37Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscriptionManagerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import java.util.Collections;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+\n+public class SubscriptionManagerTest {\n+    @Mock\n+    private GRPCConnectionManager grpcConnectionManager;\n+\n+    private SubscriptionManager uut;\n+\n+    @Before\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        uut = new SubscriptionManager(grpcConnectionManager);\n+    }\n+\n+    @Test\n+    public void testAddAndGetPublishers() {\n+        String testNode = \"testNode\";\n+        String ip1 = \"127.0.0.1\";\n+        String ip2 = \"127.0.0.2\";\n+        Assert.assertEquals(Collections.emptySet(), uut.getPublishersForNode(testNode));\n+        uut.addPublisher(testNode, ip1);\n+        Assert.assertEquals(Sets.newHashSet(ip1), uut.getPublishersForNode(testNode));\n+        uut.addPublisher(testNode, ip2);\n+        Assert.assertEquals(Sets.newHashSet(ip1, ip2), uut.getPublishersForNode(testNode));\n+    }\n+\n+    @Test\n+    public void testSubscriptionFlow() {\n+        String testNode = \"testNode\";\n+        String ip1 = \"127.0.0.1\";\n+        String ip2 = \"127.0.0.2\";\n+        String locus = \"data-node\";\n+\n+        // Test that addSubscriber doesn't work on non-matching loci\n+        SubscribeResponse.SubscriptionStatus status = uut.addSubscriber(testNode, ip1, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH, status);\n+        Assert.assertFalse(uut.isNodeSubscribed(testNode));\n+\n+        // Test that addSubscriber works for matching loci\n+        uut.setCurrentLocus(locus);\n+        status = uut.addSubscriber(testNode, ip1, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS, status);\n+        Assert.assertEquals(Sets.newHashSet(ip1), uut.getSubscribersFor(testNode));\n+        Assert.assertTrue(uut.isNodeSubscribed(testNode));\n+\n+        // Test that addSubscriber works on repeated calls\n+        status = uut.addSubscriber(testNode, ip2, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS, status);\n+        Assert.assertEquals(Sets.newHashSet(ip1, ip2), uut.getSubscribersFor(testNode));\n+        Assert.assertTrue(uut.isNodeSubscribed(testNode));\n+\n+        // Test that unsubscribeAndTerminateConnection always terminates a connection\n+        // TODO is this actually the behavior we intended?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51b7423ea6222d5fe255d3942e0ecb0dc0b5354d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4MzM4NA==", "bodyText": "ping @ktkrg", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413283384", "createdAt": "2020-04-22T19:57:15Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscriptionManagerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import java.util.Collections;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+\n+public class SubscriptionManagerTest {\n+    @Mock\n+    private GRPCConnectionManager grpcConnectionManager;\n+\n+    private SubscriptionManager uut;\n+\n+    @Before\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        uut = new SubscriptionManager(grpcConnectionManager);\n+    }\n+\n+    @Test\n+    public void testAddAndGetPublishers() {\n+        String testNode = \"testNode\";\n+        String ip1 = \"127.0.0.1\";\n+        String ip2 = \"127.0.0.2\";\n+        Assert.assertEquals(Collections.emptySet(), uut.getPublishersForNode(testNode));\n+        uut.addPublisher(testNode, ip1);\n+        Assert.assertEquals(Sets.newHashSet(ip1), uut.getPublishersForNode(testNode));\n+        uut.addPublisher(testNode, ip2);\n+        Assert.assertEquals(Sets.newHashSet(ip1, ip2), uut.getPublishersForNode(testNode));\n+    }\n+\n+    @Test\n+    public void testSubscriptionFlow() {\n+        String testNode = \"testNode\";\n+        String ip1 = \"127.0.0.1\";\n+        String ip2 = \"127.0.0.2\";\n+        String locus = \"data-node\";\n+\n+        // Test that addSubscriber doesn't work on non-matching loci\n+        SubscribeResponse.SubscriptionStatus status = uut.addSubscriber(testNode, ip1, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH, status);\n+        Assert.assertFalse(uut.isNodeSubscribed(testNode));\n+\n+        // Test that addSubscriber works for matching loci\n+        uut.setCurrentLocus(locus);\n+        status = uut.addSubscriber(testNode, ip1, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS, status);\n+        Assert.assertEquals(Sets.newHashSet(ip1), uut.getSubscribersFor(testNode));\n+        Assert.assertTrue(uut.isNodeSubscribed(testNode));\n+\n+        // Test that addSubscriber works on repeated calls\n+        status = uut.addSubscriber(testNode, ip2, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS, status);\n+        Assert.assertEquals(Sets.newHashSet(ip1, ip2), uut.getSubscribersFor(testNode));\n+        Assert.assertTrue(uut.isNodeSubscribed(testNode));\n+\n+        // Test that unsubscribeAndTerminateConnection always terminates a connection\n+        // TODO is this actually the behavior we intended?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2MjI3Nw=="}, "originalCommit": {"oid": "51b7423ea6222d5fe255d3942e0ecb0dc0b5354d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcyNTMyNw==", "bodyText": "it's outside the if block only as a catch-all. In case only the RCA framework(not the JVM or the network threads) restarted and lost the subscription information, but the other side never knew about any such happenings on this node.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r417725327", "createdAt": "2020-04-30T02:52:10Z", "author": {"login": "ktkrg"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscriptionManagerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import java.util.Collections;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+\n+public class SubscriptionManagerTest {\n+    @Mock\n+    private GRPCConnectionManager grpcConnectionManager;\n+\n+    private SubscriptionManager uut;\n+\n+    @Before\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        uut = new SubscriptionManager(grpcConnectionManager);\n+    }\n+\n+    @Test\n+    public void testAddAndGetPublishers() {\n+        String testNode = \"testNode\";\n+        String ip1 = \"127.0.0.1\";\n+        String ip2 = \"127.0.0.2\";\n+        Assert.assertEquals(Collections.emptySet(), uut.getPublishersForNode(testNode));\n+        uut.addPublisher(testNode, ip1);\n+        Assert.assertEquals(Sets.newHashSet(ip1), uut.getPublishersForNode(testNode));\n+        uut.addPublisher(testNode, ip2);\n+        Assert.assertEquals(Sets.newHashSet(ip1, ip2), uut.getPublishersForNode(testNode));\n+    }\n+\n+    @Test\n+    public void testSubscriptionFlow() {\n+        String testNode = \"testNode\";\n+        String ip1 = \"127.0.0.1\";\n+        String ip2 = \"127.0.0.2\";\n+        String locus = \"data-node\";\n+\n+        // Test that addSubscriber doesn't work on non-matching loci\n+        SubscribeResponse.SubscriptionStatus status = uut.addSubscriber(testNode, ip1, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH, status);\n+        Assert.assertFalse(uut.isNodeSubscribed(testNode));\n+\n+        // Test that addSubscriber works for matching loci\n+        uut.setCurrentLocus(locus);\n+        status = uut.addSubscriber(testNode, ip1, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS, status);\n+        Assert.assertEquals(Sets.newHashSet(ip1), uut.getSubscribersFor(testNode));\n+        Assert.assertTrue(uut.isNodeSubscribed(testNode));\n+\n+        // Test that addSubscriber works on repeated calls\n+        status = uut.addSubscriber(testNode, ip2, locus);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS, status);\n+        Assert.assertEquals(Sets.newHashSet(ip1, ip2), uut.getSubscribersFor(testNode));\n+        Assert.assertTrue(uut.isNodeSubscribed(testNode));\n+\n+        // Test that unsubscribeAndTerminateConnection always terminates a connection\n+        // TODO is this actually the behavior we intended?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2MjI3Nw=="}, "originalCommit": {"oid": "51b7423ea6222d5fe255d3942e0ecb0dc0b5354d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxODU0MzcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/messages/IntentMsg.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMjoyNDo0MVrOGDDGZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyMzoxMFrOGDp5xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0OTcwMA==", "bodyText": "If this is only for tests, can we check for the requestNode and destinationNode strings explicitly instead of overriding the equals methods ?\nOtherwise in Java, with equals(), hashcode() needs to be implemented as well", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r405849700", "createdAt": "2020-04-08T22:24:41Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/messages/IntentMsg.java", "diffHunk": "@@ -55,4 +56,17 @@ public IntentMsg(String requesterNode, String destinationNode, Map<String, Strin\n   public String toString() {\n     return String.format(\"Intent::from: '%s', to: '%s'\", requesterNode, destinationNode);\n   }\n+\n+  @Override\n+  public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f59376a87d03e039eeae3e25ad7279a11de20dd"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg1Njg4MA==", "bodyText": "Nice catch! I'll address this issue in the next PR.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r405856880", "createdAt": "2020-04-08T22:44:03Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/messages/IntentMsg.java", "diffHunk": "@@ -55,4 +56,17 @@ public IntentMsg(String requesterNode, String destinationNode, Map<String, Strin\n   public String toString() {\n     return String.format(\"Intent::from: '%s', to: '%s'\", requesterNode, destinationNode);\n   }\n+\n+  @Override\n+  public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0OTcwMA=="}, "originalCommit": {"oid": "6f59376a87d03e039eeae3e25ad7279a11de20dd"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2MjU1MQ==", "bodyText": "This is a closed pull request ? I see that you closed it but then reopened it as well. Please consider closing it if it does not need to be reviewed any more.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r406462551", "createdAt": "2020-04-09T20:37:06Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/messages/IntentMsg.java", "diffHunk": "@@ -55,4 +56,17 @@ public IntentMsg(String requesterNode, String destinationNode, Map<String, Strin\n   public String toString() {\n     return String.format(\"Intent::from: '%s', to: '%s'\", requesterNode, destinationNode);\n   }\n+\n+  @Override\n+  public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0OTcwMA=="}, "originalCommit": {"oid": "6f59376a87d03e039eeae3e25ad7279a11de20dd"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MjU4NQ==", "bodyText": "^ I closed it because the FileGCTest failed, so to get the CI check to pass, I had to close and reopen the PR because CI is triggered on a submission.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r406482585", "createdAt": "2020-04-09T21:17:09Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/messages/IntentMsg.java", "diffHunk": "@@ -55,4 +56,17 @@ public IntentMsg(String requesterNode, String destinationNode, Map<String, Strin\n   public String toString() {\n     return String.format(\"Intent::from: '%s', to: '%s'\", requesterNode, destinationNode);\n   }\n+\n+  @Override\n+  public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0OTcwMA=="}, "originalCommit": {"oid": "6f59376a87d03e039eeae3e25ad7279a11de20dd"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTQ0NQ==", "bodyText": "I've removed the equals() methods on classes where they were unnecessary, and included hashcode() for classes where they were necessary.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r406485445", "createdAt": "2020-04-09T21:23:10Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/messages/IntentMsg.java", "diffHunk": "@@ -55,4 +56,17 @@ public IntentMsg(String requesterNode, String destinationNode, Map<String, Strin\n   public String toString() {\n     return String.format(\"Intent::from: '%s', to: '%s'\", requesterNode, destinationNode);\n   }\n+\n+  @Override\n+  public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0OTcwMA=="}, "originalCommit": {"oid": "6f59376a87d03e039eeae3e25ad7279a11de20dd"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODM0MDkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/net/NetServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo0NToxM1rOGKIINA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxMzo0OVrOGKW6Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3MjExNg==", "bodyText": "Can I suggest an alternative ? Can we add a prehook and post hook which will be empty and then for test we override these methods to set the variable and we can test it ? I assume this variable is only for test purposes only ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413272116", "createdAt": "2020-04-22T19:45:13Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/net/NetServer.java", "diffHunk": "@@ -107,6 +111,7 @@ public void run() {\n     try {\n       server.start();\n       LOG.info(\"gRPC server started successfully!\");\n+      running.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNDI3NQ==", "bodyText": "Done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413514275", "createdAt": "2020-04-23T05:13:49Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/net/NetServer.java", "diffHunk": "@@ -107,6 +111,7 @@ public void run() {\n     try {\n       server.start();\n       LOG.info(\"gRPC server started successfully!\");\n+      running.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3MjExNg=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODM1MTE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/NodeStateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo0NzozOVrOGKIOFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxMzo1NlrOGKW6WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3MzYyMw==", "bodyText": "If this is for test only, can we annotate it as such ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413273623", "createdAt": "2020-04-22T19:47:39Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/NodeStateManager.java", "diffHunk": "@@ -67,12 +67,18 @@ public void updateReceiveTime(final String host, final String graphNode, final l\n    */\n   public long getLastReceivedTimestamp(String graphNode, String host) {\n     final String compositeKey = graphNode + SEPARATOR + host;\n-    if (lastReceivedTimestampMap.containsKey(compositeKey)) {\n-      return lastReceivedTimestampMap.get(compositeKey);\n-    }\n+    // Return the last received value or a value that is in the distant past.\n+    return lastReceivedTimestampMap.getOrDefault(compositeKey, 0L);\n+  }\n \n-    // Return a value that is in the distant past.\n-    return 0;\n+  public SubscriptionStatus getSubscriptionStatus(String graphNode, String host) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNDMyOQ==", "bodyText": "Done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413514329", "createdAt": "2020-04-23T05:13:56Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/NodeStateManager.java", "diffHunk": "@@ -67,12 +67,18 @@ public void updateReceiveTime(final String host, final String graphNode, final l\n    */\n   public long getLastReceivedTimestamp(String graphNode, String host) {\n     final String compositeKey = graphNode + SEPARATOR + host;\n-    if (lastReceivedTimestampMap.containsKey(compositeKey)) {\n-      return lastReceivedTimestampMap.get(compositeKey);\n-    }\n+    // Return the last received value or a value that is in the distant past.\n+    return lastReceivedTimestampMap.getOrDefault(compositeKey, 0L);\n+  }\n \n-    // Return a value that is in the distant past.\n-    return 0;\n+  public SubscriptionStatus getSubscriptionStatus(String graphNode, String host) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3MzYyMw=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODM3NTUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/ReceivedFlowUnitStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo1MTozMFrOGKIeJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxNDoyNlrOGKW7Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NzczMg==", "bodyText": "we can probably avoid this copy here, right ? Although the test is the only one that needs it, the release code also pays the price for it.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413277732", "createdAt": "2020-04-22T19:51:30Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/ReceivedFlowUnitStore.java", "diffHunk": "@@ -100,9 +100,12 @@ public boolean enqueue(final String graphNode, final FlowUnitMessage flowUnitMes\n   /**\n    * Drains out all the flow units for all nodes.\n    */\n-  public void drainAll() {\n+  public ImmutableList<FlowUnitMessage> drainAll() {\n+    List<FlowUnitMessage> drained = new ArrayList<>();\n     for (final String graphNode : flowUnitMap.keySet()) {\n-      drainNode(graphNode);\n+      ImmutableList<FlowUnitMessage> messages = drainNode(graphNode);\n+      drained.addAll(messages);\n     }\n+    return ImmutableList.copyOf(drained);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNDUwMw==", "bodyText": "Done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413514503", "createdAt": "2020-04-23T05:14:26Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/ReceivedFlowUnitStore.java", "diffHunk": "@@ -100,9 +100,12 @@ public boolean enqueue(final String graphNode, final FlowUnitMessage flowUnitMes\n   /**\n    * Drains out all the flow units for all nodes.\n    */\n-  public void drainAll() {\n+  public ImmutableList<FlowUnitMessage> drainAll() {\n+    List<FlowUnitMessage> drained = new ArrayList<>();\n     for (final String graphNode : flowUnitMap.keySet()) {\n-      drainNode(graphNode);\n+      ImmutableList<FlowUnitMessage> messages = drainNode(graphNode);\n+      drained.addAll(messages);\n     }\n+    return ImmutableList.copyOf(drained);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NzczMg=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODM4Mjk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ClusterDetailsEventProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo1Mjo0MVrOGKIjQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxNTowOVrOGKW76g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3OTA0Mg==", "bodyText": "Should we make all the arguments final ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413279042", "createdAt": "2020-04-22T19:52:41Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ClusterDetailsEventProcessor.java", "diffHunk": "@@ -124,12 +125,27 @@ public static NodeDetails getCurrentNodeDetails() {\n   }\n \n   public static class NodeDetails {\n-\n-    private String id;\n-    private String hostAddress;\n-    private String role;\n+    private final String id;\n+    private final String hostAddress;\n+    private final String role;\n     private Boolean isMasterNode;\n \n+    /**\n+     * This constructor is provided expressly for testing purposes. In general, NodeDetails should only be\n+     * retrieved through method calls such as {@link ClusterDetailsEventProcessor#getCurrentNodeDetails()}\n+     * @param id The node's id\n+     * @param hostAddress The host's address\n+     * @param role The node's role e.g. data-node\n+     * @param isMasterNode Whether or not the node is a master node\n+     */\n+    @VisibleForTesting\n+    public NodeDetails(String id, String hostAddress, String role, Boolean isMasterNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNDczMA==", "bodyText": "Removed the constructor, used a test method to generate NodeDetails, the new test method takes final arguments", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413514730", "createdAt": "2020-04-23T05:15:09Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ClusterDetailsEventProcessor.java", "diffHunk": "@@ -124,12 +125,27 @@ public static NodeDetails getCurrentNodeDetails() {\n   }\n \n   public static class NodeDetails {\n-\n-    private String id;\n-    private String hostAddress;\n-    private String role;\n+    private final String id;\n+    private final String hostAddress;\n+    private final String role;\n     private Boolean isMasterNode;\n \n+    /**\n+     * This constructor is provided expressly for testing purposes. In general, NodeDetails should only be\n+     * retrieved through method calls such as {@link ClusterDetailsEventProcessor#getCurrentNodeDetails()}\n+     * @param id The node's id\n+     * @param hostAddress The host's address\n+     * @param role The node's role e.g. data-node\n+     * @param isMasterNode Whether or not the node is a master node\n+     */\n+    @VisibleForTesting\n+    public NodeDetails(String id, String hostAddress, String role, Boolean isMasterNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3OTA0Mg=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODUwNjM1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/RejectingExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDoxNzoxN1rOGKJwnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxNToyNlrOGKW8OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5ODg0NQ==", "bodyText": "This is good but I see that it's being used by test classes (and very rightly so). So, should we move it to the test packing instead of keeping it here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413298845", "createdAt": "2020-04-22T20:17:17Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/RejectingExecutor.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * An executor which throws an {@link RejectedExecutionException} any time it is asked to execute a task\n+ * This class is useful for testing certain branches of our net code\n+ */\n+class RejectingExecutor implements ExecutorService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNDgwOQ==", "bodyText": "It is already under src/test", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413514809", "createdAt": "2020-04-23T05:15:26Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/RejectingExecutor.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * An executor which throws an {@link RejectedExecutionException} any time it is asked to execute a task\n+ * This class is useful for testing certain branches of our net code\n+ */\n+class RejectingExecutor implements ExecutorService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5ODg0NQ=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODUyMDMzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/RejectingExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDoxOToyMVrOGKJ5lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxNTozNlrOGKW8dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMTE0MQ==", "bodyText": "We are missing a newline at the end of the file ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413301141", "createdAt": "2020-04-22T20:19:21Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/RejectingExecutor.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * An executor which throws an {@link RejectedExecutionException} any time it is asked to execute a task\n+ * This class is useful for testing certain branches of our net code\n+ */\n+class RejectingExecutor implements ExecutorService {\n+\n+    @Override\n+    public void shutdown() {}\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> callable) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable runnable, T t) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable runnable) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) throws InterruptedException {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit)\n+            throws InterruptedException {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection)\n+            throws InterruptedException, ExecutionException {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void execute(Runnable runnable) {\n+        throw new RejectedExecutionException(\"REJECTED\");\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNDg2OQ==", "bodyText": "Fixed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413514869", "createdAt": "2020-04-23T05:15:36Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/RejectingExecutor.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * An executor which throws an {@link RejectedExecutionException} any time it is asked to execute a task\n+ * This class is useful for testing certain branches of our net code\n+ */\n+class RejectingExecutor implements ExecutorService {\n+\n+    @Override\n+    public void shutdown() {}\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> callable) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable runnable, T t) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable runnable) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) throws InterruptedException {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit)\n+            throws InterruptedException {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection)\n+            throws InterruptedException, ExecutionException {\n+        return null;\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        return null;\n+    }\n+\n+    @Override\n+    public void execute(Runnable runnable) {\n+        throw new RejectedExecutionException(\"REJECTED\");\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMTE0MQ=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODUzNjE3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscribeResponseHandlerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDoyMzoyNlrOGKKDBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxNjowOVrOGKW9SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMzU1OQ==", "bodyText": "Why do we always name as uut ? :)", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413303559", "createdAt": "2020-04-22T20:23:26Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscribeResponseHandlerTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SubscribeResponseHandlerTest {\n+    private static final String HOST = \"127.0.0.1\";\n+    private static final String NODE = \"TEST\";\n+\n+    private SubscriptionManager subscriptionManager;\n+    private NodeStateManager nodeStateManager;\n+    private SubscribeResponseHandler uut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNTA4MA==", "bodyText": "\"unit under test\", I'm used to that naming convention from Splunk. I don't feel strongly about it :)", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413515080", "createdAt": "2020-04-23T05:16:09Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscribeResponseHandlerTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SubscribeResponseHandlerTest {\n+    private static final String HOST = \"127.0.0.1\";\n+    private static final String NODE = \"TEST\";\n+\n+    private SubscriptionManager subscriptionManager;\n+    private NodeStateManager nodeStateManager;\n+    private SubscribeResponseHandler uut;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMzU1OQ=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODU5OTA2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscribeResponseHandlerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDozOTozNFrOGKKo2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxODoxN1rOGKXAMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxMzI0Mg==", "bodyText": "I don't quite understand what we are testing here. We should test for some expected value or else this test will always pass.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413313242", "createdAt": "2020-04-22T20:39:34Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscribeResponseHandlerTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SubscribeResponseHandlerTest {\n+    private static final String HOST = \"127.0.0.1\";\n+    private static final String NODE = \"TEST\";\n+\n+    private SubscriptionManager subscriptionManager;\n+    private NodeStateManager nodeStateManager;\n+    private SubscribeResponseHandler uut;\n+\n+    @Before\n+    public void setup() {\n+        GRPCConnectionManager grpcConnectionManager = new GRPCConnectionManager(true);\n+        subscriptionManager = new SubscriptionManager(grpcConnectionManager);\n+        nodeStateManager = new NodeStateManager();\n+        uut = new SubscribeResponseHandler(subscriptionManager, nodeStateManager, HOST, NODE);\n+    }\n+\n+    @Test\n+    public void testOnNext() {\n+        // Test that onNext() properly processes a successful subscription message\n+        SubscribeResponse success = SubscribeResponse.newBuilder()\n+                .setSubscriptionStatus(SubscribeResponse.SubscriptionStatus.SUCCESS).build();\n+        uut.onNext(success);\n+        Assert.assertEquals(subscriptionManager.getPublishersForNode(NODE), Sets.newHashSet(HOST));\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS,\n+                nodeStateManager.getSubscriptionStatus(NODE, HOST));\n+\n+        // Test that onNext() properly processes a tag mismatch subscription message\n+        SubscribeResponse mismatch = SubscribeResponse.newBuilder()\n+                .setSubscriptionStatus(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH).build();\n+        uut.onNext(mismatch);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH,\n+                nodeStateManager.getSubscriptionStatus(NODE, HOST));\n+        SubscribeResponse unknown = SubscribeResponse.newBuilder().build();\n+        uut.onNext(unknown); // This line is included for branch coverage\n+    }\n+\n+    @Test\n+    public void testOnError() {\n+        /* No-op */\n+        uut.onError(new Exception(\"no-op\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNTgyNg==", "bodyText": "This is solely for test coverage of those methods, we can't verify the logic of methods which only log. If someone adds logic to these methods at a later date, the coverage will drop unless they implement appropriate test logic here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413515826", "createdAt": "2020-04-23T05:18:17Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/SubscribeResponseHandlerTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.SubscribeResponse;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.google.common.collect.Sets;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SubscribeResponseHandlerTest {\n+    private static final String HOST = \"127.0.0.1\";\n+    private static final String NODE = \"TEST\";\n+\n+    private SubscriptionManager subscriptionManager;\n+    private NodeStateManager nodeStateManager;\n+    private SubscribeResponseHandler uut;\n+\n+    @Before\n+    public void setup() {\n+        GRPCConnectionManager grpcConnectionManager = new GRPCConnectionManager(true);\n+        subscriptionManager = new SubscriptionManager(grpcConnectionManager);\n+        nodeStateManager = new NodeStateManager();\n+        uut = new SubscribeResponseHandler(subscriptionManager, nodeStateManager, HOST, NODE);\n+    }\n+\n+    @Test\n+    public void testOnNext() {\n+        // Test that onNext() properly processes a successful subscription message\n+        SubscribeResponse success = SubscribeResponse.newBuilder()\n+                .setSubscriptionStatus(SubscribeResponse.SubscriptionStatus.SUCCESS).build();\n+        uut.onNext(success);\n+        Assert.assertEquals(subscriptionManager.getPublishersForNode(NODE), Sets.newHashSet(HOST));\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.SUCCESS,\n+                nodeStateManager.getSubscriptionStatus(NODE, HOST));\n+\n+        // Test that onNext() properly processes a tag mismatch subscription message\n+        SubscribeResponse mismatch = SubscribeResponse.newBuilder()\n+                .setSubscriptionStatus(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH).build();\n+        uut.onNext(mismatch);\n+        Assert.assertEquals(SubscribeResponse.SubscriptionStatus.TAG_MISMATCH,\n+                nodeStateManager.getSubscriptionStatus(NODE, HOST));\n+        SubscribeResponse unknown = SubscribeResponse.newBuilder().build();\n+        uut.onNext(unknown); // This line is included for branch coverage\n+    }\n+\n+    @Test\n+    public void testOnError() {\n+        /* No-op */\n+        uut.onError(new Exception(\"no-op\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxMzI0Mg=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODYxNDUzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDo0MzowNFrOGKKx5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNToxODo0NVrOGKXAyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxNTU1Ng==", "bodyText": "Is there a reason all these have to be static ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413315556", "createdAt": "2020-04-22T20:43:04Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.config.PluginSettings;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetClient;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetServer;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.GradleTaskForRca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.SymptomFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.Heap_Used;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.GenericFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Node;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.DataMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.IntentMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.PublishRequestHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.SubscribeServerHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(GradleTaskForRca.class)\n+public class WireHopperTest {\n+    private static final String NODE1 = \"NODE1\";\n+    private static final String NODE2 = \"NODE2\";\n+    private static final String LOCALHOST = \"127.0.0.1\";\n+    private static final String HOST_NOT_IN_CLUSTER = \"NOTINCLUSTER\";\n+    private static final String LOCUS = \"data-node\";\n+    private static final long EVAL_INTERVAL_S = 5L;\n+    private static final long TIMESTAMP = 66L;\n+    private static final ExecutorService rejectingExecutor = new RejectingExecutor();\n+\n+    private static NetClient netClient;\n+    private static NetServer netServer;\n+    private static ExecutorService executorService;\n+    private static ExecutorService netServerExecutor;\n+    private static GRPCConnectionManager connectionManager;\n+    private static SubscriptionManager subscriptionManager;\n+    private static NodeStateManager nodeStateManager;\n+    private static ReceivedFlowUnitStore receivedFlowUnitStore;\n+    private static AtomicReference<ExecutorService> clientExecutor;\n+    private static AtomicReference<ExecutorService> serverExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNTk3OQ==", "bodyText": "I changed a few of them which didn't need to be static. The server startup stuff happens in the static @BeforeClass method", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413515979", "createdAt": "2020-04-23T05:18:45Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.config.PluginSettings;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetClient;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetServer;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.GradleTaskForRca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.SymptomFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.Heap_Used;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.GenericFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Node;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.DataMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.IntentMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.PublishRequestHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.SubscribeServerHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(GradleTaskForRca.class)\n+public class WireHopperTest {\n+    private static final String NODE1 = \"NODE1\";\n+    private static final String NODE2 = \"NODE2\";\n+    private static final String LOCALHOST = \"127.0.0.1\";\n+    private static final String HOST_NOT_IN_CLUSTER = \"NOTINCLUSTER\";\n+    private static final String LOCUS = \"data-node\";\n+    private static final long EVAL_INTERVAL_S = 5L;\n+    private static final long TIMESTAMP = 66L;\n+    private static final ExecutorService rejectingExecutor = new RejectingExecutor();\n+\n+    private static NetClient netClient;\n+    private static NetServer netServer;\n+    private static ExecutorService executorService;\n+    private static ExecutorService netServerExecutor;\n+    private static GRPCConnectionManager connectionManager;\n+    private static SubscriptionManager subscriptionManager;\n+    private static NodeStateManager nodeStateManager;\n+    private static ReceivedFlowUnitStore receivedFlowUnitStore;\n+    private static AtomicReference<ExecutorService> clientExecutor;\n+    private static AtomicReference<ExecutorService> serverExecutor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxNTU1Ng=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODY2NTU1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDo1MTo1MFrOGKLS0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMToxMTo1N1rOGK8Upw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMyMzk4Ng==", "bodyText": "How did we arrive at this number ? I have seen arbitrary sleeps make test cases flaky. And sometimes the tests take too long to run because there are multiple tests doing this. It might be a good idea to check for the expected value in a loop for some max timeouts where the sleeps between each iteration is in milliseconds. That way we don't wait more than we have to. and the timeout can be much longer than 3 seconds as we expect to break out of them early anyways", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413323986", "createdAt": "2020-04-22T20:51:50Z", "author": {"login": "yojs"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.config.PluginSettings;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetClient;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetServer;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.GradleTaskForRca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.SymptomFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.Heap_Used;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.GenericFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Node;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.DataMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.IntentMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.PublishRequestHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.SubscribeServerHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(GradleTaskForRca.class)\n+public class WireHopperTest {\n+    private static final String NODE1 = \"NODE1\";\n+    private static final String NODE2 = \"NODE2\";\n+    private static final String LOCALHOST = \"127.0.0.1\";\n+    private static final String HOST_NOT_IN_CLUSTER = \"NOTINCLUSTER\";\n+    private static final String LOCUS = \"data-node\";\n+    private static final long EVAL_INTERVAL_S = 5L;\n+    private static final long TIMESTAMP = 66L;\n+    private static final ExecutorService rejectingExecutor = new RejectingExecutor();\n+\n+    private static NetClient netClient;\n+    private static NetServer netServer;\n+    private static ExecutorService executorService;\n+    private static ExecutorService netServerExecutor;\n+    private static GRPCConnectionManager connectionManager;\n+    private static SubscriptionManager subscriptionManager;\n+    private static NodeStateManager nodeStateManager;\n+    private static ReceivedFlowUnitStore receivedFlowUnitStore;\n+    private static AtomicReference<ExecutorService> clientExecutor;\n+    private static AtomicReference<ExecutorService> serverExecutor;\n+    // Unit under test\n+    private static WireHopper uut;\n+\n+    @BeforeClass\n+    public static void setupClass() throws InterruptedException {\n+        connectionManager = new GRPCConnectionManager(PluginSettings.instance().getHttpsEnabled());\n+        netClient = new NetClient(connectionManager);\n+        executorService = Executors.newSingleThreadExecutor();\n+        clientExecutor = new AtomicReference<>(null);\n+        serverExecutor = new AtomicReference<>(Executors.newSingleThreadExecutor());\n+        netServer = new NetServer(Util.RPC_PORT, 1, false);\n+        netServerExecutor = Executors.newSingleThreadExecutor();\n+        netServerExecutor.execute(netServer);\n+        while (!netServer.isRunning()) {\n+            Thread.sleep(1000L);\n+        }\n+    }\n+\n+    @Before\n+    public void setup() {\n+        nodeStateManager = new NodeStateManager();\n+        receivedFlowUnitStore = new ReceivedFlowUnitStore();\n+        subscriptionManager = new SubscriptionManager(connectionManager);\n+        clientExecutor.set(null);\n+        uut = new WireHopper(nodeStateManager, netClient, subscriptionManager, clientExecutor, receivedFlowUnitStore);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        executorService.shutdown();\n+        netServerExecutor.shutdown();\n+        netServer.stop();\n+        netClient.stop();\n+    }\n+\n+    @Test\n+    public void testSendIntent() throws InterruptedException {\n+        Node<MetricFlowUnit> node = new Heap_Used(EVAL_INTERVAL_S);\n+        netServer.setSubscribeHandler(new SubscribeServerHandler(subscriptionManager, serverExecutor));\n+        Map<String, String> rcaConfTags = new HashMap<>();\n+        rcaConfTags.put(\"locus\", RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        IntentMsg msg = new IntentMsg(NODE1, node.name(), rcaConfTags);\n+        // verify resilience to null executor\n+        uut.sendIntent(msg);\n+        // verify method generates appropriate task\n+        clientExecutor.set(executorService);\n+        subscriptionManager.setCurrentLocus(RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        ClusterDetailsEventProcessor.setNodesDetails(Lists.newArrayList(\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE1, LOCALHOST, \"\", false),\n+                new ClusterDetailsEventProcessor.NodeDetails(node.name(), LOCALHOST, \"\", false)\n+        ));\n+        uut.sendIntent(msg);\n+        Thread.sleep(2000L);\n+        Assert.assertEquals(1, subscriptionManager.getSubscribersFor(node.name()).size());\n+        Assert.assertEquals(LOCALHOST, subscriptionManager.getSubscribersFor(node.name()).asList().get(0));\n+        // verify resilience to RejectedExecutionException\n+        clientExecutor.set(rejectingExecutor);\n+        uut.sendIntent(msg);\n+    }\n+\n+    @Test\n+    public void testSendData() throws InterruptedException {\n+        netServer.setSendDataHandler(new PublishRequestHandler(nodeStateManager, receivedFlowUnitStore, serverExecutor));\n+        // verify resilience to null executor\n+        GenericFlowUnit flowUnit = new SymptomFlowUnit(TIMESTAMP);\n+        DataMsg msg = new DataMsg(NODE1, Lists.newArrayList(NODE2), Collections.singletonList(flowUnit));\n+        uut.sendData(msg);\n+\n+        clientExecutor.set(executorService);\n+        Assert.assertEquals(0L, nodeStateManager.getLastReceivedTimestamp(NODE1, LOCALHOST));\n+        // setup downstream subscribers\n+        subscriptionManager.setCurrentLocus(LOCUS);\n+        subscriptionManager.addSubscriber(NODE1, LOCALHOST, LOCUS);\n+        // verify sendData works\n+        ClusterDetailsEventProcessor.setNodesDetails(Lists.newArrayList(\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE1, LOCALHOST, \"\", false),\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE2, LOCALHOST, \"\", false)\n+        ));\n+        uut.sendData(msg);\n+        Thread.sleep(2000L);\n+        Assert.assertNotEquals(0L, nodeStateManager.getLastReceivedTimestamp(NODE1, LOCALHOST));\n+        List<FlowUnitMessage> receivedMags = receivedFlowUnitStore.drainNode(NODE1);\n+        Assert.assertEquals(1L, receivedMags.size());\n+\n+        // verify resilience to RejectedExecutionException\n+        clientExecutor.set(rejectingExecutor);\n+        uut.sendData(msg);\n+    }\n+\n+    @Test\n+    public void testReadFromWire() throws InterruptedException {\n+        netServer.setSubscribeHandler(new SubscribeServerHandler(subscriptionManager, serverExecutor));\n+        // Setup mock object responses\n+        Node<MetricFlowUnit> node = new Heap_Used(EVAL_INTERVAL_S);\n+        node.addTag(RcaConsts.RcaTagConstants.TAG_LOCUS, RcaConsts.RcaTagConstants.LOCUS_DATA_MASTER_NODE);\n+        // Verify resilience to null executor\n+        uut.readFromWire(node);\n+        // Execute test method and verify return value\n+        clientExecutor.set(executorService);\n+        ClusterDetailsEventProcessor.setNodesDetails(Collections.singletonList(\n+                new ClusterDetailsEventProcessor.NodeDetails(\n+                        node.name(), LOCALHOST, RcaConsts.RcaTagConstants.LOCUS_DATA_NODE, false)));\n+        subscriptionManager.setCurrentLocus(RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        subscriptionManager.addPublisher(node.name(), LOCALHOST);\n+        subscriptionManager.addPublisher(node.name(), HOST_NOT_IN_CLUSTER);\n+        nodeStateManager.updateReceiveTime(LOCALHOST, node.name(), 1L);\n+        FlowUnitMessage msg = FlowUnitMessage.newBuilder().setGraphNode(node.name()).build();\n+        ImmutableList<FlowUnitMessage> msgList = ImmutableList.<FlowUnitMessage>builder().add(msg).build();\n+        receivedFlowUnitStore.enqueue(node.name(), msg);\n+        List<FlowUnitMessage> actualMsgList = uut.readFromWire(node);\n+        Assert.assertEquals(msgList, actualMsgList);\n+        // Verify expected interactions with the subscription manager\n+        Thread.sleep(3000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNjMyNw==", "bodyText": "I've modified everything to be a uniform 1 second. Testing the mean on my local machine would likely differ from the mean on the CI runner, so I feel that 1s is a good uniform compromise.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r413516327", "createdAt": "2020-04-23T05:19:51Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.config.PluginSettings;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetClient;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetServer;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.GradleTaskForRca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.SymptomFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.Heap_Used;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.GenericFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Node;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.DataMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.IntentMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.PublishRequestHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.SubscribeServerHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(GradleTaskForRca.class)\n+public class WireHopperTest {\n+    private static final String NODE1 = \"NODE1\";\n+    private static final String NODE2 = \"NODE2\";\n+    private static final String LOCALHOST = \"127.0.0.1\";\n+    private static final String HOST_NOT_IN_CLUSTER = \"NOTINCLUSTER\";\n+    private static final String LOCUS = \"data-node\";\n+    private static final long EVAL_INTERVAL_S = 5L;\n+    private static final long TIMESTAMP = 66L;\n+    private static final ExecutorService rejectingExecutor = new RejectingExecutor();\n+\n+    private static NetClient netClient;\n+    private static NetServer netServer;\n+    private static ExecutorService executorService;\n+    private static ExecutorService netServerExecutor;\n+    private static GRPCConnectionManager connectionManager;\n+    private static SubscriptionManager subscriptionManager;\n+    private static NodeStateManager nodeStateManager;\n+    private static ReceivedFlowUnitStore receivedFlowUnitStore;\n+    private static AtomicReference<ExecutorService> clientExecutor;\n+    private static AtomicReference<ExecutorService> serverExecutor;\n+    // Unit under test\n+    private static WireHopper uut;\n+\n+    @BeforeClass\n+    public static void setupClass() throws InterruptedException {\n+        connectionManager = new GRPCConnectionManager(PluginSettings.instance().getHttpsEnabled());\n+        netClient = new NetClient(connectionManager);\n+        executorService = Executors.newSingleThreadExecutor();\n+        clientExecutor = new AtomicReference<>(null);\n+        serverExecutor = new AtomicReference<>(Executors.newSingleThreadExecutor());\n+        netServer = new NetServer(Util.RPC_PORT, 1, false);\n+        netServerExecutor = Executors.newSingleThreadExecutor();\n+        netServerExecutor.execute(netServer);\n+        while (!netServer.isRunning()) {\n+            Thread.sleep(1000L);\n+        }\n+    }\n+\n+    @Before\n+    public void setup() {\n+        nodeStateManager = new NodeStateManager();\n+        receivedFlowUnitStore = new ReceivedFlowUnitStore();\n+        subscriptionManager = new SubscriptionManager(connectionManager);\n+        clientExecutor.set(null);\n+        uut = new WireHopper(nodeStateManager, netClient, subscriptionManager, clientExecutor, receivedFlowUnitStore);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        executorService.shutdown();\n+        netServerExecutor.shutdown();\n+        netServer.stop();\n+        netClient.stop();\n+    }\n+\n+    @Test\n+    public void testSendIntent() throws InterruptedException {\n+        Node<MetricFlowUnit> node = new Heap_Used(EVAL_INTERVAL_S);\n+        netServer.setSubscribeHandler(new SubscribeServerHandler(subscriptionManager, serverExecutor));\n+        Map<String, String> rcaConfTags = new HashMap<>();\n+        rcaConfTags.put(\"locus\", RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        IntentMsg msg = new IntentMsg(NODE1, node.name(), rcaConfTags);\n+        // verify resilience to null executor\n+        uut.sendIntent(msg);\n+        // verify method generates appropriate task\n+        clientExecutor.set(executorService);\n+        subscriptionManager.setCurrentLocus(RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        ClusterDetailsEventProcessor.setNodesDetails(Lists.newArrayList(\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE1, LOCALHOST, \"\", false),\n+                new ClusterDetailsEventProcessor.NodeDetails(node.name(), LOCALHOST, \"\", false)\n+        ));\n+        uut.sendIntent(msg);\n+        Thread.sleep(2000L);\n+        Assert.assertEquals(1, subscriptionManager.getSubscribersFor(node.name()).size());\n+        Assert.assertEquals(LOCALHOST, subscriptionManager.getSubscribersFor(node.name()).asList().get(0));\n+        // verify resilience to RejectedExecutionException\n+        clientExecutor.set(rejectingExecutor);\n+        uut.sendIntent(msg);\n+    }\n+\n+    @Test\n+    public void testSendData() throws InterruptedException {\n+        netServer.setSendDataHandler(new PublishRequestHandler(nodeStateManager, receivedFlowUnitStore, serverExecutor));\n+        // verify resilience to null executor\n+        GenericFlowUnit flowUnit = new SymptomFlowUnit(TIMESTAMP);\n+        DataMsg msg = new DataMsg(NODE1, Lists.newArrayList(NODE2), Collections.singletonList(flowUnit));\n+        uut.sendData(msg);\n+\n+        clientExecutor.set(executorService);\n+        Assert.assertEquals(0L, nodeStateManager.getLastReceivedTimestamp(NODE1, LOCALHOST));\n+        // setup downstream subscribers\n+        subscriptionManager.setCurrentLocus(LOCUS);\n+        subscriptionManager.addSubscriber(NODE1, LOCALHOST, LOCUS);\n+        // verify sendData works\n+        ClusterDetailsEventProcessor.setNodesDetails(Lists.newArrayList(\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE1, LOCALHOST, \"\", false),\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE2, LOCALHOST, \"\", false)\n+        ));\n+        uut.sendData(msg);\n+        Thread.sleep(2000L);\n+        Assert.assertNotEquals(0L, nodeStateManager.getLastReceivedTimestamp(NODE1, LOCALHOST));\n+        List<FlowUnitMessage> receivedMags = receivedFlowUnitStore.drainNode(NODE1);\n+        Assert.assertEquals(1L, receivedMags.size());\n+\n+        // verify resilience to RejectedExecutionException\n+        clientExecutor.set(rejectingExecutor);\n+        uut.sendData(msg);\n+    }\n+\n+    @Test\n+    public void testReadFromWire() throws InterruptedException {\n+        netServer.setSubscribeHandler(new SubscribeServerHandler(subscriptionManager, serverExecutor));\n+        // Setup mock object responses\n+        Node<MetricFlowUnit> node = new Heap_Used(EVAL_INTERVAL_S);\n+        node.addTag(RcaConsts.RcaTagConstants.TAG_LOCUS, RcaConsts.RcaTagConstants.LOCUS_DATA_MASTER_NODE);\n+        // Verify resilience to null executor\n+        uut.readFromWire(node);\n+        // Execute test method and verify return value\n+        clientExecutor.set(executorService);\n+        ClusterDetailsEventProcessor.setNodesDetails(Collections.singletonList(\n+                new ClusterDetailsEventProcessor.NodeDetails(\n+                        node.name(), LOCALHOST, RcaConsts.RcaTagConstants.LOCUS_DATA_NODE, false)));\n+        subscriptionManager.setCurrentLocus(RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        subscriptionManager.addPublisher(node.name(), LOCALHOST);\n+        subscriptionManager.addPublisher(node.name(), HOST_NOT_IN_CLUSTER);\n+        nodeStateManager.updateReceiveTime(LOCALHOST, node.name(), 1L);\n+        FlowUnitMessage msg = FlowUnitMessage.newBuilder().setGraphNode(node.name()).build();\n+        ImmutableList<FlowUnitMessage> msgList = ImmutableList.<FlowUnitMessage>builder().add(msg).build();\n+        receivedFlowUnitStore.enqueue(node.name(), msg);\n+        List<FlowUnitMessage> actualMsgList = uut.readFromWire(node);\n+        Assert.assertEquals(msgList, actualMsgList);\n+        // Verify expected interactions with the subscription manager\n+        Thread.sleep(3000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMyMzk4Ng=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyNzI3MQ==", "bodyText": "Added the WaitFor class which is a basic reusable waiting poller", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/130#discussion_r414127271", "createdAt": "2020-04-23T21:11:57Z", "author": {"login": "sidheart"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/net/WireHopperTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.config.PluginSettings;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetClient;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.NetServer;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.GradleTaskForRca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.SymptomFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.Heap_Used;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.GenericFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Node;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.DataMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.messages.IntentMsg;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.PublishRequestHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.net.handler.SubscribeServerHandler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(GradleTaskForRca.class)\n+public class WireHopperTest {\n+    private static final String NODE1 = \"NODE1\";\n+    private static final String NODE2 = \"NODE2\";\n+    private static final String LOCALHOST = \"127.0.0.1\";\n+    private static final String HOST_NOT_IN_CLUSTER = \"NOTINCLUSTER\";\n+    private static final String LOCUS = \"data-node\";\n+    private static final long EVAL_INTERVAL_S = 5L;\n+    private static final long TIMESTAMP = 66L;\n+    private static final ExecutorService rejectingExecutor = new RejectingExecutor();\n+\n+    private static NetClient netClient;\n+    private static NetServer netServer;\n+    private static ExecutorService executorService;\n+    private static ExecutorService netServerExecutor;\n+    private static GRPCConnectionManager connectionManager;\n+    private static SubscriptionManager subscriptionManager;\n+    private static NodeStateManager nodeStateManager;\n+    private static ReceivedFlowUnitStore receivedFlowUnitStore;\n+    private static AtomicReference<ExecutorService> clientExecutor;\n+    private static AtomicReference<ExecutorService> serverExecutor;\n+    // Unit under test\n+    private static WireHopper uut;\n+\n+    @BeforeClass\n+    public static void setupClass() throws InterruptedException {\n+        connectionManager = new GRPCConnectionManager(PluginSettings.instance().getHttpsEnabled());\n+        netClient = new NetClient(connectionManager);\n+        executorService = Executors.newSingleThreadExecutor();\n+        clientExecutor = new AtomicReference<>(null);\n+        serverExecutor = new AtomicReference<>(Executors.newSingleThreadExecutor());\n+        netServer = new NetServer(Util.RPC_PORT, 1, false);\n+        netServerExecutor = Executors.newSingleThreadExecutor();\n+        netServerExecutor.execute(netServer);\n+        while (!netServer.isRunning()) {\n+            Thread.sleep(1000L);\n+        }\n+    }\n+\n+    @Before\n+    public void setup() {\n+        nodeStateManager = new NodeStateManager();\n+        receivedFlowUnitStore = new ReceivedFlowUnitStore();\n+        subscriptionManager = new SubscriptionManager(connectionManager);\n+        clientExecutor.set(null);\n+        uut = new WireHopper(nodeStateManager, netClient, subscriptionManager, clientExecutor, receivedFlowUnitStore);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() {\n+        executorService.shutdown();\n+        netServerExecutor.shutdown();\n+        netServer.stop();\n+        netClient.stop();\n+    }\n+\n+    @Test\n+    public void testSendIntent() throws InterruptedException {\n+        Node<MetricFlowUnit> node = new Heap_Used(EVAL_INTERVAL_S);\n+        netServer.setSubscribeHandler(new SubscribeServerHandler(subscriptionManager, serverExecutor));\n+        Map<String, String> rcaConfTags = new HashMap<>();\n+        rcaConfTags.put(\"locus\", RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        IntentMsg msg = new IntentMsg(NODE1, node.name(), rcaConfTags);\n+        // verify resilience to null executor\n+        uut.sendIntent(msg);\n+        // verify method generates appropriate task\n+        clientExecutor.set(executorService);\n+        subscriptionManager.setCurrentLocus(RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        ClusterDetailsEventProcessor.setNodesDetails(Lists.newArrayList(\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE1, LOCALHOST, \"\", false),\n+                new ClusterDetailsEventProcessor.NodeDetails(node.name(), LOCALHOST, \"\", false)\n+        ));\n+        uut.sendIntent(msg);\n+        Thread.sleep(2000L);\n+        Assert.assertEquals(1, subscriptionManager.getSubscribersFor(node.name()).size());\n+        Assert.assertEquals(LOCALHOST, subscriptionManager.getSubscribersFor(node.name()).asList().get(0));\n+        // verify resilience to RejectedExecutionException\n+        clientExecutor.set(rejectingExecutor);\n+        uut.sendIntent(msg);\n+    }\n+\n+    @Test\n+    public void testSendData() throws InterruptedException {\n+        netServer.setSendDataHandler(new PublishRequestHandler(nodeStateManager, receivedFlowUnitStore, serverExecutor));\n+        // verify resilience to null executor\n+        GenericFlowUnit flowUnit = new SymptomFlowUnit(TIMESTAMP);\n+        DataMsg msg = new DataMsg(NODE1, Lists.newArrayList(NODE2), Collections.singletonList(flowUnit));\n+        uut.sendData(msg);\n+\n+        clientExecutor.set(executorService);\n+        Assert.assertEquals(0L, nodeStateManager.getLastReceivedTimestamp(NODE1, LOCALHOST));\n+        // setup downstream subscribers\n+        subscriptionManager.setCurrentLocus(LOCUS);\n+        subscriptionManager.addSubscriber(NODE1, LOCALHOST, LOCUS);\n+        // verify sendData works\n+        ClusterDetailsEventProcessor.setNodesDetails(Lists.newArrayList(\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE1, LOCALHOST, \"\", false),\n+                new ClusterDetailsEventProcessor.NodeDetails(NODE2, LOCALHOST, \"\", false)\n+        ));\n+        uut.sendData(msg);\n+        Thread.sleep(2000L);\n+        Assert.assertNotEquals(0L, nodeStateManager.getLastReceivedTimestamp(NODE1, LOCALHOST));\n+        List<FlowUnitMessage> receivedMags = receivedFlowUnitStore.drainNode(NODE1);\n+        Assert.assertEquals(1L, receivedMags.size());\n+\n+        // verify resilience to RejectedExecutionException\n+        clientExecutor.set(rejectingExecutor);\n+        uut.sendData(msg);\n+    }\n+\n+    @Test\n+    public void testReadFromWire() throws InterruptedException {\n+        netServer.setSubscribeHandler(new SubscribeServerHandler(subscriptionManager, serverExecutor));\n+        // Setup mock object responses\n+        Node<MetricFlowUnit> node = new Heap_Used(EVAL_INTERVAL_S);\n+        node.addTag(RcaConsts.RcaTagConstants.TAG_LOCUS, RcaConsts.RcaTagConstants.LOCUS_DATA_MASTER_NODE);\n+        // Verify resilience to null executor\n+        uut.readFromWire(node);\n+        // Execute test method and verify return value\n+        clientExecutor.set(executorService);\n+        ClusterDetailsEventProcessor.setNodesDetails(Collections.singletonList(\n+                new ClusterDetailsEventProcessor.NodeDetails(\n+                        node.name(), LOCALHOST, RcaConsts.RcaTagConstants.LOCUS_DATA_NODE, false)));\n+        subscriptionManager.setCurrentLocus(RcaConsts.RcaTagConstants.LOCUS_DATA_NODE);\n+        subscriptionManager.addPublisher(node.name(), LOCALHOST);\n+        subscriptionManager.addPublisher(node.name(), HOST_NOT_IN_CLUSTER);\n+        nodeStateManager.updateReceiveTime(LOCALHOST, node.name(), 1L);\n+        FlowUnitMessage msg = FlowUnitMessage.newBuilder().setGraphNode(node.name()).build();\n+        ImmutableList<FlowUnitMessage> msgList = ImmutableList.<FlowUnitMessage>builder().add(msg).build();\n+        receivedFlowUnitStore.enqueue(node.name(), msg);\n+        List<FlowUnitMessage> actualMsgList = uut.readFromWire(node);\n+        Assert.assertEquals(msgList, actualMsgList);\n+        // Verify expected interactions with the subscription manager\n+        Thread.sleep(3000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMyMzk4Ng=="}, "originalCommit": {"oid": "6e64863a6e2c2acd309a30e2d8aae1ecc1c4739f"}, "originalPosition": 172}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2600, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}