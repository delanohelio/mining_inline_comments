{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NTk3OTky", "number": 265, "title": "FieldData and Shard Request Cache RCA", "bodyText": "Issue #, if available: -N/A-\nDescription of changes:\nCaching is one of the fundamental optimization strategy that is employed in information retrieval systems to expedite query processing and reduce back-end server workload. ElasticSearch supports 3 types of cache : Field Data Cache, Node Query Cache and Shard Request Cache.\nWe want to auto-size the caches dynamically, without a restart and reliance on node level elasticsearch.yml. This PR adds changes for Field Data Cache and Shard Request Cache RCA, which will help identify if the Cache is Unhealthy based on input metrics, which will then be a candidate for auto-tuning.\n\n\nField Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy. The dimension we are use for this analysis are fieldDataCacheEvictions and fieldDataCacheMaxSizeGroupByOperation upstream metrics and maintains a collector which keeps track of the time window period(tp) where we repeatedly see evictions for the last \u2018tp \u2019duration. This RCA is marked as unhealthy if \u2019tp\u2019 is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\nNote : For Field Data Cache, Hit and Miss metrics aren't available.\n\n\nShard Request Cache RCA reads shardRequestCacheEvictions, shardRequestCacheHits, shardRequestCacheSizeGroupByOperation and shardRequestCacheMaxSizeInBytes upstream metrics and maintains collectors which keep track of time window period(tp) where we repeatedly see evictions and hits for the last \u2018tp\u2019 duration. This RCA is marked as unhealthy if tp we find \u2018tp\u2019 is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\nTests: Unit Tests present.\n\n\nCode coverage percentage for this patch:\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-07-07T19:04:19Z", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265", "merged": true, "mergeCommit": {"oid": "d75a1a79d3dc567c2aa9eaf1d38c1e6c8f1de2b8"}, "closed": true, "closedAt": "2020-07-23T19:12:11Z", "author": {"login": "khushbr"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyqh8XgH2gAyNDQ1NTk3OTkyOmNmZjE5ODE5MDg3YjJmZWUyOWM4YWI1MjNiNWM5MWIwMWM5ZWQ2YTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc30VXXgH2gAyNDQ1NTk3OTkyOjE0MTI3YjJjODgwOWVhZTBhMTI5NzliNjkzMTgzNjQ1ZWUxNjhhMTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3", "author": {"user": {"login": "khushbr", "name": "Khushboo Rajput"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/cff19819087b2fee29c8ab523b5c91b01c9ed6a3", "committedDate": "2020-07-07T18:55:23Z", "message": "Squashed commit of the following:\n\ncommit e72afa1051640480bf4cea301025e1318e657016\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Tue Jul 7 11:34:59 2020 -0700\n\n    Refreshing from Mainline\n\ncommit d1b3f21da20d594b27c5f32b4999c7bd5831225b\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Tue Jul 7 11:13:49 2020 -0700\n\n    Removing a comment from the util file\n\ncommit 63ddab2539d50887594643eaab945db54bdad79b\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Tue Jul 7 02:47:36 2020 -0700\n\n    Adding final set of changes for Cache RCAs\n\ncommit 09537c24ccfcd3c485efbf56938b62818d895ea6\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Mon Jul 6 23:54:28 2020 -0700\n\n    Adding weight check for async evictions in FieldDataCache\n\ncommit 65d8f438a03f5ab28501e0d0d690a4af029c1b91\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Mon Jul 6 16:04:59 2020 -0700\n\n    Addinf UT for ShardRequestCacheRca\n\ncommit cdec05b58f62b2138316fd0daa06efc384c90c09\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Mon Jul 6 10:45:07 2020 -0700\n\n    Adding UT for FieldDataCacheRca\n\ncommit ebdbc7e8beea059f49da077943fbc2048487d662\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Sun Jul 5 23:16:57 2020 -0700\n\n    Refreshing from master\n\ncommit 4238148ce976a38fdf5540f231c93b2cdedbb148\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Sun Jul 5 23:15:08 2020 -0700\n\n    Adding the FieldDataCacheRca and ShardRequestCacheRca\n\ncommit b6f1a51eb78abad87b3bbd4a6be27c05284c4ff4\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Wed Jul 1 14:17:01 2020 -0700\n\n    Including the Protobuf re-factoring changes\n\ncommit 03cc597d008871e2ab13bf04762121e713b309ff\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Wed Jun 24 21:53:08 2020 -0700\n\n    Refreshing from master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzYyNTEz", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-444362513", "createdAt": "2020-07-08T02:01:11Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMjowMToxMVrOGuVduw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNTo0NDoyOFrOGuuLBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTM1NQ==", "bodyText": "nit: The year has to be updated to 2020 now.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451239355", "createdAt": "2020-07-08T02:01:11Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/CacheUtil.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTEwOQ==", "bodyText": "nit: \"either the cache weight exceeds\" maximum weight OR ...", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451241109", "createdAt": "2020-07-08T02:07:52Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzNg==", "bodyText": "cacheMaxSize != 0  is mentioned twice", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451241536", "createdAt": "2020-07-08T02:09:44Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjcwNQ==", "bodyText": "Floating point comparisons have rounding errors which can affect the places where this value is used. Should we just convert it to KB and use long values such that we tolerate a rounding error of 1kb?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451242705", "createdAt": "2020-07-08T02:14:22Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/CacheUtil.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+\n+public class CacheUtil {\n+    private static final Logger LOG = LogManager.getLogger(CacheUtil.class);\n+    private static final double CONVERT_BYTES_TO_MEGABYTES = Math.pow(1024, 3);\n+\n+    public static Double getTotalSizeInMB(final Metric sizeMetric) {\n+        double sizeTotalInMB = 0;\n+\n+        // we expect the Metric to have single flow unit since it is consumed locally\n+        MetricFlowUnit flowUnit = sizeMetric.getFlowUnits().get(0);\n+        if (flowUnit.isEmpty() || flowUnit.getData() == null) {\n+            return sizeTotalInMB;\n+        }\n+\n+        for (Record record : flowUnit.getData()) {\n+            double size = record.getValue(MetricsDB.MAX, Double.class);\n+            if (Double.isNaN(size)) {\n+                LOG.error(\"Failed to parse metric in FlowUnit from {}\", sizeMetric.getClass().getName());\n+            } else {\n+                sizeTotalInMB += size / CONVERT_BYTES_TO_MEGABYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0NTQ4Mw==", "bodyText": "Do we implement this for node level rcas?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451245483", "createdAt": "2020-07-08T02:25:26Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+            if (cacheEvictionCollector.isUnhealthy(currTimestamp) && exceedsSize) {\n+                context = new ResourceContext(Resources.State.UNHEALTHY);\n+                nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+                nodeSummary.appendNestedSummary(cacheEvictionCollector.generateSummary(currTimestamp));\n+            }\n+            else {\n+                context = new ResourceContext(Resources.State.HEALTHY);\n+                nodeSummary = null;\n+            }\n+\n+            counter = 0;\n+            exceedsSize = Boolean.FALSE;\n+            return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, !currentNode.getIsMasterNode());\n+        }\n+        else {\n+            return new ResourceFlowUnit<>(currTimestamp);\n+        }\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNjkzOA==", "bodyText": "Do we need the exceedsSize check for unhealthy? It's not clear to me why.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451626938", "createdAt": "2020-07-08T15:19:35Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+            if (cacheEvictionCollector.isUnhealthy(currTimestamp) && exceedsSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYzMDU1Ng==", "bodyText": "flowUnit.getData().stream() -- Can each flowUnit here have multiple data points?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451630556", "createdAt": "2020-07-08T15:24:43Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+            if (cacheEvictionCollector.isUnhealthy(currTimestamp) && exceedsSize) {\n+                context = new ResourceContext(Resources.State.UNHEALTHY);\n+                nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+                nodeSummary.appendNestedSummary(cacheEvictionCollector.generateSummary(currTimestamp));\n+            }\n+            else {\n+                context = new ResourceContext(Resources.State.HEALTHY);\n+                nodeSummary = null;\n+            }\n+\n+            counter = 0;\n+            exceedsSize = Boolean.FALSE;\n+            return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, !currentNode.getIsMasterNode());\n+        }\n+        else {\n+            return new ResourceFlowUnit<>(currTimestamp);\n+        }\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+        final List<FlowUnitMessage> flowUnitMessages =\n+                args.getWireHopper().readFromWire(args.getNode());\n+        List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+        LOG.debug(\"rca: Executing fromWire: {}\", this.getClass().getSimpleName());\n+        for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+            flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+        }\n+        setFlowUnits(flowUnitList);\n+    }\n+\n+    /**\n+     * A collector class to collect eviction metrics\n+     */\n+    private static class CacheEvictionCollector {\n+        private final Resource cache;\n+        private final Metric cacheEvictionMetrics;\n+        private boolean hasEvictions;\n+        private long evictionTimestamp;\n+        private long evictionTimePeriodThreshold;\n+\n+        private CacheEvictionCollector(final Resource cache, final Metric cacheEvictionMetrics,\n+                                       final long threshold) {\n+            this.cache = cache;\n+            this.cacheEvictionMetrics = cacheEvictionMetrics;\n+            this.hasEvictions = false;\n+            this.evictionTimestamp = 0;\n+            this.evictionTimePeriodThreshold = threshold;\n+        }\n+\n+        public void collect(final long currTimestamp) {\n+            for (MetricFlowUnit flowUnit : cacheEvictionMetrics.getFlowUnits()) {\n+                if (flowUnit.isEmpty() || flowUnit.getData() == null) {\n+                    continue;\n+                }\n+\n+                double evictionCount = flowUnit.getData().stream().mapToDouble(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYzMzA5OQ==", "bodyText": "Same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451633099", "createdAt": "2020-07-08T15:28:15Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/ShardRequestCacheRca.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_HIT;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+\n+/**\n+ * Shard Request Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction, hit count, cache current weight(size)\n+ * and cache max weight(size) configured.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios:\n+ * <ol>\n+ *   <li> Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li> Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYzNDE3Ng==", "bodyText": "same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451634176", "createdAt": "2020-07-08T15:29:46Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/ShardRequestCacheRca.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_HIT;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+\n+/**\n+ * Shard Request Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction, hit count, cache current weight(size)\n+ * and cache max weight(size) configured.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios:\n+ * <ol>\n+ *   <li> Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li> Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Shard Request Cache, TTL is defined via `indices.requests.cache.expire` setting which is never used\n+ * in production clusters and only provided for backward compatibility, thus we ignore time based evictions.\n+ * The weight based evictions(removal from Cache Map and LRU linked List with entry updated to EVICTED) occur\n+ * when the cache_weight exceeds the max_cache_weight, eviction.\n+ *\n+ * <p>The Entry Invalidation is performed manually on cache clear(), index close() and for cached results from\n+ * timed-out requests. A scheduled runnable, running every 10 minutes cleans up all the invalidated entries which\n+ * have not been read/written to since invalidation.\n+ *\n+ * <p>The Cache Hit and Eviction metric presence implies cache is undergoing frequent load and eviction or undergoing\n+ * scheduled cleanup for entries which had timed-out during execution.\n+ *\n+ * <p>This RCA reads 'shardRequestCacheEvictions',  'shardRequestCacheHits', 'shardRequestCacheSize' and\n+ * 'shardRequestCacheMaxSize' from upstream metrics and maintains collectors which keeps track of the time window\n+ * period(tp) where we repeatedly see evictions and hits for the last tp duration. This RCA is marked as unhealthy\n+ * if tp we find tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class ShardRequestCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(ShardRequestCacheRca.class);\n+    private static final long THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric shardRequestCacheEvictions;\n+    private final Metric shardRequestCacheHits;\n+    private final Metric shardRequestCacheSize;\n+    private final Metric shardRequestCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheCollector cacheEvictionCollector;\n+    private final CacheCollector cacheHitCollector;\n+\n+    public <M extends Metric> ShardRequestCacheRca(final int rcaPeriod, final M shardRequestCacheEvictions,\n+                                                   final M shardRequestCacheHits, final M shardRequestCacheSize,\n+                                                   final M shardRequestCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.shardRequestCacheEvictions = shardRequestCacheEvictions;\n+        this.shardRequestCacheHits = shardRequestCacheHits;\n+        this.shardRequestCacheSize = shardRequestCacheSize;\n+        this.shardRequestCacheMaxSize = shardRequestCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheCollector(SHARD_REQUEST_CACHE_EVICTION,\n+                shardRequestCacheEvictions, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+        this.cacheHitCollector = new CacheCollector(SHARD_REQUEST_CACHE_HIT,\n+                shardRequestCacheHits, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        cacheHitCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(shardRequestCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(shardRequestCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0MTQyMA==", "bodyText": "It's not clear why exceedsSize is important for thrashing.\nIs this to remove false positives due to TTL based evictions? The doc string mentions that TTL based evictions are not performed because setting is not present and so we ignore it.\nEven to remove the TTL eviction false +ves, cacheSize may not exceed maxCacheSize because -\n\nES accounting should mostly be accurate, which prevents cacheSize from exceeding cacheMaxSize.\nEvictions should have brought down the cacheSize.\n\nMaybe we should check for cacheSize to be within a threshold of cacheMaxSize: assume evictions were due to TTL if cacheMaxSize - cacheSize > Threshold", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451641420", "createdAt": "2020-07-08T15:40:15Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/ShardRequestCacheRca.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_HIT;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+\n+/**\n+ * Shard Request Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction, hit count, cache current weight(size)\n+ * and cache max weight(size) configured.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios:\n+ * <ol>\n+ *   <li> Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li> Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Shard Request Cache, TTL is defined via `indices.requests.cache.expire` setting which is never used\n+ * in production clusters and only provided for backward compatibility, thus we ignore time based evictions.\n+ * The weight based evictions(removal from Cache Map and LRU linked List with entry updated to EVICTED) occur\n+ * when the cache_weight exceeds the max_cache_weight, eviction.\n+ *\n+ * <p>The Entry Invalidation is performed manually on cache clear(), index close() and for cached results from\n+ * timed-out requests. A scheduled runnable, running every 10 minutes cleans up all the invalidated entries which\n+ * have not been read/written to since invalidation.\n+ *\n+ * <p>The Cache Hit and Eviction metric presence implies cache is undergoing frequent load and eviction or undergoing\n+ * scheduled cleanup for entries which had timed-out during execution.\n+ *\n+ * <p>This RCA reads 'shardRequestCacheEvictions',  'shardRequestCacheHits', 'shardRequestCacheSize' and\n+ * 'shardRequestCacheMaxSize' from upstream metrics and maintains collectors which keeps track of the time window\n+ * period(tp) where we repeatedly see evictions and hits for the last tp duration. This RCA is marked as unhealthy\n+ * if tp we find tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class ShardRequestCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(ShardRequestCacheRca.class);\n+    private static final long THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric shardRequestCacheEvictions;\n+    private final Metric shardRequestCacheHits;\n+    private final Metric shardRequestCacheSize;\n+    private final Metric shardRequestCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheCollector cacheEvictionCollector;\n+    private final CacheCollector cacheHitCollector;\n+\n+    public <M extends Metric> ShardRequestCacheRca(final int rcaPeriod, final M shardRequestCacheEvictions,\n+                                                   final M shardRequestCacheHits, final M shardRequestCacheSize,\n+                                                   final M shardRequestCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.shardRequestCacheEvictions = shardRequestCacheEvictions;\n+        this.shardRequestCacheHits = shardRequestCacheHits;\n+        this.shardRequestCacheSize = shardRequestCacheSize;\n+        this.shardRequestCacheMaxSize = shardRequestCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheCollector(SHARD_REQUEST_CACHE_EVICTION,\n+                shardRequestCacheEvictions, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+        this.cacheHitCollector = new CacheCollector(SHARD_REQUEST_CACHE_HIT,\n+                shardRequestCacheHits, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        cacheHitCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(shardRequestCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(shardRequestCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+\n+            // if eviction and hit counts persists in last 5 minutes and cache size exceeds the max cache size configured,\n+            // the cache is considered as unhealthy\n+            if (cacheEvictionCollector.isMetricPresentForThresholdTime(currTimestamp)\n+                    && cacheHitCollector.isMetricPresentForThresholdTime(currTimestamp)\n+                    && exceedsSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0MTgxMg==", "bodyText": "same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451641812", "createdAt": "2020-07-08T15:40:50Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/ShardRequestCacheRca.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_HIT;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+\n+/**\n+ * Shard Request Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction, hit count, cache current weight(size)\n+ * and cache max weight(size) configured.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios:\n+ * <ol>\n+ *   <li> Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li> Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Shard Request Cache, TTL is defined via `indices.requests.cache.expire` setting which is never used\n+ * in production clusters and only provided for backward compatibility, thus we ignore time based evictions.\n+ * The weight based evictions(removal from Cache Map and LRU linked List with entry updated to EVICTED) occur\n+ * when the cache_weight exceeds the max_cache_weight, eviction.\n+ *\n+ * <p>The Entry Invalidation is performed manually on cache clear(), index close() and for cached results from\n+ * timed-out requests. A scheduled runnable, running every 10 minutes cleans up all the invalidated entries which\n+ * have not been read/written to since invalidation.\n+ *\n+ * <p>The Cache Hit and Eviction metric presence implies cache is undergoing frequent load and eviction or undergoing\n+ * scheduled cleanup for entries which had timed-out during execution.\n+ *\n+ * <p>This RCA reads 'shardRequestCacheEvictions',  'shardRequestCacheHits', 'shardRequestCacheSize' and\n+ * 'shardRequestCacheMaxSize' from upstream metrics and maintains collectors which keeps track of the time window\n+ * period(tp) where we repeatedly see evictions and hits for the last tp duration. This RCA is marked as unhealthy\n+ * if tp we find tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class ShardRequestCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(ShardRequestCacheRca.class);\n+    private static final long THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric shardRequestCacheEvictions;\n+    private final Metric shardRequestCacheHits;\n+    private final Metric shardRequestCacheSize;\n+    private final Metric shardRequestCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheCollector cacheEvictionCollector;\n+    private final CacheCollector cacheHitCollector;\n+\n+    public <M extends Metric> ShardRequestCacheRca(final int rcaPeriod, final M shardRequestCacheEvictions,\n+                                                   final M shardRequestCacheHits, final M shardRequestCacheSize,\n+                                                   final M shardRequestCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.shardRequestCacheEvictions = shardRequestCacheEvictions;\n+        this.shardRequestCacheHits = shardRequestCacheHits;\n+        this.shardRequestCacheSize = shardRequestCacheSize;\n+        this.shardRequestCacheMaxSize = shardRequestCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheCollector(SHARD_REQUEST_CACHE_EVICTION,\n+                shardRequestCacheEvictions, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+        this.cacheHitCollector = new CacheCollector(SHARD_REQUEST_CACHE_HIT,\n+                shardRequestCacheHits, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        cacheHitCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(shardRequestCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(shardRequestCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+\n+            // if eviction and hit counts persists in last 5 minutes and cache size exceeds the max cache size configured,\n+            // the cache is considered as unhealthy\n+            if (cacheEvictionCollector.isMetricPresentForThresholdTime(currTimestamp)\n+                    && cacheHitCollector.isMetricPresentForThresholdTime(currTimestamp)\n+                    && exceedsSize) {\n+                context = new ResourceContext(Resources.State.UNHEALTHY);\n+                nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+                nodeSummary.appendNestedSummary(cacheEvictionCollector.generateSummary(currTimestamp));\n+            } else {\n+                context = new ResourceContext(Resources.State.HEALTHY);\n+                nodeSummary = null;\n+            }\n+\n+            counter = 0;\n+            exceedsSize = Boolean.FALSE;\n+            return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, !currentNode.getIsMasterNode());\n+        }\n+        else {\n+            return new ResourceFlowUnit<>(currTimestamp);\n+        }\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0NDE2NA==", "bodyText": "same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451644164", "createdAt": "2020-07-08T15:44:28Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/ShardRequestCacheRca.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_HIT;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+\n+/**\n+ * Shard Request Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction, hit count, cache current weight(size)\n+ * and cache max weight(size) configured.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios:\n+ * <ol>\n+ *   <li> Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li> Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Shard Request Cache, TTL is defined via `indices.requests.cache.expire` setting which is never used\n+ * in production clusters and only provided for backward compatibility, thus we ignore time based evictions.\n+ * The weight based evictions(removal from Cache Map and LRU linked List with entry updated to EVICTED) occur\n+ * when the cache_weight exceeds the max_cache_weight, eviction.\n+ *\n+ * <p>The Entry Invalidation is performed manually on cache clear(), index close() and for cached results from\n+ * timed-out requests. A scheduled runnable, running every 10 minutes cleans up all the invalidated entries which\n+ * have not been read/written to since invalidation.\n+ *\n+ * <p>The Cache Hit and Eviction metric presence implies cache is undergoing frequent load and eviction or undergoing\n+ * scheduled cleanup for entries which had timed-out during execution.\n+ *\n+ * <p>This RCA reads 'shardRequestCacheEvictions',  'shardRequestCacheHits', 'shardRequestCacheSize' and\n+ * 'shardRequestCacheMaxSize' from upstream metrics and maintains collectors which keeps track of the time window\n+ * period(tp) where we repeatedly see evictions and hits for the last tp duration. This RCA is marked as unhealthy\n+ * if tp we find tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class ShardRequestCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(ShardRequestCacheRca.class);\n+    private static final long THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric shardRequestCacheEvictions;\n+    private final Metric shardRequestCacheHits;\n+    private final Metric shardRequestCacheSize;\n+    private final Metric shardRequestCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheCollector cacheEvictionCollector;\n+    private final CacheCollector cacheHitCollector;\n+\n+    public <M extends Metric> ShardRequestCacheRca(final int rcaPeriod, final M shardRequestCacheEvictions,\n+                                                   final M shardRequestCacheHits, final M shardRequestCacheSize,\n+                                                   final M shardRequestCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.shardRequestCacheEvictions = shardRequestCacheEvictions;\n+        this.shardRequestCacheHits = shardRequestCacheHits;\n+        this.shardRequestCacheSize = shardRequestCacheSize;\n+        this.shardRequestCacheMaxSize = shardRequestCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheCollector(SHARD_REQUEST_CACHE_EVICTION,\n+                shardRequestCacheEvictions, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+        this.cacheHitCollector = new CacheCollector(SHARD_REQUEST_CACHE_HIT,\n+                shardRequestCacheHits, THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        cacheHitCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(shardRequestCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(shardRequestCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+\n+            // if eviction and hit counts persists in last 5 minutes and cache size exceeds the max cache size configured,\n+            // the cache is considered as unhealthy\n+            if (cacheEvictionCollector.isMetricPresentForThresholdTime(currTimestamp)\n+                    && cacheHitCollector.isMetricPresentForThresholdTime(currTimestamp)\n+                    && exceedsSize) {\n+                context = new ResourceContext(Resources.State.UNHEALTHY);\n+                nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+                nodeSummary.appendNestedSummary(cacheEvictionCollector.generateSummary(currTimestamp));\n+            } else {\n+                context = new ResourceContext(Resources.State.HEALTHY);\n+                nodeSummary = null;\n+            }\n+\n+            counter = 0;\n+            exceedsSize = Boolean.FALSE;\n+            return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, !currentNode.getIsMasterNode());\n+        }\n+        else {\n+            return new ResourceFlowUnit<>(currTimestamp);\n+        }\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+        final List<FlowUnitMessage> flowUnitMessages =\n+                args.getWireHopper().readFromWire(args.getNode());\n+        List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+        LOG.debug(\"rca: Executing fromWire: {}\", this.getClass().getSimpleName());\n+        for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+            flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+        }\n+        setFlowUnits(flowUnitList);\n+    }\n+\n+    /**\n+     * A collector class to collect metrics (eviction and hit) for cache\n+     */\n+    private static class CacheCollector {\n+        private final Resource cache;\n+        private final Metric cacheMetrics;\n+        private boolean hasMetric;\n+        private long metricTimestamp;\n+        private long metricTimePeriodThreshold;\n+\n+        public CacheCollector(final Resource cache, final Metric cacheMetrics, final long threshold) {\n+            this.cache = cache;\n+            this.cacheMetrics = cacheMetrics;\n+            this.hasMetric = false;\n+            this.metricTimestamp = 0;\n+            this.metricTimePeriodThreshold = threshold;\n+        }\n+\n+        public void collect(final long currTimestamp) {\n+            for (MetricFlowUnit flowUnit : cacheMetrics.getFlowUnits()) {\n+                if (flowUnit.isEmpty()) {\n+                    continue;\n+                }\n+\n+                Result<Record> records = flowUnit.getData();\n+                double metricCount = records.stream().mapToDouble(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 189}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTIxNjgw", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-444921680", "createdAt": "2020-07-08T16:12:41Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNjoxMjo0MVrOGuvVAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNjoxMjo0MVrOGuvVAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2MzEwNQ==", "bodyText": "We are checking if cacheMaxSize is not zero twice.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r451663105", "createdAt": "2020-07-08T16:12:41Z", "author": {"login": "sruti1312"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Njk5ODM5", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446699839", "createdAt": "2020-07-10T21:04:01Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowNDowMVrOGwFlrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowNDowMVrOGwFlrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjM5Ng==", "bodyText": "should we check the size the flowunit list to avoid null pointer exception ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453076396", "createdAt": "2020-07-10T21:04:01Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/CacheUtil.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+\n+public class CacheUtil {\n+    private static final Logger LOG = LogManager.getLogger(CacheUtil.class);\n+    private static final double CONVERT_BYTES_TO_MEGABYTES = Math.pow(1024, 3);\n+\n+    public static Double getTotalSizeInMB(final Metric sizeMetric) {\n+        double sizeTotalInMB = 0;\n+\n+        // we expect the Metric to have single flow unit since it is consumed locally\n+        MetricFlowUnit flowUnit = sizeMetric.getFlowUnits().get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzAxMTcz", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446701173", "createdAt": "2020-07-10T21:06:53Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowNjo1M1rOGwFp-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowNjo1M1rOGwFp-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NzQ5Nw==", "bodyText": "instead of iterating through the list of tuples in record, can we extend the cache metric class and leverage the SQL group by statement when reading from the db ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453077497", "createdAt": "2020-07-10T21:06:53Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/CacheUtil.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+\n+public class CacheUtil {\n+    private static final Logger LOG = LogManager.getLogger(CacheUtil.class);\n+    private static final double CONVERT_BYTES_TO_MEGABYTES = Math.pow(1024, 3);\n+\n+    public static Double getTotalSizeInMB(final Metric sizeMetric) {\n+        double sizeTotalInMB = 0;\n+\n+        // we expect the Metric to have single flow unit since it is consumed locally\n+        MetricFlowUnit flowUnit = sizeMetric.getFlowUnits().get(0);\n+        if (flowUnit.isEmpty() || flowUnit.getData() == null) {\n+            return sizeTotalInMB;\n+        }\n+\n+        for (Record record : flowUnit.getData()) {\n+            double size = record.getValue(MetricsDB.MAX, Double.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA0MDUz", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446704053", "createdAt": "2020-07-10T21:13:20Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxMzoyMFrOGwFzFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxMzoyMFrOGwFzFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTgzMQ==", "bodyText": "let's add node summary to healthy flowunit and send it as a heartbeat to cluster rca", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453079831", "createdAt": "2020-07-10T21:13:20Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+            if (cacheEvictionCollector.isUnhealthy(currTimestamp) && exceedsSize) {\n+                context = new ResourceContext(Resources.State.UNHEALTHY);\n+                nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+                nodeSummary.appendNestedSummary(cacheEvictionCollector.generateSummary(currTimestamp));\n+            }\n+            else {\n+                context = new ResourceContext(Resources.State.HEALTHY);\n+                nodeSummary = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA2MDI1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446706025", "createdAt": "2020-07-10T21:17:48Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxNzo0OFrOGwF5Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToxNzo0OFrOGwF5Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MTM4Nw==", "bodyText": "fieldDataCacheMaxSize will be collected as part of node config RCA. Do we need a separate metric here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453081387", "createdAt": "2020-07-10T21:17:48Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA3MjE1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446707215", "createdAt": "2020-07-10T21:20:27Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyMDoyN1rOGwF85g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyMDoyN1rOGwF85g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MjM0Mg==", "bodyText": "can we combine ShardRequestCacheRca and FieldDataCacheRca into one RCA and use different collector to collect those caches individually to reduce overhead ? Is there any benefit of creating two separate RCAs ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453082342", "createdAt": "2020-07-10T21:20:27Z", "author": {"login": "rguo-aws"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/ShardRequestCacheRca.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.SHARD_REQUEST_CACHE_HIT;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+\n+/**\n+ * Shard Request Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction, hit count, cache current weight(size)\n+ * and cache max weight(size) configured.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios:\n+ * <ol>\n+ *   <li> Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li> Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Shard Request Cache, TTL is defined via `indices.requests.cache.expire` setting which is never used\n+ * in production clusters and only provided for backward compatibility, thus we ignore time based evictions.\n+ * The weight based evictions(removal from Cache Map and LRU linked List with entry updated to EVICTED) occur\n+ * when the cache_weight exceeds the max_cache_weight, eviction.\n+ *\n+ * <p>The Entry Invalidation is performed manually on cache clear(), index close() and for cached results from\n+ * timed-out requests. A scheduled runnable, running every 10 minutes cleans up all the invalidated entries which\n+ * have not been read/written to since invalidation.\n+ *\n+ * <p>The Cache Hit and Eviction metric presence implies cache is undergoing frequent load and eviction or undergoing\n+ * scheduled cleanup for entries which had timed-out during execution.\n+ *\n+ * <p>This RCA reads 'shardRequestCacheEvictions',  'shardRequestCacheHits', 'shardRequestCacheSize' and\n+ * 'shardRequestCacheMaxSize' from upstream metrics and maintains collectors which keeps track of the time window\n+ * period(tp) where we repeatedly see evictions and hits for the last tp duration. This RCA is marked as unhealthy\n+ * if tp we find tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class ShardRequestCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA4MTgw", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446708180", "createdAt": "2020-07-10T21:22:37Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyMjozN1rOGwF__A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyMjozN1rOGwF__A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MzEzMg==", "bodyText": "let's reserve some field numbers for thread pool and many be we can start from 10 here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453083132", "createdAt": "2020-07-10T21:22:37Z", "author": {"login": "rguo-aws"}, "path": "src/main/proto/inter_node_rpc_service.proto", "diffHunk": "@@ -69,6 +69,11 @@ enum ResourceEnum {\n   // threadpool\n   WRITE_THREADPOOL = 4 [(additional_fields).name = \"write threadpool\"];\n   SEARCH_THREADPOOL = 5 [(additional_fields).name = \"search threadpool\"];\n+\n+  // Cache\n+  FIELD_DATA_CACHE = 6 [(additional_fields).name = \"field data cache\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzA4NjMy", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-446708632", "createdAt": "2020-07-10T21:23:38Z", "commit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyMzozOFrOGwGBVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMToyMzozOFrOGwGBVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MzQ3OQ==", "bodyText": "same as above, let reserve some field number for queue latency metric etc.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r453083479", "createdAt": "2020-07-10T21:23:38Z", "author": {"login": "rguo-aws"}, "path": "src/main/proto/inter_node_rpc_service.proto", "diffHunk": "@@ -84,6 +89,10 @@ enum MetricEnum {\n \n   // threadpool\n   QUEUE_REJECTION = 6 [(additional_fields).name = \"queue rejection\", (additional_fields).description = \"rejection period in second\"];\n+\n+  // cache\n+  CACHE_EVICTION = 7 [(additional_fields).name = \"cache eviction\", (additional_fields).description = \"cache eviction count\"];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 18}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de5da1d957a378e47e722acaf269787b2fedcda9", "author": {"user": {"login": "khushbr", "name": "Khushboo Rajput"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/de5da1d957a378e47e722acaf269787b2fedcda9", "committedDate": "2020-07-15T05:38:06Z", "message": "Refreshing from master branch"}, "afterCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3", "author": {"user": {"login": "khushbr", "name": "Khushboo Rajput"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/cff19819087b2fee29c8ab523b5c91b01c9ed6a3", "committedDate": "2020-07-07T18:55:23Z", "message": "Squashed commit of the following:\n\ncommit e72afa1051640480bf4cea301025e1318e657016\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Tue Jul 7 11:34:59 2020 -0700\n\n    Refreshing from Mainline\n\ncommit d1b3f21da20d594b27c5f32b4999c7bd5831225b\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Tue Jul 7 11:13:49 2020 -0700\n\n    Removing a comment from the util file\n\ncommit 63ddab2539d50887594643eaab945db54bdad79b\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Tue Jul 7 02:47:36 2020 -0700\n\n    Adding final set of changes for Cache RCAs\n\ncommit 09537c24ccfcd3c485efbf56938b62818d895ea6\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Mon Jul 6 23:54:28 2020 -0700\n\n    Adding weight check for async evictions in FieldDataCache\n\ncommit 65d8f438a03f5ab28501e0d0d690a4af029c1b91\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Mon Jul 6 16:04:59 2020 -0700\n\n    Addinf UT for ShardRequestCacheRca\n\ncommit cdec05b58f62b2138316fd0daa06efc384c90c09\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Mon Jul 6 10:45:07 2020 -0700\n\n    Adding UT for FieldDataCacheRca\n\ncommit ebdbc7e8beea059f49da077943fbc2048487d662\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Sun Jul 5 23:16:57 2020 -0700\n\n    Refreshing from master\n\ncommit 4238148ce976a38fdf5540f231c93b2cdedbb148\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Sun Jul 5 23:15:08 2020 -0700\n\n    Adding the FieldDataCacheRca and ShardRequestCacheRca\n\ncommit b6f1a51eb78abad87b3bbd4a6be27c05284c4ff4\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Wed Jul 1 14:17:01 2020 -0700\n\n    Including the Protobuf re-factoring changes\n\ncommit 03cc597d008871e2ab13bf04762121e713b309ff\nAuthor: khushbr <khushbr@amazon.com>\nDate:   Wed Jun 24 21:53:08 2020 -0700\n\n    Refreshing from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361003cda6b7a8c0e3abaaa396e4206190aa23c4", "author": {"user": {"login": "khushbr", "name": "Khushboo Rajput"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/361003cda6b7a8c0e3abaaa396e4206190aa23c4", "committedDate": "2020-07-15T06:10:26Z", "message": "Addressing the PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzODUzMzY0", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-453853364", "createdAt": "2020-07-23T06:03:05Z", "commit": {"oid": "361003cda6b7a8c0e3abaaa396e4206190aa23c4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowMzowNVrOG19LiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowMzowNVrOG19LiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMDA4OQ==", "bodyText": "Got it, so we need to sum the stream because this is a shard level metric?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#discussion_r459230089", "createdAt": "2020-07-23T06:03:05Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/rca/cache/FieldDataCacheRca.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.ResourceUtil.FIELD_DATA_CACHE_EVICTION;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cache.CacheUtil.getTotalSizeInMB;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Metric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotResourceSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Clock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+/**\n+ * Field Data Cache RCA is to identify when the cache is unhealthy(thrashing) and otherwise, healthy.\n+ * The dimension we are using for this analysis is cache eviction count, cache current weight(size) and\n+ * cache max weight(size) configured.\n+ * Note : For Field Data Cache, Hit and Miss metrics aren't available.\n+ *\n+ * <p>Cache eviction within Elasticsearch happens in following scenarios :\n+ * <ol>\n+ *   <li>Mutation to Cache (Entry Insertion/Promotion and Manual Invalidation)\n+ *   <li>Explicit call to refresh()\n+ * </ol>\n+ *\n+ * <p>The Cache Eviction requires that either the cache weight exceeds OR the entry TTL is expired.\n+ * For Field Data Cache, no expire setting is present, so only in case of cache_weight exceeding the\n+ * max_cache_weight, eviction(removal from Cache Map and LRU linked List, entry updated to EVICTED)\n+ * happens.\n+ *\n+ * <p>Contrarily, the Cache Invalidation is performed manually on cache clear() and index close()\n+ * invocation, with removalReason as INVALIDATED and a force eviction is performed to ensure cleanup.\n+ *\n+ * <p>This RCA reads 'fieldDataCacheEvictions', 'fieldDataCacheSize' and 'fieldDataCacheMaxSize'\n+ * from upstream metrics and maintains a collector which keeps track of the time window period(tp)\n+ * where we repeatedly see evictions for the last tp duration. This RCA is marked as unhealthy if\n+ * tp is above the threshold(300 seconds) and cache size exceeds the max cache size configured.\n+ *\n+ */\n+public class FieldDataCacheRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private static final Logger LOG = LogManager.getLogger(FieldDataCacheRca.class);\n+    private static final long EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND = TimeUnit.SECONDS.toMillis(300);\n+\n+    private final Metric fieldDataCacheEvictions;\n+    private final Metric fieldDataCacheSize;\n+    private final Metric fieldDataCacheMaxSize;\n+    private final int rcaPeriod;\n+    private int counter;\n+    private boolean exceedsSize;\n+    protected Clock clock;\n+    private final CacheEvictionCollector cacheEvictionCollector;\n+\n+    public <M extends Metric> FieldDataCacheRca(final int rcaPeriod, final M fieldDataCacheEvictions,\n+                                                final M fieldDataCacheSize, final M fieldDataCacheMaxSize) {\n+        super(5);\n+        this.rcaPeriod = rcaPeriod;\n+        this.fieldDataCacheEvictions = fieldDataCacheEvictions;\n+        this.fieldDataCacheSize = fieldDataCacheSize;\n+        this.fieldDataCacheMaxSize = fieldDataCacheMaxSize;\n+        this.counter = 0;\n+        this.exceedsSize = Boolean.FALSE;\n+        this.clock = Clock.systemUTC();\n+        this.cacheEvictionCollector = new CacheEvictionCollector(FIELD_DATA_CACHE_EVICTION,\n+                fieldDataCacheEvictions, EVICTION_THRESHOLD_TIME_PERIOD_IN_MILLISECOND);\n+    }\n+\n+    @VisibleForTesting\n+    public void setClock(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+        counter += 1;\n+        long currTimestamp = clock.millis();\n+\n+        cacheEvictionCollector.collect(currTimestamp);\n+        if (counter >= rcaPeriod) {\n+            ResourceContext context;\n+            HotNodeSummary nodeSummary;\n+\n+            ClusterDetailsEventProcessor.NodeDetails currentNode = ClusterDetailsEventProcessor.getCurrentNodeDetails();\n+            double cacheSize = getTotalSizeInMB(fieldDataCacheSize);\n+            double cacheMaxSize = getTotalSizeInMB(fieldDataCacheMaxSize);\n+            exceedsSize = cacheMaxSize != 0 && cacheMaxSize != 0 && cacheSize > cacheMaxSize;\n+            if (cacheEvictionCollector.isUnhealthy(currTimestamp) && exceedsSize) {\n+                context = new ResourceContext(Resources.State.UNHEALTHY);\n+                nodeSummary = new HotNodeSummary(currentNode.getId(), currentNode.getHostAddress());\n+                nodeSummary.appendNestedSummary(cacheEvictionCollector.generateSummary(currTimestamp));\n+            }\n+            else {\n+                context = new ResourceContext(Resources.State.HEALTHY);\n+                nodeSummary = null;\n+            }\n+\n+            counter = 0;\n+            exceedsSize = Boolean.FALSE;\n+            return new ResourceFlowUnit<>(currTimestamp, context, nodeSummary, !currentNode.getIsMasterNode());\n+        }\n+        else {\n+            return new ResourceFlowUnit<>(currTimestamp);\n+        }\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+        final List<FlowUnitMessage> flowUnitMessages =\n+                args.getWireHopper().readFromWire(args.getNode());\n+        List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+        LOG.debug(\"rca: Executing fromWire: {}\", this.getClass().getSimpleName());\n+        for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+            flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+        }\n+        setFlowUnits(flowUnitList);\n+    }\n+\n+    /**\n+     * A collector class to collect eviction metrics\n+     */\n+    private static class CacheEvictionCollector {\n+        private final Resource cache;\n+        private final Metric cacheEvictionMetrics;\n+        private boolean hasEvictions;\n+        private long evictionTimestamp;\n+        private long evictionTimePeriodThreshold;\n+\n+        private CacheEvictionCollector(final Resource cache, final Metric cacheEvictionMetrics,\n+                                       final long threshold) {\n+            this.cache = cache;\n+            this.cacheEvictionMetrics = cacheEvictionMetrics;\n+            this.hasEvictions = false;\n+            this.evictionTimestamp = 0;\n+            this.evictionTimePeriodThreshold = threshold;\n+        }\n+\n+        public void collect(final long currTimestamp) {\n+            for (MetricFlowUnit flowUnit : cacheEvictionMetrics.getFlowUnits()) {\n+                if (flowUnit.isEmpty() || flowUnit.getData() == null) {\n+                    continue;\n+                }\n+\n+                double evictionCount = flowUnit.getData().stream().mapToDouble(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYzMDU1Ng=="}, "originalCommit": {"oid": "cff19819087b2fee29c8ab523b5c91b01c9ed6a3"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mzg5NTQz", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/265#pullrequestreview-454389543", "createdAt": "2020-07-23T18:25:40Z", "commit": {"oid": "361003cda6b7a8c0e3abaaa396e4206190aa23c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14127b2c8809eae0a12979b693183645ee168a11", "author": {"user": {"login": "khushbr", "name": "Khushboo Rajput"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/14127b2c8809eae0a12979b693183645ee168a11", "committedDate": "2020-07-23T19:10:19Z", "message": "Merge branch 'master' into khushbr-cache-rca"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1063, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}