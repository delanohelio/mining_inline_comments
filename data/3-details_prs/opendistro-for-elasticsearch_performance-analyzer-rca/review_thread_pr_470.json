{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMzE1NjI1", "number": 470, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDo1OTowNVrOEurmcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNDoyOVrOEvh2qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3Mzg0MzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDo1OTowNVrOHjPpDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoxMDozMlrOHk5ImQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng==", "bodyText": "we can make it error as everything else starts with a small case ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506718476", "createdAt": "2020-10-16T20:59:05Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUxNzk5MQ==", "bodyText": "Changed it to fault", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r507517991", "createdAt": "2020-10-19T07:07:39Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwNDA0MQ==", "bodyText": "Are the latest set of changes pushed ?  I do not see fault here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508104041", "createdAt": "2020-10-19T22:41:09Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0Njg3Mw==", "bodyText": "I have made the changes. You can see it in the next revision", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446873", "createdAt": "2020-10-20T12:10:32Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxODQ3Ng=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDIwNDEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMDozMDoxOVrOHjS40w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzoxMDo0OVrOHkAiBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTY2Nw==", "bodyText": "Can you help me understand why this is an error log ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506771667", "createdAt": "2020-10-17T00:30:19Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");\n+\n+        private final String fieldValue;\n+\n+        Fields(String fieldValue) {\n+            this.fieldValue = fieldValue;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return fieldValue;\n+        }\n+\n+    }\n+\n+    public FaultDetectionMetricsSnapshot(Connection conn, Long windowStartTime) {\n+        this.create = DSL.using(conn, SQLDialect.SQLITE);\n+        this.windowStartTime = windowStartTime;\n+        this.tableName = \"fault_detection_\" + windowStartTime;\n+\n+        this.columns =\n+                new ArrayList<Field<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ST.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ET.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class));\n+                    }\n+                };\n+        create.createTable(this.tableName).columns(columns).execute();\n+    }\n+\n+    public BatchBindStep startBatchPut() {\n+\n+        List<Object> dummyValues = new ArrayList<>();\n+        for (int i = 0; i < columns.size(); i++) {\n+            dummyValues.add(null);\n+        }\n+        return create.batch(create.insertInto(DSL.table(this.tableName)).values(dummyValues));\n+    }\n+\n+    @VisibleForTesting\n+    public void putStartMetric(Long startTime, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ST.toString()), Long.class), startTime)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    @VisibleForTesting\n+    public void putEndMetric(Long endTime, int error, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ET.toString()), Long.class), endTime)\n+                .set(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class), error)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    public Result<Record> fetchAll() {\n+        return create.select().from(DSL.table(this.tableName)).fetch();\n+    }\n+\n+    @Override\n+    public void remove() throws Exception {\n+        create.dropTable(DSL.table(this.tableName)).execute();\n+    }\n+\n+    public void rolloverInFlightRequests(FaultDetectionMetricsSnapshot prevSnap) {\n+        // Fetch all entries that have not ended and write to current table.\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .select(create.select().from(prevSnap.fetchInFlightRequests()))\n+                .execute();\n+    }\n+\n+    public SelectHavingStep<Record> fetchInFlightRequests() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                    }\n+                };\n+\n+        return create\n+                .select(fields)\n+                .from(groupByRidAndTypeSelect())\n+                .where(\n+                        DSL.field(Fields.ST.toString())\n+                                .isNotNull()\n+                                .and(DSL.field(Fields.ET.toString()).isNull())\n+                                .and(DSL.field(Fields.ST.toString()).gt(this.windowStartTime - EXPIRE_AFTER)));\n+    }\n+\n+    public SelectHavingStep<Record> groupByRidAndTypeSelect() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ST.toString(), Long.class)).as(DSL.name(Fields.ST.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ET.toString(), Long.class)).as(DSL.name(Fields.ET.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ERROR.toString(), Integer.class)).as(DSL.name(Fields.ERROR.toString())));\n+        LOG.error(\"Initial - \" + fetchAll().size());\n+        LOG.error(\"Breakdown 1 - \" + create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString())).fetch().size());\n+        return create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString()));\n+    }\n+\n+    public SelectHavingStep<Record> fetchLatencyTable() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ERROR.toString(), Integer.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.field(Fields.ET.toString())\n+                        .minus(DSL.field(Fields.ST.toString()))\n+                        .as(DSL.name(Fields.LAT.toString())));\n+        LOG.error(\"Breakdown 2 - \" + create", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUxOTQ5NQ==", "bodyText": "My bad. This was log used to debug an issue. Removed it", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r507519495", "createdAt": "2020-10-19T07:10:49Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.DBUtils;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+import org.jooq.DSLContext;\n+import org.jooq.Field;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.jooq.SQLDialect;\n+import org.jooq.SelectField;\n+import org.jooq.SelectHavingStep;\n+import org.jooq.impl.DSL;\n+\n+public class FaultDetectionMetricsSnapshot implements Removable {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsSnapshot.class);\n+    private final DSLContext create;\n+    private final Long windowStartTime;\n+    private final String tableName;\n+    private ArrayList<Field<?>> columns;\n+    private static final Long EXPIRE_AFTER = 600000L;\n+\n+    public enum Fields {\n+        RID(\"rid\"),\n+        FAULT_DETECTION_TYPE(\"type\"),\n+        ST(\"st\"),\n+        ET(\"et\"),\n+        LAT(\"lat\"),\n+        ERROR(\"Error\");\n+\n+        private final String fieldValue;\n+\n+        Fields(String fieldValue) {\n+            this.fieldValue = fieldValue;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return fieldValue;\n+        }\n+\n+    }\n+\n+    public FaultDetectionMetricsSnapshot(Connection conn, Long windowStartTime) {\n+        this.create = DSL.using(conn, SQLDialect.SQLITE);\n+        this.windowStartTime = windowStartTime;\n+        this.tableName = \"fault_detection_\" + windowStartTime;\n+\n+        this.columns =\n+                new ArrayList<Field<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ST.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ET.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class));\n+                    }\n+                };\n+        create.createTable(this.tableName).columns(columns).execute();\n+    }\n+\n+    public BatchBindStep startBatchPut() {\n+\n+        List<Object> dummyValues = new ArrayList<>();\n+        for (int i = 0; i < columns.size(); i++) {\n+            dummyValues.add(null);\n+        }\n+        return create.batch(create.insertInto(DSL.table(this.tableName)).values(dummyValues));\n+    }\n+\n+    @VisibleForTesting\n+    public void putStartMetric(Long startTime, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ST.toString()), Long.class), startTime)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    @VisibleForTesting\n+    public void putEndMetric(Long endTime, int error, Map<String, String> dimensions) {\n+        Map<Field<?>, String> dimensionMap = new HashMap<>();\n+        for (Map.Entry<String, String> dimension : dimensions.entrySet()) {\n+            dimensionMap.put(DSL.field(DSL.name(dimension.getKey()), String.class), dimension.getValue());\n+        }\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .set(DSL.field(DSL.name(Fields.ET.toString()), Long.class), endTime)\n+                .set(DSL.field(DSL.name(Fields.ERROR.toString()), Integer.class), error)\n+                .set(dimensionMap)\n+                .execute();\n+    }\n+\n+    public Result<Record> fetchAll() {\n+        return create.select().from(DSL.table(this.tableName)).fetch();\n+    }\n+\n+    @Override\n+    public void remove() throws Exception {\n+        create.dropTable(DSL.table(this.tableName)).execute();\n+    }\n+\n+    public void rolloverInFlightRequests(FaultDetectionMetricsSnapshot prevSnap) {\n+        // Fetch all entries that have not ended and write to current table.\n+        create\n+                .insertInto(DSL.table(this.tableName))\n+                .select(create.select().from(prevSnap.fetchInFlightRequests()))\n+                .execute();\n+    }\n+\n+    public SelectHavingStep<Record> fetchInFlightRequests() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.ERROR.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                    }\n+                };\n+\n+        return create\n+                .select(fields)\n+                .from(groupByRidAndTypeSelect())\n+                .where(\n+                        DSL.field(Fields.ST.toString())\n+                                .isNotNull()\n+                                .and(DSL.field(Fields.ET.toString()).isNull())\n+                                .and(DSL.field(Fields.ST.toString()).gt(this.windowStartTime - EXPIRE_AFTER)));\n+    }\n+\n+    public SelectHavingStep<Record> groupByRidAndTypeSelect() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ST.toString(), Long.class)).as(DSL.name(Fields.ST.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ET.toString(), Long.class)).as(DSL.name(Fields.ET.toString())));\n+        fields.add(\n+                DSL.max(DSL.field(Fields.ERROR.toString(), Integer.class)).as(DSL.name(Fields.ERROR.toString())));\n+        LOG.error(\"Initial - \" + fetchAll().size());\n+        LOG.error(\"Breakdown 1 - \" + create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString())).fetch().size());\n+        return create\n+                .select(fields)\n+                .from(DSL.table(this.tableName))\n+                .groupBy(DSL.field(Fields.RID.toString()), DSL.field(Fields.FAULT_DETECTION_TYPE.toString()));\n+    }\n+\n+    public SelectHavingStep<Record> fetchLatencyTable() {\n+        ArrayList<SelectField<?>> fields =\n+                new ArrayList<SelectField<?>>() {\n+                    {\n+                        this.add(DSL.field(DSL.name(Fields.RID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString()), String.class));\n+                        this.add(DSL.field(DSL.name(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString()), Long.class));\n+                        this.add(DSL.field(DSL.name(Fields.FAULT_DETECTION_TYPE.toString()), String.class));\n+                        this.add(DSL.field(Fields.ST.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ET.toString(), Long.class));\n+                        this.add(DSL.field(Fields.ERROR.toString(), Integer.class));\n+                    }\n+                };\n+        fields.add(\n+                DSL.field(Fields.ET.toString())\n+                        .minus(DSL.field(Fields.ST.toString()))\n+                        .as(DSL.name(Fields.LAT.toString())));\n+        LOG.error(\"Breakdown 2 - \" + create", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTY2Nw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDIwNjA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMDozMjoyOVrOHjS56Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzoxNzo0N1rOHkAvcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTk0NQ==", "bodyText": "Do we need to add a new snapshot type or we can re-use the MASTER_EVENT_SNAPSHOTS here ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r506771945", "createdAt": "2020-10-17T00:32:29Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUyMjkzMQ==", "bodyText": "We need a new one. As far as i understand, snapshot contains table schema. Master events and Fault Detection events though both are being used to calculate latency and failure metrics have quite different schemas.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r507522931", "createdAt": "2020-10-19T07:17:47Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MTk0NQ=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjU5MzQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NDoyMlrOHkixrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo0NDoxN1rOHk4OXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDU1Ng==", "bodyText": "Minor naming suggestion. Can we use FOLLOWER_CHECK_LATENCY and similarly LATENCY and FAILURE as suffix instead of prefix ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508080556", "createdAt": "2020-10-19T21:44:22Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMTk2Ng==", "bodyText": "Changed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508431966", "createdAt": "2020-10-20T11:44:17Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDU1Ng=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjU5NjE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NToxM1rOHkizQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo0NDoyMlrOHk4Ong==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDk2MQ==", "bodyText": "An extension of above comment, use FollowerCheck_Latency ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508080961", "createdAt": "2020-10-19T21:45:13Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+\n+    private final String value;\n+\n+    FaultDetectionMetric(String value) {\n+      this.value = value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return value;\n+    }\n+\n+    public static class Constants {\n+      public static final String LATENCY_FOLLOWER_CHECK = \"Latency_FollowerCheck\";\n+      public static final String LATENCY_LEADER_CHECK = \"Latency_LeaderCheck\";\n+      public static final String FAILURE_FOLLOWER_CHECK = \"Failure_FollowerCheck\";\n+      public static final String FAILURE_LEADER_CHECK = \"Failure_LeaderCheck\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzMjAzMA==", "bodyText": "Changed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508432030", "createdAt": "2020-10-20T11:44:22Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/AllMetrics.java", "diffHunk": "@@ -1030,6 +1030,52 @@ public String toString() {\n     }\n   }\n \n+  public enum FaultDetectionMetric implements MetricValue {\n+    LATENCY_FOLLOWER_CHECK(Constants.LATENCY_FOLLOWER_CHECK),\n+    LATENCY_LEADER_CHECK(Constants.LATENCY_LEADER_CHECK),\n+    FAILURE_FOLLOWER_CHECK(Constants.FAILURE_FOLLOWER_CHECK),\n+    FAILURE_LEADER_CHECK(Constants.FAILURE_LEADER_CHECK);\n+\n+    private final String value;\n+\n+    FaultDetectionMetric(String value) {\n+      this.value = value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return value;\n+    }\n+\n+    public static class Constants {\n+      public static final String LATENCY_FOLLOWER_CHECK = \"Latency_FollowerCheck\";\n+      public static final String LATENCY_LEADER_CHECK = \"Latency_LeaderCheck\";\n+      public static final String FAILURE_FOLLOWER_CHECK = \"Failure_FollowerCheck\";\n+      public static final String FAILURE_LEADER_CHECK = \"Failure_LeaderCheck\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MDk2MQ=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjU5ODQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NTo1NFrOHki0jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo0OToxMlrOHk4ZOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTI5Mg==", "bodyText": "Generic variable name, where do we intend to use this ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081292", "createdAt": "2020-10-19T21:45:54Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java", "diffHunk": "@@ -60,6 +61,9 @@\n   public static final String MASTER_CURRENT = \"current\";\n   public static final String MASTER_META_DATA = \"metadata\";\n   public static final String METRIC_CURRENT_TIME = \"current_time\";\n+  public static final String FAULT_DETECTION_FOLLOWER_CHECK = \"follower_check\";\n+  public static final String FAULT_DETECTION_LEADER_CHECK = \"leader_check\";\n+  public static final String ERROR = \"error\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNDc0NA==", "bodyText": "used to capture fault for both FollowerCheck and LeaderCheck hence generic", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508434744", "createdAt": "2020-10-20T11:49:12Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/metrics/PerformanceAnalyzerMetrics.java", "diffHunk": "@@ -60,6 +61,9 @@\n   public static final String MASTER_CURRENT = \"current\";\n   public static final String MASTER_META_DATA = \"metadata\";\n   public static final String METRIC_CURRENT_TIME = \"current_time\";\n+  public static final String FAULT_DETECTION_FOLLOWER_CHECK = \"follower_check\";\n+  public static final String FAULT_DETECTION_LEADER_CHECK = \"leader_check\";\n+  public static final String ERROR = \"error\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTI5Mg=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjYwMDgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NjozN1rOHki10g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1MDo0M1rOHk4cdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTYxOA==", "bodyText": "Can we fix the indentation here?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081618", "createdAt": "2020-10-19T21:46:37Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java", "diffHunk": "@@ -340,6 +340,26 @@\n         new MetricAttributes(\n             MetricUnits.MILLISECOND.toString(), AllMetrics.MasterMetricDimensions.values()));\n \n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNTU3NQ==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508435575", "createdAt": "2020-10-20T11:50:43Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/model/MetricsModel.java", "diffHunk": "@@ -340,6 +340,26 @@\n         new MetricAttributes(\n             MetricUnits.MILLISECOND.toString(), AllMetrics.MasterMetricDimensions.values()));\n \n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.LATENCY_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.MILLISECOND.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_FOLLOWER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+\n+    allMetricsInitializer.put(\n+            AllMetrics.FaultDetectionMetric.FAILURE_LEADER_CHECK.toString(),\n+            new MetricAttributes(\n+                    MetricUnits.COUNT.toString(), AllMetrics.FaultDetectionDimension.values()));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTYxOA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjYwMjYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NzowNlrOHki2vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1MjozMFrOHk4grA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTg1Mg==", "bodyText": "Missing License information.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508081852", "createdAt": "2020-10-19T21:47:06Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjY1Mg==", "bodyText": "Added", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508436652", "createdAt": "2020-10-20T11:52:30Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTg1Mg=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjYwNDE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTo0NzozNlrOHki3ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1MzowNFrOHk4h-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MjA4Mw==", "bodyText": "nit: Let's move faultDetectionMetricsMap to next line.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508082083", "createdAt": "2020-10-19T21:47:36Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjk4Nw==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508436987", "createdAt": "2020-10-20T11:53:04Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MjA4Mw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY0MDkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowMDowN1rOHkjNiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1ODo1NFrOHk4udw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4NzY4OQ==", "bodyText": "I assume the keyItems or event.key will always have the expected values an index 0 and 3 here ?\nWhat happens if keyItems[3] throws an ArrayIndexOutOfBounds Exception?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508087689", "createdAt": "2020-10-19T22:00:07Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MDE4Mw==", "bodyText": "That shouldn't be the case. If this happens somehow, it will have an ArrayIndexOutOfBoundsException. Can add assert here which can check the size of keyItems.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508440183", "createdAt": "2020-10-20T11:58:54Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4NzY4OQ=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY1MzUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowNDo0MVrOHkjVIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjowNjoyNVrOHk4--w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4OTYzNA==", "bodyText": "Let us either make this a java doc string or movie this multi-line comment to inside the function.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508089634", "createdAt": "2020-10-19T22:04:41Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NDQxMQ==", "bodyText": "Made it javadoc", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508444411", "createdAt": "2020-10-20T12:06:25Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4OTYzNA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY1NzQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowNjoxMFrOHkjXfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjowODoyNlrOHk5DoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDIzNw==", "bodyText": "Import AllMetrics.FaultDetectionDimension instead of AllMetrics ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508090237", "createdAt": "2020-10-19T22:06:10Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTYwMA==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508445600", "createdAt": "2020-10-20T12:08:26Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDIzNw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY2MDc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowNzoxM1rOHkjZXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoxMDowMlrOHk5Hdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDcxOA==", "bodyText": "Let's movie this line to within the try block, after line 103", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508090718", "createdAt": "2020-10-19T22:07:13Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NjU4Mw==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446583", "createdAt": "2020-10-20T12:10:02Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MDcxOA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY2NTI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowOTowMFrOHkjcNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjowOTo1N1rOHk5HPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTQ0Nw==", "bodyText": "similar, move this to within try block after line 133", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091447", "createdAt": "2020-10-19T22:09:00Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];\n+        try {\n+            long st = Long.parseLong(startTimeVal);\n+            // A keyItem is of the form : [fault_detection, follower_check, 76543, start]\n+            String rid = keyItems[2];\n+            handle.bind(rid, sourceNodeId, targetNodeId, fault_detection_type, st, null, 0);\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Unable to parse string. StartTime:{}\", startTimeVal);\n+            StatsCollector.instance().logException(StatExceptionCode.READER_PARSER_ERROR);\n+            throw e;\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, finish]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // FinishTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // Error:0\n+    // $\n+    private void emitFinishMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String finishTimeVal = keyValueMap.get(AllMetrics.CommonMetric.FINISH_TIME.toString());\n+        String errorString = keyValueMap.get(PerformanceAnalyzerMetrics.ERROR);\n+        String fault_detection_type = keyItems[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NjUyNg==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446526", "createdAt": "2020-10-20T12:09:57Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsProcessor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatExceptionCode;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.collectors.StatsCollector;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader_writer_shared.Event;\n+import java.io.File;\n+import java.sql.Connection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.BatchBindStep;\n+\n+public class FaultDetectionMetricsProcessor implements EventProcessor {\n+    private static final Logger LOG = LogManager.getLogger(FaultDetectionMetricsProcessor.class);\n+    private FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot;\n+    private long startTime;\n+    private long endTime;\n+    private BatchBindStep handle;\n+\n+    public FaultDetectionMetricsProcessor(FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot) {\n+        this.faultDetectionMetricsSnapshot = faultDetectionMetricsSnapshot;\n+    }\n+\n+    static FaultDetectionMetricsProcessor buildFaultDetectionMetricsProcessor(\n+            long currWindowStartTime,\n+            Connection conn,\n+            NavigableMap<Long, FaultDetectionMetricsSnapshot> faultDetectionMetricsMap) {\n+        if (faultDetectionMetricsMap.get(currWindowStartTime) == null) {\n+            FaultDetectionMetricsSnapshot faultDetectionMetricsSnapshot =\n+                    new FaultDetectionMetricsSnapshot(conn, currWindowStartTime);\n+            Map.Entry<Long, FaultDetectionMetricsSnapshot> entry = faultDetectionMetricsMap.lastEntry();\n+            if (entry != null) {\n+                faultDetectionMetricsSnapshot.rolloverInFlightRequests(entry.getValue());\n+            }\n+            faultDetectionMetricsMap.put(currWindowStartTime, faultDetectionMetricsSnapshot);\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsSnapshot);\n+        } else {\n+            return new FaultDetectionMetricsProcessor(faultDetectionMetricsMap.get(currWindowStartTime));\n+        }\n+    }\n+\n+    @Override\n+    public void initializeProcessing(long startTime, long endTime) {\n+        this.startTime = startTime;\n+        this.endTime = endTime;\n+        this.handle = faultDetectionMetricsSnapshot.startBatchPut();\n+    }\n+\n+    @Override\n+    public void finalizeProcessing() {\n+        if (handle.size() > 0) {\n+            handle.execute();\n+        }\n+        LOG.debug(\"Final Fault Detection request metrics {}\", faultDetectionMetricsSnapshot.fetchAll());\n+    }\n+\n+    @Override\n+    public void processEvent(Event event) {\n+        String[] keyItems = event.key.split(File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator);\n+        if (keyItems[0].equals(PerformanceAnalyzerMetrics.sFaultDetection)) {\n+            if (keyItems[3].equals(PerformanceAnalyzerMetrics.START_FILE_NAME)) {\n+                emitStartMetric(event, keyItems);\n+            } else if (keyItems[3].equals(PerformanceAnalyzerMetrics.FINISH_FILE_NAME)) {\n+                emitFinishMetric(event, keyItems);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean shouldProcessEvent(Event event) {\n+        return event.key.contains(PerformanceAnalyzerMetrics.sFaultDetection);\n+    }\n+\n+    @Override\n+    public void commitBatchIfRequired() {\n+        if (handle.size() > BATCH_LIMIT) {\n+            handle.execute();\n+            handle = faultDetectionMetricsSnapshot.startBatchPut();\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, start]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // StartTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // $\n+    private void emitStartMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String startTimeVal = keyValueMap.get(AllMetrics.CommonMetric.START_TIME.toString());\n+        String fault_detection_type = keyItems[1];\n+        try {\n+            long st = Long.parseLong(startTimeVal);\n+            // A keyItem is of the form : [fault_detection, follower_check, 76543, start]\n+            String rid = keyItems[2];\n+            handle.bind(rid, sourceNodeId, targetNodeId, fault_detection_type, st, null, 0);\n+        } catch (NumberFormatException e) {\n+            LOG.error(\"Unable to parse string. StartTime:{}\", startTimeVal);\n+            StatsCollector.instance().logException(StatExceptionCode.READER_PARSER_ERROR);\n+            throw e;\n+        }\n+    }\n+\n+    // A keyItem is of the form : [fault_detection, follower_check, 76532, finish]\n+    //\n+    // Example value part of the entry is:\n+    // current_time:1566413979979\n+    // FinishTime:1566413987986\n+    // SourceNodeID:g52i9a93a762cd59dda8d3379b09a752a\n+    // TargetNodeID:b2a5a93a762cd59dda8d3379b09a752a\n+    // Error:0\n+    // $\n+    private void emitFinishMetric(Event entry, String[] keyItems) {\n+        Map<String, String> keyValueMap = ReaderMetricsProcessor.extractEntryData(entry.value);\n+\n+        String sourceNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+        String targetNodeId = keyValueMap.get(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+        String finishTimeVal = keyValueMap.get(AllMetrics.CommonMetric.FINISH_TIME.toString());\n+        String errorString = keyValueMap.get(PerformanceAnalyzerMetrics.ERROR);\n+        String fault_detection_type = keyItems[1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTQ0Nw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY2NTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowOToxMVrOHkjcjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoxMDoxMVrOHk5H1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUzMw==", "bodyText": "Missing License information.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091533", "createdAt": "2020-10-19T22:09:11Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NjY3OA==", "bodyText": "Added", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508446678", "createdAt": "2020-10-20T12:10:11Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshot.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUzMw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY2ODI1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowOTo1N1rOHkjd3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNjowMVrOHk6Hsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTg3MA==", "bodyText": "Missing License information.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508091870", "createdAt": "2020-10-19T22:09:57Z", "author": {"login": "khushbr"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MzAyNw==", "bodyText": "Added", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508463027", "createdAt": "2020-10-20T12:36:01Z", "author": {"login": "amathur1893"}, "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/FaultDetectionMetricsSnapshotTests.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.reader;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTg3MA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY3MDA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoxMDozOFrOHkje3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNTozOVrOHk6GtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjEyNA==", "bodyText": "nit: Can we fix the Indentation here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092124", "createdAt": "2020-10-19T22:10:38Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -119,6 +121,7 @@ public ReaderMetricsProcessor(String rootLocation, boolean processNewFormat, fin\n     shardRqMetricsMap = new TreeMap<>();\n     httpRqMetricsMap = new TreeMap<>();\n     masterEventMetricsMap = new TreeMap<>();\n+\tfaultDetectionMetricsMap = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2Mjc3Mw==", "bodyText": "fixed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462773", "createdAt": "2020-10-20T12:35:39Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -119,6 +121,7 @@ public ReaderMetricsProcessor(String rootLocation, boolean processNewFormat, fin\n     shardRqMetricsMap = new TreeMap<>();\n     httpRqMetricsMap = new TreeMap<>();\n     masterEventMetricsMap = new TreeMap<>();\n+\tfaultDetectionMetricsMap = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjEyNA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY3MTgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoxMToxNlrOHkjf4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNTo0N1rOHk6HGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjM4Ng==", "bodyText": "nit: Can we fix the Indentation here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092386", "createdAt": "2020-10-19T22:11:16Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2Mjg3NQ==", "bodyText": "fixed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462875", "createdAt": "2020-10-20T12:35:47Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -240,6 +243,7 @@ public void trimOldSnapshots() throws Exception {\n     trimMap(shardRqMetricsMap, RQ_SNAPSHOTS);\n     trimMap(httpRqMetricsMap, HTTP_RQ_SNAPSHOTS);\n     trimMap(masterEventMetricsMap, MASTER_EVENT_SNAPSHOTS);\n+\ttrimMap(faultDetectionMetricsMap, FAULT_DETECTION_SNAPSHOTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjM4Ng=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY3MzUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoxMTo1NFrOHkjg6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNTo1NVrOHk6Hbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjY1MQ==", "bodyText": "nit: Can we fix the Indentation here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092651", "createdAt": "2020-10-19T22:11:54Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -540,6 +559,7 @@ is ready so it starts to read that file (go back two windows and\n     eventDispatcher.registerEventProcessor(nodeEventsProcessor);\n     eventDispatcher.registerEventProcessor(masterEventsProcessor);\n     eventDispatcher.registerEventProcessor(clusterDetailsEventsProcessor);\n+\teventDispatcher.registerEventProcessor(faultDetectionProcessor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2Mjk1OA==", "bodyText": "fixed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462958", "createdAt": "2020-10-20T12:35:55Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ReaderMetricsProcessor.java", "diffHunk": "@@ -540,6 +559,7 @@ is ready so it starts to read that file (go back two windows and\n     eventDispatcher.registerEventProcessor(nodeEventsProcessor);\n     eventDispatcher.registerEventProcessor(masterEventsProcessor);\n     eventDispatcher.registerEventProcessor(clusterDetailsEventsProcessor);\n+\teventDispatcher.registerEventProcessor(faultDetectionProcessor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MjY1MQ=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY3NTQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoxMjo0NVrOHkjiKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNDoxMFrOHk6Cxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Mjk2OQ==", "bodyText": "Is this required ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508092969", "createdAt": "2020-10-19T22:12:45Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MTc2Nw==", "bodyText": "Removed", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508461767", "createdAt": "2020-10-20T12:34:10Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5Mjk2OQ=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY3ODcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoxNDowMVrOHkjkDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoxNDoyNlrOHk5R0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MzQ1NA==", "bodyText": "Let's import AllMetrics.FaultDetectionDimension explicitly here.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508093454", "createdAt": "2020-10-19T22:14:01Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -22,6 +22,7 @@\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoValue;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.OSMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0OTIzMg==", "bodyText": "done", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508449232", "createdAt": "2020-10-20T12:14:26Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -22,6 +22,7 @@\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoDimension;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.GCInfoValue;\n import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.OSMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.PerformanceAnalyzerMetrics;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MzQ1NA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjcyNzE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozMjoyN1rOHkkAsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNDo0OFrOHk6EUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDc4NA==", "bodyText": "Replace this with List<String> dimensionNames = snap.getDimensionNames(); ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508100784", "createdAt": "2020-10-19T22:32:27Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MjE2Mw==", "bodyText": "It is a map of dimension name and its value. It will be constructed once we have the table of records", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462163", "createdAt": "2020-10-20T12:34:48Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMDc4NA=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjczMDkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNDowNVrOHkkDBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNDowNFrOHk6CiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTM4Mw==", "bodyText": "Redundant ? We can use the dimensions defined on line 855", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508101383", "createdAt": "2020-10-19T22:34:05Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MTcwNQ==", "bodyText": "This is used to store a key value. Dimension is a map object that has key as metric dimension and value as to what is the value for it whereas dims is a list of dimension as string .", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508461705", "createdAt": "2020-10-20T12:34:04Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTM4Mw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjczMTkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjozNDoyOVrOHkkDnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjozNTowN1rOHk6FQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTUzMw==", "bodyText": "Replace dims with dimensions ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508101533", "createdAt": "2020-10-19T22:34:29Z", "author": {"login": "khushbr"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };\n+\n+      db.createMetric(\n+              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+              dims);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ2MjQwMg==", "bodyText": "Same reasoning as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/470#discussion_r508462402", "createdAt": "2020-10-20T12:35:07Z", "author": {"login": "amathur1893"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/MetricsEmitter.java", "diffHunk": "@@ -847,4 +848,141 @@ public static void emitNodeMetrics(\n           \"Total time taken for writing {} metrics metricsdb: {}\", tableName, mFinalT - mCurrT);\n     }\n   }\n+\n+    public static void emitFaultDetectionMetrics(DSLContext create, MetricsDB db, FaultDetectionMetricsSnapshot faultDetectionSnapshot) {\n+\n+      long mCurrT = System.currentTimeMillis();\n+      Dimensions dimensions = new Dimensions();\n+      Result<Record> res = faultDetectionSnapshot.fetchAggregatedTable();\n+      LOG.error(\"AHH record size is \" + res.size());\n+      List<String> dims =\n+              new ArrayList<String>() {\n+                {\n+                  this.add(AllMetrics.FaultDetectionDimension.SOURCE_NODE_ID.toString());\n+                  this.add(AllMetrics.FaultDetectionDimension.TARGET_NODE_ID.toString());\n+                }\n+              };\n+\n+      db.createMetric(\n+              new Metric<Double>(AllMetrics.FaultDetectionMetric.LATENCY_FOLLOWER_CHECK.toString(), 0d),\n+              dims);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMTUzMw=="}, "originalCommit": {"oid": "d1f587f4950141fe228fcc86c97ab3e46523e14e"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2237, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}