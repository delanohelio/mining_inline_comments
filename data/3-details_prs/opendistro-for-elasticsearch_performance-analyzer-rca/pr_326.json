{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMzc2Mjg5", "number": 326, "title": "JVM decider", "bodyText": "Issue #:\nDescription of changes:\nAdd JVM decider to RCA framework\nTests:\nWIP\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-07-31T18:12:23Z", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326", "merged": true, "mergeCommit": {"oid": "1decacb9df2c4f47e6b0d4e0ad1a60657af4d2ab"}, "closed": true, "closedAt": "2020-09-03T21:35:25Z", "author": {"login": "rguo-aws"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6YKs5AH2gAyNDYwMzc2Mjg5OjUyNzRhMTMxMWQyODczYWQ5YmMzMjE3MmM3MzgxOTdjMzYxZTM2MTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFXf1tgFqTQ4MjIxNjEyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5274a1311d2873ad9bc32172c738197c361e3618", "committedDate": "2020-07-31T18:03:06Z", "message": "JVM decider framework"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjM5NDYw", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-461239460", "createdAt": "2020-08-04T23:19:08Z", "commit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzoxOTowOVrOG70soQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDowNjoxM1rOG71ksw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MjU2MQ==", "bodyText": "I am curious why in case of increase == false, in one constructor we leave desiredCapacity at current value while in the other we decrease it by one step while the logic is identical in case increase == true. Is this intended ? Can we add a comment stating why this is so ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465382561", "createdAt": "2020-08-04T23:19:09Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheCapacityAction.java", "diffHunk": "@@ -36,21 +36,51 @@\n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n+    public ModifyCacheCapacityAction(\n+        final NodeKey esNode,\n+        final ResourceEnum cacheType,\n+        final long currentCapacityInBytes,\n+        final boolean increase) {\n+        this(esNode, cacheType, currentCapacityInBytes);\n+        long desiredCapacity =\n+            increase ? currentCapacityInBytes + getStepSize(cacheType) : currentCapacityInBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MzAzNA==", "bodyText": "can we add a comment as why this makes sense to hard code this ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465383034", "createdAt": "2020-08-04T23:20:37Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheCapacityAction.java", "diffHunk": "@@ -142,6 +172,10 @@ public long getDesiredCapacityInBytes() {\n         return desiredCapacityInBytes;\n     }\n \n+    public double getDesiredCapacityInPercent() {\n+        return 0.1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODc3Mg==", "bodyText": "A lot of the code is the same in both the read**Capacity methods. Can we extract it out to a common method ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465388772", "createdAt": "2020-08-04T23:38:57Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCacheUtil.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.MetricEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+\n+public class NodeConfigCacheUtil {\n+\n+  public static Long readCacheSize(NodeKey esNode, NodeConfigCache nodeConfigCache, ResourceEnum resourceEnum) {\n+    Long ret;\n+    Resource resource = Resource.newBuilder()\n+        .setResourceEnum(resourceEnum)\n+        .setMetricEnum(MetricEnum.CACHE_MAX_SIZE).build();\n+    try {\n+      ret = (long) nodeConfigCache.get(esNode, resource);\n+    } catch (Exception e) {\n+      ret = null;\n+    }\n+    return ret;\n+  }\n+\n+  public static Integer readQueueCapacity(NodeKey esNode, NodeConfigCache nodeConfigCache, ResourceEnum resourceEnum) {\n+    Integer ret;\n+    Resource resource = Resource.newBuilder()\n+        .setResourceEnum(resourceEnum)\n+        .setMetricEnum(MetricEnum.QUEUE_CAPACITY).build();\n+    try {\n+      ret = (int) nodeConfigCache.get(esNode, resource);\n+    } catch (Exception e) {\n+      ret = null;\n+    }\n+    return ret;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MjQwOQ==", "bodyText": "I might be wrong, but I think if we name a class as builder, it should follow the builder pattern ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465392409", "createdAt": "2020-08-04T23:51:21Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Mjc4NA==", "bodyText": "Because these seem like the initialization methods, would the constructor not be a better place for them ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465392784", "createdAt": "2020-08-04T23:52:31Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    targetCaches = Collections.unmodifiableList(caches);\n+  }\n+\n+  public LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    actionFilter = new HashMap<>();\n+    targetCaches.forEach(r -> actionFilter.put(r, false));\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  private void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * build actions for level 1 bucket.\n+   * @return List of actions\n+   */\n+  public List<Action> buildActions() {\n+    addFieldDataCacheAction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MzkyMQ==", "bodyText": "Some of the code in the LevelledActionBuilders is common. Can we move it to a base class ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465393921", "createdAt": "2020-08-04T23:56:09Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+  private static final List<ResourceEnum> targetQueues;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    List<ResourceEnum> queues = new ArrayList<>();\n+    queues.add(ResourceEnum.WRITE_THREADPOOL);\n+    queues.add(ResourceEnum.SEARCH_THREADPOOL);\n+    targetCaches = Collections.unmodifiableList(caches);\n+    targetQueues = Collections.unmodifiableList(queues);\n+  }\n+\n+  public LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjY3OQ==", "bodyText": "What is EWMA ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465396679", "createdAt": "2020-08-05T00:05:14Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+  private static final List<ResourceEnum> targetQueues;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    List<ResourceEnum> queues = new ArrayList<>();\n+    queues.add(ResourceEnum.WRITE_THREADPOOL);\n+    queues.add(ResourceEnum.SEARCH_THREADPOOL);\n+    targetCaches = Collections.unmodifiableList(caches);\n+    targetQueues = Collections.unmodifiableList(queues);\n+  }\n+\n+  public LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    actionFilter = new HashMap<>();\n+    targetCaches.forEach(r -> actionFilter.put(r, false));\n+    targetQueues.forEach(r -> actionFilter.put(r, false));\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheUtil.readQueueSize(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjkxNQ==", "bodyText": "Would we not want to take some actions if only one of the queues is non-null ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465396915", "createdAt": "2020-08-05T00:06:13Z", "author": {"login": "yojs"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+  private static final List<ResourceEnum> targetQueues;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    List<ResourceEnum> queues = new ArrayList<>();\n+    queues.add(ResourceEnum.WRITE_THREADPOOL);\n+    queues.add(ResourceEnum.SEARCH_THREADPOOL);\n+    targetCaches = Collections.unmodifiableList(caches);\n+    targetQueues = Collections.unmodifiableList(queues);\n+  }\n+\n+  public LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    actionFilter = new HashMap<>();\n+    targetCaches.forEach(r -> actionFilter.put(r, false));\n+    targetQueues.forEach(r -> actionFilter.put(r, false));\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheUtil.readQueueSize(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueEWMASize = NodeConfigCacheUtil.readQueueSize(esNode, nodeConfigCache, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueEWMASize == null || searchQueueEWMASize == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5274a1311d2873ad9bc32172c738197c361e3618"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c11c54be8cc81e62361aa62292244260fcb0ae05", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/c11c54be8cc81e62361aa62292244260fcb0ae05", "committedDate": "2020-08-05T17:47:47Z", "message": "Merge branch 'master' into rguo-jvm-decider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/3ffecf220beb933b0843abee685bec3002122e23", "committedDate": "2020-08-05T20:57:32Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMDg0Mjc4", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-462084278", "createdAt": "2020-08-05T23:12:19Z", "commit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzoxMjoxOVrOG8drog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNjozNjowN1rOG8lJvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NDA1MA==", "bodyText": "nit: isn't this an upper bound?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466054050", "createdAt": "2020-08-05T23:12:19Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -53,29 +53,63 @@\n \n   private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n \n-  public ModifyCacheMaxSizeAction(\n+  private ModifyCacheMaxSizeAction(\n       final NodeKey esNode,\n       final ResourceEnum cacheType,\n       final NodeConfigCache nodeConfigCache,\n-      final double cacheSizeUpperBound,\n-      final boolean increase) {\n-    // TODO: Add lower bound for caches\n-    // TODO: Address cache scaling down  when JVM decider is available\n+      final double cacheSizeUpperBound) {\n \n     this.esNode = esNode;\n     this.cacheType = cacheType;\n     this.nodeConfigCache = nodeConfigCache;\n     this.cacheSizeUpperBound = cacheSizeUpperBound;\n \n     setStepSize();\n+  }\n \n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n     if (validateAndSetConfigValues()) {\n       long desiredCapacity =\n               increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n       setDesiredCacheMaxSize(desiredCapacity);\n     }\n   }\n \n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase,\n+      int step) {\n+    this(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n+    if (validateAndSetConfigValues()) {\n+      long desiredCapacity =\n+          increase ? currentCacheMaxSizeInBytes + step * getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+      setDesiredCacheMaxSize(desiredCapacity);\n+    }\n+  }\n+\n+  public static ModifyCacheMaxSizeAction newMinimalCapacityAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final long cacheSizeUpperBound) {\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n+    //TODO : set lower bound to 0 for now", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NTQ0Ng==", "bodyText": "Replace with: this(esNode, threadPool, currentCapacity, increase, 1)", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466055446", "createdAt": "2020-08-05T23:16:41Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyQueueCapacityAction.java", "diffHunk": "@@ -40,14 +41,23 @@\n   private Map<ResourceEnum, Integer> lowerBound = new HashMap<>();\n   private Map<ResourceEnum, Integer> upperBound = new HashMap<>();\n \n+  public ModifyQueueCapacityAction(NodeKey esNode, ResourceEnum threadPool, int currentCapacity, boolean increase, int step) {\n+    this(esNode, threadPool, currentCapacity);\n+    int desiredCapacity = increase ? currentCapacity + step * STEP_SIZE : currentCapacity - step * STEP_SIZE;\n+    setDesiredCapacity(desiredCapacity);\n+  }\n+\n   public ModifyQueueCapacityAction(NodeKey esNode, ResourceEnum threadPool, int currentCapacity, boolean increase) {\n+    this(esNode, threadPool, currentCapacity);\n+    int desiredCapacity = increase ? currentCapacity + STEP_SIZE : currentCapacity - STEP_SIZE;\n+    setDesiredCapacity(desiredCapacity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjE0Mg==", "bodyText": "Add null checks for sanity", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466056142", "createdAt": "2020-08-05T23:19:09Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyQueueCapacityAction.java", "diffHunk": "@@ -124,4 +134,12 @@ public int getDesiredCapacity() {\n   public ResourceEnum getThreadPool() {\n     return threadPool;\n   }\n+\n+  public int getUpperBound() {\n+    return upperBound.get(threadPool);\n+  }\n+\n+  public int getLowerBound() {\n+    return lowerBound.get(threadPool);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MTE5Nw==", "bodyText": "Do ALL actions need these? Might want to move these into a subclass if not.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466061197", "createdAt": "2020-08-05T23:34:42Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MTk3Mw==", "bodyText": "actionFilter.getOrDefault(cache, false)", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466061973", "createdAt": "2020-08-05T23:37:25Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  protected abstract void registerActions();\n+\n+  protected abstract void actionPriorityFilter();\n+\n+  /**\n+   * build actions.\n+   * @return List of actions\n+   */\n+  public List<Action> build() {\n+    List<Action> actions = new ArrayList<>();\n+    cacheActionMap.forEach((cache, action) -> {\n+      if (actionFilter.containsKey(cache) && actionFilter.get(cache)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MjA2Mw==", "bodyText": "getOrDefault as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466062063", "createdAt": "2020-08-05T23:37:40Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  protected abstract void registerActions();\n+\n+  protected abstract void actionPriorityFilter();\n+\n+  /**\n+   * build actions.\n+   * @return List of actions\n+   */\n+  public List<Action> build() {\n+    List<Action> actions = new ArrayList<>();\n+    cacheActionMap.forEach((cache, action) -> {\n+      if (actionFilter.containsKey(cache) && actionFilter.get(cache)) {\n+        actions.add(action);\n+      }\n+    });\n+    queueActionMap.forEach((queue, action) -> {\n+      if (actionFilter.containsKey(queue) && actionFilter.get(queue)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MzE2Mw==", "bodyText": "So action.isActionable() takes the upper bound into consideration but not the lower bound? Are there plans to change this in the future?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466063163", "createdAt": "2020-08-05T23:41:10Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NDQ4Mw==", "bodyText": "Can we rename these? The levels seem to correspond to usage buckets which we're calling healthy with buffer, healthy, underprovisioned, and unhealthy.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466064483", "createdAt": "2020-08-05T23:45:32Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelThreeActionBuilder.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level three bucket\n+ *\n+ * <p>if old gen usage(after full gc) falls into this bucket 90% - 100%, JVM heap is extremely\n+ * contended and can run into OOM at any moment. So action builder will build a group of actions\n+ * to scale down caches to their lower bound in one shot. And for queues we will downsize all\n+ * queues simultaneously with even higher steps\n+ */\n+public class LevelThreeActionBuilder extends BaseActionBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ==", "bodyText": "This is very neat for this particular use case, but these actionbuilders aren't reusable", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466066965", "createdAt": "2020-08-05T23:54:15Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {\n+      return LevelOneActionBuilder.newBuilder(esNode, nodeConfigCache).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3NTE0Mg==", "bodyText": "After rereading this my thoughts are the same. I don't understand what problem we were trying to solve by using the builder pattern here. We don't actually use the builders as legitimate builders, they're just wrappers around specific logic for generating a list of actions given a known bucket level. Why can't the static variables be held in this class with the List generated in actions() itself? Who would reuse these classes down the line?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466175142", "createdAt": "2020-08-06T06:32:45Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {\n+      return LevelOneActionBuilder.newBuilder(esNode, nodeConfigCache).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3NjQ0NQ==", "bodyText": "The only moderately complex logic seems to live entirely in LevelTwoActionBuilder#actionPriorityForQueue(), but might not this just live in a function in this class?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466176445", "createdAt": "2020-08-06T06:36:07Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {\n+      return LevelOneActionBuilder.newBuilder(esNode, nodeConfigCache).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8cea381d6c9d30c51b9f1e1de68c51c97e21c83", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/a8cea381d6c9d30c51b9f1e1de68c51c97e21c83", "committedDate": "2020-08-11T22:22:57Z", "message": "Add UTs, WIP"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk3ODQx", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-469897841", "createdAt": "2020-08-18T23:31:48Z", "commit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozMTo0OFrOHCqJTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNzo0MDo0OFrOHDSgaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0OTcxMQ==", "bodyText": "Both upper and lower bounds should be read from config and adhered to. We cannot set cache lower bounds to 0 as it is effectively disables the caches.\nCache decider+rca looks for a combination of hit rate and eviction rate to check if size should be increased. Setting it to 0 makes eviction rate 0 - as a result caches are never increased even when enough mem is available.\nWe have to determine apt lower bounds and stick to those values.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r472549711", "createdAt": "2020-08-18T23:31:48Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -53,29 +53,63 @@\n \n   private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n \n-  public ModifyCacheMaxSizeAction(\n+  private ModifyCacheMaxSizeAction(\n       final NodeKey esNode,\n       final ResourceEnum cacheType,\n       final NodeConfigCache nodeConfigCache,\n-      final double cacheSizeUpperBound,\n-      final boolean increase) {\n-    // TODO: Add lower bound for caches\n-    // TODO: Address cache scaling down  when JVM decider is available\n+      final double cacheSizeUpperBound) {\n \n     this.esNode = esNode;\n     this.cacheType = cacheType;\n     this.nodeConfigCache = nodeConfigCache;\n     this.cacheSizeUpperBound = cacheSizeUpperBound;\n \n     setStepSize();\n+  }\n \n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n     if (validateAndSetConfigValues()) {\n       long desiredCapacity =\n               increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n       setDesiredCacheMaxSize(desiredCapacity);\n     }\n   }\n \n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase,\n+      int step) {\n+    this(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n+    if (validateAndSetConfigValues()) {\n+      long desiredCapacity =\n+          increase ? currentCacheMaxSizeInBytes + step * getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+      setDesiredCacheMaxSize(desiredCapacity);\n+    }\n+  }\n+\n+  public static ModifyCacheMaxSizeAction newMinimalCapacityAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final long cacheSizeUpperBound) {\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n+    //TODO : set lower bound to 0 for now", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NDA1MA=="}, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDY4Mg==", "bodyText": "Do we really need to levels for describing step size (step * STEP_SIZE)? Now caller must remember that the param passed is number of STEP_SIZEs to modify a queue by. How about we directly take the full STEP_SIZE as input, and use default values if that's not provided.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r472550682", "createdAt": "2020-08-18T23:34:41Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyQueueCapacityAction.java", "diffHunk": "@@ -40,14 +41,23 @@\n   private Map<ResourceEnum, Integer> lowerBound = new HashMap<>();\n   private Map<ResourceEnum, Integer> upperBound = new HashMap<>();\n \n+  public ModifyQueueCapacityAction(NodeKey esNode, ResourceEnum threadPool, int currentCapacity, boolean increase, int step) {\n+    this(esNode, threadPool, currentCapacity);\n+    int desiredCapacity = increase ? currentCapacity + step * STEP_SIZE : currentCapacity - step * STEP_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3Nzk2Mw==", "bodyText": "Pls add a docstring describing the intent of these methods", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473177963", "createdAt": "2020-08-19T16:51:25Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  protected abstract void registerActions();\n+\n+  protected abstract void actionPriorityFilter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3OTI0OA==", "bodyText": "What is the purpose of these objects? It's not clear from the base class alone.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473179248", "createdAt": "2020-08-19T16:53:42Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MDIwMg==", "bodyText": "Do we need to wrap these consts in a class? Can we just keep them as independent constants and move them to the top of the file?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473180202", "createdAt": "2020-08-19T16:55:19Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  //TODO : read consts from rca.conf\n+  private static class LEVEL_ONE_CONST {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MjkwOQ==", "bodyText": "action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND\nThis will be ensured by the action itself, we shouldn't have to check this again at the decider. isActionable() will return false if desiredCap <= lowerBound.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473182909", "createdAt": "2020-08-19T16:58:04Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MzMzOA==", "bodyText": "Same as above", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473183338", "createdAt": "2020-08-19T16:58:29Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA==", "bodyText": "How does this ensure a priority order? Keys in the HashMap are not ordered, right? I also didn't understand the significance of boolean value field", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473185470", "createdAt": "2020-08-19T17:00:29Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4OTQ2MQ==", "bodyText": "Do you also want to add a cacheClearAction for level 3, that clears all ES caches, but runs with a high cool off time to avoid repeated invocations?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473189461", "createdAt": "2020-08-19T17:04:31Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelThreeActionBuilder.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level three bucket\n+ *\n+ * <p>if old gen usage(after full gc) falls into this bucket 90% - 100%, JVM heap is extremely\n+ * contended and can run into OOM at any moment. So action builder will build a group of actions\n+ * to scale down caches to their lower bound in one shot. And for queues we will downsize all\n+ * queues simultaneously with even higher steps", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTM5MQ==", "bodyText": "IIUC, you are using the actionFilter to check which actions to pick based on different levels? e.g. only the actions allowed at that level will be marked true. Is this understanding correct?\nIf so, then why don't we just create only the relevant actions in each level and do away with this action filter.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473199391", "createdAt": "2020-08-19T17:20:26Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA=="}, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDQ4MA==", "bodyText": "Minor: This can be done via a flag in the builder now.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473200480", "createdAt": "2020-08-19T17:22:18Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelThreeActionBuilder.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level three bucket\n+ *\n+ * <p>if old gen usage(after full gc) falls into this bucket 90% - 100%, JVM heap is extremely\n+ * contended and can run into OOM at any moment. So action builder will build a group of actions\n+ * to scale down caches to their lower bound in one shot. And for queues we will downsize all\n+ * queues simultaneously with even higher steps\n+ */\n+public class LevelThreeActionBuilder extends BaseActionBuilder {\n+\n+  private LevelThreeActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelThreeActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelThreeActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  //downsize field data cache to its lower bound in one shot\n+  public void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction.newMinimalCapacityAction(esNode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwNzkwNw==", "bodyText": "I see what you are doing with bucketization here, this is good. We should add a doc string to explain to future readers.\nThe important point being that we cannot just look at {w|s}QueueEWMASize/{w|s}QueueCapacity because if QueueCapacity is already very low, say 200 for write queue, and all of it is constantly full (likely with small queues), we will get %age used as ~100% and keep reducing the same small queue.\nHence we need to look at the full range of sizes available for each queue (lower bound to upper bound), to get a sense of which queue is using more mem. We also don't simply compare absolute values of {w|s}QueueEWMASizes because they inherently have different overheads. Comparing them according to their full range ensures we maintain the same proportion while comparing them.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473207907", "createdAt": "2020-08-19T17:35:26Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder extends BaseActionBuilder {\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelTwoActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueEWMASize == null || searchQueueEWMASize == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction writeQueueAction = queueActionMap.get(ResourceEnum.WRITE_THREADPOOL);\n+    ModifyQueueCapacityAction searchQueueAction = queueActionMap.get(ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueAction != null && searchQueueAction != null) {\n+      int writeQueueSizeBucket = bucketization(writeQueueAction.getLowerBound(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwODM5Nw==", "bodyText": "Add a doc string to explain this formulae, and what step means here", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473208397", "createdAt": "2020-08-19T17:36:17Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder extends BaseActionBuilder {\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelTwoActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwOTAwNA==", "bodyText": "Should this be a separate constant? These are just bands that you are using to divide the range of queue capacity, can this just be local to the bucketization function?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473209004", "createdAt": "2020-08-19T17:37:19Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder extends BaseActionBuilder {\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelTwoActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueEWMASize == null || searchQueueEWMASize == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction writeQueueAction = queueActionMap.get(ResourceEnum.WRITE_THREADPOOL);\n+    ModifyQueueCapacityAction searchQueueAction = queueActionMap.get(ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueAction != null && searchQueueAction != null) {\n+      int writeQueueSizeBucket = bucketization(writeQueueAction.getLowerBound(),\n+          writeQueueAction.getUpperBound(), writeQueueEWMASize, LEVEL_TWO_CONST.QUEUE_SIZE_BUCKET_SIZE);\n+      int searchQueueSizeBucket = bucketization(searchQueueAction.getLowerBound(),\n+          searchQueueAction.getUpperBound(), searchQueueEWMASize, LEVEL_TWO_CONST.QUEUE_SIZE_BUCKET_SIZE);\n+      if (writeQueueSizeBucket > searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+      }\n+      else if (writeQueueSizeBucket < searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.SEARCH_THREADPOOL, true);\n+      }\n+      //tie breaker. default policy prefer writing over indexing\n+      else {\n+        actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+      }\n+    }\n+    else if (writeQueueAction != null) {\n+      actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+    }\n+    else if (searchQueueAction != null) {\n+      actionFilter.put(ResourceEnum.SEARCH_THREADPOOL, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+    addSearchQueueAction();\n+    addWriteQueueAction();\n+  }\n+\n+  /**\n+   * The default priority in this level is\n+   * 1. downsize both caches simultaneously with larger step size.\n+   * 2. Allocate size of each queue into buckets and downsize any queue that has\n+   * higher bucket size.\n+   * 3. if the bucket size of both queues are equal,\n+   * the action priority will act as tie breaker and the default setting\n+   * favors write over search as write is more important in log analytic workload\n+   * 4. The above default action priority can be overridden by customer settings\n+   * but customer's acton priority will only affect step 3 above. Step 1 and 2 will\n+   * be executed regardless of priority action settings\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionPriorityForCache();\n+    actionPriorityForQueue();\n+  }\n+\n+  //TODO : read consts from rca.conf\n+  private static class LEVEL_TWO_CONST {\n+    public static final double FIELD_DATA_CACHE_LOWER_BOUND = 0.02;\n+    public static final double SHARD_REQUEST_CACHE_LOWER_BOUND = 0.01;\n+    public static final int CACHE_ACTION_STEP_COUNT = 2;\n+    public static final int QUEUE_ACTION_STEP_COUNT = 1;\n+    public static final int QUEUE_SIZE_BUCKET_SIZE = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxMDA4MA==", "bodyText": "I agree with Sid, I don't really see a need for the common base class here. We have different strategies for each level that we want to be able to evolve independently. A simple interface might be enough.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473210080", "createdAt": "2020-08-19T17:39:16Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {\n+      return LevelOneActionBuilder.newBuilder(esNode, nodeConfigCache).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxMDk4Nw==", "bodyText": "Do you want to give more observation time for level 2 and level 3? Level 2 & 3 are post GC IHOP - should we factor in some time for gc trying and failing to clear things up?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473210987", "createdAt": "2020-08-19T17:40:48Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "848c6a798af03fa18ad4014df106c8900196f42c", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/848c6a798af03fa18ad4014df106c8900196f42c", "committedDate": "2020-08-19T20:37:45Z", "message": "Merge remote-tracking branch 'origin' into rguo-jvm-decider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ead5c04f0d8ddd6cd1772d8d1beee64b7f59a804", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/ead5c04f0d8ddd6cd1772d8d1beee64b7f59a804", "committedDate": "2020-08-25T23:55:43Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/158721b562b91aa47323b8a62259f8e661e356a1", "committedDate": "2020-08-28T22:28:02Z", "message": "clean up code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4Nzk0OTIz", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-478794923", "createdAt": "2020-08-31T17:14:51Z", "commit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzoxNDo1MVrOHKBaOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzoyMzoyN1rOHKBrHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3MDkwNQ==", "bodyText": "Please review and rebase changes from #402 once merged", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480270905", "createdAt": "2020-08-31T17:14:51Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -144,25 +147,24 @@ public ResourceEnum getCacheType() {\n     private final NodeKey esNode;\n     private final AppContext appContext;\n     private double upperBoundThreshold;\n+    private double lowerBoundThreshold;\n \n     private long stepSizeInBytes;\n     private boolean isIncrease;\n     private boolean canUpdate;\n     private long coolOffPeriodInMillis;\n \n     private Long currentCacheMaxSizeInBytes;\n-    private Long desiredCacheMaxSizeInBytes;\n+    private Double desiredCacheMaxSizeInPercent;\n     private Long heapMaxSizeInBytes;\n \n-    private Builder(\n+    public Builder(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3MTM2MA==", "bodyText": "This should already be present in the Decider base class", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480271360", "createdAt": "2020-08-31T17:15:45Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -87,6 +91,11 @@ public Decision operate() {\n     return decision;\n   }\n \n+  @Override\n+  public void readRcaConf(RcaConf conf) {\n+    deciderConfig = conf.getDeciderConfig();\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3MjMzMA==", "bodyText": "Update with changes in #402", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480272330", "createdAt": "2020-08-31T17:17:48Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.CacheBoundConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelOneActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder {\n+  private final AppContext appContext;\n+  private final LevelOneActionBuilderConfig actionBuilderConfig;\n+  private final CacheBoundConfig cacheBoundConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final AppContext appContext, final\n+  DeciderConfig deciderConfig) {\n+    this.appContext = appContext;\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelOneActionBuilderConfig();\n+    this.cacheBoundConfig = deciderConfig.getCacheBoundConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext, final\n+  DeciderConfig deciderConfig) {\n+    return new LevelOneActionBuilder(esNode, appContext, deciderConfig);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.fieldDataCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.fieldDataCacheUpperBound())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NDQyNg==", "bodyText": "I see. But from current changes, I don't see any action being added to actionFilter as false, so it seems like we just add actions to the actionFilter map as true, and pick all of them in build for each level*ActionBuilder. What am i missing?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480274426", "createdAt": "2020-08-31T17:21:52Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA=="}, "originalCommit": {"oid": "3ffecf220beb933b0843abee685bec3002122e23"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NTIzMA==", "bodyText": "Let's use changes in #402 ?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480275230", "createdAt": "2020-08-31T17:23:27Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/CacheBoundConfig.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class CacheBoundConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4OTgwNDA3", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-478980407", "createdAt": "2020-08-31T21:52:00Z", "commit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo1MjowMFrOHKKe0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTo1MjowMFrOHKKe0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxOTUzOA==", "bodyText": "typo: write", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480419538", "createdAt": "2020-08-31T21:52:00Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.CacheBoundConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.ThreadPoolConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.WorkLoadTypeConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelTwoActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final AppContext appContext;\n+  private final LevelTwoActionBuilderConfig actionBuilderConfig;\n+  private final WorkLoadTypeConfig workLoadTypeConfig;\n+  private final CacheBoundConfig cacheBoundConfig;\n+  private final ThreadPoolConfig threadPoolConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final AppContext appContext,\n+      final DeciderConfig deciderConfig) {\n+    this.appContext = appContext;\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelTwoActionBuilderConfig();\n+    this.workLoadTypeConfig = deciderConfig.getWorkLoadTypeConfig();\n+    this.cacheBoundConfig = deciderConfig.getCacheBoundConfig();\n+    this.threadPoolConfig = deciderConfig.getThreadPoolConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext,\n+      final DeciderConfig deciderConfig) {\n+    return new LevelTwoActionBuilder(esNode, appContext, deciderConfig);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    //TODO : increase step size\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.fieldDataCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.fieldDataCacheUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    //TODO : increase step size\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.SHARD_REQUEST_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.shardRequestCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.shardRequestCacheUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.WRITE_THREADPOOL, appContext)\n+        .increase(false)\n+        .lowerBound(threadPoolConfig.writeQueueCapacityLowerBound())\n+        .upperBound(threadPoolConfig.writeQueueCapacityUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.SEARCH_THREADPOOL, appContext)\n+        .increase(false)\n+        .lowerBound(threadPoolConfig.searchQueueCapacityLowerBound())\n+        .upperBound(threadPoolConfig.searchQueueCapacityUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * This function divide the range {lower bound - upper bound } of search/wrire queue into", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64d3f72f3eb8c8b5829d0e935548cc7a17d4be31", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/64d3f72f3eb8c8b5829d0e935548cc7a17d4be31", "committedDate": "2020-09-01T21:20:25Z", "message": "Merge remote-tracking branch 'origin' into rguo-jvm-decider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTgwMjYw", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-480180260", "createdAt": "2020-09-01T23:19:48Z", "commit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoxOTo0OFrOHLLeCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoxOTo0OFrOHLLeCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDI5Ng==", "bodyText": "Let's move these to CacheActionConfig? we can call them soft-upper/lower-bound.", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r481484296", "createdAt": "2020-09-01T23:19:48Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/jvm/LevelOneActionBuilderConfig.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class LevelOneActionBuilderConfig {\n+  public static final double DEFAULT_FIELD_DATA_CACHE_LOWER_BOUND = 0.1;\n+  public static final double DEFAULT_SHARD_REQUEST_CACHE_LOWER_BOUND = 0.02;\n+  private static String FIELD_DATA_CACHE_LOWER_BOUND_CONFIG_NAME = \"fielddata-cache-lower-bound\";\n+  private static String SHARD_REQUEST_CACHE_LOWER_BOUND_CONFIG_NAME = \"shard-request-cache-lower-bound\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTgwODk0", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-480180894", "createdAt": "2020-09-01T23:21:29Z", "commit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoyMToyOVrOHLLgVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoyMToyOVrOHLLgVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDg4NA==", "bodyText": "Pls see if you really need a lower-bound, level-1-bound, level-2-bound, upper-bound? Can we do away with level-2 bound?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r481484884", "createdAt": "2020-09-01T23:21:29Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/jvm/LevelTwoActionBuilderConfig.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class LevelTwoActionBuilderConfig {\n+  public static final double DEFAULT_FIELD_DATA_CACHE_LOWER_BOUND = 0.02;\n+  public static final double DEFAULT_SHARD_REQUEST_CACHE_LOWER_BOUND = 0.01;\n+  public static final int DEFAULT_CACHE_ACTION_STEP_COUNT = 2;\n+  public static final int DEFAULT_QUEUE_ACTION_STEP_COUNT = 1;\n+  public static final int DEFAULT_QUEUE_BUCKET_SIZE = 10;\n+  private static String FIELD_DATA_CACHE_LOWER_BOUND_CONFIG_NAME = \"fielddata-cache-lower-bound\";\n+  private static String SHARD_REQUEST_CACHE_LOWER_BOUND_CONFIG_NAME = \"shard-request-cache-lower-bound\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTgxMTE1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-480181115", "createdAt": "2020-09-01T23:22:01Z", "commit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoyMjowMVrOHLLhHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMzoyMjowMVrOHLLhHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTA4Ng==", "bodyText": "Can these be merged with queue/cache action configs?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r481485086", "createdAt": "2020-09-01T23:22:01Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/jvm/LevelTwoActionBuilderConfig.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class LevelTwoActionBuilderConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9c6ead72d1fc3b67ba0086aaa0290f8b6dc0198", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/e9c6ead72d1fc3b67ba0086aaa0290f8b6dc0198", "committedDate": "2020-09-02T01:16:49Z", "message": "rebase to the latest master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/38366cd4d5266aa1de5e535d27f8134a97d260b8", "committedDate": "2020-09-03T01:34:48Z", "message": "Address more PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTE1MzA4", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-481515308", "createdAt": "2020-09-03T06:03:13Z", "commit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNjowMzoxM1rOHMXGDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNjoxNzoyOVrOHMXZmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyMzM0MA==", "bodyText": "Nice!", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482723340", "createdAt": "2020-09-03T06:03:13Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/configs/CacheActionConfig.java", "diffHunk": "@@ -64,9 +68,24 @@ public CacheActionConfig(RcaConf conf) {\n     cacheSettingsConfig = new NestedConfig(\"cache-settings\", actionConfig);\n     fieldDataCacheConfig = new FieldDataCacheConfig(cacheSettingsConfig);\n     shardRequestCacheConfig = new ShardRequestCacheConfig(cacheSettingsConfig);\n+    totalStepCount = new Config<>(TOTAL_STEP_COUNT_CONFIG_NAME, cacheSettingsConfig.getValue(),\n+        DEFAULT_TOTAL_STEP_COUNT, (s) -> (s > 0), Integer.class);\n     createThresholdConfigMap();\n   }\n \n+  public int getTotalStepCount() {\n+    return totalStepCount.getValue();\n+  }\n+\n+  /**\n+   * this function calculate the size of a single step given the range {lower bound - upper bound}\n+   * and number of steps\n+   */\n+  public double getStepSize(ResourceEnum cacheType) {\n+    ThresholdConfig<Double> threshold = getThresholdConfig(cacheType);\n+    return (threshold.upperBound() - threshold.lowerBound()) / (double) getTotalStepCount();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNTY5OA==", "bodyText": "@rguo-aws pls fix before merging", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482725698", "createdAt": "2020-09-03T06:09:58Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.CacheBoundConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.ThreadPoolConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.WorkLoadTypeConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelTwoActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final AppContext appContext;\n+  private final LevelTwoActionBuilderConfig actionBuilderConfig;\n+  private final WorkLoadTypeConfig workLoadTypeConfig;\n+  private final CacheBoundConfig cacheBoundConfig;\n+  private final ThreadPoolConfig threadPoolConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final AppContext appContext,\n+      final DeciderConfig deciderConfig) {\n+    this.appContext = appContext;\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelTwoActionBuilderConfig();\n+    this.workLoadTypeConfig = deciderConfig.getWorkLoadTypeConfig();\n+    this.cacheBoundConfig = deciderConfig.getCacheBoundConfig();\n+    this.threadPoolConfig = deciderConfig.getThreadPoolConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext,\n+      final DeciderConfig deciderConfig) {\n+    return new LevelTwoActionBuilder(esNode, appContext, deciderConfig);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    //TODO : increase step size\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.fieldDataCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.fieldDataCacheUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    //TODO : increase step size\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.SHARD_REQUEST_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.shardRequestCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.shardRequestCacheUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.WRITE_THREADPOOL, appContext)\n+        .increase(false)\n+        .lowerBound(threadPoolConfig.writeQueueCapacityLowerBound())\n+        .upperBound(threadPoolConfig.writeQueueCapacityUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.SEARCH_THREADPOOL, appContext)\n+        .increase(false)\n+        .lowerBound(threadPoolConfig.searchQueueCapacityLowerBound())\n+        .upperBound(threadPoolConfig.searchQueueCapacityUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * This function divide the range {lower bound - upper bound } of search/wrire queue into", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxOTUzOA=="}, "originalCommit": {"oid": "158721b562b91aa47323b8a62259f8e661e356a1"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNjU3Mg==", "bodyText": "if ingest is preferable, we should downsize search queue, no?", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482726572", "createdAt": "2020-09-03T06:12:24Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.configs.CacheActionConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.configs.QueueActionConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.configs.ThresholdConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.WorkLoadTypeConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelTwoActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.OldGenDecisionPolicyConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final AppContext appContext;\n+  private final RcaConf rcaConf;\n+  private final OldGenDecisionPolicyConfig oldGenDecisionPolicyConfig;\n+  private final LevelTwoActionBuilderConfig actionBuilderConfig;\n+  private final WorkLoadTypeConfig workLoadTypeConfig;\n+  private final CacheActionConfig cacheActionConfig;\n+  private final QueueActionConfig queueActionConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final AppContext appContext,\n+      final RcaConf rcaConf) {\n+    this.appContext = appContext;\n+    this.rcaConf = rcaConf;\n+    DeciderConfig deciderConfig = rcaConf.getDeciderConfig();\n+    this.oldGenDecisionPolicyConfig = rcaConf.getDeciderConfig().getOldGenDecisionPolicyConfig();\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelTwoActionBuilderConfig();\n+    this.workLoadTypeConfig = deciderConfig.getWorkLoadTypeConfig();\n+    this.cacheActionConfig = rcaConf.getCacheActionConfig();\n+    this.queueActionConfig = rcaConf.getQueueActionConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext,\n+      final RcaConf rcaConf) {\n+    return new LevelTwoActionBuilder(esNode, appContext, rcaConf);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    double stepSizeInPercent = cacheActionConfig.getStepSize(ResourceEnum.FIELD_DATA_CACHE);\n+\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext, rcaConf)\n+        .increase(false)\n+        .stepSizeInPercent(stepSizeInPercent * actionBuilderConfig.fieldDataCacheStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    double stepSizeInPercent = cacheActionConfig.getStepSize(ResourceEnum.SHARD_REQUEST_CACHE);\n+\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.SHARD_REQUEST_CACHE, appContext, rcaConf)\n+        .increase(false)\n+        .stepSizeInPercent(stepSizeInPercent * actionBuilderConfig.shardRequestCacheStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    int stepSize = queueActionConfig.getStepSize(ResourceEnum.WRITE_THREADPOOL);\n+\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.WRITE_THREADPOOL, appContext, rcaConf)\n+        .increase(false)\n+        .stepSize(stepSize * actionBuilderConfig.writeQueueStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    int stepSize = queueActionConfig.getStepSize(ResourceEnum.SEARCH_THREADPOOL);\n+\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.SEARCH_THREADPOOL, appContext, rcaConf)\n+        .increase(false)\n+        .stepSize(stepSize * actionBuilderConfig.searchQueueStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * This function divide the range {lower bound - upper bound } of search/wrire queue into\n+   * buckets. And allocate the val into its corresponding bucket. The value here refers to the\n+   * EWMA size of search/write queue. step here is calculated as {range of queue} / {num of buckets}\n+   * The queue's lower/upper bound can be configured in rca.conf\n+   */\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    NodeConfigCache nodeConfigCache = appContext.getNodeConfigCache();\n+    Integer writeQueueCapacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueCapacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueCapacity == null || searchQueueCapacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction writeQueueAction = queueActionMap.get(ResourceEnum.WRITE_THREADPOOL);\n+    ModifyQueueCapacityAction searchQueueAction = queueActionMap.get(ResourceEnum.SEARCH_THREADPOOL);\n+    ThresholdConfig<Integer> writeQueueConfig = queueActionConfig.getThresholdConfig(ResourceEnum.WRITE_THREADPOOL);\n+    ThresholdConfig<Integer> searchQueueConfig = queueActionConfig.getThresholdConfig(ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueAction != null && searchQueueAction != null) {\n+      int writeQueueSizeBucket = bucketization(\n+          writeQueueConfig.lowerBound(),\n+          writeQueueConfig.upperBound(),\n+          writeQueueCapacity,\n+          oldGenDecisionPolicyConfig.queueBucketSize());\n+      int searchQueueSizeBucket = bucketization(\n+          searchQueueConfig.lowerBound(),\n+          searchQueueConfig.upperBound(),\n+          searchQueueCapacity,\n+          oldGenDecisionPolicyConfig.queueBucketSize());\n+      if (writeQueueSizeBucket > searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+      }\n+      else if (writeQueueSizeBucket < searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.SEARCH_THREADPOOL, true);\n+      }\n+      // tie breaker\n+      else {\n+        if (workLoadTypeConfig.preferIngestOverSearch()) {\n+          actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNzIyOA==", "bodyText": "Does this work? I was having trouble casting with generics", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482727228", "createdAt": "2020-09-03T06:14:21Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/CachePriorityOrderConfig.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Config;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.NestedConfig;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * \"cache-type\": {\n+ *    \"priority-order\": [\"fielddata-cache\", \"shard-request-cache\"]\n+ * }\n+ */\n+public class CachePriorityOrderConfig {\n+  private static final String PRIORITY_ORDER_CONFIG_NAME = \"priority-order\";\n+  private static String FIELDDATA_CACHE = \"fielddata-cache\";\n+  private static String SHARD_REQUEST_CACHE = \"shard-request-cache\";\n+  public static final List<String> DEFAULT_PRIORITY_ORDER = Collections.unmodifiableList(\n+      Arrays.asList(FIELDDATA_CACHE, SHARD_REQUEST_CACHE));\n+  private Config<List<String>> priorityOrder;\n+\n+  public CachePriorityOrderConfig(NestedConfig configs) {\n+    priorityOrder = new Config(PRIORITY_ORDER_CONFIG_NAME, configs.getValue(),\n+        DEFAULT_PRIORITY_ORDER, List.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyODM0NA==", "bodyText": "Since there is only search and ingest (2 values), we can make this simpler by renaming the config. Instead of taking a list, we can do things like:\n{ \"decider-config-settings\": {\n    \"prefer-ingest-over-search\": true\n    }\n}", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482728344", "createdAt": "2020-09-03T06:17:29Z", "author": {"login": "vigyasharma"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/WorkLoadTypeConfig.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Config;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.NestedConfig;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+/**\n+ * \"workload-type\": {\n+ *   \"priority-order\": [\"ingest\", \"search\"]\n+ * }\n+ */\n+public class WorkLoadTypeConfig {\n+\n+  private static final String PRIORITY_ORDER_CONFIG_NAME = \"priority-order\";\n+  private static String INGEST = \"ingest\";\n+  private static String SEARCH = \"search\";\n+  public static final List<String> DEFAULT_PRIORITY_ORDER = Collections.unmodifiableList(\n+      Arrays.asList(INGEST, SEARCH));\n+  private Config<List<String>> priorityOrder;\n+  private Predicate<List<String>> listValidator;\n+\n+  public WorkLoadTypeConfig(NestedConfig configs) {\n+    listValidator = (list) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7ef3396d129aa3d99ae926eec4e87507c15ce72", "author": {"user": {"login": "rguo-aws", "name": "Ruizhen Guo"}}, "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d7ef3396d129aa3d99ae926eec4e87507c15ce72", "committedDate": "2020-09-03T19:34:22Z", "message": "Address more comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTY3OTA1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-482167905", "createdAt": "2020-09-03T20:13:37Z", "commit": {"oid": "d7ef3396d129aa3d99ae926eec4e87507c15ce72"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoxMzozN1rOHM15cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoxMzozN1rOHM15cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyODAxNw==", "bodyText": "+1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483228017", "createdAt": "2020-09-03T20:13:37Z", "author": {"login": "sidheart"}, "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/configs/CacheActionConfig.java", "diffHunk": "@@ -64,9 +68,24 @@ public CacheActionConfig(RcaConf conf) {\n     cacheSettingsConfig = new NestedConfig(\"cache-settings\", actionConfig);\n     fieldDataCacheConfig = new FieldDataCacheConfig(cacheSettingsConfig);\n     shardRequestCacheConfig = new ShardRequestCacheConfig(cacheSettingsConfig);\n+    totalStepCount = new Config<>(TOTAL_STEP_COUNT_CONFIG_NAME, cacheSettingsConfig.getValue(),\n+        DEFAULT_TOTAL_STEP_COUNT, (s) -> (s > 0), Integer.class);\n     createThresholdConfigMap();\n   }\n \n+  public int getTotalStepCount() {\n+    return totalStepCount.getValue();\n+  }\n+\n+  /**\n+   * this function calculate the size of a single step given the range {lower bound - upper bound}\n+   * and number of steps\n+   */\n+  public double getStepSize(ResourceEnum cacheType) {\n+    ThresholdConfig<Double> threshold = getThresholdConfig(cacheType);\n+    return (threshold.upperBound() - threshold.lowerBound()) / (double) getTotalStepCount();\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyMzM0MA=="}, "originalCommit": {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMjE2MTI1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#pullrequestreview-482216125", "createdAt": "2020-09-03T21:29:27Z", "commit": {"oid": "d7ef3396d129aa3d99ae926eec4e87507c15ce72"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 845, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}