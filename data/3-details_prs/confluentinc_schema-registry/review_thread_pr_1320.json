{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyOTAxMzU2", "number": 1320, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MToyMFrODe-YFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MToyMFrODe-YFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA1ODQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MToyMFrOFoaezQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyMToyNFrOFobTnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTIyOQ==", "bodyText": "I think it might be a bit nicer to have another overload for the default format: 'text' (in addition to empty or null).\nIn the clients, I feel like I want an enum for specifying this: SchemaFormat.Text/Serialized. Less flexible structure than a string, but I don't feel it'll ever be too limiting?", "url": "https://github.com/confluentinc/schema-registry/pull/1320#discussion_r377921229", "createdAt": "2020-02-11T21:51:20Z", "author": {"login": "mhowlett"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -866,13 +877,19 @@ public SchemaString get(int id, boolean fetchMaxId) throws SchemaRegistryExcepti\n     }\n     SchemaString schemaString = new SchemaString();\n     schemaString.setSchemaType(schema.getSchemaType());\n-    schemaString.setSchemaString(schema.getSchema());\n-    List<SchemaReference> refs = schema.getReferences();\n-    if (refs != null) {\n-      schemaString.setReferences(refs.stream()\n-          .map(ref -> new io.confluent.kafka.schemaregistry.client.rest.entities.SchemaReference(\n-              ref.getName(), ref.getSubject(), ref.getVersion()))\n-          .collect(Collectors.toList()));\n+    List<io.confluent.kafka.schemaregistry.client.rest.entities.SchemaReference> refs =\n+        schema.getReferences() != null\n+        ? schema.getReferences().stream()\n+            .map(ref -> new io.confluent.kafka.schemaregistry.client.rest.entities.SchemaReference(\n+                ref.getName(), ref.getSubject(), ref.getVersion()))\n+          .collect(Collectors.toList())\n+        : null;\n+    schemaString.setReferences(refs);\n+    if (format != null && !format.trim().isEmpty()) {\n+      ParsedSchema parsedSchema = parseSchema(schema.getSchemaType(), schema.getSchema(), refs);\n+      schemaString.setSchemaString(parsedSchema.formattedString(format));\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8bc69230c00d49aa09ee86d9c116342bd2fec20"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDc0OA==", "bodyText": "I was also thinking of possibly having a pretty-print option as well, in the future.", "url": "https://github.com/confluentinc/schema-registry/pull/1320#discussion_r377934748", "createdAt": "2020-02-11T22:21:24Z", "author": {"login": "rayokota"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -866,13 +877,19 @@ public SchemaString get(int id, boolean fetchMaxId) throws SchemaRegistryExcepti\n     }\n     SchemaString schemaString = new SchemaString();\n     schemaString.setSchemaType(schema.getSchemaType());\n-    schemaString.setSchemaString(schema.getSchema());\n-    List<SchemaReference> refs = schema.getReferences();\n-    if (refs != null) {\n-      schemaString.setReferences(refs.stream()\n-          .map(ref -> new io.confluent.kafka.schemaregistry.client.rest.entities.SchemaReference(\n-              ref.getName(), ref.getSubject(), ref.getVersion()))\n-          .collect(Collectors.toList()));\n+    List<io.confluent.kafka.schemaregistry.client.rest.entities.SchemaReference> refs =\n+        schema.getReferences() != null\n+        ? schema.getReferences().stream()\n+            .map(ref -> new io.confluent.kafka.schemaregistry.client.rest.entities.SchemaReference(\n+                ref.getName(), ref.getSubject(), ref.getVersion()))\n+          .collect(Collectors.toList())\n+        : null;\n+    schemaString.setReferences(refs);\n+    if (format != null && !format.trim().isEmpty()) {\n+      ParsedSchema parsedSchema = parseSchema(schema.getSchemaType(), schema.getSchema(), refs);\n+      schemaString.setSchemaString(parsedSchema.formattedString(format));\n+    } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTIyOQ=="}, "originalCommit": {"oid": "b8bc69230c00d49aa09ee86d9c116342bd2fec20"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1943, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}