{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3OTYwMjk1", "number": 1350, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToxNDozOVrODicezA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDowNzoyNVrODidghw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDQ0ODEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToxNDozOVrOFtsjGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOTozMDo0MVrOFttDTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MDEyMQ==", "bodyText": "Here and below: we already throw, why the log message ?", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383460121", "createdAt": "2020-02-24T19:14:39Z", "author": {"login": "dragosvictor"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -796,14 +797,18 @@ private void forwardSetModeRequestToMaster(\n   }\n \n   private void canonicalizeSchema(Schema schema) throws InvalidSchemaException {\n-    if (schema == null || schema.getSchema().trim().isEmpty()) {\n+    if (schema == null\n+        || schema.getSchema() == null\n+        || schema.getSchema().trim().isEmpty()) {\n+      log.error(\"Empty schema\");\n       throw new InvalidSchemaException(\"Empty schema\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2ODM2NA==", "bodyText": "Just to make sure it appears in the log.", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383468364", "createdAt": "2020-02-24T19:30:41Z", "author": {"login": "rayokota"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -796,14 +797,18 @@ private void forwardSetModeRequestToMaster(\n   }\n \n   private void canonicalizeSchema(Schema schema) throws InvalidSchemaException {\n-    if (schema == null || schema.getSchema().trim().isEmpty()) {\n+    if (schema == null\n+        || schema.getSchema() == null\n+        || schema.getSchema().trim().isEmpty()) {\n+      log.error(\"Empty schema\");\n       throw new InvalidSchemaException(\"Empty schema\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MDEyMQ=="}, "originalCommit": {"oid": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDQ2MjM4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/confluent/kafka/schemaregistry/rest/RestApiTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToxOToyMVrOFtssSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOTozMDozOVrOFttDQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MjQ3Mg==", "bodyText": "Do we know for sure the list has the same order as returned by the underlying map ?", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383462472", "createdAt": "2020-02-24T19:19:21Z", "author": {"login": "dragosvictor"}, "path": "core/src/test/java/io/confluent/kafka/schemaregistry/rest/RestApiTest.java", "diffHunk": "@@ -590,6 +591,21 @@ public void testGetSubjectsAssociatedWithNotFoundSchemaId() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testGetVersionsAssociatedWithSchemaId() throws Exception {\n+    String subject1 = \"testTopic1\";\n+    String subject2 = \"testTopic2\";\n+\n+    String schema = TestUtils.getRandomCanonicalAvroString(1).get(0);\n+    TestUtils.registerAndVerifySchema(restApp.restClient, schema, 1, subject1);\n+    TestUtils.registerAndVerifySchema(restApp.restClient, schema, 1, subject2);\n+\n+    List<SubjectVersion> associatedSubjects = restApp.restClient.getAllVersionsById(1);\n+    assertEquals(associatedSubjects.size(), 2);\n+    assertEquals(Arrays.asList(new SubjectVersion(subject1, 1), new SubjectVersion(subject2, 1)),\n+        associatedSubjects);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2ODM1Mg==", "bodyText": "Good point, I'll fix it", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383468352", "createdAt": "2020-02-24T19:30:39Z", "author": {"login": "rayokota"}, "path": "core/src/test/java/io/confluent/kafka/schemaregistry/rest/RestApiTest.java", "diffHunk": "@@ -590,6 +591,21 @@ public void testGetSubjectsAssociatedWithNotFoundSchemaId() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testGetVersionsAssociatedWithSchemaId() throws Exception {\n+    String subject1 = \"testTopic1\";\n+    String subject2 = \"testTopic2\";\n+\n+    String schema = TestUtils.getRandomCanonicalAvroString(1).get(0);\n+    TestUtils.registerAndVerifySchema(restApp.restClient, schema, 1, subject1);\n+    TestUtils.registerAndVerifySchema(restApp.restClient, schema, 1, subject2);\n+\n+    List<SubjectVersion> associatedSubjects = restApp.restClient.getAllVersionsById(1);\n+    assertEquals(associatedSubjects.size(), 2);\n+    assertEquals(Arrays.asList(new SubjectVersion(subject1, 1), new SubjectVersion(subject2, 1)),\n+        associatedSubjects);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MjQ3Mg=="}, "originalCommit": {"oid": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDYwOTY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDowNDo1N1rOFtuHjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDowNDo1N1rOFtuHjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NTgzOQ==", "bodyText": "Should we have a copy method for Schema?", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383485839", "createdAt": "2020-02-24T20:04:57Z", "author": {"login": "tuvtran"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -970,6 +976,38 @@ public SchemaString get(\n     )).allSubjects();\n   }\n \n+  public List<SubjectVersion> listVersionsForId(int id) throws SchemaRegistryException {\n+    SchemaValue schema = null;\n+    try {\n+      SchemaKey subjectVersionKey = lookupCache.schemaKeyById(id);\n+      if (subjectVersionKey == null) {\n+        return null;\n+      }\n+      schema = (SchemaValue) kafkaStore.get(subjectVersionKey);\n+      if (schema == null) {\n+        return null;\n+      }\n+    } catch (StoreException e) {\n+      throw new SchemaRegistryStoreException(\"Error while retrieving schema with id \"\n+                                              + id + \" from the backend Kafka store\", e);\n+    }\n+\n+    return lookupCache.schemaIdAndSubjects(new Schema(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5db3b83272ab72d40fee33934ab39d3953e2c6f"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDYxNjM5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDowNzoyNVrOFtuMBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMDoxODozOFrOFtufkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njk4Mg==", "bodyText": "Since the function only checks compatibility should we avoid adding side effect to newSchema?", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383486982", "createdAt": "2020-02-24T20:07:25Z", "author": {"login": "tuvtran"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1155,7 +1193,11 @@ public boolean isCompatible(String subject,\n       prevParsedSchemas.add(prevParsedSchema);\n     }\n \n-    return parseSchema(newSchema).isCompatible(compatibility, prevParsedSchemas);\n+    ParsedSchema parsedSchema = parseSchema(newSchema);\n+    boolean isCompatible = parsedSchema.isCompatible(compatibility, prevParsedSchemas);\n+    // Allow schema providers to modify the schema during compatibility checks\n+    newSchema.setSchema(parsedSchema.canonicalString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5db3b83272ab72d40fee33934ab39d3953e2c6f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MDM0NA==", "bodyText": "I'm allowing for use cases where the new schema can be merged with the older schema during the compat check.  I added this JavaDoc elsewhere in the PR:\nCustom providers may choose to modify this schema during this check, to ensure that it is compatible with the specified schema.", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383490344", "createdAt": "2020-02-24T20:15:00Z", "author": {"login": "rayokota"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1155,7 +1193,11 @@ public boolean isCompatible(String subject,\n       prevParsedSchemas.add(prevParsedSchema);\n     }\n \n-    return parseSchema(newSchema).isCompatible(compatibility, prevParsedSchemas);\n+    ParsedSchema parsedSchema = parseSchema(newSchema);\n+    boolean isCompatible = parsedSchema.isCompatible(compatibility, prevParsedSchemas);\n+    // Allow schema providers to modify the schema during compatibility checks\n+    newSchema.setSchema(parsedSchema.canonicalString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njk4Mg=="}, "originalCommit": {"oid": "c5db3b83272ab72d40fee33934ab39d3953e2c6f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MTk4NQ==", "bodyText": "Gotcha. Thanks!", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383491985", "createdAt": "2020-02-24T20:18:38Z", "author": {"login": "tuvtran"}, "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1155,7 +1193,11 @@ public boolean isCompatible(String subject,\n       prevParsedSchemas.add(prevParsedSchema);\n     }\n \n-    return parseSchema(newSchema).isCompatible(compatibility, prevParsedSchemas);\n+    ParsedSchema parsedSchema = parseSchema(newSchema);\n+    boolean isCompatible = parsedSchema.isCompatible(compatibility, prevParsedSchemas);\n+    // Allow schema providers to modify the schema during compatibility checks\n+    newSchema.setSchema(parsedSchema.canonicalString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njk4Mg=="}, "originalCommit": {"oid": "c5db3b83272ab72d40fee33934ab39d3953e2c6f"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1951, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}