{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNDY4MDAz", "number": 1318, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNzoyNzoxNFrODeGFhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNzoyNzoxNFrODeGFhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODgzNTkxOnYy", "diffSide": "RIGHT", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNzoyNzoxNFrOFnEhgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODoyNjowMlrOFnGFCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMjg5OQ==", "bodyText": "Is this ever accessed concurrently ? If so, we should protect the 'schemaObj' field when accessing it. This was likely not a problem before since the field was set in the constructor.", "url": "https://github.com/confluentinc/schema-registry/pull/1318#discussion_r376512899", "createdAt": "2020-02-07T17:27:14Z", "author": {"login": "dragosvictor"}, "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -66,87 +69,116 @@\n \n   private transient String canonicalString;\n \n-  private final ObjectMapper objectMapper = Jackson.newObjectMapper();\n+  private static final ObjectMapper objectMapper = Jackson.newObjectMapper();\n \n   @VisibleForTesting\n   public JsonSchema(JsonNode jsonNode) throws JsonProcessingException {\n-    this(new ObjectMapper().writeValueAsString(jsonNode));\n+    this(jsonNode, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(String schemaString) {\n     this(schemaString, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(\n-      String schemaString,\n+      JsonNode jsonNode,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       Integer version\n   ) {\n-    SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n-    if (resolvedReferences != null) {\n-      try {\n-        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n-          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n-        }\n-      } catch (URISyntaxException e) {\n-        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n-      }\n-    }\n-    builder.schemaJson(new JSONObject(schemaString));\n-    SchemaLoader loader = builder.build();\n-    this.schemaObj = loader.load().build();\n+    this.jsonNode = jsonNode;\n     this.version = version;\n     this.references = Collections.unmodifiableList(references);\n     this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n   }\n \n+  public JsonSchema(\n+      String schemaString,\n+      List<SchemaReference> references,\n+      Map<String, String> resolvedReferences,\n+      Integer version\n+  ) {\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaString);\n+      this.version = version;\n+      this.references = Collections.unmodifiableList(references);\n+      this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaString, e);\n+    }\n+  }\n+\n   public JsonSchema(Schema schemaObj) {\n     this(schemaObj, null);\n   }\n \n   public JsonSchema(Schema schemaObj, Integer version) {\n-    this.schemaObj = schemaObj;\n-    this.version = version;\n-    this.references = Collections.emptyList();\n-    this.resolvedReferences = Collections.emptyMap();\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaObj.toString());\n+      this.schemaObj = schemaObj;\n+      this.version = version;\n+      this.references = Collections.emptyList();\n+      this.resolvedReferences = Collections.emptyMap();\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaObj.toString(), e);\n+    }\n   }\n \n   private JsonSchema(\n+      JsonNode jsonNode,\n       Schema schemaObj,\n       Integer version,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       String canonicalString\n   ) {\n+    this.jsonNode = jsonNode;\n     this.schemaObj = schemaObj;\n     this.version = version;\n     this.references = references;\n     this.resolvedReferences = resolvedReferences;\n     this.canonicalString = canonicalString;\n   }\n \n-  public static JsonSchema copy(JsonSchema schema) {\n+  public JsonSchema copy() {\n     return new JsonSchema(\n-        schema.schemaObj,\n-        schema.version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.jsonNode,\n+        this.schemaObj,\n+        this.version,\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n-  public static JsonSchema copy(JsonSchema schema, Integer version) {\n+  public JsonSchema copy(Integer version) {\n     return new JsonSchema(\n-        schema.schemaObj,\n+        this.jsonNode,\n+        this.schemaObj,\n         version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n   public Schema rawSchema() {\n+    if (schemaObj == null) {\n+      try {\n+        SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n+        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n+          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n+        }\n+        JSONObject jsonObject = objectMapper.treeToValue((jsonNode), JSONObject.class);\n+        builder.schemaJson(jsonObject);\n+        SchemaLoader loader = builder.build();\n+        schemaObj = loader.load().build();\n+      } catch (URISyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n+      } catch (IOException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON\", e);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4aa27589ac389d26628e3440fe0b952da9330853"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUyNzg0MQ==", "bodyText": "This class is not meant to be accessed concurrently.", "url": "https://github.com/confluentinc/schema-registry/pull/1318#discussion_r376527841", "createdAt": "2020-02-07T18:02:25Z", "author": {"login": "rayokota"}, "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -66,87 +69,116 @@\n \n   private transient String canonicalString;\n \n-  private final ObjectMapper objectMapper = Jackson.newObjectMapper();\n+  private static final ObjectMapper objectMapper = Jackson.newObjectMapper();\n \n   @VisibleForTesting\n   public JsonSchema(JsonNode jsonNode) throws JsonProcessingException {\n-    this(new ObjectMapper().writeValueAsString(jsonNode));\n+    this(jsonNode, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(String schemaString) {\n     this(schemaString, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(\n-      String schemaString,\n+      JsonNode jsonNode,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       Integer version\n   ) {\n-    SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n-    if (resolvedReferences != null) {\n-      try {\n-        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n-          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n-        }\n-      } catch (URISyntaxException e) {\n-        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n-      }\n-    }\n-    builder.schemaJson(new JSONObject(schemaString));\n-    SchemaLoader loader = builder.build();\n-    this.schemaObj = loader.load().build();\n+    this.jsonNode = jsonNode;\n     this.version = version;\n     this.references = Collections.unmodifiableList(references);\n     this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n   }\n \n+  public JsonSchema(\n+      String schemaString,\n+      List<SchemaReference> references,\n+      Map<String, String> resolvedReferences,\n+      Integer version\n+  ) {\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaString);\n+      this.version = version;\n+      this.references = Collections.unmodifiableList(references);\n+      this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaString, e);\n+    }\n+  }\n+\n   public JsonSchema(Schema schemaObj) {\n     this(schemaObj, null);\n   }\n \n   public JsonSchema(Schema schemaObj, Integer version) {\n-    this.schemaObj = schemaObj;\n-    this.version = version;\n-    this.references = Collections.emptyList();\n-    this.resolvedReferences = Collections.emptyMap();\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaObj.toString());\n+      this.schemaObj = schemaObj;\n+      this.version = version;\n+      this.references = Collections.emptyList();\n+      this.resolvedReferences = Collections.emptyMap();\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaObj.toString(), e);\n+    }\n   }\n \n   private JsonSchema(\n+      JsonNode jsonNode,\n       Schema schemaObj,\n       Integer version,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       String canonicalString\n   ) {\n+    this.jsonNode = jsonNode;\n     this.schemaObj = schemaObj;\n     this.version = version;\n     this.references = references;\n     this.resolvedReferences = resolvedReferences;\n     this.canonicalString = canonicalString;\n   }\n \n-  public static JsonSchema copy(JsonSchema schema) {\n+  public JsonSchema copy() {\n     return new JsonSchema(\n-        schema.schemaObj,\n-        schema.version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.jsonNode,\n+        this.schemaObj,\n+        this.version,\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n-  public static JsonSchema copy(JsonSchema schema, Integer version) {\n+  public JsonSchema copy(Integer version) {\n     return new JsonSchema(\n-        schema.schemaObj,\n+        this.jsonNode,\n+        this.schemaObj,\n         version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n   public Schema rawSchema() {\n+    if (schemaObj == null) {\n+      try {\n+        SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n+        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n+          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n+        }\n+        JSONObject jsonObject = objectMapper.treeToValue((jsonNode), JSONObject.class);\n+        builder.schemaJson(jsonObject);\n+        SchemaLoader loader = builder.build();\n+        schemaObj = loader.load().build();\n+      } catch (URISyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n+      } catch (IOException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON\", e);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMjg5OQ=="}, "originalCommit": {"oid": "4aa27589ac389d26628e3440fe0b952da9330853"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzODM3Nw==", "bodyText": "Got it !", "url": "https://github.com/confluentinc/schema-registry/pull/1318#discussion_r376538377", "createdAt": "2020-02-07T18:26:02Z", "author": {"login": "dragosvictor"}, "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -66,87 +69,116 @@\n \n   private transient String canonicalString;\n \n-  private final ObjectMapper objectMapper = Jackson.newObjectMapper();\n+  private static final ObjectMapper objectMapper = Jackson.newObjectMapper();\n \n   @VisibleForTesting\n   public JsonSchema(JsonNode jsonNode) throws JsonProcessingException {\n-    this(new ObjectMapper().writeValueAsString(jsonNode));\n+    this(jsonNode, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(String schemaString) {\n     this(schemaString, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(\n-      String schemaString,\n+      JsonNode jsonNode,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       Integer version\n   ) {\n-    SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n-    if (resolvedReferences != null) {\n-      try {\n-        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n-          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n-        }\n-      } catch (URISyntaxException e) {\n-        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n-      }\n-    }\n-    builder.schemaJson(new JSONObject(schemaString));\n-    SchemaLoader loader = builder.build();\n-    this.schemaObj = loader.load().build();\n+    this.jsonNode = jsonNode;\n     this.version = version;\n     this.references = Collections.unmodifiableList(references);\n     this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n   }\n \n+  public JsonSchema(\n+      String schemaString,\n+      List<SchemaReference> references,\n+      Map<String, String> resolvedReferences,\n+      Integer version\n+  ) {\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaString);\n+      this.version = version;\n+      this.references = Collections.unmodifiableList(references);\n+      this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaString, e);\n+    }\n+  }\n+\n   public JsonSchema(Schema schemaObj) {\n     this(schemaObj, null);\n   }\n \n   public JsonSchema(Schema schemaObj, Integer version) {\n-    this.schemaObj = schemaObj;\n-    this.version = version;\n-    this.references = Collections.emptyList();\n-    this.resolvedReferences = Collections.emptyMap();\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaObj.toString());\n+      this.schemaObj = schemaObj;\n+      this.version = version;\n+      this.references = Collections.emptyList();\n+      this.resolvedReferences = Collections.emptyMap();\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaObj.toString(), e);\n+    }\n   }\n \n   private JsonSchema(\n+      JsonNode jsonNode,\n       Schema schemaObj,\n       Integer version,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       String canonicalString\n   ) {\n+    this.jsonNode = jsonNode;\n     this.schemaObj = schemaObj;\n     this.version = version;\n     this.references = references;\n     this.resolvedReferences = resolvedReferences;\n     this.canonicalString = canonicalString;\n   }\n \n-  public static JsonSchema copy(JsonSchema schema) {\n+  public JsonSchema copy() {\n     return new JsonSchema(\n-        schema.schemaObj,\n-        schema.version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.jsonNode,\n+        this.schemaObj,\n+        this.version,\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n-  public static JsonSchema copy(JsonSchema schema, Integer version) {\n+  public JsonSchema copy(Integer version) {\n     return new JsonSchema(\n-        schema.schemaObj,\n+        this.jsonNode,\n+        this.schemaObj,\n         version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n   public Schema rawSchema() {\n+    if (schemaObj == null) {\n+      try {\n+        SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n+        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n+          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n+        }\n+        JSONObject jsonObject = objectMapper.treeToValue((jsonNode), JSONObject.class);\n+        builder.schemaJson(jsonObject);\n+        SchemaLoader loader = builder.build();\n+        schemaObj = loader.load().build();\n+      } catch (URISyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n+      } catch (IOException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON\", e);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMjg5OQ=="}, "originalCommit": {"oid": "4aa27589ac389d26628e3440fe0b952da9330853"}, "originalPosition": 163}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1940, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}