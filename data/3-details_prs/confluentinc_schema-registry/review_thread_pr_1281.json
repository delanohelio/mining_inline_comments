{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMjE4NzIy", "number": 1281, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozNzowN1rODWbL1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozOTowMVrODWbMvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODQwNjYwOnYy", "diffSide": "RIGHT", "path": "avro-serializer/src/main/java/io/confluent/kafka/serializers/AbstractKafkaAvroDeserializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozNzowN1rOFbLYQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozNzowN1rOFbLYQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjMwNw==", "bodyText": "nit: The build is complaining that whitespace is needed around !=", "url": "https://github.com/confluentinc/schema-registry/pull/1281#discussion_r364042307", "createdAt": "2020-01-08T02:37:07Z", "author": {"login": "rayokota"}, "path": "avro-serializer/src/main/java/io/confluent/kafka/serializers/AbstractKafkaAvroDeserializer.java", "diffHunk": "@@ -173,58 +173,91 @@ protected GenericContainerWithVersion deserializeWithSchemaAndVersion(\n   }\n \n   protected DatumReader<?> getDatumReader(Schema writerSchema, Schema readerSchema) {\n+    // normalize reader schema\n+    readerSchema = getReaderSchema(writerSchema, readerSchema);\n     boolean writerSchemaIsPrimitive =\n         AvroSchemaUtils.getPrimitiveSchemas().values().contains(writerSchema);\n-    // do not use SpecificDatumReader if writerSchema is a primitive\n-    if (useSchemaReflection && !writerSchemaIsPrimitive) {\n-      if (readerSchema == null) {\n-        throw new SerializationException(\n-            \"Reader schema cannot be null when using Avro schema reflection\");\n-      }\n+    if (writerSchemaIsPrimitive) {\n+      return new GenericDatumReader<>(writerSchema, readerSchema);\n+    } else if (useSchemaReflection) {\n       return new ReflectDatumReader<>(writerSchema, readerSchema);\n-    } else if (useSpecificAvroReader && !writerSchemaIsPrimitive) {\n-      if (readerSchema == null) {\n-        readerSchema = getReaderSchema(writerSchema);\n-      }\n+    } else if (useSpecificAvroReader) {\n       return new SpecificDatumReader<>(writerSchema, readerSchema);\n     } else {\n-      if (readerSchema == null) {\n-        return new GenericDatumReader<>(writerSchema);\n-      }\n       return new GenericDatumReader<>(writerSchema, readerSchema);\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n-  private Schema getReaderSchema(Schema writerSchema) {\n-    Schema readerSchema = readerSchemaCache.get(writerSchema.getFullName());\n-    if (readerSchema == null) {\n-      Class<SpecificRecord> readerClass = SpecificData.get().getClass(writerSchema);\n-      if (readerClass != null) {\n-        try {\n-          readerSchema = readerClass.newInstance().getSchema();\n-        } catch (InstantiationException e) {\n-          throw new SerializationException(writerSchema.getFullName()\n-                                           + \" specified by the \"\n-                                           + \"writers schema could not be instantiated to \"\n-                                           + \"find the readers schema.\");\n-        } catch (IllegalAccessException e) {\n-          throw new SerializationException(writerSchema.getFullName()\n-                                           + \" specified by the \"\n-                                           + \"writers schema is not allowed to be instantiated \"\n-                                           + \"to find the readers schema.\");\n-        }\n-        readerSchemaCache.put(writerSchema.getFullName(), readerSchema);\n-      } else {\n-        throw new SerializationException(\"Could not find class \"\n-                                         + writerSchema.getFullName()\n-                                         + \" specified in writer's schema whilst finding reader's \"\n-                                         + \"schema for a SpecificRecord.\");\n-      }\n+  /**\n+   * Normalizes the reader schema, puts the resolved schema into the cache. \n+   * <li>\n+   * <ul>if the reader schema is provided, use the provided one</ul>\n+   * <ul>if the reader schema is cached for the writer schema full name, use the cached value</ul>\n+   * <ul>if the writer schema is primitive, use the writer one</ul>\n+   * <ul>if schema reflection is used, generate one from the class referred by writer schema</ul>\n+   * <ul>if generated classes are used, query the class referred by writer schema</ul>\n+   * <ul>otherwise use the writer schema</ul>\n+   * </li>\n+   */\n+  private Schema getReaderSchema(Schema writerSchema, Schema readerSchema) {\n+    if (readerSchema!=null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642d3f73f277a4c3b7f898df1312db175a3cd32d"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODQwNjg2OnYy", "diffSide": "RIGHT", "path": "avro-serializer/src/main/java/io/confluent/kafka/serializers/AbstractKafkaAvroDeserializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozNzoyMlrOFbLYbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozNzoyMlrOFbLYbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjM1MQ==", "bodyText": "nit: The build is complaining that whitespace is needed around !=", "url": "https://github.com/confluentinc/schema-registry/pull/1281#discussion_r364042351", "createdAt": "2020-01-08T02:37:22Z", "author": {"login": "rayokota"}, "path": "avro-serializer/src/main/java/io/confluent/kafka/serializers/AbstractKafkaAvroDeserializer.java", "diffHunk": "@@ -173,58 +173,91 @@ protected GenericContainerWithVersion deserializeWithSchemaAndVersion(\n   }\n \n   protected DatumReader<?> getDatumReader(Schema writerSchema, Schema readerSchema) {\n+    // normalize reader schema\n+    readerSchema = getReaderSchema(writerSchema, readerSchema);\n     boolean writerSchemaIsPrimitive =\n         AvroSchemaUtils.getPrimitiveSchemas().values().contains(writerSchema);\n-    // do not use SpecificDatumReader if writerSchema is a primitive\n-    if (useSchemaReflection && !writerSchemaIsPrimitive) {\n-      if (readerSchema == null) {\n-        throw new SerializationException(\n-            \"Reader schema cannot be null when using Avro schema reflection\");\n-      }\n+    if (writerSchemaIsPrimitive) {\n+      return new GenericDatumReader<>(writerSchema, readerSchema);\n+    } else if (useSchemaReflection) {\n       return new ReflectDatumReader<>(writerSchema, readerSchema);\n-    } else if (useSpecificAvroReader && !writerSchemaIsPrimitive) {\n-      if (readerSchema == null) {\n-        readerSchema = getReaderSchema(writerSchema);\n-      }\n+    } else if (useSpecificAvroReader) {\n       return new SpecificDatumReader<>(writerSchema, readerSchema);\n     } else {\n-      if (readerSchema == null) {\n-        return new GenericDatumReader<>(writerSchema);\n-      }\n       return new GenericDatumReader<>(writerSchema, readerSchema);\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n-  private Schema getReaderSchema(Schema writerSchema) {\n-    Schema readerSchema = readerSchemaCache.get(writerSchema.getFullName());\n-    if (readerSchema == null) {\n-      Class<SpecificRecord> readerClass = SpecificData.get().getClass(writerSchema);\n-      if (readerClass != null) {\n-        try {\n-          readerSchema = readerClass.newInstance().getSchema();\n-        } catch (InstantiationException e) {\n-          throw new SerializationException(writerSchema.getFullName()\n-                                           + \" specified by the \"\n-                                           + \"writers schema could not be instantiated to \"\n-                                           + \"find the readers schema.\");\n-        } catch (IllegalAccessException e) {\n-          throw new SerializationException(writerSchema.getFullName()\n-                                           + \" specified by the \"\n-                                           + \"writers schema is not allowed to be instantiated \"\n-                                           + \"to find the readers schema.\");\n-        }\n-        readerSchemaCache.put(writerSchema.getFullName(), readerSchema);\n-      } else {\n-        throw new SerializationException(\"Could not find class \"\n-                                         + writerSchema.getFullName()\n-                                         + \" specified in writer's schema whilst finding reader's \"\n-                                         + \"schema for a SpecificRecord.\");\n-      }\n+  /**\n+   * Normalizes the reader schema, puts the resolved schema into the cache. \n+   * <li>\n+   * <ul>if the reader schema is provided, use the provided one</ul>\n+   * <ul>if the reader schema is cached for the writer schema full name, use the cached value</ul>\n+   * <ul>if the writer schema is primitive, use the writer one</ul>\n+   * <ul>if schema reflection is used, generate one from the class referred by writer schema</ul>\n+   * <ul>if generated classes are used, query the class referred by writer schema</ul>\n+   * <ul>otherwise use the writer schema</ul>\n+   * </li>\n+   */\n+  private Schema getReaderSchema(Schema writerSchema, Schema readerSchema) {\n+    if (readerSchema!=null) {\n+      return readerSchema;\n+    }\n+    readerSchema = readerSchemaCache.get(writerSchema.getFullName());\n+    if (readerSchema!=null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642d3f73f277a4c3b7f898df1312db175a3cd32d"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODQwODc0OnYy", "diffSide": "RIGHT", "path": "avro-serde/src/main/java/io/confluent/kafka/streams/serdes/avro/ReflectionAvroDeserializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozODo1MlrOFbLZjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozODo1MlrOFbLZjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjYzNw==", "bodyText": "Are there tests that use this?", "url": "https://github.com/confluentinc/schema-registry/pull/1281#discussion_r364042637", "createdAt": "2020-01-08T02:38:52Z", "author": {"login": "rayokota"}, "path": "avro-serde/src/main/java/io/confluent/kafka/streams/serdes/avro/ReflectionAvroDeserializer.java", "diffHunk": "@@ -40,11 +40,24 @@\n   private final KafkaAvroDeserializer inner;\n   private final Schema schema;\n \n+  public ReflectionAvroDeserializer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642d3f73f277a4c3b7f898df1312db175a3cd32d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODQwODkyOnYy", "diffSide": "RIGHT", "path": "avro-serde/src/main/java/io/confluent/kafka/streams/serdes/avro/ReflectionAvroDeserializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozOTowMVrOFbLZqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMjozOTowMVrOFbLZqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjY2NQ==", "bodyText": "Are there tests that use this?", "url": "https://github.com/confluentinc/schema-registry/pull/1281#discussion_r364042665", "createdAt": "2020-01-08T02:39:01Z", "author": {"login": "rayokota"}, "path": "avro-serde/src/main/java/io/confluent/kafka/streams/serdes/avro/ReflectionAvroDeserializer.java", "diffHunk": "@@ -40,11 +40,24 @@\n   private final KafkaAvroDeserializer inner;\n   private final Schema schema;\n \n+  public ReflectionAvroDeserializer() {\n+    this.schema = null;\n+    this.inner = new KafkaAvroDeserializer();\n+  }\n+\n   public ReflectionAvroDeserializer(Class<T> type) {\n     this.schema = ReflectData.get().getSchema(type);\n     this.inner = new KafkaAvroDeserializer();\n   }\n \n+  /**\n+   * For testing purposes only.\n+   */\n+  ReflectionAvroDeserializer(final SchemaRegistryClient client) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642d3f73f277a4c3b7f898df1312db175a3cd32d"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1921, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}