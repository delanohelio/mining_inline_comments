{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NDk0NDM1", "number": 3860, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzowNjozM1rOD1EVVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozNzozN1rOD1I7LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTcyMTE5OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.tsx", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzowNjozM1rOGKUhCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzowNzoxOVrOGKy2mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ3NTA4Mg==", "bodyText": "Can we update placeholder to be {Search ${dataIndex}} so its unique, ie Search key for source table and Search name for entity table, instead of using data-testid. We should use data-testid sparingly if there are other possible selectors.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413475082", "createdAt": "2020-04-23T03:06:33Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.tsx", "diffHunk": "@@ -304,46 +322,150 @@ const SourceToEntityMap = (props) => {\n         return mapStyle;\n     }\n \n+    //For filter search in source table\n+    let searchInput: any;\n+    //For Source Table\n+    const [searchSourceText,setSearchSourceText] = useState('');\n+    const [searchedSourceColumn,setSearchedSourceColumn] = useState('');\n+    //For Entity table\n+    const [searchEntityText,setSearchEntityText] = useState('');\n+    const [searchedEntityColumn,setSearchedEntityColumn] = useState('');\n+\n+    const handleColSearch = (selectedKeys, confirm, dataIndex) => {\n+        confirm();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText(selectedKeys[0]);\n+            setSearchedSourceColumn(dataIndex); \n+        } else {\n+            setSearchEntityText(selectedKeys[0]);\n+            setSearchedEntityColumn(dataIndex);\n+        }\n+      };\n+\n+    const handleSearchReset = (clearFilters,dataIndex) => {\n+        clearFilters();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText('');\n+            setSearchedSourceColumn(''); \n+        } else {\n+            setSearchEntityText('');\n+            setSearchedEntityColumn('');\n+        }\n+    };\n+\n+    const getColumnFilterProps = dataIndex => ({\n+        filterDropdown: ({ setSelectedKeys, selectedKeys, confirm, clearFilters }) => (\n+            <div className={styles.filterContainer}>\n+                <Input\n+                    ref={node => {\n+                        searchInput = node;\n+                    }}\n+                    data-testid={`searchInput-${dataIndex}`}\n+                    placeholder={`Search name`}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2NTg2Mw==", "bodyText": "@bsrikan - The placeholder text is as per the design given by UX. Also, the work 'key' is used behind the scenes for that column and user might get confused here if we mention \"Search key\" as placeholder because to the user the column name is 'Name'.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413965863", "createdAt": "2020-04-23T16:58:32Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.tsx", "diffHunk": "@@ -304,46 +322,150 @@ const SourceToEntityMap = (props) => {\n         return mapStyle;\n     }\n \n+    //For filter search in source table\n+    let searchInput: any;\n+    //For Source Table\n+    const [searchSourceText,setSearchSourceText] = useState('');\n+    const [searchedSourceColumn,setSearchedSourceColumn] = useState('');\n+    //For Entity table\n+    const [searchEntityText,setSearchEntityText] = useState('');\n+    const [searchedEntityColumn,setSearchedEntityColumn] = useState('');\n+\n+    const handleColSearch = (selectedKeys, confirm, dataIndex) => {\n+        confirm();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText(selectedKeys[0]);\n+            setSearchedSourceColumn(dataIndex); \n+        } else {\n+            setSearchEntityText(selectedKeys[0]);\n+            setSearchedEntityColumn(dataIndex);\n+        }\n+      };\n+\n+    const handleSearchReset = (clearFilters,dataIndex) => {\n+        clearFilters();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText('');\n+            setSearchedSourceColumn(''); \n+        } else {\n+            setSearchEntityText('');\n+            setSearchedEntityColumn('');\n+        }\n+    };\n+\n+    const getColumnFilterProps = dataIndex => ({\n+        filterDropdown: ({ setSelectedKeys, selectedKeys, confirm, clearFilters }) => (\n+            <div className={styles.filterContainer}>\n+                <Input\n+                    ref={node => {\n+                        searchInput = node;\n+                    }}\n+                    data-testid={`searchInput-${dataIndex}`}\n+                    placeholder={`Search name`}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ3NTA4Mg=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MjEyMw==", "bodyText": "You are right. Will let it be then.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413972123", "createdAt": "2020-04-23T17:07:19Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.tsx", "diffHunk": "@@ -304,46 +322,150 @@ const SourceToEntityMap = (props) => {\n         return mapStyle;\n     }\n \n+    //For filter search in source table\n+    let searchInput: any;\n+    //For Source Table\n+    const [searchSourceText,setSearchSourceText] = useState('');\n+    const [searchedSourceColumn,setSearchedSourceColumn] = useState('');\n+    //For Entity table\n+    const [searchEntityText,setSearchEntityText] = useState('');\n+    const [searchedEntityColumn,setSearchedEntityColumn] = useState('');\n+\n+    const handleColSearch = (selectedKeys, confirm, dataIndex) => {\n+        confirm();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText(selectedKeys[0]);\n+            setSearchedSourceColumn(dataIndex); \n+        } else {\n+            setSearchEntityText(selectedKeys[0]);\n+            setSearchedEntityColumn(dataIndex);\n+        }\n+      };\n+\n+    const handleSearchReset = (clearFilters,dataIndex) => {\n+        clearFilters();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText('');\n+            setSearchedSourceColumn(''); \n+        } else {\n+            setSearchEntityText('');\n+            setSearchedEntityColumn('');\n+        }\n+    };\n+\n+    const getColumnFilterProps = dataIndex => ({\n+        filterDropdown: ({ setSelectedKeys, selectedKeys, confirm, clearFilters }) => (\n+            <div className={styles.filterContainer}>\n+                <Input\n+                    ref={node => {\n+                        searchInput = node;\n+                    }}\n+                    data-testid={`searchInput-${dataIndex}`}\n+                    placeholder={`Search name`}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ3NTA4Mg=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDE4MDQ5OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/config/data.config.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoxODozOFrOGKYZvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxODoxOFrOGK6YwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzODc1MQ==", "bodyText": "for an xml doc, first key itself should be a parent.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413538751", "createdAt": "2020-04-23T06:18:38Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/config/data.config.js", "diffHunk": "@@ -72,6 +72,32 @@ const mapProps = {\n     { key: '@proteinType', val: 'home' },\n     { key: 'nutFree:name', val: 'testName1' }\n   ],\n+  entityTypePropertiesUpdated : [\n+    { name: 'propId', type: 'int' },\n+    { name: 'propName', type: 'string' },\n+    {\n+      name: 'items', type: 'parent-ItemType [ ]', children: [\n+        { name: 'items/itemTypes', type: 'string' },\n+        {\n+          name: 'items/itemCategory', type: 'parent-catItem', children: [\n+            { name: 'items/itemCategory/artCraft', type: 'string' },\n+            { name: 'items/itemCategory/automobile', type: 'string' }\n+          ]\n+        }]\n+    },\n+    { name: 'gender', type: 'string' }\n+  ],\n+  sourceDataUpdated : [\n+    { key: 'proteinId', val: '123EAC' },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTU1Mg==", "bodyText": "This will be taken care of in a separate story.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414095552", "createdAt": "2020-04-23T20:18:18Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/config/data.config.js", "diffHunk": "@@ -72,6 +72,32 @@ const mapProps = {\n     { key: '@proteinType', val: 'home' },\n     { key: 'nutFree:name', val: 'testName1' }\n   ],\n+  entityTypePropertiesUpdated : [\n+    { name: 'propId', type: 'int' },\n+    { name: 'propName', type: 'string' },\n+    {\n+      name: 'items', type: 'parent-ItemType [ ]', children: [\n+        { name: 'items/itemTypes', type: 'string' },\n+        {\n+          name: 'items/itemCategory', type: 'parent-catItem', children: [\n+            { name: 'items/itemCategory/artCraft', type: 'string' },\n+            { name: 'items/itemCategory/automobile', type: 'string' }\n+          ]\n+        }]\n+    },\n+    { name: 'gender', type: 'string' }\n+  ],\n+  sourceDataUpdated : [\n+    { key: 'proteinId', val: '123EAC' },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzODc1MQ=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDE4NzI0OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyMDo1NVrOGKYdfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxODozMVrOGK6ZLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzOTcxMA==", "bodyText": "need to repeat this test using proper xml doc and convert this one to use json doc.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413539710", "createdAt": "2020-04-23T06:20:55Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTY2MA==", "bodyText": "This will be taken care of in a separate story.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414095660", "createdAt": "2020-04-23T20:18:31Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzOTcxMA=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDE5OTI3OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDo1NFrOGKYkIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxODo0NVrOGK6ZvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0MTQxMQ==", "bodyText": "we can create and store json and xml source data outside of mapProps and default mapProps.sourceData to use json. This way for xml usecases we can simply say sourceData={data.xmlSourceData}. In other words all the overrides can stay outside of mapProps.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413541411", "createdAt": "2020-04-23T06:24:54Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTgwNA==", "bodyText": "Done.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414095804", "createdAt": "2020-04-23T20:18:45Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0MTQxMQ=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDI3NjM2OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0Nzo1M1rOGKZPDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxODo1M1rOGK6Z_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MjM5OQ==", "bodyText": "fix typo in texting", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413552399", "createdAt": "2020-04-23T06:47:53Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTg2OA==", "bodyText": "Done", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414095868", "createdAt": "2020-04-23T20:18:53Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MjM5OQ=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDMwNDE4OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1MjozN1rOGKZgew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxOTozMVrOGK6bnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Njg1OQ==", "bodyText": "fireEvent on exp would fail if it was not found in the DOM. So we can get rid of the assertion in line 131 and other similar assertions like this in the test, since they wont add any value to the test.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413556859", "createdAt": "2020-04-23T06:52:37Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NjI4Nw==", "bodyText": "Done", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414096287", "createdAt": "2020-04-23T20:19:31Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Njg1OQ=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDMyMDE3OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NzowMVrOGKZpYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxOTo0NFrOGK6cEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1OTEzOQ==", "bodyText": "can we check for column options toBeChecked instead.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413559139", "createdAt": "2020-04-23T06:57:01Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NjQwMA==", "bodyText": "Done.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414096400", "createdAt": "2020-04-23T20:19:44Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1OTEzOQ=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDQ0NjQyOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozMDo1NFrOGKaz0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDozNzo1MlrOGK7F-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3ODE5NA==", "bodyText": "This works but if test data changes this wouldnt be reliable. An alternate suggestion is to check columns dont exist. Like so:\nlet entityTableHeaderRow = within(getByTestId('entityTableType').closest('tr'))\nexpect(entityTableHeaderRow.queryByText('Name')).not.toBeInTheDocument();\nexpect(entityTableHeaderRow.queryByText('XPath Expression')).not.toBeInTheDocument();\n\nThe same can be repurposed to verify they exist.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413578194", "createdAt": "2020-04-23T07:30:54Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column\n+\n+      //Confirm that the Name column is not visible in Entity table anymore.\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Uncheck Name column\n+\n+      //Confirm that the XPath Expression column(Along with Name Column) is not visible in Entity table anymore.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNzEyOQ==", "bodyText": "Done", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414107129", "createdAt": "2020-04-23T20:37:52Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column\n+\n+      //Confirm that the Name column is not visible in Entity table anymore.\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Uncheck Name column\n+\n+      //Confirm that the XPath Expression column(Along with Name Column) is not visible in Entity table anymore.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3ODE5NA=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDQ1NjEwOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozMzoxOFrOGKa5fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMToyOTo0MFrOGK87WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3OTY0Nw==", "bodyText": "can add filtering and then uncheck to verify column doesnt exist and filter gets reset.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413579647", "createdAt": "2020-04-23T07:33:18Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzNzE3Nw==", "bodyText": "Done. Added the test scenario in column option selector test.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r414137177", "createdAt": "2020-04-23T21:29:40Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3OTY0Nw=="}, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDQ3MzQxOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozNzozN1rOGKbD7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozNzozN1rOGKbD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4MjMxOQ==", "bodyText": "sorting is good.\nlike the spacing & grouping of columns, makes it readable. Goes well with \"Arrange, Act, Assert\" way of writing tests.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413582319", "createdAt": "2020-04-23T07:37:37Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column\n+\n+      //Confirm that the Name column is not visible in Entity table anymore.\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Uncheck Name column\n+\n+      //Confirm that the XPath Expression column(Along with Name Column) is not visible in Entity table anymore.\n+      expect(queryByText(\"concat(propName,'-NEW')\")).not.toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Checking the columns one by one in selector and verify that they appear in entity table\n+      fireEvent.click(Name); //Check Name column\n+      //Props below should be available now\n+      expect(getByText('propId')).toBeInTheDocument(); \n+      expect(getByText('propName')).toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Check XPathExpression column\n+      //Props below should be available now\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+\n+    });\n+\n+    test('Sorting in Source and Entity table',() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3432, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}