{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NTgzNTEx", "number": 3862, "title": "DHFPROD-4226: Export rows as csv", "bodyText": "Description\nChecklist:\n- Note: do not change the below\n\n\nOwner:\n\n\n JIRA_ID included in all the commit messages\n\n\n PR title is in the format JIRA_ID:Title\n\n\n Rebase the branch with upstream\n\n\n Squashed all commits into a single commit\n\n\n Added Tests\n\n\nReviewer:\n\n\n Reviewed Tests", "createdAt": "2020-04-22T22:38:55Z", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862", "merged": true, "mergeCommit": {"oid": "b9929e076cc8ba4f1d70fa5ba08bfb8b304df74f"}, "closed": true, "closedAt": "2020-04-27T20:37:54Z", "author": {"login": "akshaysonvane"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaTSh-gFqTM5ODcwOTMwNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcb0l4wgFqTQwMTI2NzMzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzA5MzA1", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-398709305", "createdAt": "2020-04-23T02:03:05Z", "commit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjowMzowNVrOGKTQ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjoxNjoyOVrOGKThVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NDU2Mw==", "bodyText": "For consistency, the functionName should be the same  as the filename, minus \".api\".", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413454563", "createdAt": "2020-04-23T02:03:05Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.api", "diffHunk": "@@ -0,0 +1,37 @@\n+{\n+    \"functionName\": \"getOpticPlan\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTE5MQ==", "bodyText": "This is not likely to work in DHS, as we don't know the group name. Today, in a typical DHS setup, there are 4 other groups, and Default is not used at all.\nInstead of depending on an options document to exist, what if we generate this based on the entity name? hub-entities.xqy provides a nice function for generating this.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413455191", "createdAt": "2020-04-23T02:04:58Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTUzMA==", "bodyText": "Pinging @ryanjdew - should this be in XQuery instead of SJS? I ask that because we're dealing with a lot of XML here, and that's of course more difficult to do in SJS vs XQuery.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413455530", "createdAt": "2020-04-23T02:06:05Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTg2Nw==", "bodyText": "Given that we need an amp plus a separate module, which then has to invoke a function in the modules database for a document whose URI will be dependent on the groups - I think we should just generate these on the fly. Check out hub-entities.xqy.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413455867", "createdAt": "2020-04-23T02:07:07Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var columns = xdmp.getRequestField(\"columns\");\n+\n+structQuery = fn.head(xdmp.unquote(structQuery)).root;\n+searchQText = searchQText || \"\";\n+\n+const oldOptions = options.getSearchOptions(entityOptionsFileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODMxNg==", "bodyText": "I've worked on projects before where we create a lot of test files that are stored in version control, and it can quickly become difficult to manage. I think it's far better in the long term to write a simple program to generate documents in memory and write them to ML. It's fewer files in version control, and it's easier to change.\nRight now, it doesn't look like the test cares what's in the documents, though I think it should - shouldn't it be verifying that the correct value is present in each column in each row?\nFor that reason, I would only insert 2 test documents (generally, there's zero, there's 1, and then there's 2 or more). And I'd only request maybe 3 columns. Now you only need to verify 6 values. And since you have 2 test documents, you can have a separate test that passes in a limit of 1, and you can verify you only get 1 row back.\nWith that in mind, I'd design a bare minimum test document - no headers, no triples, no attachments. And if you're only requesting 3 properties, I'd populate 4 total properties - that allows you to verify that when you ask for 3 of them, you don't get the 4th. Then, make a simple method in here that allows you to insert a document with 3 known values.\nAlso, let's use the entity-reference-model project. The Customer entity has three atomic properties so far - customerId, name, and customerSince. Feel free to add a fourth atomic property for your test. That avoids having to create a new example project, and the more tests we have using the same sample project, the easier it is to understand the tests.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413458316", "createdAt": "2020-04-23T02:15:15Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +77,122 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installExportProject();\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Order\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Order\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"sku\\\",\\n\" +\n+            \"            \\\"title\\\",\\n\" +\n+            \"            \\\"price\\\",\\n\" +\n+            \"            \\\"discounted-price\\\",\\n\" +\n+            \"            \\\"order-date\\\",\\n\" +\n+            \"            \\\"ship-date\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 5;\n+        int headerRow = 1;\n+        int totalColumns = 6;\n+        int totalRows = limit + headerRow;\n+\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+    }\n+\n+    private void installExportProject() throws IOException {\n+        String projectFolder = \"test-projects/export-project\";\n+        installProjectInFolder(projectFolder);\n+        entityManager.deployQueryOptions();\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(\"Order\")\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        GenericDocumentManager finalDocMgr = getHubConfig().newFinalClient().newDocumentManager();\n+        DocumentWriteSet writeSet = finalDocMgr.newWriteSet();\n+        File inputDir = new ClassPathResource(projectFolder + \"/input\").getFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA==", "bodyText": "Is there something under src/main/java that needs this? The only reference I saw to \"async\" is in EntitySearchControllerTest.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413458774", "createdAt": "2020-04-23T02:16:29Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 15}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/5509ea3767fcc4714b3c1b65fd58f7be467f851f", "committedDate": "2020-04-22T22:35:33Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "4497b74605bd30a13205acb1a9e68baa06e32b17", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/4497b74605bd30a13205acb1a9e68baa06e32b17", "committedDate": "2020-04-24T20:09:26Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4497b74605bd30a13205acb1a9e68baa06e32b17", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/4497b74605bd30a13205acb1a9e68baa06e32b17", "committedDate": "2020-04-24T20:09:26Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "801d3387dbb69fff9e41367a525b975e7ab076a9", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/801d3387dbb69fff9e41367a525b975e7ab076a9", "committedDate": "2020-04-24T21:29:39Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "801d3387dbb69fff9e41367a525b975e7ab076a9", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/801d3387dbb69fff9e41367a525b975e7ab076a9", "committedDate": "2020-04-24T21:29:39Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/e393bb174cc60ae6fca374d2012615a13c59098e", "committedDate": "2020-04-24T21:37:13Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDA0NjA3", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-400404607", "createdAt": "2020-04-25T15:36:59Z", "commit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTozNjo1OVrOGL225Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo1MTo0NVrOGL3A9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjMwOQ==", "bodyText": "I think this method needs to make that clear. Spring is great at making it easy to setup useful, reusable stuff, but the few lines of code required to do so often beg the question of - \"Why is this being configured?\"\nThe method name is usually a good way to answer that question - e.g. \"configureAsyncProcessingForStreamingResponses\". Each setting needs a comment as well - why 10 threads? Why 10 minutes? Why did we choose those numbers? 3 months from now, someone will look at this code and wonder why these settings were chosen.\nI also think it's worth explicitly identifying the feature this is for - i.e. exporting entities. That may expand in the future - i.e. when we support exporting other results.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415086309", "createdAt": "2020-04-25T15:36:59Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjYzMQ==", "bodyText": "Looking at this, it does seem like there's a chance for a null pointer. How about \"searchQuery.hasEntityTypeIds()\"? That results in less work for the controller, and that method can be coded to ensure an NPE can't occur.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415086631", "createdAt": "2020-04-25T15:38:53Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -100,7 +112,7 @@ public StringHandle search(SearchQuery searchQuery) {\n         }\n         catch (MarkLogicServerException e) {\n             // If there are no entityModels to search, then we expect an error because no search options will exist\n-            if(searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {\n+            if (searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzA1Mg==", "bodyText": "Why is this here? I don't think any post-commit triggers fire when entity instances are saved?", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087052", "createdAt": "2020-04-25T15:41:26Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzE3Ng==", "bodyText": "Nice - is this verifying that the async support is configured correctly then?", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087176", "createdAt": "2020-04-25T15:41:57Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzUwOA==", "bodyText": "This is reusable stuff that is worth adding to the ReferenceModelProject class.\nThe current \"createCustomer\" method in there is for \"raw\" customers. I think it's worth renaming that to \"createRawCustomer\", and then this can become \"createCustomerInstance\", which makes it clear we're creating entity instances here.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087508", "createdAt": "2020-04-25T15:44:01Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzcxMg==", "bodyText": "This can move to the testFixture source set in core DH too. Make it a regular public class though, with private fields and getters/setters, as we can use Jackson to generate JSON for it automatically, which will save some effort. We'll likely add more to this class so to make writing tests easier as we go.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087712", "createdAt": "2020-04-25T15:45:28Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {\n+        String customerEntityType = \"Customer\";\n+\n+        JSONDocumentManager mgr = getHubConfig().newFinalClient().newJSONDocumentManager();\n+        ObjectNode customerProps = objectMapper.createObjectNode();\n+        customerProps.put(\"customerId\", customer.customerId);\n+        customerProps.put(\"name\", customer.name);\n+        customerProps.put(\"customerNumber\", customer.customerNumber);\n+        customerProps.put(\"customerSince\", customer.customerSince);\n+\n+        ObjectNode infoProp = objectMapper.createObjectNode();\n+        infoProp.put(\"title\", customerEntityType);\n+        infoProp.put(\"version\", \"0.0.1\");\n+        infoProp.put(\"baseUri\", \"http://example.org/\");\n+\n+        ObjectNode instanceProps = objectMapper.createObjectNode();\n+        instanceProps.set(\"info\", infoProp);\n+        instanceProps.set(customerEntityType, customerProps);\n+\n+        ObjectNode instance = objectMapper.createObjectNode().set(\"instance\", instanceProps);\n+        ObjectNode envelope = objectMapper.createObjectNode().set(\"envelope\", instance);\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(customerEntityType)\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        mgr.write(\"/\" + customerEntityType + customer.customerId + \".json\", metadata, new JacksonHandle(envelope));\n+    }\n+\n+    private Set<Integer> calculateHash(String csvData) throws IOException {\n+        Set<Integer> rowSet = new HashSet<>();\n+\n+        try (BufferedReader reader = new BufferedReader(new StringReader(csvData))) {\n+            String line = reader.readLine();\n+            while (line != null) {\n+                line = line.replaceAll(\",\", \"\");\n+                rowSet.add(line.hashCode());\n+                line = reader.readLine();\n+            }\n+        }\n+\n+        return rowSet;\n+    }\n+\n+    private MultiValueMap<String, String> getRequestParams(int limit, String json) {\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        return params;\n+    }\n+\n+    static class Customer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4Nzg4Mw==", "bodyText": "Just an FYI, we have the reference project in both core and central - I'll get that resolved soon, as central can definitely reuse the one in core.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087883", "createdAt": "2020-04-25T15:46:19Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/resources/test-projects/reference-project/entities/Customer.entity.json", "diffHunk": "@@ -10,6 +10,9 @@\n         \"name\"\n       ],\n       \"properties\": {\n+        \"customerId\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODMyMg==", "bodyText": "I think we need to catch an exception here in case the options exist. They should exist - but if they don't, the user is going to get an error they likely won't understand and I'll probably get pinged with a message saying that Gradle is broken.\nSo use a try/catch here to catch an exception if the options don't exist, and rethrow the error with a message of e.g. \"Could not find search options: (name); system is not configured correctly, please contact a system administrator\".", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415088322", "createdAt": "2020-04-25T15:48:44Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -278,6 +290,126 @@ protected String buildSearchOptions(String query, SearchQuery searchQuery) {\n         return sb.toString();\n     }\n \n+    public void exportById(String queryId, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        JsonNode queryDocument = EntitySearchService.on(finalDataServiceClient).getSavedQuery(queryId);\n+        exportByQuery(queryDocument, fileType, limit, out, response);\n+    }\n+\n+    public void exportByQuery(JsonNode queryDocument, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        if (\"CSV\".equals(fileType.toUpperCase())) {\n+            prepareResponseHeader(response, CSV_CONTENT_TYPE, getFileNameForDownload(queryDocument, CSV_FILE_EXTENSION));\n+            exportRows(queryDocument, limit, out);\n+        }\n+        else {\n+            throw new DataHubException(\"Invalid file type: \" + fileType);\n+        }\n+    }\n+\n+    public void exportRows(JsonNode queryDocument, Long limit, OutputStream out) {\n+        QueryManager queryMgr = finalDatabaseClient.newQueryManager();\n+        SearchQuery searchQuery = transformToSearchQuery(queryDocument);\n+        StructuredQueryDefinition structuredQueryDefinition = buildQuery(queryMgr, searchQuery);\n+\n+        String structQuery = structuredQueryDefinition.serialize();\n+        String searchQText = searchQuery.getQuery().getSearchText();\n+        String queryOptions = finalDatabaseClient.newServerConfigManager().newQueryOptionsManager().readOptionsAs(QUERY_OPTIONS, Format.XML, String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODg4NA==", "bodyText": "I think you can define the DS API with queryOptions as type = jsonDocument, and then pass (hopefully) a JacksonHandle into it in the Java code. Same goes for the structQuery - if these are JSON objects, let's have a richer interface than using \"String\".\nAlso, \"searchText\" is widely used as the parameter name for a user's search text, so let's use that instead of \"searchQText\".\nOne other nit - generally, I'm opposed to abbreviating words unless there's a really, really good reason. So let's say \"structuredQuery\" instead of \"structQuery\".", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415088884", "createdAt": "2020-04-25T15:51:45Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/getOpticPlan.sjs", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+\n+const returnFlags = `<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\n+  <return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\n+  <return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\n+  <return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\n+  <return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\n+  <return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\n+  <return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\n+  <return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\n+  <return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\n+  <return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\n+  <return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>`;\n+\n+const stylesheet = fn.head(xdmp.unquote(`<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n+   <xsl:template match=\"node()|@*\">\n+      <xsl:copy>\n+         <xsl:apply-templates select=\"node()|@*\" />\n+      </xsl:copy>\n+   </xsl:template>\n+   <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\n+   <xsl:template match=\"*:options\">\n+      <xsl:copy>\n+         <xsl:apply-templates select=\"node()|@*\" />\n+         ${returnFlags}\n+      </xsl:copy>\n+   </xsl:template>\n+</xsl:stylesheet>`));\n+\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var queryOptions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 54}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/e393bb174cc60ae6fca374d2012615a13c59098e", "committedDate": "2020-04-24T21:37:13Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "45a63b2769e96098de1f5366610dfef9ad7d703f", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/45a63b2769e96098de1f5366610dfef9ad7d703f", "committedDate": "2020-04-26T01:43:46Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45a63b2769e96098de1f5366610dfef9ad7d703f", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/45a63b2769e96098de1f5366610dfef9ad7d703f", "committedDate": "2020-04-26T01:43:46Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "6228cd71470419c915fa9b0fbf5dba53357f8164", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/6228cd71470419c915fa9b0fbf5dba53357f8164", "committedDate": "2020-04-26T03:05:54Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6228cd71470419c915fa9b0fbf5dba53357f8164", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/6228cd71470419c915fa9b0fbf5dba53357f8164", "committedDate": "2020-04-26T03:05:54Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "45d98a812646b139f060d9a108c2947c96ceaceb", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/45d98a812646b139f060d9a108c2947c96ceaceb", "committedDate": "2020-04-27T15:47:55Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjQxMDE4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-401241018", "createdAt": "2020-04-27T19:01:17Z", "commit": {"oid": "45d98a812646b139f060d9a108c2947c96ceaceb"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjQxODcz", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-401241873", "createdAt": "2020-04-27T19:02:33Z", "commit": {"oid": "45d98a812646b139f060d9a108c2947c96ceaceb"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf8c512f7e182b1702120ab3d26916964df32e2a", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/bf8c512f7e182b1702120ab3d26916964df32e2a", "committedDate": "2020-04-27T19:26:06Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjU5NDc4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-401259478", "createdAt": "2020-04-27T19:27:18Z", "commit": {"oid": "45d98a812646b139f060d9a108c2947c96ceaceb"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45d98a812646b139f060d9a108c2947c96ceaceb", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/45d98a812646b139f060d9a108c2947c96ceaceb", "committedDate": "2020-04-27T15:47:55Z", "message": "DHFPROD-4226: Export rows as csv"}, "afterCommit": {"oid": "bf8c512f7e182b1702120ab3d26916964df32e2a", "author": {"user": {"login": "akshaysonvane", "name": "Akshay Sonvane"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/bf8c512f7e182b1702120ab3d26916964df32e2a", "committedDate": "2020-04-27T19:26:06Z", "message": "DHFPROD-4226: Export rows as csv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjY0MDI4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-401264028", "createdAt": "2020-04-27T19:33:42Z", "commit": {"oid": "bf8c512f7e182b1702120ab3d26916964df32e2a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjY3MzM1", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#pullrequestreview-401267335", "createdAt": "2020-04-27T19:38:29Z", "commit": {"oid": "bf8c512f7e182b1702120ab3d26916964df32e2a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3091, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}