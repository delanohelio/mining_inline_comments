{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2OTY5NDUz", "number": 3938, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjozODoyMlrOD72V3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjozOToxOFrOD72Wsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDgyOTExOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjozODoyMlrOGUbZKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzozMzozNVrOGUchxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzUxNQ==", "bodyText": "lets initialize resetSearch here. all the elements here, to go with arrange/act/assert way of writing tests.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3938#discussion_r424073515", "createdAt": "2020-05-12T22:38:22Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -44,88 +44,172 @@ describe('RTL Source-to-entity map tests', () => {\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n     });\n \n-    test('Filtering Name column in Source and Entity tables',() => {\n+    test('Filtering Name column in Source (JSON Source Data) and Entity tables', () => {\n \n-      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps}\n-        mappingVisible={true}\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.jsonSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n         />);\n \n-      //Expanding all the nested levels first to apply filter later\n-      fireEvent.click(getByTestId('expandCollapseBtn-source'));\n-      fireEvent.click(getByTestId('expandCollapseBtn-entity'));\n+        /* Test filter for JSON Source data in Source table  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        expect(filterIcon).toBeInTheDocument();\n+        fireEvent.click(filterIcon);\n+        let inputSearch = getByTestId('searchInput-key');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b241ee6616feb777128bce95ffe712a123453614"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjEwMQ==", "bodyText": "Done.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3938#discussion_r424092101", "createdAt": "2020-05-12T23:33:35Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -44,88 +44,172 @@ describe('RTL Source-to-entity map tests', () => {\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n     });\n \n-    test('Filtering Name column in Source and Entity tables',() => {\n+    test('Filtering Name column in Source (JSON Source Data) and Entity tables', () => {\n \n-      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps}\n-        mappingVisible={true}\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.jsonSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n         />);\n \n-      //Expanding all the nested levels first to apply filter later\n-      fireEvent.click(getByTestId('expandCollapseBtn-source'));\n-      fireEvent.click(getByTestId('expandCollapseBtn-entity'));\n+        /* Test filter for JSON Source data in Source table  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        expect(filterIcon).toBeInTheDocument();\n+        fireEvent.click(filterIcon);\n+        let inputSearch = getByTestId('searchInput-key');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzUxNQ=="}, "originalCommit": {"oid": "b241ee6616feb777128bce95ffe712a123453614"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDgyOTI4OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjozODoyNlrOGUbZSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzozMzoyNlrOGUchnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzU0NQ==", "bodyText": "Click will assert that element to be in the dom. We can get rid of the assertion here, line 60, 62 and other places if present.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3938#discussion_r424073545", "createdAt": "2020-05-12T22:38:26Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -44,88 +44,172 @@ describe('RTL Source-to-entity map tests', () => {\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n     });\n \n-    test('Filtering Name column in Source and Entity tables',() => {\n+    test('Filtering Name column in Source (JSON Source Data) and Entity tables', () => {\n \n-      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps}\n-        mappingVisible={true}\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.jsonSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n         />);\n \n-      //Expanding all the nested levels first to apply filter later\n-      fireEvent.click(getByTestId('expandCollapseBtn-source'));\n-      fireEvent.click(getByTestId('expandCollapseBtn-entity'));\n+        /* Test filter for JSON Source data in Source table  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        expect(filterIcon).toBeInTheDocument();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b241ee6616feb777128bce95ffe712a123453614"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjA2Mw==", "bodyText": "Done.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3938#discussion_r424092063", "createdAt": "2020-05-12T23:33:26Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -44,88 +44,172 @@ describe('RTL Source-to-entity map tests', () => {\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n     });\n \n-    test('Filtering Name column in Source and Entity tables',() => {\n+    test('Filtering Name column in Source (JSON Source Data) and Entity tables', () => {\n \n-      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps}\n-        mappingVisible={true}\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.jsonSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n         />);\n \n-      //Expanding all the nested levels first to apply filter later\n-      fireEvent.click(getByTestId('expandCollapseBtn-source'));\n-      fireEvent.click(getByTestId('expandCollapseBtn-entity'));\n+        /* Test filter for JSON Source data in Source table  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        expect(filterIcon).toBeInTheDocument();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzU0NQ=="}, "originalCommit": {"oid": "b241ee6616feb777128bce95ffe712a123453614"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDgzMTIzOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMjozOToxOFrOGUbaeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoxOToxNlrOGUcQHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3Mzg1MA==", "bodyText": "All the \"not\" here are siblings right?", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3938#discussion_r424073850", "createdAt": "2020-05-12T22:39:18Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -44,88 +44,172 @@ describe('RTL Source-to-entity map tests', () => {\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n     });\n \n-    test('Filtering Name column in Source and Entity tables',() => {\n+    test('Filtering Name column in Source (JSON Source Data) and Entity tables', () => {\n \n-      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps}\n-        mappingVisible={true}\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.jsonSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n         />);\n \n-      //Expanding all the nested levels first to apply filter later\n-      fireEvent.click(getByTestId('expandCollapseBtn-source'));\n-      fireEvent.click(getByTestId('expandCollapseBtn-entity'));\n+        /* Test filter for JSON Source data in Source table  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        expect(filterIcon).toBeInTheDocument();\n+        fireEvent.click(filterIcon);\n+        let inputSearch = getByTestId('searchInput-key');\n+        expect(inputSearch).toBeInTheDocument();\n+        fireEvent.change(inputSearch, { target: { value: \"first\" } }); //Enter a case-insensitive value in inputSearch field\n+        expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+        expect(inputSearch).toHaveValue('first');\n+        fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+\n+        //Check if the expected values are available/not available in search result.\n+        expect(getByText('nutFreeName')).toBeInTheDocument();\n+        expect(getByText('NamePreferred')).toBeInTheDocument();\n+        expect(getByText('John')).toBeInTheDocument();\n+        expect(queryByText('proteinId')).not.toBeInTheDocument();\n+        expect(queryByText('proteinType')).not.toBeInTheDocument();\n+        expect(queryByText('withNutsOrganism')).not.toBeInTheDocument();\n+        expect(queryByText('OrganismName')).not.toBeInTheDocument();\n+        expect(queryByText('Frog virus 3')).not.toBeInTheDocument();\n+        expect(queryByText('OrganismType')).not.toBeInTheDocument();\n+        expect(queryByText('scientific')).not.toBeInTheDocument();\n+\n+        //Check if the entity properties are not affected by the filter on source table\n+        expect(getByText('propId')).toBeInTheDocument();\n+        expect(getByText('propName')).toBeInTheDocument();\n+        expect(queryByText('artCraft')).not.toBeInTheDocument();\n+        expect(queryByText('automobile')).not.toBeInTheDocument();\n+        expect(queryByText('speedometer')).not.toBeInTheDocument();\n+        expect(queryByText('windscreen')).not.toBeInTheDocument();\n \n-      /* Test filter on Source table  */\n-      let filterIcon = getByTestId('filterIcon-key');\n-      expect(filterIcon).toBeInTheDocument();\n-      fireEvent.click(filterIcon);\n-      let inputSearch = getByTestId('searchInput-key');\n-      expect(inputSearch).toBeInTheDocument();\n-      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n-      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n-      expect(inputSearch).toHaveValue('first');\n-      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n-\n-      //Check if the expected values are available/not available in search result.\n-      expect(getByText('nutFreeName')).toBeInTheDocument();\n-      expect(getByText('NamePreferred')).toBeInTheDocument();\n-      expect(getByText('John')).toBeInTheDocument();\n-      expect(queryByText('proteinId')).not.toBeInTheDocument();\n-      expect(queryByText('proteinType')).not.toBeInTheDocument();\n-\n-      //Check if the entity properties are not affected by the filter on source table\n-      expect(getByText('propId')).toBeInTheDocument();\n-      expect(getByText('propName')).toBeInTheDocument();\n-      expect(getByText('artCraft')).toBeInTheDocument();\n-      expect(getByText('automobile')).toBeInTheDocument();\n+        //Reset the search filter on Source table\n+        fireEvent.click(filterIcon);\n+        let resetSearch = getByTestId('ResetSearch-key');\n+        fireEvent.click(resetSearch);\n+\n+        //Check if the table goes back to the default state after resetting the filter on source table.\n+        expect(getByText('proteinId')).toBeInTheDocument();\n+        expect(getByText('proteinType')).toBeInTheDocument();\n+        expect(getByText('withNutsOrganism')).toBeInTheDocument();\n+        expect(getByText('OrganismName')).toBeInTheDocument();\n+        expect(getByText('Frog virus 3')).toBeInTheDocument();\n+        expect(getByText('OrganismType')).toBeInTheDocument();\n+        expect(getByText('scientific')).toBeInTheDocument();\n+        expect(getByText('nutFreeName')).toBeInTheDocument();\n+        expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+        expect(getByText('John')).toBeInTheDocument();\n+        expect(queryByText('suffix')).not.toBeInTheDocument(); //This is not visible since only root and first level are expanded in the default state\n+\n+        /* Test filter on Entity table  */\n+\n+        //Updating expression for few fields to be validated later\n+        let exp = getByText('testNameInExp');\n+        fireEvent.change(exp, { target: { value: \"concat(propName,'-NEW')\" } });\n+        fireEvent.blur(exp);\n+        expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+\n+        //Moving along with the filter test\n+        let entityfilterIcon = getByTestId('filterIcon-name');\n+        fireEvent.click(entityfilterIcon);\n+        let inputSearchEntity = getByTestId('searchInput-name');\n+        fireEvent.change(inputSearchEntity, { target: { value: \"craft\" } }); //Enter a case-insensitive value in inputEntitySearch field\n+        expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+        expect(inputSearchEntity).toHaveValue('craft');\n+        fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+        //Check if the expected values are available/not available in search result.\n+        expect(getByText('items')).toBeInTheDocument();\n+        expect(getByText('itemTypes')).toBeInTheDocument();\n+        expect(getByText('itemCategory')).toBeInTheDocument();\n+        expect(getByText('Craft')).toBeInTheDocument();\n+        expect(queryByText('propId')).not.toBeInTheDocument();\n+        expect(queryByText('propName')).not.toBeInTheDocument();\n+        //productCategory should be visible and collapsed\n+        expect(getByText('productCategory')).toBeInTheDocument();\n+        expect(queryByText('speedometer')).not.toBeInTheDocument();\n+        expect(queryByText('windscreen')).not.toBeInTheDocument();\n+\n+        //Check if the source table properties are not affected by the filter on Entity table\n+        expect(getByText('proteinId')).toBeInTheDocument();\n+        expect(getByText('proteinType')).toBeInTheDocument();\n+        expect(getByText('nutFreeName')).toBeInTheDocument();\n+        expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+        expect(getByText('LastName')).toBeInTheDocument();\n+        expect(getByText('withNutsOrganism')).toBeInTheDocument();\n+        expect(getByText('OrganismName')).toBeInTheDocument();\n+        expect(getByText('Frog virus 3')).toBeInTheDocument();\n+        expect(getByText('OrganismType')).toBeInTheDocument();\n+        expect(getByText('scientific')).toBeInTheDocument();\n+        expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+        expect(getByText('John')).toBeInTheDocument();\n+        expect(queryByText('suffix')).not.toBeInTheDocument();\n \n-      //Reset the search filter on Source table\n-      fireEvent.click(filterIcon);\n-      let resetSearch = getByTestId('ResetSearch-key');\n-      fireEvent.click(resetSearch);\n+        //Reset the search filter on Entity table\n+        fireEvent.click(entityfilterIcon);\n+        let resetEntitySearch = getByTestId('ResetSearch-name');\n+        fireEvent.click(resetEntitySearch);\n \n-      //Check if the expected values are present now after resetting the filter on source table.\n-      expect(getByText('proteinId')).toBeInTheDocument();\n-      expect(getByText('proteinType')).toBeInTheDocument();\n+        //Check if the table goes back to the default state after resetting the filter on Entity table.\n+        expect(getByText('propId')).toBeInTheDocument();\n+        expect(getByText('propName')).toBeInTheDocument();\n+        expect(getByText('itemTypes')).toBeInTheDocument();\n+        expect(getByText('itemCategory')).toBeInTheDocument();\n+        expect(onClosestTableRow(getByText('artCraft'))?.style.display).toBe('none');\n+        expect(onClosestTableRow(getByText('automobile'))?.style.display).toBe('none');\n+        expect(getByText('productCategory')).toBeInTheDocument();\n+        expect(queryByText('speedometer')).not.toBeInTheDocument();\n+        expect(queryByText('windscreen')).not.toBeInTheDocument();\n+    });\n \n-      /* Test filter on Entity table  */\n+    test('Filtering of Name column in XML Source data', () => {\n \n-      //Updating expression for few fields to be validated later\n-      let exp = getByText('testNameInExp');\n-      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n-      fireEvent.blur(exp);\n-      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.xmlSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n+        />);\n+\n+        /* Test filter on Source table with XML data  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        fireEvent.click(filterIcon);\n+        let inputSearch = getByTestId('searchInput-key');\n+        expect(inputSearch).toBeInTheDocument();\n+        fireEvent.change(inputSearch, { target: { value: \"organism\" } }); //Enter a case-insensitive value in inputSearch field\n+        expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+        expect(inputSearch).toHaveValue('organism');\n+        fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+\n+        //Check if the expected values are available/not available in search result.\n+        expect(getByText(/withNuts:/)).toBeInTheDocument();\n+        expect(getByText('Frog virus 3')).toBeInTheDocument();\n+        expect(getByText('scientific')).toBeInTheDocument();\n+        expect(getByText(/nutFree:/)).toBeInTheDocument();\n+        expect(queryByText('NamePreferred')).not.toBeInTheDocument();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b241ee6616feb777128bce95ffe712a123453614"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzU4MA==", "bodyText": "Yes.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3938#discussion_r424087580", "createdAt": "2020-05-12T23:19:16Z", "author": {"login": "xnikhil08"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -44,88 +44,172 @@ describe('RTL Source-to-entity map tests', () => {\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n     });\n \n-    test('Filtering Name column in Source and Entity tables',() => {\n+    test('Filtering Name column in Source (JSON Source Data) and Entity tables', () => {\n \n-      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps}\n-        mappingVisible={true}\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.jsonSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n         />);\n \n-      //Expanding all the nested levels first to apply filter later\n-      fireEvent.click(getByTestId('expandCollapseBtn-source'));\n-      fireEvent.click(getByTestId('expandCollapseBtn-entity'));\n+        /* Test filter for JSON Source data in Source table  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        expect(filterIcon).toBeInTheDocument();\n+        fireEvent.click(filterIcon);\n+        let inputSearch = getByTestId('searchInput-key');\n+        expect(inputSearch).toBeInTheDocument();\n+        fireEvent.change(inputSearch, { target: { value: \"first\" } }); //Enter a case-insensitive value in inputSearch field\n+        expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+        expect(inputSearch).toHaveValue('first');\n+        fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+\n+        //Check if the expected values are available/not available in search result.\n+        expect(getByText('nutFreeName')).toBeInTheDocument();\n+        expect(getByText('NamePreferred')).toBeInTheDocument();\n+        expect(getByText('John')).toBeInTheDocument();\n+        expect(queryByText('proteinId')).not.toBeInTheDocument();\n+        expect(queryByText('proteinType')).not.toBeInTheDocument();\n+        expect(queryByText('withNutsOrganism')).not.toBeInTheDocument();\n+        expect(queryByText('OrganismName')).not.toBeInTheDocument();\n+        expect(queryByText('Frog virus 3')).not.toBeInTheDocument();\n+        expect(queryByText('OrganismType')).not.toBeInTheDocument();\n+        expect(queryByText('scientific')).not.toBeInTheDocument();\n+\n+        //Check if the entity properties are not affected by the filter on source table\n+        expect(getByText('propId')).toBeInTheDocument();\n+        expect(getByText('propName')).toBeInTheDocument();\n+        expect(queryByText('artCraft')).not.toBeInTheDocument();\n+        expect(queryByText('automobile')).not.toBeInTheDocument();\n+        expect(queryByText('speedometer')).not.toBeInTheDocument();\n+        expect(queryByText('windscreen')).not.toBeInTheDocument();\n \n-      /* Test filter on Source table  */\n-      let filterIcon = getByTestId('filterIcon-key');\n-      expect(filterIcon).toBeInTheDocument();\n-      fireEvent.click(filterIcon);\n-      let inputSearch = getByTestId('searchInput-key');\n-      expect(inputSearch).toBeInTheDocument();\n-      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n-      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n-      expect(inputSearch).toHaveValue('first');\n-      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n-\n-      //Check if the expected values are available/not available in search result.\n-      expect(getByText('nutFreeName')).toBeInTheDocument();\n-      expect(getByText('NamePreferred')).toBeInTheDocument();\n-      expect(getByText('John')).toBeInTheDocument();\n-      expect(queryByText('proteinId')).not.toBeInTheDocument();\n-      expect(queryByText('proteinType')).not.toBeInTheDocument();\n-\n-      //Check if the entity properties are not affected by the filter on source table\n-      expect(getByText('propId')).toBeInTheDocument();\n-      expect(getByText('propName')).toBeInTheDocument();\n-      expect(getByText('artCraft')).toBeInTheDocument();\n-      expect(getByText('automobile')).toBeInTheDocument();\n+        //Reset the search filter on Source table\n+        fireEvent.click(filterIcon);\n+        let resetSearch = getByTestId('ResetSearch-key');\n+        fireEvent.click(resetSearch);\n+\n+        //Check if the table goes back to the default state after resetting the filter on source table.\n+        expect(getByText('proteinId')).toBeInTheDocument();\n+        expect(getByText('proteinType')).toBeInTheDocument();\n+        expect(getByText('withNutsOrganism')).toBeInTheDocument();\n+        expect(getByText('OrganismName')).toBeInTheDocument();\n+        expect(getByText('Frog virus 3')).toBeInTheDocument();\n+        expect(getByText('OrganismType')).toBeInTheDocument();\n+        expect(getByText('scientific')).toBeInTheDocument();\n+        expect(getByText('nutFreeName')).toBeInTheDocument();\n+        expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+        expect(getByText('John')).toBeInTheDocument();\n+        expect(queryByText('suffix')).not.toBeInTheDocument(); //This is not visible since only root and first level are expanded in the default state\n+\n+        /* Test filter on Entity table  */\n+\n+        //Updating expression for few fields to be validated later\n+        let exp = getByText('testNameInExp');\n+        fireEvent.change(exp, { target: { value: \"concat(propName,'-NEW')\" } });\n+        fireEvent.blur(exp);\n+        expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+\n+        //Moving along with the filter test\n+        let entityfilterIcon = getByTestId('filterIcon-name');\n+        fireEvent.click(entityfilterIcon);\n+        let inputSearchEntity = getByTestId('searchInput-name');\n+        fireEvent.change(inputSearchEntity, { target: { value: \"craft\" } }); //Enter a case-insensitive value in inputEntitySearch field\n+        expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+        expect(inputSearchEntity).toHaveValue('craft');\n+        fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+        //Check if the expected values are available/not available in search result.\n+        expect(getByText('items')).toBeInTheDocument();\n+        expect(getByText('itemTypes')).toBeInTheDocument();\n+        expect(getByText('itemCategory')).toBeInTheDocument();\n+        expect(getByText('Craft')).toBeInTheDocument();\n+        expect(queryByText('propId')).not.toBeInTheDocument();\n+        expect(queryByText('propName')).not.toBeInTheDocument();\n+        //productCategory should be visible and collapsed\n+        expect(getByText('productCategory')).toBeInTheDocument();\n+        expect(queryByText('speedometer')).not.toBeInTheDocument();\n+        expect(queryByText('windscreen')).not.toBeInTheDocument();\n+\n+        //Check if the source table properties are not affected by the filter on Entity table\n+        expect(getByText('proteinId')).toBeInTheDocument();\n+        expect(getByText('proteinType')).toBeInTheDocument();\n+        expect(getByText('nutFreeName')).toBeInTheDocument();\n+        expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+        expect(getByText('LastName')).toBeInTheDocument();\n+        expect(getByText('withNutsOrganism')).toBeInTheDocument();\n+        expect(getByText('OrganismName')).toBeInTheDocument();\n+        expect(getByText('Frog virus 3')).toBeInTheDocument();\n+        expect(getByText('OrganismType')).toBeInTheDocument();\n+        expect(getByText('scientific')).toBeInTheDocument();\n+        expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+        expect(getByText('John')).toBeInTheDocument();\n+        expect(queryByText('suffix')).not.toBeInTheDocument();\n \n-      //Reset the search filter on Source table\n-      fireEvent.click(filterIcon);\n-      let resetSearch = getByTestId('ResetSearch-key');\n-      fireEvent.click(resetSearch);\n+        //Reset the search filter on Entity table\n+        fireEvent.click(entityfilterIcon);\n+        let resetEntitySearch = getByTestId('ResetSearch-name');\n+        fireEvent.click(resetEntitySearch);\n \n-      //Check if the expected values are present now after resetting the filter on source table.\n-      expect(getByText('proteinId')).toBeInTheDocument();\n-      expect(getByText('proteinType')).toBeInTheDocument();\n+        //Check if the table goes back to the default state after resetting the filter on Entity table.\n+        expect(getByText('propId')).toBeInTheDocument();\n+        expect(getByText('propName')).toBeInTheDocument();\n+        expect(getByText('itemTypes')).toBeInTheDocument();\n+        expect(getByText('itemCategory')).toBeInTheDocument();\n+        expect(onClosestTableRow(getByText('artCraft'))?.style.display).toBe('none');\n+        expect(onClosestTableRow(getByText('automobile'))?.style.display).toBe('none');\n+        expect(getByText('productCategory')).toBeInTheDocument();\n+        expect(queryByText('speedometer')).not.toBeInTheDocument();\n+        expect(queryByText('windscreen')).not.toBeInTheDocument();\n+    });\n \n-      /* Test filter on Entity table  */\n+    test('Filtering of Name column in XML Source data', () => {\n \n-      //Updating expression for few fields to be validated later\n-      let exp = getByText('testNameInExp');\n-      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n-      fireEvent.blur(exp);\n-      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+        const { getByText, getByTestId, queryByText } = render(<SourceToEntityMap {...data.mapProps}\n+            mappingVisible={true}\n+            sourceData={data.xmlSourceDataMultipleSiblings}\n+            entityTypeProperties={data.entityTypePropertiesMultipleSiblings}\n+        />);\n+\n+        /* Test filter on Source table with XML data  */\n+        let filterIcon = getByTestId('filterIcon-key');\n+        fireEvent.click(filterIcon);\n+        let inputSearch = getByTestId('searchInput-key');\n+        expect(inputSearch).toBeInTheDocument();\n+        fireEvent.change(inputSearch, { target: { value: \"organism\" } }); //Enter a case-insensitive value in inputSearch field\n+        expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+        expect(inputSearch).toHaveValue('organism');\n+        fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+\n+        //Check if the expected values are available/not available in search result.\n+        expect(getByText(/withNuts:/)).toBeInTheDocument();\n+        expect(getByText('Frog virus 3')).toBeInTheDocument();\n+        expect(getByText('scientific')).toBeInTheDocument();\n+        expect(getByText(/nutFree:/)).toBeInTheDocument();\n+        expect(queryByText('NamePreferred')).not.toBeInTheDocument();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3Mzg1MA=="}, "originalCommit": {"oid": "b241ee6616feb777128bce95ffe712a123453614"}, "originalPosition": 187}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4126, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}