{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NDk0NDM1", "number": 3860, "title": "DHFPROD-3020: Filtering, Sorting in Source/Entity Mapping tables and Column Option Selector in Entity Table", "bodyText": "Description\nThis PR contains adds the Filtering and Sorting capability in Mapping Source and Entity tables.\nAlso adds a Column Option Selector for Entity table.\nChecklist:\n- Note: do not change the below\n\n\nOwner:\n\n\n JIRA_ID included in all the commit messages\n\n\n PR title is in the format JIRA_ID:Title\n\n\n Rebase the branch with upstream\n\n\n Squashed all commits into a single commit\n\n\n Added Tests\n\n\nReviewer:\n\n\n Reviewed Tests", "createdAt": "2020-04-22T19:32:23Z", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860", "merged": true, "mergeCommit": {"oid": "218165c9be6e471c2fa7fd53786a2691975c49e1"}, "closed": true, "closedAt": "2020-04-23T23:27:41Z", "author": {"login": "xnikhil08"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaOcgLgFqTM5ODU2NzI4MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaj-brgFqTM5OTQ5ODM0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTY3Mjgx", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398567281", "createdAt": "2020-04-22T20:37:55Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjM5MTUy", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398639152", "createdAt": "2020-04-22T22:38:41Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjY0Mjg3", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398664287", "createdAt": "2020-04-22T23:40:47Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzI3OTUy", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398727952", "createdAt": "2020-04-23T03:06:32Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzowNjozM1rOGKUhCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMzowNjozM1rOGKUhCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ3NTA4Mg==", "bodyText": "Can we update placeholder to be {Search ${dataIndex}} so its unique, ie Search key for source table and Search name for entity table, instead of using data-testid. We should use data-testid sparingly if there are other possible selectors.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413475082", "createdAt": "2020-04-23T03:06:33Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.tsx", "diffHunk": "@@ -304,46 +322,150 @@ const SourceToEntityMap = (props) => {\n         return mapStyle;\n     }\n \n+    //For filter search in source table\n+    let searchInput: any;\n+    //For Source Table\n+    const [searchSourceText,setSearchSourceText] = useState('');\n+    const [searchedSourceColumn,setSearchedSourceColumn] = useState('');\n+    //For Entity table\n+    const [searchEntityText,setSearchEntityText] = useState('');\n+    const [searchedEntityColumn,setSearchedEntityColumn] = useState('');\n+\n+    const handleColSearch = (selectedKeys, confirm, dataIndex) => {\n+        confirm();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText(selectedKeys[0]);\n+            setSearchedSourceColumn(dataIndex); \n+        } else {\n+            setSearchEntityText(selectedKeys[0]);\n+            setSearchedEntityColumn(dataIndex);\n+        }\n+      };\n+\n+    const handleSearchReset = (clearFilters,dataIndex) => {\n+        clearFilters();\n+        if(dataIndex === 'key'){\n+            setSearchSourceText('');\n+            setSearchedSourceColumn(''); \n+        } else {\n+            setSearchEntityText('');\n+            setSearchedEntityColumn('');\n+        }\n+    };\n+\n+    const getColumnFilterProps = dataIndex => ({\n+        filterDropdown: ({ setSelectedKeys, selectedKeys, confirm, clearFilters }) => (\n+            <div className={styles.filterContainer}>\n+                <Input\n+                    ref={node => {\n+                        searchInput = node;\n+                    }}\n+                    data-testid={`searchInput-${dataIndex}`}\n+                    placeholder={`Search name`}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzczNjI5", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398773629", "createdAt": "2020-04-23T05:41:51Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Nzg4MjYw", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398788260", "createdAt": "2020-04-23T06:18:38Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoxODozOFrOGKYZvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoxODozOFrOGKYZvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzODc1MQ==", "bodyText": "for an xml doc, first key itself should be a parent.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413538751", "createdAt": "2020-04-23T06:18:38Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/config/data.config.js", "diffHunk": "@@ -72,6 +72,32 @@ const mapProps = {\n     { key: '@proteinType', val: 'home' },\n     { key: 'nutFree:name', val: 'testName1' }\n   ],\n+  entityTypePropertiesUpdated : [\n+    { name: 'propId', type: 'int' },\n+    { name: 'propName', type: 'string' },\n+    {\n+      name: 'items', type: 'parent-ItemType [ ]', children: [\n+        { name: 'items/itemTypes', type: 'string' },\n+        {\n+          name: 'items/itemCategory', type: 'parent-catItem', children: [\n+            { name: 'items/itemCategory/artCraft', type: 'string' },\n+            { name: 'items/itemCategory/automobile', type: 'string' }\n+          ]\n+        }]\n+    },\n+    { name: 'gender', type: 'string' }\n+  ],\n+  sourceDataUpdated : [\n+    { key: 'proteinId', val: '123EAC' },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Nzg5MjU4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398789258", "createdAt": "2020-04-23T06:20:54Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyMDo1NVrOGKYdfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyMDo1NVrOGKYdfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzOTcxMA==", "bodyText": "need to repeat this test using proper xml doc and convert this one to use json doc.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413539710", "createdAt": "2020-04-23T06:20:55Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzkxMDU4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398791058", "createdAt": "2020-04-23T06:24:54Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDo1NFrOGKYkIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDo1NFrOGKYkIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0MTQxMQ==", "bodyText": "we can create and store json and xml source data outside of mapProps and default mapProps.sourceData to use json. This way for xml usecases we can simply say sourceData={data.xmlSourceData}. In other words all the overrides can stay outside of mapProps.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413541411", "createdAt": "2020-04-23T06:24:54Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODAzOTk5", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398803999", "createdAt": "2020-04-23T06:47:53Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0Nzo1M1rOGKZPDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0Nzo1M1rOGKZPDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MjM5OQ==", "bodyText": "fix typo in texting", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413552399", "createdAt": "2020-04-23T06:47:53Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODA2NTM1", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398806535", "createdAt": "2020-04-23T06:52:36Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1MjozN1rOGKZgew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1MjozN1rOGKZgew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Njg1OQ==", "bodyText": "fireEvent on exp would fail if it was not found in the DOM. So we can get rid of the assertion in line 131 and other similar assertions like this in the test, since they wont add any value to the test.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413556859", "createdAt": "2020-04-23T06:52:37Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODA4OTM4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398808938", "createdAt": "2020-04-23T06:57:01Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NzowMVrOGKZpYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NzowMVrOGKZpYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1OTEzOQ==", "bodyText": "can we check for column options toBeChecked instead.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413559139", "createdAt": "2020-04-23T06:57:01Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODI5OTE3", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398829917", "createdAt": "2020-04-23T07:30:54Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozMDo1NFrOGKaz0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozMDo1NFrOGKaz0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3ODE5NA==", "bodyText": "This works but if test data changes this wouldnt be reliable. An alternate suggestion is to check columns dont exist. Like so:\nlet entityTableHeaderRow = within(getByTestId('entityTableType').closest('tr'))\nexpect(entityTableHeaderRow.queryByText('Name')).not.toBeInTheDocument();\nexpect(entityTableHeaderRow.queryByText('XPath Expression')).not.toBeInTheDocument();\n\nThe same can be repurposed to verify they exist.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413578194", "createdAt": "2020-04-23T07:30:54Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column\n+\n+      //Confirm that the Name column is not visible in Entity table anymore.\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Uncheck Name column\n+\n+      //Confirm that the XPath Expression column(Along with Name Column) is not visible in Entity table anymore.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODMxNTQ3", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398831547", "createdAt": "2020-04-23T07:33:17Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozMzoxOFrOGKa5fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozMzoxOFrOGKa5fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3OTY0Nw==", "bodyText": "can add filtering and then uncheck to verify column doesnt exist and filter gets reset.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413579647", "createdAt": "2020-04-23T07:33:18Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODM0NTEy", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-398834512", "createdAt": "2020-04-23T07:37:37Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozNzozN1rOGKbD7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozNzozN1rOGKbD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4MjMxOQ==", "bodyText": "sorting is good.\nlike the spacing & grouping of columns, makes it readable. Goes well with \"Arrange, Act, Assert\" way of writing tests.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#discussion_r413582319", "createdAt": "2020-04-23T07:37:37Z", "author": {"login": "bsrikan"}, "path": "marklogic-data-hub-central/ui/src/components/entities/mapping/source-entity-map/source-to-entity-map.test.tsx", "diffHunk": "@@ -37,7 +38,225 @@ describe('RTL Source-to-entity map tests', () => {\n         fireEvent.click(getByText('Clear'));\n         expect(getByText('Clear')).toBeEnabled();\n         expect(getByText(\"concat(name,'-NEW')\")).toBeInTheDocument();\n-        console.log(container);\n+    });\n+\n+    test('Filtering Name column in Source and Entity tables',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      /* Test filter on Source table  */\n+      let filterIcon = getByTestId('filterIcon-key');\n+      expect(filterIcon).toBeInTheDocument();\n+      fireEvent.click(filterIcon);\n+      let inputSearch = getByTestId('searchInput-key');\n+      expect(inputSearch).toBeInTheDocument();\n+      fireEvent.change(inputSearch, { target: {value: \"first\" }}); //Enter a case-insensitive value in inputSearch field\n+      expect(getByTestId('submitSearch-key')).toBeInTheDocument();\n+      expect(inputSearch).toHaveValue('first');\n+      fireEvent.click(getByTestId('submitSearch-key')); //Click on Search button to apply the filter with the desired string\n+      \n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText(/nutFree:/)).toBeInTheDocument();\n+      expect(getByText('NamePreferred')).toBeInTheDocument();\n+      expect(getByText('John')).toBeInTheDocument();\n+      expect(queryByText('proteinId')).not.toBeInTheDocument(); \n+      expect(queryByText('@proteinType')).not.toBeInTheDocument();\n+\n+      //Check if the entity properties are not affected by the filter on source table\n+      expect(getByText('propId')).toBeInTheDocument();\n+      expect(getByText('propName')).toBeInTheDocument();\n+      expect(getByText('artCraft')).toBeInTheDocument();\n+      expect(getByText('automobile')).toBeInTheDocument();\n+\n+      //Reset the search filter on Source table\n+      fireEvent.click(filterIcon);\n+      let resetSearch = getByTestId('ResetSearch-key');\n+      expect(resetSearch).toBeInTheDocument();\n+      fireEvent.click(resetSearch);\n+\n+      //Check if the expected values are present now after resetting the filter on source table.\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      \n+\n+      /* Test filter on Entity table  */\n+      let entityfilterIcon = getByTestId('filterIcon-name');\n+      expect(entityfilterIcon).toBeInTheDocument();\n+      fireEvent.click(entityfilterIcon);\n+      let inputSearchEntity = getByTestId('searchInput-name');\n+      expect(inputSearchEntity).toBeInTheDocument();\n+      fireEvent.change(inputSearchEntity, { target: {value: \"craft\" }}); //Enter a case-insensitive value in inputEntitySearch field\n+      expect(getByTestId('submitSearch-name')).toBeInTheDocument();\n+      expect(inputSearchEntity).toHaveValue('craft');\n+      fireEvent.click(getByTestId('submitSearch-name')); //Click on Search button to apply the filter with the desired string\n+\n+      //Check if the expected values are available/not available in search result.\n+      expect(getByText('items')).toBeInTheDocument();\n+      expect(getByText('itemTypes')).toBeInTheDocument();\n+      expect(getByText('itemCategory')).toBeInTheDocument();\n+      expect(getByText('Craft')).toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument(); \n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Check if the source table properties are not affected by the filter on Entity table\n+      expect(getByText('proteinId')).toBeInTheDocument();\n+      expect(getByText('@proteinType')).toBeInTheDocument();\n+      expect(getByText('FirstNamePreferred')).toBeInTheDocument();\n+      expect(getByText('LastName')).toBeInTheDocument();\n+\n+       //Reset the search filter on Entity table\n+       fireEvent.click(entityfilterIcon);\n+       let resetEntitySearch = getByTestId('ResetSearch-name');\n+       expect(resetEntitySearch).toBeInTheDocument();\n+       fireEvent.click(resetEntitySearch);\n+ \n+       //Check if the expected values are present now after resetting the filter on Entity table.\n+       expect(getByText('propId')).toBeInTheDocument();\n+       expect(getByText('propName')).toBeInTheDocument();\n+    });\n+\n+    test('Column option selector in Entity table',() => {\n+      \n+      const { getByText,getByTestId,queryByText } = render(<SourceToEntityMap {...data.mapProps} \n+        mappingVisible={true} \n+        entityTypeProperties={data.mapProps.entityTypePropertiesUpdated} \n+        sourceData={data.mapProps.sourceDataUpdated}/>);\n+\n+      //Set the data for texting in xpath expression\n+\n+      let exp = getByText('testNameInExp');\n+      expect(exp).toBeInTheDocument();\n+      fireEvent.change(exp, { target: {value: \"concat(propName,'-NEW')\" }});\n+      fireEvent.blur(exp);\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+      \n+      /* Test column option selector in Entity table  */\n+      let colOptSelect = getByText('Column Options');\n+      expect(colOptSelect).toBeInTheDocument();\n+      fireEvent.click(colOptSelect);\n+      let Name = getByTestId('columnOptionsCheckBox-name');\n+      let Type = getByTestId('columnOptionsCheckBox-type');\n+      let XPathExpression = getByTestId('columnOptionsCheckBox-key');\n+      let Value = getByTestId('columnOptionsCheckBox-value');\n+      expect(Name).toBeInTheDocument();\n+      expect(Type).toBeInTheDocument();\n+      expect(XPathExpression).toBeInTheDocument();\n+      expect(Value).toBeInTheDocument();\n+\n+      fireEvent.click(Name); //Uncheck Name column\n+\n+      //Confirm that the Name column is not visible in Entity table anymore.\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Uncheck Name column\n+\n+      //Confirm that the XPath Expression column(Along with Name Column) is not visible in Entity table anymore.\n+      expect(queryByText(\"concat(propName,'-NEW')\")).not.toBeInTheDocument();\n+      expect(queryByText('propId')).not.toBeInTheDocument();\n+      expect(queryByText('propName')).not.toBeInTheDocument();\n+\n+      //Checking the columns one by one in selector and verify that they appear in entity table\n+      fireEvent.click(Name); //Check Name column\n+      //Props below should be available now\n+      expect(getByText('propId')).toBeInTheDocument(); \n+      expect(getByText('propName')).toBeInTheDocument();\n+\n+      fireEvent.click(XPathExpression); //Check XPathExpression column\n+      //Props below should be available now\n+      expect(getByText(\"concat(propName,'-NEW')\")).toBeInTheDocument();\n+\n+    });\n+\n+    test('Sorting in Source and Entity table',() => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzM2MzEy", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-399336312", "createdAt": "2020-04-23T17:48:04Z", "commit": {"oid": "18d60b37934ef7b46326d1f0e90e26c3858e5792"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ff56a3d080dccc7df1619ce80dcd122d29560f2", "author": {"user": {"login": "xnikhil08", "name": "Nikhil Shrivastava"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/8ff56a3d080dccc7df1619ce80dcd122d29560f2", "committedDate": "2020-04-23T21:26:54Z", "message": "DHFPROD-3020: Updated test data and fixed the corresponding tests"}, "afterCommit": {"oid": "babc49fa97f371422b1074eb7eb2d636e29da2e4", "author": {"user": {"login": "xnikhil08", "name": "Nikhil Shrivastava"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/babc49fa97f371422b1074eb7eb2d636e29da2e4", "committedDate": "2020-04-23T21:27:23Z", "message": "DHFPROD-3020: Updated test data and fixed the corresponding tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe0b78d4912196e890fead6db013c2912e5a1a4d", "author": {"user": {"login": "xnikhil08", "name": "Nikhil Shrivastava"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/fe0b78d4912196e890fead6db013c2912e5a1a4d", "committedDate": "2020-04-23T21:28:18Z", "message": "DHFPROD-3020: Filtering, Sorting in Source/Entity tables and Column Option Selector in Entity Table\nDHFPROD-3020: Updated test data and fixed the corresponding tests (+1 squashed commit)\nSquashed commits:\n[57153440c] DHFPROD-3020: Filtering, Sorting in Source/Entity tables and Column Option Selector in Entity Table\nDHFPROD-3020: Added Tests for Filtering , Sorting and Column Option Selector. Also fixed few issues in sorting. (+3 squashed commits)\nSquashed commits:\n[67c5c0970] DHFPROD-3020: Adding Filter capability for nested columns in Source and Entity tables\n[c65c6b233] DHFPROD-3020: Adding the filter capability in source and entity Name columns\n[41e1ee9ea] DHFPROD-3020: Added column options dropdown menu for entity table"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "babc49fa97f371422b1074eb7eb2d636e29da2e4", "author": {"user": {"login": "xnikhil08", "name": "Nikhil Shrivastava"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/babc49fa97f371422b1074eb7eb2d636e29da2e4", "committedDate": "2020-04-23T21:27:23Z", "message": "DHFPROD-3020: Updated test data and fixed the corresponding tests"}, "afterCommit": {"oid": "fe0b78d4912196e890fead6db013c2912e5a1a4d", "author": {"user": {"login": "xnikhil08", "name": "Nikhil Shrivastava"}}, "url": "https://github.com/marklogic/marklogic-data-hub/commit/fe0b78d4912196e890fead6db013c2912e5a1a4d", "committedDate": "2020-04-23T21:28:18Z", "message": "DHFPROD-3020: Filtering, Sorting in Source/Entity tables and Column Option Selector in Entity Table\nDHFPROD-3020: Updated test data and fixed the corresponding tests (+1 squashed commit)\nSquashed commits:\n[57153440c] DHFPROD-3020: Filtering, Sorting in Source/Entity tables and Column Option Selector in Entity Table\nDHFPROD-3020: Added Tests for Filtering , Sorting and Column Option Selector. Also fixed few issues in sorting. (+3 squashed commits)\nSquashed commits:\n[67c5c0970] DHFPROD-3020: Adding Filter capability for nested columns in Source and Entity tables\n[c65c6b233] DHFPROD-3020: Adding the filter capability in source and entity Name columns\n[41e1ee9ea] DHFPROD-3020: Added column options dropdown menu for entity table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDk1MTQ4", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-399495148", "createdAt": "2020-04-23T21:37:19Z", "commit": {"oid": "fe0b78d4912196e890fead6db013c2912e5a1a4d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDk4MzQ3", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3860#pullrequestreview-399498347", "createdAt": "2020-04-23T21:42:59Z", "commit": {"oid": "fe0b78d4912196e890fead6db013c2912e5a1a4d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3083, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}