{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NTgzNTEx", "number": 3862, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjowMzowNVrOD1DbHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo1MTo0NVrOD2IzkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTU3MjE0OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.api", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjowMzowNVrOGKTQ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzowNTo0MVrOGKyx2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NDU2Mw==", "bodyText": "For consistency, the functionName should be the same  as the filename, minus \".api\".", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413454563", "createdAt": "2020-04-23T02:03:05Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.api", "diffHunk": "@@ -0,0 +1,37 @@\n+{\n+    \"functionName\": \"getOpticPlan\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MDkwNQ==", "bodyText": "Got it.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413970905", "createdAt": "2020-04-23T17:05:41Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.api", "diffHunk": "@@ -0,0 +1,37 @@\n+{\n+    \"functionName\": \"getOpticPlan\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NDU2Mw=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTU3NjczOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjowNDo1OFrOGKTTVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzowNzoyM1rOGKy2zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTE5MQ==", "bodyText": "This is not likely to work in DHS, as we don't know the group name. Today, in a typical DHS setup, there are 4 other groups, and Default is not used at all.\nInstead of depending on an options document to exist, what if we generate this based on the entity name? hub-entities.xqy provides a nice function for generating this.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413455191", "createdAt": "2020-04-23T02:04:58Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NDk4Mg==", "bodyText": "Another option would be to use http://docs.marklogic.com/xdmp.groupName which doesn't require any special permissions.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413954982", "createdAt": "2020-04-23T16:43:06Z", "author": {"login": "ryanjdew"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTE5MQ=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MjE3NA==", "bodyText": "Right, I completely forgot about the groups. We need to rework this.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413972174", "createdAt": "2020-04-23T17:07:23Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTE5MQ=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTU3OTIwOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjowNjowNVrOGKTUqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzowNjowM1rOGKyy7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTUzMA==", "bodyText": "Pinging @ryanjdew - should this be in XQuery instead of SJS? I ask that because we're dealing with a lot of XML here, and that's of course more difficult to do in SJS vs XQuery.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413455530", "createdAt": "2020-04-23T02:06:05Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0OTc2Nw==", "bodyText": "@rjrudin I'm fine with having this in JavaScript. I recommended to @akshaysonvane that we call XSLT from JavaScript. @akshaysonvane, for readability, can we adjust this to use template literals for multiline strings? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413949767", "createdAt": "2020-04-23T16:35:49Z", "author": {"login": "ryanjdew"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTUzMA=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTE4Mw==", "bodyText": "Sure, @ryanjdew.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413971183", "createdAt": "2020-04-23T17:06:03Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTUzMA=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTU4MTc2OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjowNzowN1rOGKTV-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzoyOTowM1rOGKzxmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTg2Nw==", "bodyText": "Given that we need an amp plus a separate module, which then has to invoke a function in the modules database for a document whose URI will be dependent on the groups - I think we should just generate these on the fly. Check out hub-entities.xqy.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413455867", "createdAt": "2020-04-23T02:07:07Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var columns = xdmp.getRequestField(\"columns\");\n+\n+structQuery = fn.head(xdmp.unquote(structQuery)).root;\n+searchQText = searchQText || \"\";\n+\n+const oldOptions = options.getSearchOptions(entityOptionsFileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTY2MQ==", "bodyText": "My understanding was that a user is free to edit the search options file.\nDo we still allow a user to edit the options file for HC?\nAnother alternative here could be to perform the search operation from the java middle-tier. Though it would increase a request, it would make sure that we use the correct search options file.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413971661", "createdAt": "2020-04-23T17:06:40Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var columns = xdmp.getRequestField(\"columns\");\n+\n+structQuery = fn.head(xdmp.unquote(structQuery)).root;\n+searchQText = searchQText || \"\";\n+\n+const oldOptions = options.getSearchOptions(entityOptionsFileName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTg2Nw=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4NzIyNg==", "bodyText": "If the user does edit the options file, it'll get overwritten when an entity model is modified.\nI like the idea of having the middle tier fetch the options and then pass them to the DS endpoint. That way, the endpoint doesn't have to worry about what group to use when finding the options.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413987226", "createdAt": "2020-04-23T17:29:03Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/opticPlanExportService.sjs", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+const options = require(\"/data-hub/5/impl/hub-utils/invoke-search-options.sjs\");\n+\n+const returnFlags = '<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\\n' +\n+  '<return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\\n' +\n+  '<return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\\n' +\n+  '<return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\\n' +\n+  '<return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\\n' +\n+  '<return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\\n' +\n+  '<return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\\n' +\n+  '<return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\\n' +\n+  '<return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\\n' +\n+  '<return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\\n' +\n+  '<return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>\\n';\n+\n+const stylesheet = fn.head(xdmp.unquote('<xsl:stylesheet version=\"1.0\"\\n' +\n+  ' xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"node()|@*\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\"/>\\n' +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\\n' +\n+  '\\n' +\n+  ' <xsl:template match=\"*:options\">\\n' +\n+  '  <xsl:copy>\\n' +\n+  '   <xsl:apply-templates select=\"node()|@*\" />\\n' +\n+  returnFlags +\n+  '  </xsl:copy>\\n' +\n+  ' </xsl:template>\\n' +\n+  '\\n' +\n+  '</xsl:stylesheet>'));\n+\n+const entityOptionsFileName = '/Default/data-hub-FINAL/rest-api/options/exp-final-entity-options.xml';\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var columns = xdmp.getRequestField(\"columns\");\n+\n+structQuery = fn.head(xdmp.unquote(structQuery)).root;\n+searchQText = searchQText || \"\";\n+\n+const oldOptions = options.getSearchOptions(entityOptionsFileName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1NTg2Nw=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTU5OTIyOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjoxNToxNVrOGKTfjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzowNjo0OVrOGKy1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODMxNg==", "bodyText": "I've worked on projects before where we create a lot of test files that are stored in version control, and it can quickly become difficult to manage. I think it's far better in the long term to write a simple program to generate documents in memory and write them to ML. It's fewer files in version control, and it's easier to change.\nRight now, it doesn't look like the test cares what's in the documents, though I think it should - shouldn't it be verifying that the correct value is present in each column in each row?\nFor that reason, I would only insert 2 test documents (generally, there's zero, there's 1, and then there's 2 or more). And I'd only request maybe 3 columns. Now you only need to verify 6 values. And since you have 2 test documents, you can have a separate test that passes in a limit of 1, and you can verify you only get 1 row back.\nWith that in mind, I'd design a bare minimum test document - no headers, no triples, no attachments. And if you're only requesting 3 properties, I'd populate 4 total properties - that allows you to verify that when you ask for 3 of them, you don't get the 4th. Then, make a simple method in here that allows you to insert a document with 3 known values.\nAlso, let's use the entity-reference-model project. The Customer entity has three atomic properties so far - customerId, name, and customerSince. Feel free to add a fourth atomic property for your test. That avoids having to create a new example project, and the more tests we have using the same sample project, the easier it is to understand the tests.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413458316", "createdAt": "2020-04-23T02:15:15Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +77,122 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installExportProject();\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Order\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Order\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"sku\\\",\\n\" +\n+            \"            \\\"title\\\",\\n\" +\n+            \"            \\\"price\\\",\\n\" +\n+            \"            \\\"discounted-price\\\",\\n\" +\n+            \"            \\\"order-date\\\",\\n\" +\n+            \"            \\\"ship-date\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 5;\n+        int headerRow = 1;\n+        int totalColumns = 6;\n+        int totalRows = limit + headerRow;\n+\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+    }\n+\n+    private void installExportProject() throws IOException {\n+        String projectFolder = \"test-projects/export-project\";\n+        installProjectInFolder(projectFolder);\n+        entityManager.deployQueryOptions();\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(\"Order\")\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        GenericDocumentManager finalDocMgr = getHubConfig().newFinalClient().newDocumentManager();\n+        DocumentWriteSet writeSet = finalDocMgr.newWriteSet();\n+        File inputDir = new ClassPathResource(projectFolder + \"/input\").getFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTc3Ng==", "bodyText": "Makes sense. I'll update the tests.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413971776", "createdAt": "2020-04-23T17:06:49Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +77,122 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installExportProject();\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Order\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Order\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"sku\\\",\\n\" +\n+            \"            \\\"title\\\",\\n\" +\n+            \"            \\\"price\\\",\\n\" +\n+            \"            \\\"discounted-price\\\",\\n\" +\n+            \"            \\\"order-date\\\",\\n\" +\n+            \"            \\\"ship-date\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 5;\n+        int headerRow = 1;\n+        int totalColumns = 6;\n+        int totalRows = limit + headerRow;\n+\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), params)\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+                assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+            });\n+    }\n+\n+    private void installExportProject() throws IOException {\n+        String projectFolder = \"test-projects/export-project\";\n+        installProjectInFolder(projectFolder);\n+        entityManager.deployQueryOptions();\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(\"Order\")\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        GenericDocumentManager finalDocMgr = getHubConfig().newFinalClient().newDocumentManager();\n+        DocumentWriteSet writeSet = finalDocMgr.newWriteSet();\n+        File inputDir = new ClassPathResource(projectFolder + \"/input\").getFile();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODMxNg=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTYwMjYxOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMjoxNjoyOVrOGKThVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNToyMFrOGL9NWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA==", "bodyText": "Is there something under src/main/java that needs this? The only reference I saw to \"async\" is in EntitySearchControllerTest.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413458774", "createdAt": "2020-04-23T02:16:29Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MjAwNA==", "bodyText": "We need this since we are using a StreamingResponseBody for asynchronous request processing.\nStreamingResponseBody by default uses a SimpleAsyncTaskExecutor which does not reuse threads, as a result, its advisable to provide our own TaskExecutor.\nAlso, this allows us to configure the Default Timeout which at this point is 10 minutes.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r413972004", "createdAt": "2020-04-23T17:07:08Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjMwOQ==", "bodyText": "I think this method needs to make that clear. Spring is great at making it easy to setup useful, reusable stuff, but the few lines of code required to do so often beg the question of - \"Why is this being configured?\"\nThe method name is usually a good way to answer that question - e.g. \"configureAsyncProcessingForStreamingResponses\". Each setting needs a comment as well - why 10 threads? Why 10 minutes? Why did we choose those numbers? 3 months from now, someone will look at this code and wonder why these settings were chosen.\nI also think it's worth explicitly identifying the feature this is for - i.e. exporting entities. That may expand in the future - i.e. when we support exporting other results.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415086309", "createdAt": "2020-04-25T15:36:59Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDM2MA==", "bodyText": "Makes sense. I'll add the code comments.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190360", "createdAt": "2020-04-26T02:05:20Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/WebMvcConfig.java", "diffHunk": "@@ -44,4 +46,14 @@ protected Resource getResource(String resourcePath, Resource location)\n                 }\n             });\n     }\n+\n+    @Override\n+    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1ODc3NA=="}, "originalCommit": {"oid": "5509ea3767fcc4714b3c1b65fd58f7be467f851f"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkxOTcyOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTozODo1M1rOGL24Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNjowMVrOGL9NpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjYzMQ==", "bodyText": "Looking at this, it does seem like there's a chance for a null pointer. How about \"searchQuery.hasEntityTypeIds()\"? That results in less work for the controller, and that method can be coded to ensure an NPE can't occur.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415086631", "createdAt": "2020-04-25T15:38:53Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -100,7 +112,7 @@ public StringHandle search(SearchQuery searchQuery) {\n         }\n         catch (MarkLogicServerException e) {\n             // If there are no entityModels to search, then we expect an error because no search options will exist\n-            if(searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {\n+            if (searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDQzNw==", "bodyText": "Since the models have been designed to initialize these objects in the constructor it won't throw an NPE.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190437", "createdAt": "2020-04-26T02:06:01Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -100,7 +112,7 @@ public StringHandle search(SearchQuery searchQuery) {\n         }\n         catch (MarkLogicServerException e) {\n             // If there are no entityModels to search, then we expect an error because no search options will exist\n-            if(searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {\n+            if (searchQuery.getQuery().getEntityTypeIds().isEmpty() || modelManager.getModels().size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NjYzMQ=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkyMzQ3OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo0MToyNlrOGL25zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNjowOFrOGL9NyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzA1Mg==", "bodyText": "Why is this here? I don't think any post-commit triggers fire when entity instances are saved?", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087052", "createdAt": "2020-04-25T15:41:26Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDQ3Mw==", "bodyText": "Right, this needs to go. I missed that while refactoring the code.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190473", "createdAt": "2020-04-26T02:06:08Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzA1Mg=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkyNDYxOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo0MTo1N1rOGL26SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNjoxOFrOGL9OEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzE3Ng==", "bodyText": "Nice - is this verifying that the async support is configured correctly then?", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087176", "createdAt": "2020-04-25T15:41:57Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDU0NQ==", "bodyText": "Yes, request().asyncStarted() checks for the async support.\ngetAsyncResult() is needed to wait for the async result to return.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190545", "createdAt": "2020-04-26T02:06:18Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzE3Ng=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkyNzU4OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo0NDowMVrOGL27lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNjozMlrOGL9ONA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzUwOA==", "bodyText": "This is reusable stuff that is worth adding to the ReferenceModelProject class.\nThe current \"createCustomer\" method in there is for \"raw\" customers. I think it's worth renaming that to \"createRawCustomer\", and then this can become \"createCustomerInstance\", which makes it clear we're creating entity instances here.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087508", "createdAt": "2020-04-25T15:44:01Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDU4MA==", "bodyText": "To the ReferenceModelProject this goes then.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190580", "createdAt": "2020-04-26T02:06:32Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzUwOA=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkyOTM0OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo0NToyOFrOGL28YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNjo0M1rOGL9OYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzcxMg==", "bodyText": "This can move to the testFixture source set in core DH too. Make it a regular public class though, with private fields and getters/setters, as we can use Jackson to generate JSON for it automatically, which will save some effort. We'll likely add more to this class so to make writing tests easier as we go.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087712", "createdAt": "2020-04-25T15:45:28Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {\n+        String customerEntityType = \"Customer\";\n+\n+        JSONDocumentManager mgr = getHubConfig().newFinalClient().newJSONDocumentManager();\n+        ObjectNode customerProps = objectMapper.createObjectNode();\n+        customerProps.put(\"customerId\", customer.customerId);\n+        customerProps.put(\"name\", customer.name);\n+        customerProps.put(\"customerNumber\", customer.customerNumber);\n+        customerProps.put(\"customerSince\", customer.customerSince);\n+\n+        ObjectNode infoProp = objectMapper.createObjectNode();\n+        infoProp.put(\"title\", customerEntityType);\n+        infoProp.put(\"version\", \"0.0.1\");\n+        infoProp.put(\"baseUri\", \"http://example.org/\");\n+\n+        ObjectNode instanceProps = objectMapper.createObjectNode();\n+        instanceProps.set(\"info\", infoProp);\n+        instanceProps.set(customerEntityType, customerProps);\n+\n+        ObjectNode instance = objectMapper.createObjectNode().set(\"instance\", instanceProps);\n+        ObjectNode envelope = objectMapper.createObjectNode().set(\"envelope\", instance);\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(customerEntityType)\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        mgr.write(\"/\" + customerEntityType + customer.customerId + \".json\", metadata, new JacksonHandle(envelope));\n+    }\n+\n+    private Set<Integer> calculateHash(String csvData) throws IOException {\n+        Set<Integer> rowSet = new HashSet<>();\n+\n+        try (BufferedReader reader = new BufferedReader(new StringReader(csvData))) {\n+            String line = reader.readLine();\n+            while (line != null) {\n+                line = line.replaceAll(\",\", \"\");\n+                rowSet.add(line.hashCode());\n+                line = reader.readLine();\n+            }\n+        }\n+\n+        return rowSet;\n+    }\n+\n+    private MultiValueMap<String, String> getRequestParams(int limit, String json) {\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        return params;\n+    }\n+\n+    static class Customer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDYyNg==", "bodyText": "Will do.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190626", "createdAt": "2020-04-26T02:06:43Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/test/java/com/marklogic/hub/central/controllers/EntitySearchControllerTest.java", "diffHunk": "@@ -57,30 +71,198 @@ void testCRUDOnSavedQuery() throws Exception {\n         MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n         params.add(\"id\", savedQueryResponse.get(\"savedQuery\").get(\"id\").asText());\n \n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n-                });\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertEquals(savedQueryResponse.get(\"savedQuery\").get(\"id\").asText(), response.get(\"savedQuery\").get(\"id\").asText());\n+            });\n \n         // testing get all savedQuery documents\n         getJson(SAVED_QUERIES_PATH, new LinkedMultiValueMap<>())\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n-                    assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n-                });\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ArrayNode response = readJsonArray(result.getResponse().getContentAsString());\n+                assertTrue(response.size() > 0, \"There should be at least one saved query document\");\n+            });\n \n         // testing delete savedQuery document\n-        deleteJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isNoContent());\n-\n-        getJson(SAVED_QUERIES_PATH+\"/query\", params)\n-                .andExpect(status().isOk())\n-                .andDo(result -> {\n-                    ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n-                    assertTrue(response.isEmpty());\n-                });\n+        deleteJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isNoContent());\n+\n+        getJson(SAVED_QUERIES_PATH + \"/query\", params)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                ObjectNode response = readJsonObject(result.getResponse().getContentAsString());\n+                assertTrue(response.isEmpty());\n+            });\n+    }\n+\n+\n+    @Test\n+    void testRowExport() throws Exception {\n+        installReferenceProject(true);\n+\n+        Customer customer1 = new Customer(1, \"Jane\", 123456789, \"2012-05-16\");\n+        Customer customer2 = new Customer(2, \"John\", 987654321, \"2013-06-16\");\n+        createCustomer(customer1);\n+        createCustomer(customer2);\n+\n+        waitForTasksToFinish();\n+\n+        loginAsUser(TestConstants.OPERATOR_USERNAME);\n+\n+        String json = \"{\\n\" +\n+            \"    \\\"savedQuery\\\": {\\n\" +\n+            \"        \\\"id\\\": \\\"\\\",\\n\" +\n+            \"        \\\"name\\\": \\\"some-query\\\",\\n\" +\n+            \"        \\\"description\\\": \\\"some-query-description\\\",\\n\" +\n+            \"        \\\"query\\\": {\\n\" +\n+            \"            \\\"searchText\\\": \\\"\\\",\\n\" +\n+            \"            \\\"entityTypeIds\\\": [\\n\" +\n+            \"                \\\"Customer\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"selectedFacets\\\": {\\n\" +\n+            \"                \\\"Collection\\\": {\\n\" +\n+            \"                    \\\"dataType\\\": \\\"xs:string\\\",\\n\" +\n+            \"                    \\\"stringValues\\\": [\\n\" +\n+            \"                        \\\"Customer\\\"\\n\" +\n+            \"                    ]\\n\" +\n+            \"                }\\n\" +\n+            \"            }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"propertiesToDisplay\\\": [\\n\" +\n+            \"            \\\"customerId\\\",\\n\" +\n+            \"            \\\"name\\\",\\n\" +\n+            \"            \\\"customerNumber\\\"\\n\" +\n+            \"        ]\\n\" +\n+            \"    }\\n\" +\n+            \"}\";\n+\n+        int limit = 2;\n+        int totalColumns = 3;\n+\n+        // Export using query document\n+        postWithParams(EXPORT_PATH, getRequestParams(limit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+        postJson(SAVED_QUERIES_PATH, json)\n+            .andExpect(status().isCreated())\n+            .andDo(result -> savedQueryResponse = readJsonObject(result.getResponse().getContentAsString()));\n+\n+        // Export using queryId\n+        getJson(EXPORT_PATH + \"/query/\" + savedQueryResponse.get(\"savedQuery\").get(\"id\").textValue(), getRequestParams(limit, null))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(limit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()));\n+                assertTrue(actualRowSet.contains(customer2.getHashCode()));\n+            });\n+\n+\n+        // test limit\n+        int newLimit = 1;\n+        postWithParams(EXPORT_PATH, getRequestParams(newLimit, json))\n+            .andExpect(request().asyncStarted())\n+            .andDo(MvcResult::getAsyncResult)\n+            .andExpect(status().isOk())\n+            .andDo(result -> {\n+                String response = result.getResponse().getContentAsString();\n+                Set<Integer> actualRowSet = calculateHash(response);\n+                assertRowsAndColumns(newLimit, totalColumns, response);\n+                assertTrue(actualRowSet.contains(customer1.getHashCode()) || actualRowSet.contains(customer2.getHashCode()));\n+            });\n+    }\n+\n+    private void assertRowsAndColumns(int limit, int totalColumns, String response) {\n+        int headerRow = 1;\n+        int totalRows = limit + headerRow;\n+\n+        assertEquals(totalRows, response.chars().filter(i -> i == '\\n').count() + 1);\n+        assertEquals(totalColumns, response.substring(0, response.indexOf(\"\\n\")).chars().filter(i -> i == ',').count() + 1);\n+    }\n+\n+    private void createCustomer(Customer customer) {\n+        String customerEntityType = \"Customer\";\n+\n+        JSONDocumentManager mgr = getHubConfig().newFinalClient().newJSONDocumentManager();\n+        ObjectNode customerProps = objectMapper.createObjectNode();\n+        customerProps.put(\"customerId\", customer.customerId);\n+        customerProps.put(\"name\", customer.name);\n+        customerProps.put(\"customerNumber\", customer.customerNumber);\n+        customerProps.put(\"customerSince\", customer.customerSince);\n+\n+        ObjectNode infoProp = objectMapper.createObjectNode();\n+        infoProp.put(\"title\", customerEntityType);\n+        infoProp.put(\"version\", \"0.0.1\");\n+        infoProp.put(\"baseUri\", \"http://example.org/\");\n+\n+        ObjectNode instanceProps = objectMapper.createObjectNode();\n+        instanceProps.set(\"info\", infoProp);\n+        instanceProps.set(customerEntityType, customerProps);\n+\n+        ObjectNode instance = objectMapper.createObjectNode().set(\"instance\", instanceProps);\n+        ObjectNode envelope = objectMapper.createObjectNode().set(\"envelope\", instance);\n+\n+        DocumentMetadataHandle metadata = new DocumentMetadataHandle()\n+            .withCollections(customerEntityType)\n+            .withPermission(\"data-hub-operator\", DocumentMetadataHandle.Capability.READ, DocumentMetadataHandle.Capability.UPDATE);\n+        mgr.write(\"/\" + customerEntityType + customer.customerId + \".json\", metadata, new JacksonHandle(envelope));\n+    }\n+\n+    private Set<Integer> calculateHash(String csvData) throws IOException {\n+        Set<Integer> rowSet = new HashSet<>();\n+\n+        try (BufferedReader reader = new BufferedReader(new StringReader(csvData))) {\n+            String line = reader.readLine();\n+            while (line != null) {\n+                line = line.replaceAll(\",\", \"\");\n+                rowSet.add(line.hashCode());\n+                line = reader.readLine();\n+            }\n+        }\n+\n+        return rowSet;\n+    }\n+\n+    private MultiValueMap<String, String> getRequestParams(int limit, String json) {\n+        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"fileType\", \"csv\");\n+        params.add(\"limit\", String.valueOf(limit));\n+        params.add(\"queryDocument\", json);\n+\n+        return params;\n+    }\n+\n+    static class Customer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4NzcxMg=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkzMDgzOnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/test/resources/test-projects/reference-project/entities/Customer.entity.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo0NjoxOVrOGL29Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjoxMTo1OVrOGL9Rdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4Nzg4Mw==", "bodyText": "Just an FYI, we have the reference project in both core and central - I'll get that resolved soon, as central can definitely reuse the one in core.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415087883", "createdAt": "2020-04-25T15:46:19Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/test/resources/test-projects/reference-project/entities/Customer.entity.json", "diffHunk": "@@ -10,6 +10,9 @@\n         \"name\"\n       ],\n       \"properties\": {\n+        \"customerId\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MTQxNQ==", "bodyText": "Updated the hub central code and tests to use the reference model project from the core.\nI haven't deleted the project since there's a test that does use the flows and other configs from the HC's reference project and I didn't want to copy all of that baggage over to the reference model project in the core.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415191415", "createdAt": "2020-04-26T02:11:59Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/test/resources/test-projects/reference-project/entities/Customer.entity.json", "diffHunk": "@@ -10,6 +10,9 @@\n         \"name\"\n       ],\n       \"properties\": {\n+        \"customerId\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4Nzg4Mw=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkzNDY3OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo0ODo0NFrOGL2-wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNzowNVrOGL9OjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODMyMg==", "bodyText": "I think we need to catch an exception here in case the options exist. They should exist - but if they don't, the user is going to get an error they likely won't understand and I'll probably get pinged with a message saying that Gradle is broken.\nSo use a try/catch here to catch an exception if the options don't exist, and rethrow the error with a message of e.g. \"Could not find search options: (name); system is not configured correctly, please contact a system administrator\".", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415088322", "createdAt": "2020-04-25T15:48:44Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -278,6 +290,126 @@ protected String buildSearchOptions(String query, SearchQuery searchQuery) {\n         return sb.toString();\n     }\n \n+    public void exportById(String queryId, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        JsonNode queryDocument = EntitySearchService.on(finalDataServiceClient).getSavedQuery(queryId);\n+        exportByQuery(queryDocument, fileType, limit, out, response);\n+    }\n+\n+    public void exportByQuery(JsonNode queryDocument, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        if (\"CSV\".equals(fileType.toUpperCase())) {\n+            prepareResponseHeader(response, CSV_CONTENT_TYPE, getFileNameForDownload(queryDocument, CSV_FILE_EXTENSION));\n+            exportRows(queryDocument, limit, out);\n+        }\n+        else {\n+            throw new DataHubException(\"Invalid file type: \" + fileType);\n+        }\n+    }\n+\n+    public void exportRows(JsonNode queryDocument, Long limit, OutputStream out) {\n+        QueryManager queryMgr = finalDatabaseClient.newQueryManager();\n+        SearchQuery searchQuery = transformToSearchQuery(queryDocument);\n+        StructuredQueryDefinition structuredQueryDefinition = buildQuery(queryMgr, searchQuery);\n+\n+        String structQuery = structuredQueryDefinition.serialize();\n+        String searchQText = searchQuery.getQuery().getSearchText();\n+        String queryOptions = finalDatabaseClient.newServerConfigManager().newQueryOptionsManager().readOptionsAs(QUERY_OPTIONS, Format.XML, String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDY2OA==", "bodyText": "Good catch. I'll catch the exception.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190668", "createdAt": "2020-04-26T02:07:05Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub-central/src/main/java/com/marklogic/hub/central/managers/EntitySearchManager.java", "diffHunk": "@@ -278,6 +290,126 @@ protected String buildSearchOptions(String query, SearchQuery searchQuery) {\n         return sb.toString();\n     }\n \n+    public void exportById(String queryId, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        JsonNode queryDocument = EntitySearchService.on(finalDataServiceClient).getSavedQuery(queryId);\n+        exportByQuery(queryDocument, fileType, limit, out, response);\n+    }\n+\n+    public void exportByQuery(JsonNode queryDocument, String fileType, Long limit, OutputStream out, HttpServletResponse response) {\n+        if (\"CSV\".equals(fileType.toUpperCase())) {\n+            prepareResponseHeader(response, CSV_CONTENT_TYPE, getFileNameForDownload(queryDocument, CSV_FILE_EXTENSION));\n+            exportRows(queryDocument, limit, out);\n+        }\n+        else {\n+            throw new DataHubException(\"Invalid file type: \" + fileType);\n+        }\n+    }\n+\n+    public void exportRows(JsonNode queryDocument, Long limit, OutputStream out) {\n+        QueryManager queryMgr = finalDatabaseClient.newQueryManager();\n+        SearchQuery searchQuery = transformToSearchQuery(queryDocument);\n+        StructuredQueryDefinition structuredQueryDefinition = buildQuery(queryMgr, searchQuery);\n+\n+        String structQuery = structuredQueryDefinition.serialize();\n+        String searchQText = searchQuery.getQuery().getSearchText();\n+        String queryOptions = finalDatabaseClient.newServerConfigManager().newQueryOptionsManager().readOptionsAs(QUERY_OPTIONS, Format.XML, String.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODMyMg=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MDkzOTY4OnYy", "diffSide": "RIGHT", "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/getOpticPlan.sjs", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxNTo1MTo0NVrOGL3A9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjowNzozNVrOGL9OtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODg4NA==", "bodyText": "I think you can define the DS API with queryOptions as type = jsonDocument, and then pass (hopefully) a JacksonHandle into it in the Java code. Same goes for the structQuery - if these are JSON objects, let's have a richer interface than using \"String\".\nAlso, \"searchText\" is widely used as the parameter name for a user's search text, so let's use that instead of \"searchQText\".\nOne other nit - generally, I'm opposed to abbreviating words unless there's a really, really good reason. So let's say \"structuredQuery\" instead of \"structQuery\".", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415088884", "createdAt": "2020-04-25T15:51:45Z", "author": {"login": "rjrudin"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/getOpticPlan.sjs", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+\n+const returnFlags = `<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\n+  <return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\n+  <return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\n+  <return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\n+  <return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\n+  <return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\n+  <return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\n+  <return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\n+  <return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\n+  <return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\n+  <return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>`;\n+\n+const stylesheet = fn.head(xdmp.unquote(`<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n+   <xsl:template match=\"node()|@*\">\n+      <xsl:copy>\n+         <xsl:apply-templates select=\"node()|@*\" />\n+      </xsl:copy>\n+   </xsl:template>\n+   <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\n+   <xsl:template match=\"*:options\">\n+      <xsl:copy>\n+         <xsl:apply-templates select=\"node()|@*\" />\n+         ${returnFlags}\n+      </xsl:copy>\n+   </xsl:template>\n+</xsl:stylesheet>`));\n+\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var queryOptions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5MDcwOA==", "bodyText": "Both of them are XML docs which I get as a String from the relevant methods in the middle tier.\nConverting them to an Object would mean a lot of unnecessary serialization/deserialization at both ends of the wire.", "url": "https://github.com/marklogic/marklogic-data-hub/pull/3862#discussion_r415190708", "createdAt": "2020-04-26T02:07:35Z", "author": {"login": "akshaysonvane"}, "path": "marklogic-data-hub/src/main/resources/ml-modules/root/data-hub/5/data-services/entitySearch/getOpticPlan.sjs", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+  Copyright (c) 2020 MarkLogic Corporation\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+     http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+*/\n+'use strict';\n+\n+const op = require('/MarkLogic/optic');\n+const search = require('/MarkLogic/appservices/search/search');\n+\n+const returnFlags = `<return-aggregates xmlns=\"http://marklogic.com/appservices/search\">false</return-aggregates>\n+  <return-constraints xmlns=\"http://marklogic.com/appservices/search\">false</return-constraints>\n+  <return-facets xmlns=\"http://marklogic.com/appservices/search\">false</return-facets>\n+  <return-frequencies xmlns=\"http://marklogic.com/appservices/search\">false</return-frequencies>\n+  <return-metrics xmlns=\"http://marklogic.com/appservices/search\">false</return-metrics>\n+  <return-plan xmlns=\"http://marklogic.com/appservices/search\">false</return-plan>\n+  <return-qtext xmlns=\"http://marklogic.com/appservices/search\">false</return-qtext>\n+  <return-results xmlns=\"http://marklogic.com/appservices/search\">false</return-results>\n+  <return-similar xmlns=\"http://marklogic.com/appservices/search\">false</return-similar>\n+  <return-values xmlns=\"http://marklogic.com/appservices/search\">false</return-values>\n+  <return-query xmlns=\"http://marklogic.com/appservices/search\">true</return-query>`;\n+\n+const stylesheet = fn.head(xdmp.unquote(`<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n+   <xsl:template match=\"node()|@*\">\n+      <xsl:copy>\n+         <xsl:apply-templates select=\"node()|@*\" />\n+      </xsl:copy>\n+   </xsl:template>\n+   <xsl:template match=\"*:return-aggregates|*:return-constraints|*:return-facets|*:return-frequencies|*:return-metrics|*:return-plan|*:return-qtext|*:return-results|*:return-similar|*:return-values|*:return-query\" />\n+   <xsl:template match=\"*:options\">\n+      <xsl:copy>\n+         <xsl:apply-templates select=\"node()|@*\" />\n+         ${returnFlags}\n+      </xsl:copy>\n+   </xsl:template>\n+</xsl:stylesheet>`));\n+\n+\n+var viewName;\n+var schemaName;\n+var limit;\n+var structQuery;\n+var searchQText;\n+var queryOptions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4ODg4NA=="}, "originalCommit": {"oid": "e393bb174cc60ae6fca374d2012615a13c59098e"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3439, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}