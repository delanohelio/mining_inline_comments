{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MjI4NjA5", "number": 1119, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjowMToyN1rODZMAlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwOToxMDoyNFrODbJS7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NzM3NzQ4OnYy", "diffSide": "RIGHT", "path": "iidm/iidm-api/src/main/java/com/powsybl/iidm/network/NetworkFactory.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMjowMToyN1rOFfcMCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwOTowNTo0N1rOFfynug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxMjAwOQ==", "bodyText": "Should you name the property default? Isn't impl more understandable for example?", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r368512009", "createdAt": "2020-01-20T12:01:27Z", "author": {"login": "miovd"}, "path": "iidm/iidm-api/src/main/java/com/powsybl/iidm/network/NetworkFactory.java", "diffHunk": "@@ -47,7 +48,11 @@ static NetworkFactory find(String name) {\n      * @return default {@code NetworkFactory} instance.\n      */\n     static NetworkFactory findDefault() {\n-        return find(NetworkFactoryConstants.DEFAULT);\n+        String defaultName = PlatformConfig.defaultConfig()\n+                .getOptionalModuleConfig(\"iidm\")\n+                .map(module -> module.getStringProperty(\"default\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab5b04db69a309c4af54648cbe6d66aeb88045b6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxNjIyNg==", "bodyText": "I chose this to be consistent with the loadflow.default configuration", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r368516226", "createdAt": "2020-01-20T12:12:08Z", "author": {"login": "jonenst"}, "path": "iidm/iidm-api/src/main/java/com/powsybl/iidm/network/NetworkFactory.java", "diffHunk": "@@ -47,7 +48,11 @@ static NetworkFactory find(String name) {\n      * @return default {@code NetworkFactory} instance.\n      */\n     static NetworkFactory findDefault() {\n-        return find(NetworkFactoryConstants.DEFAULT);\n+        String defaultName = PlatformConfig.defaultConfig()\n+                .getOptionalModuleConfig(\"iidm\")\n+                .map(module -> module.getStringProperty(\"default\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxMjAwOQ=="}, "originalCommit": {"oid": "ab5b04db69a309c4af54648cbe6d66aeb88045b6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUyODMzMw==", "bodyText": "As we known that IIDM \"branding\" should one day disappear and just call it \"the powsybl network model\", I would have named it:\nnetwork:\n    default-impl-name: xxx", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r368528333", "createdAt": "2020-01-20T12:43:40Z", "author": {"login": "geofjamg"}, "path": "iidm/iidm-api/src/main/java/com/powsybl/iidm/network/NetworkFactory.java", "diffHunk": "@@ -47,7 +48,11 @@ static NetworkFactory find(String name) {\n      * @return default {@code NetworkFactory} instance.\n      */\n     static NetworkFactory findDefault() {\n-        return find(NetworkFactoryConstants.DEFAULT);\n+        String defaultName = PlatformConfig.defaultConfig()\n+                .getOptionalModuleConfig(\"iidm\")\n+                .map(module -> module.getStringProperty(\"default\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxMjAwOQ=="}, "originalCommit": {"oid": "ab5b04db69a309c4af54648cbe6d66aeb88045b6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU1NTIxOQ==", "bodyText": "network-model:\n   default: xxx\n?\nIf we use default-impl-name, we should update the loadflow.default config for consistency", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r368555219", "createdAt": "2020-01-20T13:46:43Z", "author": {"login": "jonenst"}, "path": "iidm/iidm-api/src/main/java/com/powsybl/iidm/network/NetworkFactory.java", "diffHunk": "@@ -47,7 +48,11 @@ static NetworkFactory find(String name) {\n      * @return default {@code NetworkFactory} instance.\n      */\n     static NetworkFactory findDefault() {\n-        return find(NetworkFactoryConstants.DEFAULT);\n+        String defaultName = PlatformConfig.defaultConfig()\n+                .getOptionalModuleConfig(\"iidm\")\n+                .map(module -> module.getStringProperty(\"default\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxMjAwOQ=="}, "originalCommit": {"oid": "ab5b04db69a309c4af54648cbe6d66aeb88045b6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3OTU0Ng==", "bodyText": "I actually prefer @geofjamg's proposition, given than we will then update the loadflow config names to be consistent.", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r368879546", "createdAt": "2020-01-21T09:05:47Z", "author": {"login": "miovd"}, "path": "iidm/iidm-api/src/main/java/com/powsybl/iidm/network/NetworkFactory.java", "diffHunk": "@@ -47,7 +48,11 @@ static NetworkFactory find(String name) {\n      * @return default {@code NetworkFactory} instance.\n      */\n     static NetworkFactory findDefault() {\n-        return find(NetworkFactoryConstants.DEFAULT);\n+        String defaultName = PlatformConfig.defaultConfig()\n+                .getOptionalModuleConfig(\"iidm\")\n+                .map(module -> module.getStringProperty(\"default\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUxMjAwOQ=="}, "originalCommit": {"oid": "ab5b04db69a309c4af54648cbe6d66aeb88045b6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTEzMjIxOnYy", "diffSide": "RIGHT", "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0NDoxOFrOFiDD-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNzowNjoyN1rOFjQX7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NjA3Mw==", "bodyText": "Not sure I understand how this method is different from getName()? It is never overriden in the code, is it? In which case would it be overriden?", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371246073", "createdAt": "2020-01-27T13:44:18Z", "author": {"login": "miovd"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM1ODgyNw==", "bodyText": "This is done to automatically reuse the implement of \"getName\" methods from other interfaces (e.g. Versionable ) in most cases, but still allow to have different names in case you need it. It is not currently needed in our code now.", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371358827", "createdAt": "2020-01-27T16:52:42Z", "author": {"login": "jonenst"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NjA3Mw=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUxMjc1MA==", "bodyText": "ok", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r372512750", "createdAt": "2020-01-29T17:06:27Z", "author": {"login": "miovd"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NjA3Mw=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTEzMzMwOnYy", "diffSide": "RIGHT", "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0NDozOVrOFiDEog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowMzo0MVrOFjLpog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NjI0Mg==", "bodyText": "Small typo:\n\nOverride this method only if getName() is", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371246242", "createdAt": "2020-01-27T13:44:39Z", "author": {"login": "miovd"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNTM2Mg==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r372435362", "createdAt": "2020-01-29T15:03:41Z", "author": {"login": "jonenst"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NjI0Mg=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzcwNTUyOnYy", "diffSide": "RIGHT", "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNzo1Mjo1MFrOFibq-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowMzozNlrOFjLpeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY0OTI3NQ==", "bodyText": "Coding style: Indent this code like in the previous method", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371649275", "createdAt": "2020-01-28T07:52:50Z", "author": {"login": "mathbagu"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNTMyMg==", "bodyText": "ok", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r372435322", "createdAt": "2020-01-29T15:03:36Z", "author": {"login": "jonenst"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY0OTI3NQ=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzcwNjcyOnYy", "diffSide": "RIGHT", "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNzo1MzoyNlrOFibruA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowMzozMVrOFjLpPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY0OTQ2NA==", "bodyText": "Coding style: To increase the readability, we should write 1 stream function per line", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371649464", "createdAt": "2020-01-28T07:53:26Z", "author": {"login": "mathbagu"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);\n+        }\n+\n+        private static Optional<String> getOptionalFirstProperty(ModuleConfig moduleConfig,\n+                List<String> propertyNames) {\n+            return propertyNames.stream().map(moduleConfig::getOptionalStringProperty)\n+                    .filter(Optional::isPresent).map(Optional::get).findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNTI2Mw==", "bodyText": "ok", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r372435263", "createdAt": "2020-01-29T15:03:31Z", "author": {"login": "jonenst"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);\n+        }\n+\n+        private static Optional<String> getOptionalFirstProperty(ModuleConfig moduleConfig,\n+                List<String> propertyNames) {\n+            return propertyNames.stream().map(moduleConfig::getOptionalStringProperty)\n+                    .filter(Optional::isPresent).map(Optional::get).findFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY0OTQ2NA=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzcxMjU5OnYy", "diffSide": "RIGHT", "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNzo1NjoxMFrOFibvTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowMjoxOVrOFjLmbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1MDM4MQ==", "bodyText": "We discussed about this few days ago... You propose to remove this assertion, because, if the name is not null we don't need platformConfig. Did you change your mind?", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371650381", "createdAt": "2020-01-28T07:56:10Z", "author": {"login": "mathbagu"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);\n+        }\n+\n+        private static Optional<String> getOptionalFirstProperty(ModuleConfig moduleConfig,\n+                List<String> propertyNames) {\n+            return propertyNames.stream().map(moduleConfig::getOptionalStringProperty)\n+                    .filter(Optional::isPresent).map(Optional::get).findFirst();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <K, V, T extends V> T alwaysSameComputeIfAbsent(\n+                Map<K, V> map, K key,\n+                Function<? super K, T> mappingFunction) {\n+            // Casting to (T) is safe if we awlays pass the same T argument for a given key\n+            return (T) map.computeIfAbsent(key, mappingFunction);\n+        }\n+\n+        private static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, Class<T> clazz,\n+                PlatformConfig platformConfig) {\n+            List<T> providers = alwaysSameComputeIfAbsent(PROVIDERS, clazz,\n+                k -> Lists.newArrayList(ServiceLoader.load(clazz)));\n+            return find(name, moduleName, propertyNames, providers, platformConfig);\n+        }\n+\n+        // package private for tests\n+        static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, List<T> providers,\n+                PlatformConfig platformConfig) {\n+            Objects.requireNonNull(providers);\n+            Objects.requireNonNull(platformConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNDU0Mw==", "bodyText": "Yes, I find it more robust to always require non null. This avoids problems when the code \"works\" when the name is not null, but suddenly name becomes null and it doesn't work anymore.\nWe can rework the API in the future in a separate PR to not give this API where parameters are used depending on whether other parameters are null", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r372434543", "createdAt": "2020-01-29T15:02:19Z", "author": {"login": "jonenst"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);\n+        }\n+\n+        private static Optional<String> getOptionalFirstProperty(ModuleConfig moduleConfig,\n+                List<String> propertyNames) {\n+            return propertyNames.stream().map(moduleConfig::getOptionalStringProperty)\n+                    .filter(Optional::isPresent).map(Optional::get).findFirst();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <K, V, T extends V> T alwaysSameComputeIfAbsent(\n+                Map<K, V> map, K key,\n+                Function<? super K, T> mappingFunction) {\n+            // Casting to (T) is safe if we awlays pass the same T argument for a given key\n+            return (T) map.computeIfAbsent(key, mappingFunction);\n+        }\n+\n+        private static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, Class<T> clazz,\n+                PlatformConfig platformConfig) {\n+            List<T> providers = alwaysSameComputeIfAbsent(PROVIDERS, clazz,\n+                k -> Lists.newArrayList(ServiceLoader.load(clazz)));\n+            return find(name, moduleName, propertyNames, providers, platformConfig);\n+        }\n+\n+        // package private for tests\n+        static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, List<T> providers,\n+                PlatformConfig platformConfig) {\n+            Objects.requireNonNull(providers);\n+            Objects.requireNonNull(platformConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1MDM4MQ=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzkwNDQ1OnYy", "diffSide": "RIGHT", "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwOToxMDoyNFrOFidiDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowMzoyMlrOFjLo2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3OTc1Ng==", "bodyText": "Should be renamed?", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r371679756", "createdAt": "2020-01-28T09:10:24Z", "author": {"login": "geofjamg"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);\n+        }\n+\n+        private static Optional<String> getOptionalFirstProperty(ModuleConfig moduleConfig,\n+                List<String> propertyNames) {\n+            return propertyNames.stream().map(moduleConfig::getOptionalStringProperty)\n+                    .filter(Optional::isPresent).map(Optional::get).findFirst();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <K, V, T extends V> T alwaysSameComputeIfAbsent(\n+                Map<K, V> map, K key,\n+                Function<? super K, T> mappingFunction) {\n+            // Casting to (T) is safe if we awlays pass the same T argument for a given key\n+            return (T) map.computeIfAbsent(key, mappingFunction);\n+        }\n+\n+        private static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, Class<T> clazz,\n+                PlatformConfig platformConfig) {\n+            List<T> providers = alwaysSameComputeIfAbsent(PROVIDERS, clazz,\n+                k -> Lists.newArrayList(ServiceLoader.load(clazz)));\n+            return find(name, moduleName, propertyNames, providers, platformConfig);\n+        }\n+\n+        // package private for tests\n+        static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, List<T> providers,\n+                PlatformConfig platformConfig) {\n+            Objects.requireNonNull(providers);\n+            Objects.requireNonNull(platformConfig);\n+\n+            if (providers.isEmpty()) {\n+                throw new PowsyblException(\"No \" + moduleName + \" providers found\");\n+            }\n+\n+            // if no implementation name is provided through the API we look for information\n+            // in platform configuration\n+            String finalName = name != null ? name\n+                    : platformConfig.getOptionalModuleConfig(moduleName)\n+                            .flatMap(mc -> getOptionalFirstProperty(mc, propertyNames))\n+                            .orElse(null);\n+            T provider;\n+            if (providers.size() == 1 && finalName == null) {\n+                // no information to select the implementation but only one provider, so we can\n+                // use it by default\n+                // (that is be the most common use case)\n+                provider = providers.get(0);\n+            } else {\n+                if (providers.size() > 1 && finalName == null) {\n+                    // several providers and no information to select which one to choose, we can\n+                    // only throw\n+                    // an exception\n+                    List<String> loadFlowNames = providers.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzNTE2MQ==", "bodyText": "done. I used clazz.getSimpleName() in the message because this is expected to be used on our classes which have very specific names (e.g. LoadFlowProvider)", "url": "https://github.com/powsybl/powsybl-core/pull/1119#discussion_r372435161", "createdAt": "2020-01-29T15:03:22Z", "author": {"login": "jonenst"}, "path": "commons/src/main/java/com/powsybl/commons/config/PlatformConfigNamedProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.commons.config;\n+\n+import com.google.common.collect.Lists;\n+import com.powsybl.commons.PowsyblException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A provider that can be loaded by by Java's ServiceLoader based on its name\n+ * present in an entry in the PlatformConfig.\n+ *\n+ * @author Jon Harper <jon.harper at rte-france.com>\n+ */\n+public interface PlatformConfigNamedProvider {\n+\n+    /**\n+     * Get the name.\n+     *\n+     * @return the name\n+     */\n+    String getName();\n+\n+    /**\n+     * Get the Provider name used for identifying this provider in the\n+     * PlatformConfig. Defaults to getName(). Override this method only getName() is\n+     * already implemented and returns the wrong name.\n+     *\n+     * @return the name\n+     */\n+    default String getPlatformConfigName() {\n+        return getName();\n+    }\n+\n+    /**\n+     * A utility class to find providers in the {@link PlatformConfig} by their\n+     * names configured in standard fields. the find* methods use the standard\n+     * fields while the find*BackwardsCompatible methods also look in the legacy\n+     * fields.\n+     *\n+     * @author Jon harper <jon.harper at rte-france.com>\n+     * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n+     */\n+    static final class Finder {\n+\n+        private Finder() {\n+        }\n+\n+        private static final String DEFAULT_SERVICE_IMPL_NAME_PROPERTY = \"default-impl-name\";\n+        private static final String LEGACY_SERVICE_IMPL_NAME_PROPERTY = \"default\";\n+\n+        private static final Map<Class<? extends PlatformConfigNamedProvider>, List<? extends PlatformConfigNamedProvider>> PROVIDERS = new ConcurrentHashMap<>();\n+\n+        /**\n+         * Find the default provider configured in the standard field of\n+         * {@code moduleName} in {@code platformConfig} among the {@code providers}\n+         * arguments based on its name.\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T findDefault(String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link findDefault}\n+         *\n+         * @return the provider\n+         */\n+        public static <T extends PlatformConfigNamedProvider> T find(String name, String moduleName,\n+                Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY), clazz,\n+                    platformConfig);\n+        }\n+\n+        /**\n+         * Find the default provider configured in the standard field or the legacy\n+         * field of {@code moduleName} in {@code platformConfig} among the\n+         * {@code providers} arguments based on its name.\n+         *\n+         * @deprecated Use {@link #findDefault} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findDefaultBackwardsCompatible(\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(null, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                    LEGACY_SERVICE_IMPL_NAME_PROPERTY), clazz, platformConfig);\n+        }\n+\n+        /**\n+         * Find the provider among the {@code providers} based on its {@code name}, or\n+         * if {@code name} is null find the default provider like @{link\n+         * findDefaultBackwardsCompatible}\n+         *\n+         * @deprecated Use {@link #find} instead\n+         *\n+         * @return the provider\n+         */\n+        @Deprecated\n+        public static <T extends PlatformConfigNamedProvider> T findBackwardsCompatible(String name,\n+                String moduleName, Class<T> clazz, PlatformConfig platformConfig) {\n+            return find(name, moduleName,\n+                    Arrays.asList(DEFAULT_SERVICE_IMPL_NAME_PROPERTY,\n+                            LEGACY_SERVICE_IMPL_NAME_PROPERTY),\n+                    clazz, platformConfig);\n+        }\n+\n+        private static Optional<String> getOptionalFirstProperty(ModuleConfig moduleConfig,\n+                List<String> propertyNames) {\n+            return propertyNames.stream().map(moduleConfig::getOptionalStringProperty)\n+                    .filter(Optional::isPresent).map(Optional::get).findFirst();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <K, V, T extends V> T alwaysSameComputeIfAbsent(\n+                Map<K, V> map, K key,\n+                Function<? super K, T> mappingFunction) {\n+            // Casting to (T) is safe if we awlays pass the same T argument for a given key\n+            return (T) map.computeIfAbsent(key, mappingFunction);\n+        }\n+\n+        private static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, Class<T> clazz,\n+                PlatformConfig platformConfig) {\n+            List<T> providers = alwaysSameComputeIfAbsent(PROVIDERS, clazz,\n+                k -> Lists.newArrayList(ServiceLoader.load(clazz)));\n+            return find(name, moduleName, propertyNames, providers, platformConfig);\n+        }\n+\n+        // package private for tests\n+        static <T extends PlatformConfigNamedProvider> T find(String name,\n+                String moduleName, List<String> propertyNames, List<T> providers,\n+                PlatformConfig platformConfig) {\n+            Objects.requireNonNull(providers);\n+            Objects.requireNonNull(platformConfig);\n+\n+            if (providers.isEmpty()) {\n+                throw new PowsyblException(\"No \" + moduleName + \" providers found\");\n+            }\n+\n+            // if no implementation name is provided through the API we look for information\n+            // in platform configuration\n+            String finalName = name != null ? name\n+                    : platformConfig.getOptionalModuleConfig(moduleName)\n+                            .flatMap(mc -> getOptionalFirstProperty(mc, propertyNames))\n+                            .orElse(null);\n+            T provider;\n+            if (providers.size() == 1 && finalName == null) {\n+                // no information to select the implementation but only one provider, so we can\n+                // use it by default\n+                // (that is be the most common use case)\n+                provider = providers.get(0);\n+            } else {\n+                if (providers.size() > 1 && finalName == null) {\n+                    // several providers and no information to select which one to choose, we can\n+                    // only throw\n+                    // an exception\n+                    List<String> loadFlowNames = providers.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3OTc1Ng=="}, "originalCommit": {"oid": "1547f3c98d175653101252c17b26c97231df6741"}, "originalPosition": 179}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 30, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}