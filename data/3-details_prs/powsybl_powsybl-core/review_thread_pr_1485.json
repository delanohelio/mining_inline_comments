{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyODU2Mjg0", "number": 1485, "reviewThreads": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowOTo1M1rOEp1BQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjoxMDo0N1rOFA3tNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjk1NzQ0OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowOTo1M1rOHbvH-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTowMTozOVrOHeUzTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTY4OA==", "bodyText": "params is never null. Furthermore, you should use  ConversionParameters.readBooleanParameter here.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498845688", "createdAt": "2020-10-02T14:09:53Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU2MDE0MA==", "bodyText": "params may be null when called from specific unit tests. A Conversion Parameter has been added to the CgmesExport class. By the way, the generic Exporter interface does not define getParameters like its Importer counterpart.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501560140", "createdAt": "2020-10-08T09:01:39Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTY4OA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjk2MDAzOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoxMDozNFrOHbvJlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTowNTowNlrOHeU7zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NjEwMA==", "bodyText": "Not sure why an exception is thrown? We could just ignore it.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498846100", "createdAt": "2020-10-02T14:10:34Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {\n+            if (ext != null) {\n+                CgmesModel cgmesSource = ext.getCgmesModel();\n+                if (cgmesSource != null) {\n+                    throw new CgmesModelException(\"CGMES model should not be available as Network extension\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU2MjMxNw==", "bodyText": "Check has been removed.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501562317", "createdAt": "2020-10-08T09:05:06Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {\n+            if (ext != null) {\n+                CgmesModel cgmesSource = ext.getCgmesModel();\n+                if (cgmesSource != null) {\n+                    throw new CgmesModelException(\"CGMES model should not be available as Network extension\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NjEwMA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjk2ODkzOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoxMzowOFrOHbvPhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMzozN1rOHeWCNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NzYyMA==", "bodyText": "Don't really think it should be a property? I think it should use a parameter cgmes.export.base-name (if not filled, use network.getNameOrId()). Ideally, it should also be a field in CgmesExportContext but I will probably do it in a later PR.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498847620", "createdAt": "2020-10-02T14:13:08Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {\n+            if (ext != null) {\n+                CgmesModel cgmesSource = ext.getCgmesModel();\n+                if (cgmesSource != null) {\n+                    throw new CgmesModelException(\"CGMES model should not be available as Network extension\");\n+                }\n+            }\n+            exportUsingOnlyNetwork(network, ds);\n+        } else {\n+            if (ext == null) {\n+                throw new CgmesModelException(\"CGMES model is required and not found in Network extension\");\n+            }\n+            exportUsingOriginalCgmesModel(network, ds, ext);\n         }\n-        CgmesUpdate cgmesUpdate = ext.getCgmesUpdate();\n+    }\n \n+    private void exportUsingOnlyNetwork(Network network, DataSource ds) {\n+        // At this point only SSH, SV can be exported when relying only in Network data\n+        // (minimum amount of CGMES references are expected as aliases/properties/extensions)\n+        String baseName = network.hasProperty(\"baseName\") ? network.getProperty(\"baseName\") : network.getNameOrId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4MDM0Mg==", "bodyText": "Defined a new BASE_NAME parameter in CgmesExport.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501580342", "createdAt": "2020-10-08T09:33:37Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {\n+            if (ext != null) {\n+                CgmesModel cgmesSource = ext.getCgmesModel();\n+                if (cgmesSource != null) {\n+                    throw new CgmesModelException(\"CGMES model should not be available as Network extension\");\n+                }\n+            }\n+            exportUsingOnlyNetwork(network, ds);\n+        } else {\n+            if (ext == null) {\n+                throw new CgmesModelException(\"CGMES model is required and not found in Network extension\");\n+            }\n+            exportUsingOriginalCgmesModel(network, ds, ext);\n         }\n-        CgmesUpdate cgmesUpdate = ext.getCgmesUpdate();\n+    }\n \n+    private void exportUsingOnlyNetwork(Network network, DataSource ds) {\n+        // At this point only SSH, SV can be exported when relying only in Network data\n+        // (minimum amount of CGMES references are expected as aliases/properties/extensions)\n+        String baseName = network.hasProperty(\"baseName\") ? network.getProperty(\"baseName\") : network.getNameOrId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NzYyMA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjk4ODYwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoxODoyOVrOHbvb1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozOTo0N1rOHeWRZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MDc3Mg==", "bodyText": "I don't really agree with throwing a PowsyblException in any case. You should do:\ncatch (IOException e) {\n   throw new UncheckedIOException(e);\n} catch (XMLStreamException e) {\n    throw new UncheckedXmlStreamException(e);\n}\nYou can write this only once at the end of the method (not twice)", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498850772", "createdAt": "2020-10-02T14:18:29Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {\n+            if (ext != null) {\n+                CgmesModel cgmesSource = ext.getCgmesModel();\n+                if (cgmesSource != null) {\n+                    throw new CgmesModelException(\"CGMES model should not be available as Network extension\");\n+                }\n+            }\n+            exportUsingOnlyNetwork(network, ds);\n+        } else {\n+            if (ext == null) {\n+                throw new CgmesModelException(\"CGMES model is required and not found in Network extension\");\n+            }\n+            exportUsingOriginalCgmesModel(network, ds, ext);\n         }\n-        CgmesUpdate cgmesUpdate = ext.getCgmesUpdate();\n+    }\n \n+    private void exportUsingOnlyNetwork(Network network, DataSource ds) {\n+        // At this point only SSH, SV can be exported when relying only in Network data\n+        // (minimum amount of CGMES references are expected as aliases/properties/extensions)\n+        String baseName = network.hasProperty(\"baseName\") ? network.getProperty(\"baseName\") : network.getNameOrId();\n+        String filenameSv = baseName + \"_SV.xml\";\n+        String filenameSsh = baseName + \"_SSH.xml\";\n+        CgmesExportContext context = new CgmesExportContext(network);\n+        try (OutputStream os = ds.newOutputStream(filenameSv, false)) {\n+            XMLStreamWriter writer = XmlUtil.initializeWriter(true, \"    \", os);\n+            StateVariablesExport.write(network, writer, context);\n+        } catch (IOException | XMLStreamException x) {\n+            throw new PowsyblException(\"Exporting to CGMES using only Network\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NDIyOA==", "bodyText": "Done. Defined a single try-with-resources block for export SV and SSH export", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501584228", "createdAt": "2020-10-08T09:39:47Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -27,22 +38,50 @@\n \n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n-\n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n+        Objects.requireNonNull(network);\n         CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+        if (params != null && Boolean.valueOf(params.getProperty(\"cgmes.export.usingOnlyNetwork\"))) {\n+            if (ext != null) {\n+                CgmesModel cgmesSource = ext.getCgmesModel();\n+                if (cgmesSource != null) {\n+                    throw new CgmesModelException(\"CGMES model should not be available as Network extension\");\n+                }\n+            }\n+            exportUsingOnlyNetwork(network, ds);\n+        } else {\n+            if (ext == null) {\n+                throw new CgmesModelException(\"CGMES model is required and not found in Network extension\");\n+            }\n+            exportUsingOriginalCgmesModel(network, ds, ext);\n         }\n-        CgmesUpdate cgmesUpdate = ext.getCgmesUpdate();\n+    }\n \n+    private void exportUsingOnlyNetwork(Network network, DataSource ds) {\n+        // At this point only SSH, SV can be exported when relying only in Network data\n+        // (minimum amount of CGMES references are expected as aliases/properties/extensions)\n+        String baseName = network.hasProperty(\"baseName\") ? network.getProperty(\"baseName\") : network.getNameOrId();\n+        String filenameSv = baseName + \"_SV.xml\";\n+        String filenameSsh = baseName + \"_SSH.xml\";\n+        CgmesExportContext context = new CgmesExportContext(network);\n+        try (OutputStream os = ds.newOutputStream(filenameSv, false)) {\n+            XMLStreamWriter writer = XmlUtil.initializeWriter(true, \"    \", os);\n+            StateVariablesExport.write(network, writer, context);\n+        } catch (IOException | XMLStreamException x) {\n+            throw new PowsyblException(\"Exporting to CGMES using only Network\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MDc3Mg=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjk5NzU0OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoyMDo1M1rOHbvhSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo0MToxN1rOHeWVBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MjE2OA==", "bodyText": "To confirm, but maybe it might be a good idea to use the extension in powsybl-balance-adjustements . I will look into it.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498852168", "createdAt": "2020-10-02T14:20:53Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "diffHunk": "@@ -306,6 +311,34 @@ private void addCgmesSvMetadata(Network network) {\n         }\n     }\n \n+    private void addCgmesSshMetadata(Network network) {\n+        PropertyBags sshDescription = cgmes.fullModel(CgmesSubset.STEADY_STATE_HYPOTHESIS.getProfile());\n+        if (sshDescription != null && !sshDescription.isEmpty()) {\n+            CgmesSshMetadataAdder adder = network.newExtension(CgmesSshMetadataAdder.class)\n+                    .setDescription(sshDescription.get(0).getId(\"description\"))\n+                    .setSshVersion(sshDescription.get(0).asInt(\"version\"))\n+                    .setModelingAuthoritySet(sshDescription.get(0).getId(\"modelingAuthoritySet\"));\n+            sshDescription.pluckLocals(\"DependentOn\").forEach(adder::addDependency);\n+            adder.add();\n+        }\n+    }\n+\n+    private void addCgmesSshControlAreas(Network network) {\n+        PropertyBags sshControlAreas = cgmes.controlAreas();\n+        if (sshControlAreas != null && !sshControlAreas.isEmpty()) {\n+            CgmesSshControlAreasAdder adder = network.newExtension(CgmesSshControlAreasAdder.class);\n+\n+            sshControlAreas.forEach(sshControlArea -> {\n+                String id = sshControlArea.getId(\"ControlArea\");\n+                double netInterchange = sshControlArea.asDouble(\"netInterchange\");\n+                double pTolerance = sshControlArea.asDouble(\"pTolerance\");\n+                ControlArea controlArea = new ControlArea(id, netInterchange, pTolerance);\n+                adder.addControlArea(controlArea);\n+            });\n+            adder.add();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NTE1OA==", "bodyText": "We will analyse the powsybl-balance-adjustements extension for a later refactoring.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501585158", "createdAt": "2020-10-08T09:41:17Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "diffHunk": "@@ -306,6 +311,34 @@ private void addCgmesSvMetadata(Network network) {\n         }\n     }\n \n+    private void addCgmesSshMetadata(Network network) {\n+        PropertyBags sshDescription = cgmes.fullModel(CgmesSubset.STEADY_STATE_HYPOTHESIS.getProfile());\n+        if (sshDescription != null && !sshDescription.isEmpty()) {\n+            CgmesSshMetadataAdder adder = network.newExtension(CgmesSshMetadataAdder.class)\n+                    .setDescription(sshDescription.get(0).getId(\"description\"))\n+                    .setSshVersion(sshDescription.get(0).asInt(\"version\"))\n+                    .setModelingAuthoritySet(sshDescription.get(0).getId(\"modelingAuthoritySet\"));\n+            sshDescription.pluckLocals(\"DependentOn\").forEach(adder::addDependency);\n+            adder.add();\n+        }\n+    }\n+\n+    private void addCgmesSshControlAreas(Network network) {\n+        PropertyBags sshControlAreas = cgmes.controlAreas();\n+        if (sshControlAreas != null && !sshControlAreas.isEmpty()) {\n+            CgmesSshControlAreasAdder adder = network.newExtension(CgmesSshControlAreasAdder.class);\n+\n+            sshControlAreas.forEach(sshControlArea -> {\n+                String id = sshControlArea.getId(\"ControlArea\");\n+                double netInterchange = sshControlArea.asDouble(\"netInterchange\");\n+                double pTolerance = sshControlArea.asDouble(\"pTolerance\");\n+                ControlArea controlArea = new ControlArea(id, netInterchange, pTolerance);\n+                adder.addControlArea(controlArea);\n+            });\n+            adder.add();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MjE2OA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAwMjM2OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForGenerators.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoyMjowNFrOHbvkOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMTo0Nzo1MFrOHi4GUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MjkyMA==", "bodyText": "Is it useful? If the RegulatingControl only regulates generators, we can put the targetDeadband as 0.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498852920", "createdAt": "2020-10-02T14:22:04Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForGenerators.java", "diffHunk": "@@ -117,6 +117,9 @@ private boolean setRegulatingControlVoltage(String controlId,\n                     .add();\n         }\n \n+        gen.setProperty(\"RegulatingControl\", controlId);\n+        gen.setProperty(\"targetDeadBand\", String.valueOf(control.getTargetDeadBand()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NjMyNQ==", "bodyText": "We tried to keep the original value read from input data, even it is not applicable in IIDM for generators. Some regulating controls in conformity test cases have targetDeadband != 0.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501586325", "createdAt": "2020-10-08T09:43:15Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForGenerators.java", "diffHunk": "@@ -117,6 +117,9 @@ private boolean setRegulatingControlVoltage(String controlId,\n                     .add();\n         }\n \n+        gen.setProperty(\"RegulatingControl\", controlId);\n+        gen.setProperty(\"targetDeadBand\", String.valueOf(control.getTargetDeadBand()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MjkyMA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMzMjc1Mw==", "bodyText": "The RegulatingControlId is not stored as an alias in the generator ? I think that maybe we have two options :\n\nWith the option USING_ONLY_NETWORK_PARAMETER, we should introduce default values and not relying too much on properties ;\nWith the option that use the CGMES model, you retriev all the information.\n@MioRtia and @mathbagu what do you think ?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506332753", "createdAt": "2020-10-16T11:47:50Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForGenerators.java", "diffHunk": "@@ -117,6 +117,9 @@ private boolean setRegulatingControlVoltage(String controlId,\n                     .add();\n         }\n \n+        gen.setProperty(\"RegulatingControl\", controlId);\n+        gen.setProperty(\"targetDeadBand\", String.valueOf(control.getTargetDeadBand()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1MjkyMA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAxMjc0OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMapping.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoyNDo1M1rOHbvqng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo0NDozN1rOHeWdLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NDU1OA==", "bodyText": "Just for me, the modifications in this class regards the updating of the original SSH export? If yes, it may be easier to review in another PR...", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498854558", "createdAt": "2020-10-02T14:24:53Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMapping.java", "diffHunk": "@@ -58,7 +58,7 @@ public RegulatingControlMappingForStaticVarCompensators forStaticVarCompensators\n         return regulatingControlMappingForStaticVarCompensators;\n     }\n \n-    static class RegulatingControl {\n+    public static class RegulatingControl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NzI0NQ==", "bodyText": "Yes the modification is related to SSH export. The change was very small (only visibility of inner class), so we decided to include it here.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501587245", "createdAt": "2020-10-08T09:44:37Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMapping.java", "diffHunk": "@@ -58,7 +58,7 @@ public RegulatingControlMappingForStaticVarCompensators forStaticVarCompensators\n         return regulatingControlMappingForStaticVarCompensators;\n     }\n \n-    static class RegulatingControl {\n+    public static class RegulatingControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NDU1OA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAyODY2OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoyOTowMlrOHbv0xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo0ODo0N1rOHeWnfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzE1OQ==", "bodyText": "Not sure it is warranted. Is it useful to keep information that are not consistent? I understand it is useful for debug purposes but is there another usecase where this information is meaningful?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498857159", "createdAt": "2020-10-02T14:29:02Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -57,10 +57,15 @@ private void apply(ShuntCompensator shuntCompensator, CgmesRegulatingControlForS\n         if (cgmesRc == null) {\n             return;\n         }\n+        String rcId = cgmesRc.regulatingControlId;\n+\n+        // We are saving the relationship with the\n+        // original regulating control even if it is not enabled\n+        // or if we are not able to set it properly in IIDM\n         if (!cgmesRc.controlEnabled) {\n+            setAdditionalProperties(shuntCompensator, rcId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4OTg4Nw==", "bodyText": "We want to keep original regulating control information without changing the current logic about its use in IIDM.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501589887", "createdAt": "2020-10-08T09:48:47Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -57,10 +57,15 @@ private void apply(ShuntCompensator shuntCompensator, CgmesRegulatingControlForS\n         if (cgmesRc == null) {\n             return;\n         }\n+        String rcId = cgmesRc.regulatingControlId;\n+\n+        // We are saving the relationship with the\n+        // original regulating control even if it is not enabled\n+        // or if we are not able to set it properly in IIDM\n         if (!cgmesRc.controlEnabled) {\n+            setAdditionalProperties(shuntCompensator, rcId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzE1OQ=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAzMDI2OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoyOToyMFrOHbv1tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1MDowMFrOHeWqgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzM5Nw==", "bodyText": "Does it happen when this method is called?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498857397", "createdAt": "2020-10-02T14:29:20Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MDY1Nw==", "bodyText": "yes it could happen", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501590657", "createdAt": "2020-10-08T09:50:00Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzM5Nw=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAzMjUwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDoyOTo1NFrOHbv3NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1MToyMFrOHeWt0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1Nzc4MQ==", "bodyText": "Does it happen when this method is called?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498857781", "createdAt": "2020-10-02T14:29:54Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }\n+        RegulatingControl rc = parent.cachedRegulatingControls().get(rcId);\n+        if (rc == null) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MTUwNQ==", "bodyText": "yes, it could happen; we keep the same logic that when regulating control is processed", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501591505", "createdAt": "2020-10-08T09:51:20Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }\n+        RegulatingControl rc = parent.cachedRegulatingControls().get(rcId);\n+        if (rc == null) {\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1Nzc4MQ=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAzMzU1OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDozMDowN1rOHbv30A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMTo1NjoyMlrOHi4gkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzkzNg==", "bodyText": "See questions above", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498857936", "createdAt": "2020-10-02T14:30:07Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }\n+        RegulatingControl rc = parent.cachedRegulatingControls().get(rcId);\n+        if (rc == null) {\n+            return;\n+        }\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+        shuntCompensator.setProperty(\"targetValue\", String.valueOf(rc.targetValue));\n+        shuntCompensator.setProperty(\"targetDeadBand\", String.valueOf(rc.targetDeadband));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MTc3OA==", "bodyText": "trying to keep original data about regulating control", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501591778", "createdAt": "2020-10-08T09:51:46Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }\n+        RegulatingControl rc = parent.cachedRegulatingControls().get(rcId);\n+        if (rc == null) {\n+            return;\n+        }\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+        shuntCompensator.setProperty(\"targetValue\", String.valueOf(rc.targetValue));\n+        shuntCompensator.setProperty(\"targetDeadBand\", String.valueOf(rc.targetDeadband));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzkzNg=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMzOTQ3Mw==", "bodyText": "Why do we need the targetValue as property as we have it in IIDM ?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506339473", "createdAt": "2020-10-16T11:56:22Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -95,6 +100,21 @@ private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingC\n         }\n         // Take default terminal if it has not been defined in CGMES files (it is never null)\n         shuntCompensator.setRegulatingTerminal(parent.getRegulatingTerminal(shuntCompensator, rc.cgmesTerminal));\n+\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+    }\n+\n+    private void setAdditionalProperties(ShuntCompensator shuntCompensator, String rcId) {\n+        if (rcId == null) {\n+            return;\n+        }\n+        RegulatingControl rc = parent.cachedRegulatingControls().get(rcId);\n+        if (rc == null) {\n+            return;\n+        }\n+        shuntCompensator.setProperty(\"RegulatingControl\", rcId);\n+        shuntCompensator.setProperty(\"targetValue\", String.valueOf(rc.targetValue));\n+        shuntCompensator.setProperty(\"targetDeadBand\", String.valueOf(rc.targetDeadband));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NzkzNg=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzAzNzMyOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForStaticVarCompensators.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDozMTowNVrOHbv6UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1MjoyNVrOHeWwrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1ODU3Nw==", "bodyText": "Same remark as for generators: if a regulating control only regulates svc, maybe we can considerate the deadband is 0 and not keep this information from the CGMES file.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498858577", "createdAt": "2020-10-02T14:31:05Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForStaticVarCompensators.java", "diffHunk": "@@ -123,6 +123,8 @@ private boolean setRegulatingControl(CgmesRegulatingControlForStaticVarCompensat\n         }\n         svc.setRegulatingTerminal(terminal);\n \n+        svc.setProperty(\"RegulatingControl\", rc.regulatingControlId);\n+        svc.setProperty(\"targetDeadBand\", String.valueOf(control.getTargetDeadBand()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MjIzNg==", "bodyText": "trying to keep original data about regulating control (the conformity tests contain examples of deadband != 0)", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501592236", "createdAt": "2020-10-08T09:52:25Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForStaticVarCompensators.java", "diffHunk": "@@ -123,6 +123,8 @@ private boolean setRegulatingControl(CgmesRegulatingControlForStaticVarCompensat\n         }\n         svc.setRegulatingTerminal(terminal);\n \n+        svc.setProperty(\"RegulatingControl\", rc.regulatingControlId);\n+        svc.setProperty(\"targetDeadBand\", String.valueOf(control.getTargetDeadBand()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1ODU3Nw=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzA0MTU3OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDozMjoxN1rOHbv9DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1Njo0MVrOHeW7Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1OTI3Ng==", "bodyText": "Just for me, can a generating unit be linked to several synchronous machines?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498859276", "createdAt": "2020-10-02T14:32:17Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "diffHunk": "@@ -60,6 +60,14 @@ public void convert() {\n         if (p.asInt(\"referencePriority\", 0) > 0) {\n             SlackTerminal.reset(g.getTerminal().getVoltageLevel(), g.getTerminal());\n         }\n+        if (p.containsKey(\"normalPF\")) {\n+            // Convert to double then to string to have canonical representation of number\n+            g.setProperty(\"GeneratingUnit.normalPF\", Double.valueOf(p.get(\"normalPF\")).toString());\n+        }\n+        String generatingUnit = p.getId(\"GeneratingUnit\");\n+        if (generatingUnit != null) {\n+            g.setProperty(\"GeneratingUnit\", generatingUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5NDg5MA==", "bodyText": "Yes, a GeneratingUnit can contain one or more synchronous machines. From CGMES doc, a GeneratingUnit is defined as A single or set of synchronous machines for converting mechanical power into alternating-current power.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501594890", "createdAt": "2020-10-08T09:56:41Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "diffHunk": "@@ -60,6 +60,14 @@ public void convert() {\n         if (p.asInt(\"referencePriority\", 0) > 0) {\n             SlackTerminal.reset(g.getTerminal().getVoltageLevel(), g.getTerminal());\n         }\n+        if (p.containsKey(\"normalPF\")) {\n+            // Convert to double then to string to have canonical representation of number\n+            g.setProperty(\"GeneratingUnit.normalPF\", Double.valueOf(p.get(\"normalPF\")).toString());\n+        }\n+        String generatingUnit = p.getId(\"GeneratingUnit\");\n+        if (generatingUnit != null) {\n+            g.setProperty(\"GeneratingUnit\", generatingUnit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1OTI3Ng=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzA0Njc2OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDozMzo0M1rOHbwAQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1ODoxN1rOHeW--Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2MDA5OQ==", "bodyText": "This method is private. If we are sure the regulatingControlId is not null when the method is called, it is not useful for me to check it.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498860099", "createdAt": "2020-10-02T14:33:43Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +122,81 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        Objects.requireNonNull(regulatingControlId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5NTg5Nw==", "bodyText": "Done", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501595897", "createdAt": "2020-10-08T09:58:17Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +122,81 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        Objects.requireNonNull(regulatingControlId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2MDA5OQ=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzA2OTUyOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDozOTo1OVrOHbwOcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMDowMDowNFrOHeXDSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2MzcyOQ==", "bodyText": "Do you need this because it is done after combination? Can't it be done the same way for hidden and non hidden tap changers?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498863729", "createdAt": "2020-10-02T14:39:59Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +122,81 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        Objects.requireNonNull(regulatingControlId);\n+        return context.regulatingControlMapping().cachedRegulatingControls().get(regulatingControlId);\n+    }\n+\n+    protected void addCgmesDataAsProperties(Identifiable<?> transformer, TapChanger rtc, TapChanger ptc, Context context) {\n+        addRatioTapChangerProperties(transformer, rtc, context);\n+        addPhaseTapChangerProperties(transformer, ptc, context);\n+    }\n+\n+    private static void  addRatioTapChangerProperties(Identifiable<?> transformer, TapChanger rtc, Context context) {\n+        if (rtc == null || rtc.getId() == null) {\n+            return;\n+        }\n+\n+        if (rtc.getRegulatingControlId() != null) {\n+            String key = String.format(\"RatioTapChanger.%s.TapChangerControl\", rtc.getId());\n+            transformer.setProperty(key, rtc.getRegulatingControlId());\n+        }\n+\n+        if (rtc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, rtc, rtc.getHiddenCombinedTapChanger(), \"RatioTapChanger\", context);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5NzAwMQ==", "bodyText": "they must be done in a different way for hidden and not-hidden. Hidden after combination do not exist in IIDM Network, and non-hidden properties are taken from Network object.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501597001", "createdAt": "2020-10-08T10:00:04Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +122,81 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        Objects.requireNonNull(regulatingControlId);\n+        return context.regulatingControlMapping().cachedRegulatingControls().get(regulatingControlId);\n+    }\n+\n+    protected void addCgmesDataAsProperties(Identifiable<?> transformer, TapChanger rtc, TapChanger ptc, Context context) {\n+        addRatioTapChangerProperties(transformer, rtc, context);\n+        addPhaseTapChangerProperties(transformer, ptc, context);\n+    }\n+\n+    private static void  addRatioTapChangerProperties(Identifiable<?> transformer, TapChanger rtc, Context context) {\n+        if (rtc == null || rtc.getId() == null) {\n+            return;\n+        }\n+\n+        if (rtc.getRegulatingControlId() != null) {\n+            String key = String.format(\"RatioTapChanger.%s.TapChangerControl\", rtc.getId());\n+            transformer.setProperty(key, rtc.getRegulatingControlId());\n+        }\n+\n+        if (rtc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, rtc, rtc.getHiddenCombinedTapChanger(), \"RatioTapChanger\", context);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2MzcyOQ=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzA4MDIyOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/CgmesExportContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo0Mjo1NFrOHbwVRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMDowNjowMFrOHeXRyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2NTQ3Ng==", "bodyText": "Can you explain this comment to me?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498865476", "createdAt": "2020-10-02T14:42:54Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/CgmesExportContext.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.conversion.extensions.CgmesSshMetadata;\n+import com.powsybl.cgmes.conversion.extensions.CgmesSvMetadata;\n+import com.powsybl.cgmes.conversion.extensions.CimCharacteristics;\n+import com.powsybl.cgmes.model.CgmesNamespace;\n+\n+import com.powsybl.iidm.network.Network;\n+import org.joda.time.DateTime;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public class CgmesExportContext {\n+\n+    private int cimVersion = 16;\n+    private CgmesTopologyKind topologyKind = CgmesTopologyKind.BUS_BRANCH;\n+    private DateTime scenarioTime = DateTime.now();\n+\n+    private ModelDescription svModelDescription = new ModelDescription(\"SV Model\", CgmesNamespace.SV_PROFILE);\n+    private ModelDescription sshModelDescription = new ModelDescription(\"SSH Model\", CgmesNamespace.SSH_PROFILE);\n+\n+    private boolean exportBoundaryPowerFlows = false;\n+\n+    public static final class ModelDescription {\n+\n+        private String description = \"Model\";\n+        private int version = 1;\n+        private final List<String> dependencies = new ArrayList<>();\n+        private String modelingAuthoritySet = \"powsybl.org\";\n+        // TODO Each model may have a list of profiles, not only one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMDcxMw==", "bodyText": "This is a comment relevant if we try to build a generic ModelDescription class. In general a single file CGMES XML can contain references to multiple profiles. For example an EQ file may contain references to EquipmentBoundary, EquipmentCore, EquipmentOperation (if it is node-breaker), ShortCircuit, ...", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501600713", "createdAt": "2020-10-08T10:06:00Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/CgmesExportContext.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.conversion.extensions.CgmesSshMetadata;\n+import com.powsybl.cgmes.conversion.extensions.CgmesSvMetadata;\n+import com.powsybl.cgmes.conversion.extensions.CimCharacteristics;\n+import com.powsybl.cgmes.model.CgmesNamespace;\n+\n+import com.powsybl.iidm.network.Network;\n+import org.joda.time.DateTime;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public class CgmesExportContext {\n+\n+    private int cimVersion = 16;\n+    private CgmesTopologyKind topologyKind = CgmesTopologyKind.BUS_BRANCH;\n+    private DateTime scenarioTime = DateTime.now();\n+\n+    private ModelDescription svModelDescription = new ModelDescription(\"SV Model\", CgmesNamespace.SV_PROFILE);\n+    private ModelDescription sshModelDescription = new ModelDescription(\"SSH Model\", CgmesNamespace.SSH_PROFILE);\n+\n+    private boolean exportBoundaryPowerFlows = false;\n+\n+    public static final class ModelDescription {\n+\n+        private String description = \"Model\";\n+        private int version = 1;\n+        private final List<String> dependencies = new ArrayList<>();\n+        private String modelingAuthoritySet = \"powsybl.org\";\n+        // TODO Each model may have a list of profiles, not only one", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2NTQ3Ng=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzExMjEyOnYy", "diffSide": "RIGHT", "path": "commons/src/test/java/com/powsybl/commons/AbstractConverterTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo1MTowMVrOHbwpag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMDowNzo0N1rOHeXV6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3MDYzNA==", "bodyText": "Delete this empty line", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r498870634", "createdAt": "2020-10-02T14:51:01Z", "author": {"login": "miovd"}, "path": "commons/src/test/java/com/powsybl/commons/AbstractConverterTest.java", "diffHunk": "@@ -9,6 +9,7 @@\n import com.google.common.io.ByteStreams;\n import com.google.common.jimfs.Configuration;\n import com.google.common.jimfs.Jimfs;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMTc2OQ==", "bodyText": "Removed", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r501601769", "createdAt": "2020-10-08T10:07:47Z", "author": {"login": "zamarrenolm"}, "path": "commons/src/test/java/com/powsybl/commons/AbstractConverterTest.java", "diffHunk": "@@ -9,6 +9,7 @@\n import com.google.common.io.ByteStreams;\n import com.google.common.jimfs.Configuration;\n import com.google.common.jimfs.Jimfs;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3MDYzNA=="}, "originalCommit": {"oid": "d4e3a891c42f23f1d36d066cac55369ce9b850de"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTUzOTA4OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMTo1MzoyNlrOHi4W6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMTo1MzoyNlrOHi4W6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMzNzAwMQ==", "bodyText": "I am not sure we have to support this as we don't have the use-case (or the workflow) because it could lead to bad choices for the extension CgmesSshControlAreas. It could be a generic extension shared by UCTE and CGMES workflows. This extension can be an extension of a voltage level or a substation, that only say in which control area the voltage levl or the substation belong. And then, we will have a processing to compute the net position each time, without storing it.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506337001", "createdAt": "2020-10-16T11:53:26Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "diffHunk": "@@ -306,6 +311,34 @@ private void addCgmesSvMetadata(Network network) {\n         }\n     }\n \n+    private void addCgmesSshMetadata(Network network) {\n+        PropertyBags sshDescription = cgmes.fullModel(CgmesSubset.STEADY_STATE_HYPOTHESIS.getProfile());\n+        if (sshDescription != null && !sshDescription.isEmpty()) {\n+            CgmesSshMetadataAdder adder = network.newExtension(CgmesSshMetadataAdder.class)\n+                    .setDescription(sshDescription.get(0).getId(\"description\"))\n+                    .setSshVersion(sshDescription.get(0).asInt(\"version\"))\n+                    .setModelingAuthoritySet(sshDescription.get(0).getId(\"modelingAuthoritySet\"));\n+            sshDescription.pluckLocals(\"DependentOn\").forEach(adder::addDependency);\n+            adder.add();\n+        }\n+    }\n+\n+    private void addCgmesSshControlAreas(Network network) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTU3MjQyOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjowMDowN1rOHi4sqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjowMTowNFrOHi4vQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0MjU2OA==", "bodyText": "We don't have an extension for that ? What is the difference with ActivePowerControl ?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506342568", "createdAt": "2020-10-16T12:00:07Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "diffHunk": "@@ -60,6 +60,14 @@ public void convert() {\n         if (p.asInt(\"referencePriority\", 0) > 0) {\n             SlackTerminal.reset(g.getTerminal().getVoltageLevel(), g.getTerminal());\n         }\n+        if (p.containsKey(\"normalPF\")) {\n+            // Convert to double then to string to have canonical representation of number\n+            g.setProperty(\"GeneratingUnit.normalPF\", Double.valueOf(p.get(\"normalPF\")).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0MzIzMw==", "bodyText": "Do we really need a property ? Increase an extension ?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506343233", "createdAt": "2020-10-16T12:01:04Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "diffHunk": "@@ -60,6 +60,14 @@ public void convert() {\n         if (p.asInt(\"referencePriority\", 0) > 0) {\n             SlackTerminal.reset(g.getTerminal().getVoltageLevel(), g.getTerminal());\n         }\n+        if (p.containsKey(\"normalPF\")) {\n+            // Convert to double then to string to have canonical representation of number\n+            g.setProperty(\"GeneratingUnit.normalPF\", Double.valueOf(p.get(\"normalPF\")).toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0MjU2OA=="}, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTU4ODMxOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjowMzo0NlrOHi42yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo1ODo1MlrOHkCIug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0NTE2MA==", "bodyText": "Why do we need all these properties ? We have most of these information in IIDM tap changer, no ?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506345160", "createdAt": "2020-10-16T12:03:46Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +121,80 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        return context.regulatingControlMapping().cachedRegulatingControls().get(regulatingControlId);\n+    }\n+\n+    protected void addCgmesDataAsProperties(Identifiable<?> transformer, TapChanger rtc, TapChanger ptc, Context context) {\n+        addRatioTapChangerProperties(transformer, rtc, context);\n+        addPhaseTapChangerProperties(transformer, ptc, context);\n+    }\n+\n+    private static void  addRatioTapChangerProperties(Identifiable<?> transformer, TapChanger rtc, Context context) {\n+        if (rtc == null || rtc.getId() == null) {\n+            return;\n+        }\n+\n+        if (rtc.getRegulatingControlId() != null) {\n+            String key = String.format(\"RatioTapChanger.%s.TapChangerControl\", rtc.getId());\n+            transformer.setProperty(key, rtc.getRegulatingControlId());\n+        }\n+\n+        if (rtc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, rtc, rtc.getHiddenCombinedTapChanger(), \"RatioTapChanger\", context);\n+        }\n+    }\n+\n+    private static void  addPhaseTapChangerProperties(Identifiable<?> transformer, TapChanger ptc, Context context) {\n+        if (ptc == null || ptc.getId() == null) {\n+            return;\n+        }\n+\n+        if (ptc.getRegulatingControlId() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.TapChangerControl\", ptc.getId());\n+            transformer.setProperty(key, ptc.getRegulatingControlId());\n+        }\n+        if (ptc.getType() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getId());\n+            transformer.setProperty(key, ptc.getType());\n+        }\n+\n+        if (ptc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, ptc, ptc.getHiddenCombinedTapChanger(), \"PhaseTapChanger\", context);\n+\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getHiddenCombinedTapChanger().getId());\n+            transformer.setProperty(key, ptc.getHiddenCombinedTapChanger().getType());\n+        }\n+    }\n+\n+    private static void defineHiddenTapChangerProperties(Identifiable<?> transformer, TapChanger tc, TapChanger hiddenTc, String propertyTag, Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0NTc4OQ==", "bodyText": "We have to use IIDM model in priority.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506345789", "createdAt": "2020-10-16T12:04:32Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +121,80 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        return context.regulatingControlMapping().cachedRegulatingControls().get(regulatingControlId);\n+    }\n+\n+    protected void addCgmesDataAsProperties(Identifiable<?> transformer, TapChanger rtc, TapChanger ptc, Context context) {\n+        addRatioTapChangerProperties(transformer, rtc, context);\n+        addPhaseTapChangerProperties(transformer, ptc, context);\n+    }\n+\n+    private static void  addRatioTapChangerProperties(Identifiable<?> transformer, TapChanger rtc, Context context) {\n+        if (rtc == null || rtc.getId() == null) {\n+            return;\n+        }\n+\n+        if (rtc.getRegulatingControlId() != null) {\n+            String key = String.format(\"RatioTapChanger.%s.TapChangerControl\", rtc.getId());\n+            transformer.setProperty(key, rtc.getRegulatingControlId());\n+        }\n+\n+        if (rtc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, rtc, rtc.getHiddenCombinedTapChanger(), \"RatioTapChanger\", context);\n+        }\n+    }\n+\n+    private static void  addPhaseTapChangerProperties(Identifiable<?> transformer, TapChanger ptc, Context context) {\n+        if (ptc == null || ptc.getId() == null) {\n+            return;\n+        }\n+\n+        if (ptc.getRegulatingControlId() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.TapChangerControl\", ptc.getId());\n+            transformer.setProperty(key, ptc.getRegulatingControlId());\n+        }\n+        if (ptc.getType() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getId());\n+            transformer.setProperty(key, ptc.getType());\n+        }\n+\n+        if (ptc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, ptc, ptc.getHiddenCombinedTapChanger(), \"PhaseTapChanger\", context);\n+\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getHiddenCombinedTapChanger().getId());\n+            transformer.setProperty(key, ptc.getHiddenCombinedTapChanger().getType());\n+        }\n+    }\n+\n+    private static void defineHiddenTapChangerProperties(Identifiable<?> transformer, TapChanger tc, TapChanger hiddenTc, String propertyTag, Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0NTE2MA=="}, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0NDU0NQ==", "bodyText": "@zamarrenolm How much does it happen?\nAnother thing: for a hidden tap changer, I would rather have an extension than a lot of properties...", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r507544545", "createdAt": "2020-10-19T07:56:52Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +121,80 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        return context.regulatingControlMapping().cachedRegulatingControls().get(regulatingControlId);\n+    }\n+\n+    protected void addCgmesDataAsProperties(Identifiable<?> transformer, TapChanger rtc, TapChanger ptc, Context context) {\n+        addRatioTapChangerProperties(transformer, rtc, context);\n+        addPhaseTapChangerProperties(transformer, ptc, context);\n+    }\n+\n+    private static void  addRatioTapChangerProperties(Identifiable<?> transformer, TapChanger rtc, Context context) {\n+        if (rtc == null || rtc.getId() == null) {\n+            return;\n+        }\n+\n+        if (rtc.getRegulatingControlId() != null) {\n+            String key = String.format(\"RatioTapChanger.%s.TapChangerControl\", rtc.getId());\n+            transformer.setProperty(key, rtc.getRegulatingControlId());\n+        }\n+\n+        if (rtc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, rtc, rtc.getHiddenCombinedTapChanger(), \"RatioTapChanger\", context);\n+        }\n+    }\n+\n+    private static void  addPhaseTapChangerProperties(Identifiable<?> transformer, TapChanger ptc, Context context) {\n+        if (ptc == null || ptc.getId() == null) {\n+            return;\n+        }\n+\n+        if (ptc.getRegulatingControlId() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.TapChangerControl\", ptc.getId());\n+            transformer.setProperty(key, ptc.getRegulatingControlId());\n+        }\n+        if (ptc.getType() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getId());\n+            transformer.setProperty(key, ptc.getType());\n+        }\n+\n+        if (ptc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, ptc, ptc.getHiddenCombinedTapChanger(), \"PhaseTapChanger\", context);\n+\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getHiddenCombinedTapChanger().getId());\n+            transformer.setProperty(key, ptc.getHiddenCombinedTapChanger().getType());\n+        }\n+    }\n+\n+    private static void defineHiddenTapChangerProperties(Identifiable<?> transformer, TapChanger tc, TapChanger hiddenTc, String propertyTag, Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0NTE2MA=="}, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0NTc4Ng==", "bodyText": "@zamarrenolm If it doesn't happen a lot and if there is no physical sense, we can afford to lose them (maybe with a warning?)", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r507545786", "createdAt": "2020-10-19T07:58:52Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -120,4 +121,80 @@ protected void addAliases(Identifiable<?> identifiable) {\n             }\n         }\n     }\n+\n+    private static RegulatingControl getRegulatingControl(Context context, String regulatingControlId) {\n+        return context.regulatingControlMapping().cachedRegulatingControls().get(regulatingControlId);\n+    }\n+\n+    protected void addCgmesDataAsProperties(Identifiable<?> transformer, TapChanger rtc, TapChanger ptc, Context context) {\n+        addRatioTapChangerProperties(transformer, rtc, context);\n+        addPhaseTapChangerProperties(transformer, ptc, context);\n+    }\n+\n+    private static void  addRatioTapChangerProperties(Identifiable<?> transformer, TapChanger rtc, Context context) {\n+        if (rtc == null || rtc.getId() == null) {\n+            return;\n+        }\n+\n+        if (rtc.getRegulatingControlId() != null) {\n+            String key = String.format(\"RatioTapChanger.%s.TapChangerControl\", rtc.getId());\n+            transformer.setProperty(key, rtc.getRegulatingControlId());\n+        }\n+\n+        if (rtc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, rtc, rtc.getHiddenCombinedTapChanger(), \"RatioTapChanger\", context);\n+        }\n+    }\n+\n+    private static void  addPhaseTapChangerProperties(Identifiable<?> transformer, TapChanger ptc, Context context) {\n+        if (ptc == null || ptc.getId() == null) {\n+            return;\n+        }\n+\n+        if (ptc.getRegulatingControlId() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.TapChangerControl\", ptc.getId());\n+            transformer.setProperty(key, ptc.getRegulatingControlId());\n+        }\n+        if (ptc.getType() != null) {\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getId());\n+            transformer.setProperty(key, ptc.getType());\n+        }\n+\n+        if (ptc.getHiddenCombinedTapChanger() != null) {\n+            defineHiddenTapChangerProperties(transformer, ptc, ptc.getHiddenCombinedTapChanger(), \"PhaseTapChanger\", context);\n+\n+            String key = String.format(\"PhaseTapChanger.%s.type\", ptc.getHiddenCombinedTapChanger().getId());\n+            transformer.setProperty(key, ptc.getHiddenCombinedTapChanger().getType());\n+        }\n+    }\n+\n+    private static void defineHiddenTapChangerProperties(Identifiable<?> transformer, TapChanger tc, TapChanger hiddenTc, String propertyTag, Context context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0NTE2MA=="}, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTYyNTgzOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/TapChanger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoxMjoxN1rOHi5PbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoxMjoxN1rOHi5PbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1MTQ2OA==", "bodyText": "For hidden combined tap changer: see my comment about the two modes of the conversion. I am not sure we have to support that in the mode USING_ONLY_NETWORK_PARAMETER.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506351468", "createdAt": "2020-10-16T12:12:17Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/TapChanger.java", "diffHunk": "@@ -173,6 +180,11 @@ public TapChanger setTapChangerControlEnabled(boolean tapChangerControlEnabled)\n         return this;\n     }\n \n+    public TapChanger setHiddenCombinedTapChanger(TapChanger hiddenCombinedTapChanger) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTY0MDgwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/extensions/CgmesSshControlAreas.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoxNTo0NVrOHi5ZFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoxNTo0NVrOHi5ZFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1Mzk0Mw==", "bodyText": "I am really not sure about this extension as we don't have the use case.Maybe we have to accept to not support these fields in the beginning.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r506353943", "createdAt": "2020-10-16T12:15:45Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/extensions/CgmesSshControlAreas.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.extensions;\n+\n+import com.powsybl.cgmes.conversion.extensions.CgmesSshControlAreasImpl.ControlArea;\n+import com.powsybl.commons.extensions.Extension;\n+import com.powsybl.iidm.network.Network;\n+\n+import java.util.List;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public interface CgmesSshControlAreas extends Extension<Network> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a338f37b32967ea02668fb9fe1f8f5112826d9c9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDM3OTE3OnYy", "diffSide": "LEFT", "path": "cgmes/cgmes-conversion/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDo0Mjo1MFrOH46PHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowMzoxMFrOH5FBuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzNjQ0Ng==", "bodyText": "Just a question, why did you remove the version?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529436446", "createdAt": "2020-11-24T10:42:50Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/pom.xml", "diffHunk": "@@ -193,7 +193,6 @@\n         <dependency>\n             <groupId>org.xmlunit</groupId>\n             <artifactId>xmlunit-core</artifactId>\n-            <version>${xmlunit.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzI0MQ==", "bodyText": "The version details about external dependencies are specified only in the root pom.xml. All modules should just reference the artifact that has been declared there.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529613241", "createdAt": "2020-11-24T15:03:10Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/pom.xml", "diffHunk": "@@ -193,7 +193,6 @@\n         <dependency>\n             <groupId>org.xmlunit</groupId>\n             <artifactId>xmlunit-core</artifactId>\n-            <version>${xmlunit.version}</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzNjQ0Ng=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDM5MDQwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDo0NDoyNlrOH46WdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwODoyODoyM1rOH5oAfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzODMyNQ==", "bodyText": "params is never supposed to be null, I think it is okay to throw a NullPointerException if it happens (otherwise, it would have a different behavior than the other exporters and that might be weird)", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529438325", "createdAt": "2020-11-24T10:44:26Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -7,42 +7,91 @@\n \n package com.powsybl.cgmes.conversion;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n import java.util.Properties;\n \n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n import com.google.auto.service.AutoService;\n+import com.google.common.collect.ImmutableList;\n+import com.powsybl.cgmes.conversion.export.CgmesExportContext;\n+import com.powsybl.cgmes.conversion.export.StateVariablesAdder;\n+import com.powsybl.cgmes.conversion.export.StateVariablesExport;\n+import com.powsybl.cgmes.conversion.export.SteadyStateHypothesisExport;\n import com.powsybl.cgmes.conversion.update.CgmesUpdate;\n-import com.powsybl.cgmes.conversion.update.StateVariablesAdder;\n import com.powsybl.cgmes.model.CgmesModel;\n import com.powsybl.cgmes.model.CgmesModelException;\n import com.powsybl.cgmes.model.CgmesModelFactory;\n import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.commons.xml.XmlUtil;\n+import com.powsybl.iidm.ConversionParameters;\n import com.powsybl.iidm.export.Exporter;\n import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterType;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n  */\n @AutoService(Exporter.class)\n public class CgmesExport implements Exporter {\n \n+    public List<Parameter> getParameters() {\n+        return Collections.unmodifiableList(STATIC_PARAMETERS);\n+    }\n+\n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n+        Objects.requireNonNull(network);\n+        if (params != null && ConversionParameters.readBooleanParameter(getFormat(), params, USING_ONLY_NETWORK_PARAMETER)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNzY1OA==", "bodyText": "Sorry, I always thought parameters in Exporters.export API could be null. In fact TestExporter in package com.powsybl.iidm.export and a few related tests use parameters == null.\nAlso, I followed the XmlExporter, where the parameters are used in the createExportOptions method, that finally ends in the ConversionParameters.readParameter method, where parameters is explicitly checked for null, so null is also allowed in iidm-xml-converter.\nAm I right ? Am I missing something ?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529627658", "createdAt": "2020-11-24T15:21:11Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -7,42 +7,91 @@\n \n package com.powsybl.cgmes.conversion;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n import java.util.Properties;\n \n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n import com.google.auto.service.AutoService;\n+import com.google.common.collect.ImmutableList;\n+import com.powsybl.cgmes.conversion.export.CgmesExportContext;\n+import com.powsybl.cgmes.conversion.export.StateVariablesAdder;\n+import com.powsybl.cgmes.conversion.export.StateVariablesExport;\n+import com.powsybl.cgmes.conversion.export.SteadyStateHypothesisExport;\n import com.powsybl.cgmes.conversion.update.CgmesUpdate;\n-import com.powsybl.cgmes.conversion.update.StateVariablesAdder;\n import com.powsybl.cgmes.model.CgmesModel;\n import com.powsybl.cgmes.model.CgmesModelException;\n import com.powsybl.cgmes.model.CgmesModelFactory;\n import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.commons.xml.XmlUtil;\n+import com.powsybl.iidm.ConversionParameters;\n import com.powsybl.iidm.export.Exporter;\n import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterType;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n  */\n @AutoService(Exporter.class)\n public class CgmesExport implements Exporter {\n \n+    public List<Parameter> getParameters() {\n+        return Collections.unmodifiableList(STATIC_PARAMETERS);\n+    }\n+\n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n+        Objects.requireNonNull(network);\n+        if (params != null && ConversionParameters.readBooleanParameter(getFormat(), params, USING_ONLY_NETWORK_PARAMETER)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzODMyNQ=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2NjY5OA==", "bodyText": "You are right parameters can be null, I stand corrected!\nHowever, an issue remains: it means network can't be exported using only network when params is null, why is that? The test params != null should be removed for me", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r530166698", "createdAt": "2020-11-25T07:51:20Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -7,42 +7,91 @@\n \n package com.powsybl.cgmes.conversion;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n import java.util.Properties;\n \n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n import com.google.auto.service.AutoService;\n+import com.google.common.collect.ImmutableList;\n+import com.powsybl.cgmes.conversion.export.CgmesExportContext;\n+import com.powsybl.cgmes.conversion.export.StateVariablesAdder;\n+import com.powsybl.cgmes.conversion.export.StateVariablesExport;\n+import com.powsybl.cgmes.conversion.export.SteadyStateHypothesisExport;\n import com.powsybl.cgmes.conversion.update.CgmesUpdate;\n-import com.powsybl.cgmes.conversion.update.StateVariablesAdder;\n import com.powsybl.cgmes.model.CgmesModel;\n import com.powsybl.cgmes.model.CgmesModelException;\n import com.powsybl.cgmes.model.CgmesModelFactory;\n import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.commons.xml.XmlUtil;\n+import com.powsybl.iidm.ConversionParameters;\n import com.powsybl.iidm.export.Exporter;\n import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterType;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n  */\n @AutoService(Exporter.class)\n public class CgmesExport implements Exporter {\n \n+    public List<Parameter> getParameters() {\n+        return Collections.unmodifiableList(STATIC_PARAMETERS);\n+    }\n+\n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n+        Objects.requireNonNull(network);\n+        if (params != null && ConversionParameters.readBooleanParameter(getFormat(), params, USING_ONLY_NETWORK_PARAMETER)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzODMyNQ=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4NjM2Ng==", "bodyText": "Totally right, there is no need to check for params != null. The ConversionParameters.readBooleanParameter will take care of parameters received as Properties, ignoring them if they are null or overriding configuration if they are provided.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r530186366", "createdAt": "2020-11-25T08:28:23Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -7,42 +7,91 @@\n \n package com.powsybl.cgmes.conversion;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n import java.util.Properties;\n \n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n import com.google.auto.service.AutoService;\n+import com.google.common.collect.ImmutableList;\n+import com.powsybl.cgmes.conversion.export.CgmesExportContext;\n+import com.powsybl.cgmes.conversion.export.StateVariablesAdder;\n+import com.powsybl.cgmes.conversion.export.StateVariablesExport;\n+import com.powsybl.cgmes.conversion.export.SteadyStateHypothesisExport;\n import com.powsybl.cgmes.conversion.update.CgmesUpdate;\n-import com.powsybl.cgmes.conversion.update.StateVariablesAdder;\n import com.powsybl.cgmes.model.CgmesModel;\n import com.powsybl.cgmes.model.CgmesModelException;\n import com.powsybl.cgmes.model.CgmesModelFactory;\n import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.commons.xml.XmlUtil;\n+import com.powsybl.iidm.ConversionParameters;\n import com.powsybl.iidm.export.Exporter;\n import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterType;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n  */\n @AutoService(Exporter.class)\n public class CgmesExport implements Exporter {\n \n+    public List<Parameter> getParameters() {\n+        return Collections.unmodifiableList(STATIC_PARAMETERS);\n+    }\n+\n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n+        Objects.requireNonNull(network);\n+        if (params != null && ConversionParameters.readBooleanParameter(getFormat(), params, USING_ONLY_NETWORK_PARAMETER)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzODMyNQ=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDYxNDgzOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMToyOTowM1rOH48j7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyNTozMFrOH5GIkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NDU0Mw==", "bodyText": "I think this method can be static", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529474543", "createdAt": "2020-11-24T11:29:03Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -7,42 +7,91 @@\n \n package com.powsybl.cgmes.conversion;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n import java.util.Properties;\n \n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n import com.google.auto.service.AutoService;\n+import com.google.common.collect.ImmutableList;\n+import com.powsybl.cgmes.conversion.export.CgmesExportContext;\n+import com.powsybl.cgmes.conversion.export.StateVariablesAdder;\n+import com.powsybl.cgmes.conversion.export.StateVariablesExport;\n+import com.powsybl.cgmes.conversion.export.SteadyStateHypothesisExport;\n import com.powsybl.cgmes.conversion.update.CgmesUpdate;\n-import com.powsybl.cgmes.conversion.update.StateVariablesAdder;\n import com.powsybl.cgmes.model.CgmesModel;\n import com.powsybl.cgmes.model.CgmesModelException;\n import com.powsybl.cgmes.model.CgmesModelFactory;\n import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.commons.xml.XmlUtil;\n+import com.powsybl.iidm.ConversionParameters;\n import com.powsybl.iidm.export.Exporter;\n import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterType;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n  */\n @AutoService(Exporter.class)\n public class CgmesExport implements Exporter {\n \n+    public List<Parameter> getParameters() {\n+        return Collections.unmodifiableList(STATIC_PARAMETERS);\n+    }\n+\n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n+        Objects.requireNonNull(network);\n+        if (params != null && ConversionParameters.readBooleanParameter(getFormat(), params, USING_ONLY_NETWORK_PARAMETER)) {\n+            exportUsingOnlyNetwork(network, params, ds);\n+        } else {\n+            CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n+            if (ext == null) {\n+                throw new CgmesModelException(\"CGMES model is required and not found in Network extension\");\n+            }\n+            exportUsingOriginalCgmesModel(network, ds, ext);\n+        }\n+    }\n+\n+    private String baseName(Network network, Properties params) {\n+        String baseName = ConversionParameters.readStringParameter(getFormat(), params, BASE_NAME_PARAMETER);\n+        return baseName != null ? baseName : network.getNameOrId();\n+    }\n \n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n-        CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+    private void exportUsingOnlyNetwork(Network network, Properties params, DataSource ds) {\n+        // At this point only SSH, SV can be exported when relying only in Network data\n+        // (minimum amount of CGMES references are expected as aliases/properties/extensions)\n+        String baseName = baseName(network, params);\n+        String filenameSv = baseName + \"_SV.xml\";\n+        String filenameSsh = baseName + \"_SSH.xml\";\n+        CgmesExportContext context = new CgmesExportContext(network);\n+        try (OutputStream osv = ds.newOutputStream(filenameSv, false);\n+                OutputStream ossh = ds.newOutputStream(filenameSsh, false)) {\n+            XMLStreamWriter writer;\n+            writer = XmlUtil.initializeWriter(true, \"    \", osv);\n+            StateVariablesExport.write(network, writer, context);\n+            writer = XmlUtil.initializeWriter(true, \"    \", ossh);\n+            SteadyStateHypothesisExport.write(network, writer, context);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n         }\n-        CgmesUpdate cgmesUpdate = ext.getCgmesUpdate();\n+    }\n \n+    private void exportUsingOriginalCgmesModel(Network network, DataSource ds, CgmesModelExtension ext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMTM3Nw==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529631377", "createdAt": "2020-11-24T15:25:30Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -7,42 +7,91 @@\n \n package com.powsybl.cgmes.conversion;\n \n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n import java.util.Properties;\n \n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n import com.google.auto.service.AutoService;\n+import com.google.common.collect.ImmutableList;\n+import com.powsybl.cgmes.conversion.export.CgmesExportContext;\n+import com.powsybl.cgmes.conversion.export.StateVariablesAdder;\n+import com.powsybl.cgmes.conversion.export.StateVariablesExport;\n+import com.powsybl.cgmes.conversion.export.SteadyStateHypothesisExport;\n import com.powsybl.cgmes.conversion.update.CgmesUpdate;\n-import com.powsybl.cgmes.conversion.update.StateVariablesAdder;\n import com.powsybl.cgmes.model.CgmesModel;\n import com.powsybl.cgmes.model.CgmesModelException;\n import com.powsybl.cgmes.model.CgmesModelFactory;\n import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.commons.xml.XmlUtil;\n+import com.powsybl.iidm.ConversionParameters;\n import com.powsybl.iidm.export.Exporter;\n import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterType;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n  */\n @AutoService(Exporter.class)\n public class CgmesExport implements Exporter {\n \n+    public List<Parameter> getParameters() {\n+        return Collections.unmodifiableList(STATIC_PARAMETERS);\n+    }\n+\n     @Override\n     public void export(Network network, Properties params, DataSource ds) {\n+        Objects.requireNonNull(network);\n+        if (params != null && ConversionParameters.readBooleanParameter(getFormat(), params, USING_ONLY_NETWORK_PARAMETER)) {\n+            exportUsingOnlyNetwork(network, params, ds);\n+        } else {\n+            CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n+            if (ext == null) {\n+                throw new CgmesModelException(\"CGMES model is required and not found in Network extension\");\n+            }\n+            exportUsingOriginalCgmesModel(network, ds, ext);\n+        }\n+    }\n+\n+    private String baseName(Network network, Properties params) {\n+        String baseName = ConversionParameters.readStringParameter(getFormat(), params, BASE_NAME_PARAMETER);\n+        return baseName != null ? baseName : network.getNameOrId();\n+    }\n \n-        // Right now the network must contain the original CgmesModel\n-        // In the future it should be possible to export to CGMES\n-        // directly from an IIDM Network,\n-        // without the need for the original CgmesModel\n-        CgmesModelExtension ext = network.getExtension(CgmesModelExtension.class);\n-        if (ext == null) {\n-            throw new CgmesModelException(\"No extension for CGMES model found in Network\");\n+    private void exportUsingOnlyNetwork(Network network, Properties params, DataSource ds) {\n+        // At this point only SSH, SV can be exported when relying only in Network data\n+        // (minimum amount of CGMES references are expected as aliases/properties/extensions)\n+        String baseName = baseName(network, params);\n+        String filenameSv = baseName + \"_SV.xml\";\n+        String filenameSsh = baseName + \"_SSH.xml\";\n+        CgmesExportContext context = new CgmesExportContext(network);\n+        try (OutputStream osv = ds.newOutputStream(filenameSv, false);\n+                OutputStream ossh = ds.newOutputStream(filenameSsh, false)) {\n+            XMLStreamWriter writer;\n+            writer = XmlUtil.initializeWriter(true, \"    \", osv);\n+            StateVariablesExport.write(network, writer, context);\n+            writer = XmlUtil.initializeWriter(true, \"    \", ossh);\n+            SteadyStateHypothesisExport.write(network, writer, context);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n         }\n-        CgmesUpdate cgmesUpdate = ext.getCgmesUpdate();\n+    }\n \n+    private void exportUsingOriginalCgmesModel(Network network, DataSource ds, CgmesModelExtension ext) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NDU0Mw=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDYyNTQwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMTozMTo0NlrOH48qPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyNTozN1rOH5GJJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NjE1Nw==", "bodyText": "Maybe add a TODO comment", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529476157", "createdAt": "2020-11-24T11:31:46Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "diffHunk": "@@ -306,6 +309,25 @@ private void addCgmesSvMetadata(Network network) {\n         }\n     }\n \n+    private void addCgmesSshMetadata(Network network) {\n+        PropertyBags sshDescription = cgmes.fullModel(CgmesSubset.STEADY_STATE_HYPOTHESIS.getProfile());\n+        if (sshDescription != null && !sshDescription.isEmpty()) {\n+            CgmesSshMetadataAdder adder = network.newExtension(CgmesSshMetadataAdder.class)\n+                    .setDescription(sshDescription.get(0).getId(\"description\"))\n+                    .setSshVersion(sshDescription.get(0).asInt(\"version\"))\n+                    .setModelingAuthoritySet(sshDescription.get(0).getId(\"modelingAuthoritySet\"));\n+            sshDescription.pluckLocals(\"DependentOn\").forEach(adder::addDependency);\n+            adder.add();\n+        }\n+    }\n+\n+    private void addCgmesSshControlAreas(Network network, Context context) {\n+        PropertyBags sshControlAreas = cgmes.controlAreas();\n+        if (sshControlAreas != null && !sshControlAreas.isEmpty()) {\n+            context.ignored(\"ControlAreas\", \"Unsupported in current version\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMTUyNA==", "bodyText": "added TODO comment", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529631524", "createdAt": "2020-11-24T15:25:37Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Conversion.java", "diffHunk": "@@ -306,6 +309,25 @@ private void addCgmesSvMetadata(Network network) {\n         }\n     }\n \n+    private void addCgmesSshMetadata(Network network) {\n+        PropertyBags sshDescription = cgmes.fullModel(CgmesSubset.STEADY_STATE_HYPOTHESIS.getProfile());\n+        if (sshDescription != null && !sshDescription.isEmpty()) {\n+            CgmesSshMetadataAdder adder = network.newExtension(CgmesSshMetadataAdder.class)\n+                    .setDescription(sshDescription.get(0).getId(\"description\"))\n+                    .setSshVersion(sshDescription.get(0).asInt(\"version\"))\n+                    .setModelingAuthoritySet(sshDescription.get(0).getId(\"modelingAuthoritySet\"));\n+            sshDescription.pluckLocals(\"DependentOn\").forEach(adder::addDependency);\n+            adder.add();\n+        }\n+    }\n+\n+    private void addCgmesSshControlAreas(Network network, Context context) {\n+        PropertyBags sshControlAreas = cgmes.controlAreas();\n+        if (sshControlAreas != null && !sshControlAreas.isEmpty()) {\n+            context.ignored(\"ControlAreas\", \"Unsupported in current version\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NjE1Nw=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTA4ODY2OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozNDowMFrOH5BB-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTowNDozM1rOH5pXxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0Nzc3MA==", "bodyText": "Why is it necessary?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529547770", "createdAt": "2020-11-24T13:34:00Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -109,15 +109,41 @@ protected void addAliases(Identifiable<?> identifiable) {\n         if (ptcs != null) {\n             for (int  i = 0; i < ptcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + index));\n+                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + index));\n             }\n         }\n         List<String> rtcs = context.cgmes().ratioTapChangerListForPowerTransformer(identifiable.getId());\n         if (rtcs != null) {\n             for (int i = 0; i < rtcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + index));\n+                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + index));\n             }\n         }\n     }\n+\n+    protected static void addCgmesReferences(Identifiable<?> transformer, TapChanger tc) {\n+        if (tc == null || tc.getId() == null) {\n+            return;\n+        }\n+        if (tc.getRegulatingControlId() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"TapChangerControl\"), tc.getRegulatingControlId());\n+        }\n+        if (tc.getType() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"type\"), tc.getType());\n+        }\n+        TapChanger tch = tc.getHiddenCombinedTapChanger();\n+        if (tch != null) {\n+            // All the tap changers have already been added as aliases,\n+            // Through properties we only label which one has been combined and kept hidden\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"hiddenTapChangerId\"), tch.getId());\n+            transformer.setProperty(cgmesReferenceKey(tch.getId(), \"step\"), String.valueOf(tch.getTapPosition()));\n+            if (tch.getType() != null) {\n+                transformer.setProperty(cgmesReferenceKey(tch.getId(), \"type\"), tch.getType());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0MzU2Ng==", "bodyText": "For phase tap changers, the subtype of tap changer (Linear, non-Linear Asymmetrical, non-Linear Symmetrical) must be stored as a property because the subtype class name is required for proper SSH export. The XML element must be named with the subtype. An example for the MicroGrid test case:\n  <cim:PhaseTapChangerAsymmetrical rdf:about=\"#_6ebbef67-3061-4236-a6fd-6ccc4595f6c3\">\n    <cim:TapChanger.step>10</cim:TapChanger.step>\n    <cim:TapChanger.controlEnabled>true</cim:TapChanger.controlEnabled>\n  </cim:PhaseTapChangerAsymmetrical>\nIn PowSyBl all phase tap changers are tabular, and there is no other way to recover this information from the IIDM PhaseTapChanger object, so we decided to save it as a property.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529643566", "createdAt": "2020-11-24T15:34:18Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -109,15 +109,41 @@ protected void addAliases(Identifiable<?> identifiable) {\n         if (ptcs != null) {\n             for (int  i = 0; i < ptcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + index));\n+                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + index));\n             }\n         }\n         List<String> rtcs = context.cgmes().ratioTapChangerListForPowerTransformer(identifiable.getId());\n         if (rtcs != null) {\n             for (int i = 0; i < rtcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + index));\n+                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + index));\n             }\n         }\n     }\n+\n+    protected static void addCgmesReferences(Identifiable<?> transformer, TapChanger tc) {\n+        if (tc == null || tc.getId() == null) {\n+            return;\n+        }\n+        if (tc.getRegulatingControlId() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"TapChangerControl\"), tc.getRegulatingControlId());\n+        }\n+        if (tc.getType() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"type\"), tc.getType());\n+        }\n+        TapChanger tch = tc.getHiddenCombinedTapChanger();\n+        if (tch != null) {\n+            // All the tap changers have already been added as aliases,\n+            // Through properties we only label which one has been combined and kept hidden\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"hiddenTapChangerId\"), tch.getId());\n+            transformer.setProperty(cgmesReferenceKey(tch.getId(), \"step\"), String.valueOf(tch.getTapPosition()));\n+            if (tch.getType() != null) {\n+                transformer.setProperty(cgmesReferenceKey(tch.getId(), \"type\"), tch.getType());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0Nzc3MA=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2OTM2MA==", "bodyText": "Okay! In this case, I wrote it in SSHExport file, but in export, the default type should be tabular", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r530169360", "createdAt": "2020-11-25T07:56:34Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -109,15 +109,41 @@ protected void addAliases(Identifiable<?> identifiable) {\n         if (ptcs != null) {\n             for (int  i = 0; i < ptcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + index));\n+                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + index));\n             }\n         }\n         List<String> rtcs = context.cgmes().ratioTapChangerListForPowerTransformer(identifiable.getId());\n         if (rtcs != null) {\n             for (int i = 0; i < rtcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + index));\n+                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + index));\n             }\n         }\n     }\n+\n+    protected static void addCgmesReferences(Identifiable<?> transformer, TapChanger tc) {\n+        if (tc == null || tc.getId() == null) {\n+            return;\n+        }\n+        if (tc.getRegulatingControlId() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"TapChangerControl\"), tc.getRegulatingControlId());\n+        }\n+        if (tc.getType() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"type\"), tc.getType());\n+        }\n+        TapChanger tch = tc.getHiddenCombinedTapChanger();\n+        if (tch != null) {\n+            // All the tap changers have already been added as aliases,\n+            // Through properties we only label which one has been combined and kept hidden\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"hiddenTapChangerId\"), tch.getId());\n+            transformer.setProperty(cgmesReferenceKey(tch.getId(), \"step\"), String.valueOf(tch.getTapPosition()));\n+            if (tch.getType() != null) {\n+                transformer.setProperty(cgmesReferenceKey(tch.getId(), \"type\"), tch.getType());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0Nzc3MA=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIwODcwOA==", "bodyText": "You are right, I fixed the default value (PhaseTapChanger is an abstract class in CGMES, a subtype must be used, and default should be PhaseTapChangerTabular, according to IIDM modelling).", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r530208708", "createdAt": "2020-11-25T09:04:33Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/transformers/AbstractTransformerConversion.java", "diffHunk": "@@ -109,15 +109,41 @@ protected void addAliases(Identifiable<?> identifiable) {\n         if (ptcs != null) {\n             for (int  i = 0; i < ptcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + index));\n+                Optional.ofNullable(ptcs.get(i)).ifPresent(ptc -> identifiable.addAlias(ptc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + index));\n             }\n         }\n         List<String> rtcs = context.cgmes().ratioTapChangerListForPowerTransformer(identifiable.getId());\n         if (rtcs != null) {\n             for (int i = 0; i < rtcs.size(); i++) {\n                 int index = i + 1;\n-                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + index));\n+                Optional.ofNullable(rtcs.get(i)).ifPresent(rtc -> identifiable.addAlias(rtc, Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + index));\n             }\n         }\n     }\n+\n+    protected static void addCgmesReferences(Identifiable<?> transformer, TapChanger tc) {\n+        if (tc == null || tc.getId() == null) {\n+            return;\n+        }\n+        if (tc.getRegulatingControlId() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"TapChangerControl\"), tc.getRegulatingControlId());\n+        }\n+        if (tc.getType() != null) {\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"type\"), tc.getType());\n+        }\n+        TapChanger tch = tc.getHiddenCombinedTapChanger();\n+        if (tch != null) {\n+            // All the tap changers have already been added as aliases,\n+            // Through properties we only label which one has been combined and kept hidden\n+            transformer.setProperty(cgmesReferenceKey(tc.getId(), \"hiddenTapChangerId\"), tch.getId());\n+            transformer.setProperty(cgmesReferenceKey(tch.getId(), \"step\"), String.valueOf(tch.getTapPosition()));\n+            if (tch.getType() != null) {\n+                transformer.setProperty(cgmesReferenceKey(tch.getId(), \"type\"), tch.getType());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0Nzc3MA=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTA5Njc1OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForTransformers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozNTo1MVrOH5BG5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0MDo1NFrOH5Hd1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0OTAyOA==", "bodyText": "I didn't find out where you added the regulatingControlId of transformers?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529549028", "createdAt": "2020-11-24T13:35:51Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForTransformers.java", "diffHunk": "@@ -64,9 +64,10 @@ public CgmesRegulatingControlRatio buildRegulatingControlRatio(String id, String\n         return rtc;\n     }\n \n-    public CgmesRegulatingControlPhase buildRegulatingControlPhase(String regulatingControlId,\n+    public CgmesRegulatingControlPhase buildRegulatingControlPhase(String id, String regulatingControlId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MzIwNA==", "bodyText": "In the AbstractTransformerConversion.addCgmesReferences method:\nif (tc.getRegulatingControlId() != null) {\n    transformer.setProperty(cgmesReferenceKey(tc.getId(), \"TapChangerControl\"), tc.getRegulatingControlId());\n}", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529653204", "createdAt": "2020-11-24T15:40:54Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForTransformers.java", "diffHunk": "@@ -64,9 +64,10 @@ public CgmesRegulatingControlRatio buildRegulatingControlRatio(String id, String\n         return rtc;\n     }\n \n-    public CgmesRegulatingControlPhase buildRegulatingControlPhase(String regulatingControlId,\n+    public CgmesRegulatingControlPhase buildRegulatingControlPhase(String id, String regulatingControlId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0OTAyOA=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTEwNTY1OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozNzo1NlrOH5BMdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0NzozNFrOH5IC3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDQ1Mg==", "bodyText": "Is this case supposed to happen? If not, throw an AssertionError", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529550452", "createdAt": "2020-11-24T13:37:56Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    linearNonlinear = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    linearNonlinear = \"Nonlinear\";\n+                    break;\n+                default:\n+                    linearNonlinear = \"\";\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2MjY4Ng==", "bodyText": "AssertionError thrown", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529662686", "createdAt": "2020-11-24T15:47:34Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    linearNonlinear = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    linearNonlinear = \"Nonlinear\";\n+                    break;\n+                default:\n+                    linearNonlinear = \"\";\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDQ1Mg=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTEwNjg3OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozODoxOFrOH5BNUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0ODozMFrOH5IH1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDY3NA==", "bodyText": "Maybe call it shuntType?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529550674", "createdAt": "2020-11-24T13:38:18Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2Mzk1OQ==", "bodyText": "renamed", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529663959", "createdAt": "2020-11-24T15:48:30Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDY3NA=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTExOTk0OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzo0MToyMVrOH5BVTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo1MDowNFrOH5IQrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MjcxOA==", "bodyText": "Add default case and throw an exception", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529552718", "createdAt": "2020-11-24T13:41:21Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    linearNonlinear = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    linearNonlinear = \"Nonlinear\";\n+                    break;\n+                default:\n+                    linearNonlinear = \"\";\n+                    break;\n+            }\n+            boolean controlEnabled = s.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, linearNonlinear + \"ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + s.getId());\n+            writer.writeStartElement(cimNamespace, \"ShuntCompensator.sections\");\n+            writer.writeCharacters(CgmesExportUtil.format(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+            addRegulatingControlView(s, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(ShuntCompensator s, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (s.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as discrete, with a certain targetDeadband\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = s.getProperty(REGULATING_CONTROL_PROPERTY);\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, true,\n+                s.isVoltageRegulatorOn(), s.getTargetDeadband(), s.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeSynchronousMachines(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (Generator g : network.getGenerators()) {\n+            boolean controlEnabled = g.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + g.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.p\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getP()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine.referencePriority\");\n+            // reference priority is used for angle reference selection (slack)\n+            writer.writeCharacters(isInSlackBus(g) ? \"1\" : \"0\");\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(cimNamespace, \"SynchronousMachine.operatingMode\");\n+            // All generators in PowSyBl are considered as generator, not motor\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, cimNamespace + \"SynchronousMachineOperatingMode.generator\");\n+            writer.writeEndElement();\n+\n+            addRegulatingControlView(g, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(Generator g, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (g.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as continuous and with targetDeadband of size 0\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = g.getProperty(REGULATING_CONTROL_PROPERTY);\n+            double targetDeadband = 0;\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                g.isVoltageRegulatorOn(), targetDeadband, g.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeStaticVarCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (StaticVarCompensator svc : network.getStaticVarCompensators()) {\n+            StaticVarCompensator.RegulationMode regulationMode = svc.getRegulationMode();\n+            boolean controlEnabled = regulationMode != StaticVarCompensator.RegulationMode.OFF;\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + svc.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(svc.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+\n+            if (svc.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+                String rcid = svc.getProperty(REGULATING_CONTROL_PROPERTY);\n+                double targetDeadband = 0;\n+                // Regulating control could be reactive power or voltage\n+                double targetValue;\n+                String multiplier;\n+                if (regulationMode == StaticVarCompensator.RegulationMode.VOLTAGE) {\n+                    targetValue = svc.getVoltageSetpoint();\n+                    multiplier = \"k\";\n+                } else if (regulationMode == StaticVarCompensator.RegulationMode.REACTIVE_POWER) {\n+                    targetValue = svc.getReactivePowerSetpoint();\n+                    multiplier = \"M\";\n+                } else {\n+                    targetValue = 0;\n+                    multiplier = \"k\";\n+                }\n+                RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                        controlEnabled, targetDeadband, targetValue, multiplier);\n+                regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static boolean isInSlackBus(Generator g) {\n+        VoltageLevel vl = g.getTerminal().getVoltageLevel();\n+        SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+        if (slackTerminal != null) {\n+            Bus slackBus = slackTerminal.getTerminal().getBusBreakerView().getBus();\n+            if (slackBus == g.getTerminal().getBusBreakerView().getBus()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void writeTapChanger(String type, String id, TapChanger<?, ?> tc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writeTapChanger(type, id, tc.isRegulating(), tc.getTapPosition(), cimNamespace, writer);\n+    }\n+\n+    private static void writeTapChanger(String type, String id, boolean controlEnabled, int step, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, type);\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + id);\n+        writer.writeStartElement(cimNamespace, \"TapChanger.controlEnabled\");\n+        writer.writeCharacters(Boolean.toString(controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"TapChanger.step\");\n+        writer.writeCharacters(CgmesExportUtil.format(step));\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void addRegulatingControlView(TapChanger tc, String tcId, Identifiable<?> eq, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        // Multiple tap changers can be stored at the same equipment\n+        // We use the tap changer id as part of the key for storing the tap changer control id\n+        String key = String.format(\"%s%s.TapChangerControl\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId);\n+        if (eq.hasProperty(key)) {\n+            String controlId = eq.getProperty(key);\n+            RegulatingControlView rcv = null;\n+            if (tc instanceof RatioTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((RatioTapChanger) tc).getTargetV(),\n+                        // Unit multiplier is k for ratio tap changers (regulation value is a voltage in kV)\n+                        \"k\");\n+            } else if (tc instanceof PhaseTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((PhaseTapChanger) tc).getRegulationValue(),\n+                        // Unit multiplier is M for phase tap changers (regulation value is an active power flow in MW)\n+                        \"M\");\n+            }\n+            if (rcv != null) {\n+                regulatingControlViews.computeIfAbsent(controlId, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static String cgmesTapChangerReferenceKey(String tcId, String property) {\n+        return String.format(\"%s%s.%s\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId, property);\n+    }\n+\n+    private static void writeHiddenTapChanger(Identifiable<?> eq, String tcId, String defaultType, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String key = cgmesTapChangerReferenceKey(tcId, \"hiddenTapChangerId\");\n+        if (!eq.hasProperty(key)) {\n+            return;\n+        }\n+        String hiddenTcId = eq.getProperty(key);\n+        int step = Integer.parseInt(eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"step\")));\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"type\"), defaultType);\n+        writeTapChanger(type, hiddenTcId, false, step, cimNamespace, writer);\n+    }\n+\n+    private static void writeRegulatingControls(Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        for (List<RegulatingControlView> views : regulatingControlViews.values()) {\n+            writeRegulatingControl(combineRegulatingControlViews(views), cimNamespace, writer);\n+        }\n+    }\n+\n+    private static RegulatingControlView combineRegulatingControlViews(List<RegulatingControlView> rcs) {\n+        RegulatingControlView combined = rcs.get(0);\n+        if (rcs.size() > 1) {\n+            LOG.warn(\"Multiple views ({}) for regulating control {} are combined\", rcs.size(), rcs.get(0).id);\n+        }\n+        for (int k = 1; k < rcs.size(); k++) {\n+            RegulatingControlView current = rcs.get(k);\n+            if (combined.targetDeadband == 0 && current.targetDeadband > 0) {\n+                combined.targetDeadband = current.targetDeadband;\n+            }\n+            if (!combined.discrete && current.discrete) {\n+                combined.discrete = true;\n+            }\n+            if (!combined.controlEnabled && current.controlEnabled) {\n+                combined.controlEnabled = true;\n+            }\n+        }\n+        return combined;\n+    }\n+\n+    private static void writeRegulatingControl(RegulatingControlView rc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, regulatingControlClassname(rc.type));\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + rc.id);\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.discrete\");\n+        writer.writeCharacters(Boolean.toString(rc.discrete));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.enabled\");\n+        writer.writeCharacters(Boolean.toString(rc.controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetDeadband\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetDeadband));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetValue\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetValue));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(cimNamespace, \"RegulatingControl.targetValueUnitMultiplier\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"resource\", cimNamespace + \"UnitMultiplier.\" + rc.targetValueUnitMultiplier);\n+        writer.writeEndElement();\n+    }\n+\n+    private static String regulatingControlClassname(RegulatingControlType type) {\n+        if (type == RegulatingControlType.TAP_CHANGER_CONTROL) {\n+            return \"TapChangerControl\";\n+        } else {\n+            return \"RegulatingControl\";\n+        }\n+    }\n+\n+    private static void writeTerminal(Terminal t, Connectable<?> c, String cimNamespace, XMLStreamWriter writer) {\n+        Optional<String> tid;\n+        if (c instanceof DanglingLine) {\n+            tid = c.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Network\");\n+        } else {\n+            int numt = 0;\n+            if (c.getTerminals().size() == 1) {\n+                numt = 1;\n+            } else {\n+                if (c instanceof Injection) {\n+                    // An injection should have only one terminal\n+                } else if (c instanceof Branch) {\n+                    switch (((Branch<?>) c).getSide(t)) {\n+                        case ONE:\n+                            numt = 1;\n+                            break;\n+                        case TWO:\n+                            numt = 2;\n+                            break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2NjIyMA==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529666220", "createdAt": "2020-11-24T15:50:04Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    linearNonlinear = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    linearNonlinear = \"Nonlinear\";\n+                    break;\n+                default:\n+                    linearNonlinear = \"\";\n+                    break;\n+            }\n+            boolean controlEnabled = s.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, linearNonlinear + \"ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + s.getId());\n+            writer.writeStartElement(cimNamespace, \"ShuntCompensator.sections\");\n+            writer.writeCharacters(CgmesExportUtil.format(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+            addRegulatingControlView(s, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(ShuntCompensator s, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (s.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as discrete, with a certain targetDeadband\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = s.getProperty(REGULATING_CONTROL_PROPERTY);\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, true,\n+                s.isVoltageRegulatorOn(), s.getTargetDeadband(), s.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeSynchronousMachines(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (Generator g : network.getGenerators()) {\n+            boolean controlEnabled = g.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + g.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.p\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getP()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine.referencePriority\");\n+            // reference priority is used for angle reference selection (slack)\n+            writer.writeCharacters(isInSlackBus(g) ? \"1\" : \"0\");\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(cimNamespace, \"SynchronousMachine.operatingMode\");\n+            // All generators in PowSyBl are considered as generator, not motor\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, cimNamespace + \"SynchronousMachineOperatingMode.generator\");\n+            writer.writeEndElement();\n+\n+            addRegulatingControlView(g, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(Generator g, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (g.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as continuous and with targetDeadband of size 0\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = g.getProperty(REGULATING_CONTROL_PROPERTY);\n+            double targetDeadband = 0;\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                g.isVoltageRegulatorOn(), targetDeadband, g.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeStaticVarCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (StaticVarCompensator svc : network.getStaticVarCompensators()) {\n+            StaticVarCompensator.RegulationMode regulationMode = svc.getRegulationMode();\n+            boolean controlEnabled = regulationMode != StaticVarCompensator.RegulationMode.OFF;\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + svc.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(svc.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+\n+            if (svc.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+                String rcid = svc.getProperty(REGULATING_CONTROL_PROPERTY);\n+                double targetDeadband = 0;\n+                // Regulating control could be reactive power or voltage\n+                double targetValue;\n+                String multiplier;\n+                if (regulationMode == StaticVarCompensator.RegulationMode.VOLTAGE) {\n+                    targetValue = svc.getVoltageSetpoint();\n+                    multiplier = \"k\";\n+                } else if (regulationMode == StaticVarCompensator.RegulationMode.REACTIVE_POWER) {\n+                    targetValue = svc.getReactivePowerSetpoint();\n+                    multiplier = \"M\";\n+                } else {\n+                    targetValue = 0;\n+                    multiplier = \"k\";\n+                }\n+                RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                        controlEnabled, targetDeadband, targetValue, multiplier);\n+                regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static boolean isInSlackBus(Generator g) {\n+        VoltageLevel vl = g.getTerminal().getVoltageLevel();\n+        SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+        if (slackTerminal != null) {\n+            Bus slackBus = slackTerminal.getTerminal().getBusBreakerView().getBus();\n+            if (slackBus == g.getTerminal().getBusBreakerView().getBus()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void writeTapChanger(String type, String id, TapChanger<?, ?> tc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writeTapChanger(type, id, tc.isRegulating(), tc.getTapPosition(), cimNamespace, writer);\n+    }\n+\n+    private static void writeTapChanger(String type, String id, boolean controlEnabled, int step, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, type);\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + id);\n+        writer.writeStartElement(cimNamespace, \"TapChanger.controlEnabled\");\n+        writer.writeCharacters(Boolean.toString(controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"TapChanger.step\");\n+        writer.writeCharacters(CgmesExportUtil.format(step));\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void addRegulatingControlView(TapChanger tc, String tcId, Identifiable<?> eq, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        // Multiple tap changers can be stored at the same equipment\n+        // We use the tap changer id as part of the key for storing the tap changer control id\n+        String key = String.format(\"%s%s.TapChangerControl\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId);\n+        if (eq.hasProperty(key)) {\n+            String controlId = eq.getProperty(key);\n+            RegulatingControlView rcv = null;\n+            if (tc instanceof RatioTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((RatioTapChanger) tc).getTargetV(),\n+                        // Unit multiplier is k for ratio tap changers (regulation value is a voltage in kV)\n+                        \"k\");\n+            } else if (tc instanceof PhaseTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((PhaseTapChanger) tc).getRegulationValue(),\n+                        // Unit multiplier is M for phase tap changers (regulation value is an active power flow in MW)\n+                        \"M\");\n+            }\n+            if (rcv != null) {\n+                regulatingControlViews.computeIfAbsent(controlId, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static String cgmesTapChangerReferenceKey(String tcId, String property) {\n+        return String.format(\"%s%s.%s\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId, property);\n+    }\n+\n+    private static void writeHiddenTapChanger(Identifiable<?> eq, String tcId, String defaultType, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String key = cgmesTapChangerReferenceKey(tcId, \"hiddenTapChangerId\");\n+        if (!eq.hasProperty(key)) {\n+            return;\n+        }\n+        String hiddenTcId = eq.getProperty(key);\n+        int step = Integer.parseInt(eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"step\")));\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"type\"), defaultType);\n+        writeTapChanger(type, hiddenTcId, false, step, cimNamespace, writer);\n+    }\n+\n+    private static void writeRegulatingControls(Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        for (List<RegulatingControlView> views : regulatingControlViews.values()) {\n+            writeRegulatingControl(combineRegulatingControlViews(views), cimNamespace, writer);\n+        }\n+    }\n+\n+    private static RegulatingControlView combineRegulatingControlViews(List<RegulatingControlView> rcs) {\n+        RegulatingControlView combined = rcs.get(0);\n+        if (rcs.size() > 1) {\n+            LOG.warn(\"Multiple views ({}) for regulating control {} are combined\", rcs.size(), rcs.get(0).id);\n+        }\n+        for (int k = 1; k < rcs.size(); k++) {\n+            RegulatingControlView current = rcs.get(k);\n+            if (combined.targetDeadband == 0 && current.targetDeadband > 0) {\n+                combined.targetDeadband = current.targetDeadband;\n+            }\n+            if (!combined.discrete && current.discrete) {\n+                combined.discrete = true;\n+            }\n+            if (!combined.controlEnabled && current.controlEnabled) {\n+                combined.controlEnabled = true;\n+            }\n+        }\n+        return combined;\n+    }\n+\n+    private static void writeRegulatingControl(RegulatingControlView rc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, regulatingControlClassname(rc.type));\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + rc.id);\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.discrete\");\n+        writer.writeCharacters(Boolean.toString(rc.discrete));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.enabled\");\n+        writer.writeCharacters(Boolean.toString(rc.controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetDeadband\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetDeadband));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetValue\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetValue));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(cimNamespace, \"RegulatingControl.targetValueUnitMultiplier\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"resource\", cimNamespace + \"UnitMultiplier.\" + rc.targetValueUnitMultiplier);\n+        writer.writeEndElement();\n+    }\n+\n+    private static String regulatingControlClassname(RegulatingControlType type) {\n+        if (type == RegulatingControlType.TAP_CHANGER_CONTROL) {\n+            return \"TapChangerControl\";\n+        } else {\n+            return \"RegulatingControl\";\n+        }\n+    }\n+\n+    private static void writeTerminal(Terminal t, Connectable<?> c, String cimNamespace, XMLStreamWriter writer) {\n+        Optional<String> tid;\n+        if (c instanceof DanglingLine) {\n+            tid = c.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Network\");\n+        } else {\n+            int numt = 0;\n+            if (c.getTerminals().size() == 1) {\n+                numt = 1;\n+            } else {\n+                if (c instanceof Injection) {\n+                    // An injection should have only one terminal\n+                } else if (c instanceof Branch) {\n+                    switch (((Branch<?>) c).getSide(t)) {\n+                        case ONE:\n+                            numt = 1;\n+                            break;\n+                        case TWO:\n+                            numt = 2;\n+                            break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MjcxOA=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTEyMDY1OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzo0MToyOVrOH5BVsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo1MDoxMFrOH5IRXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MjgxOQ==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529552819", "createdAt": "2020-11-24T13:41:29Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    linearNonlinear = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    linearNonlinear = \"Nonlinear\";\n+                    break;\n+                default:\n+                    linearNonlinear = \"\";\n+                    break;\n+            }\n+            boolean controlEnabled = s.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, linearNonlinear + \"ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + s.getId());\n+            writer.writeStartElement(cimNamespace, \"ShuntCompensator.sections\");\n+            writer.writeCharacters(CgmesExportUtil.format(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+            addRegulatingControlView(s, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(ShuntCompensator s, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (s.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as discrete, with a certain targetDeadband\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = s.getProperty(REGULATING_CONTROL_PROPERTY);\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, true,\n+                s.isVoltageRegulatorOn(), s.getTargetDeadband(), s.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeSynchronousMachines(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (Generator g : network.getGenerators()) {\n+            boolean controlEnabled = g.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + g.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.p\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getP()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine.referencePriority\");\n+            // reference priority is used for angle reference selection (slack)\n+            writer.writeCharacters(isInSlackBus(g) ? \"1\" : \"0\");\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(cimNamespace, \"SynchronousMachine.operatingMode\");\n+            // All generators in PowSyBl are considered as generator, not motor\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, cimNamespace + \"SynchronousMachineOperatingMode.generator\");\n+            writer.writeEndElement();\n+\n+            addRegulatingControlView(g, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(Generator g, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (g.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as continuous and with targetDeadband of size 0\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = g.getProperty(REGULATING_CONTROL_PROPERTY);\n+            double targetDeadband = 0;\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                g.isVoltageRegulatorOn(), targetDeadband, g.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeStaticVarCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (StaticVarCompensator svc : network.getStaticVarCompensators()) {\n+            StaticVarCompensator.RegulationMode regulationMode = svc.getRegulationMode();\n+            boolean controlEnabled = regulationMode != StaticVarCompensator.RegulationMode.OFF;\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + svc.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(svc.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+\n+            if (svc.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+                String rcid = svc.getProperty(REGULATING_CONTROL_PROPERTY);\n+                double targetDeadband = 0;\n+                // Regulating control could be reactive power or voltage\n+                double targetValue;\n+                String multiplier;\n+                if (regulationMode == StaticVarCompensator.RegulationMode.VOLTAGE) {\n+                    targetValue = svc.getVoltageSetpoint();\n+                    multiplier = \"k\";\n+                } else if (regulationMode == StaticVarCompensator.RegulationMode.REACTIVE_POWER) {\n+                    targetValue = svc.getReactivePowerSetpoint();\n+                    multiplier = \"M\";\n+                } else {\n+                    targetValue = 0;\n+                    multiplier = \"k\";\n+                }\n+                RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                        controlEnabled, targetDeadband, targetValue, multiplier);\n+                regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static boolean isInSlackBus(Generator g) {\n+        VoltageLevel vl = g.getTerminal().getVoltageLevel();\n+        SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+        if (slackTerminal != null) {\n+            Bus slackBus = slackTerminal.getTerminal().getBusBreakerView().getBus();\n+            if (slackBus == g.getTerminal().getBusBreakerView().getBus()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void writeTapChanger(String type, String id, TapChanger<?, ?> tc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writeTapChanger(type, id, tc.isRegulating(), tc.getTapPosition(), cimNamespace, writer);\n+    }\n+\n+    private static void writeTapChanger(String type, String id, boolean controlEnabled, int step, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, type);\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + id);\n+        writer.writeStartElement(cimNamespace, \"TapChanger.controlEnabled\");\n+        writer.writeCharacters(Boolean.toString(controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"TapChanger.step\");\n+        writer.writeCharacters(CgmesExportUtil.format(step));\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void addRegulatingControlView(TapChanger tc, String tcId, Identifiable<?> eq, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        // Multiple tap changers can be stored at the same equipment\n+        // We use the tap changer id as part of the key for storing the tap changer control id\n+        String key = String.format(\"%s%s.TapChangerControl\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId);\n+        if (eq.hasProperty(key)) {\n+            String controlId = eq.getProperty(key);\n+            RegulatingControlView rcv = null;\n+            if (tc instanceof RatioTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((RatioTapChanger) tc).getTargetV(),\n+                        // Unit multiplier is k for ratio tap changers (regulation value is a voltage in kV)\n+                        \"k\");\n+            } else if (tc instanceof PhaseTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((PhaseTapChanger) tc).getRegulationValue(),\n+                        // Unit multiplier is M for phase tap changers (regulation value is an active power flow in MW)\n+                        \"M\");\n+            }\n+            if (rcv != null) {\n+                regulatingControlViews.computeIfAbsent(controlId, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static String cgmesTapChangerReferenceKey(String tcId, String property) {\n+        return String.format(\"%s%s.%s\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId, property);\n+    }\n+\n+    private static void writeHiddenTapChanger(Identifiable<?> eq, String tcId, String defaultType, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String key = cgmesTapChangerReferenceKey(tcId, \"hiddenTapChangerId\");\n+        if (!eq.hasProperty(key)) {\n+            return;\n+        }\n+        String hiddenTcId = eq.getProperty(key);\n+        int step = Integer.parseInt(eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"step\")));\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"type\"), defaultType);\n+        writeTapChanger(type, hiddenTcId, false, step, cimNamespace, writer);\n+    }\n+\n+    private static void writeRegulatingControls(Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        for (List<RegulatingControlView> views : regulatingControlViews.values()) {\n+            writeRegulatingControl(combineRegulatingControlViews(views), cimNamespace, writer);\n+        }\n+    }\n+\n+    private static RegulatingControlView combineRegulatingControlViews(List<RegulatingControlView> rcs) {\n+        RegulatingControlView combined = rcs.get(0);\n+        if (rcs.size() > 1) {\n+            LOG.warn(\"Multiple views ({}) for regulating control {} are combined\", rcs.size(), rcs.get(0).id);\n+        }\n+        for (int k = 1; k < rcs.size(); k++) {\n+            RegulatingControlView current = rcs.get(k);\n+            if (combined.targetDeadband == 0 && current.targetDeadband > 0) {\n+                combined.targetDeadband = current.targetDeadband;\n+            }\n+            if (!combined.discrete && current.discrete) {\n+                combined.discrete = true;\n+            }\n+            if (!combined.controlEnabled && current.controlEnabled) {\n+                combined.controlEnabled = true;\n+            }\n+        }\n+        return combined;\n+    }\n+\n+    private static void writeRegulatingControl(RegulatingControlView rc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, regulatingControlClassname(rc.type));\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + rc.id);\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.discrete\");\n+        writer.writeCharacters(Boolean.toString(rc.discrete));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.enabled\");\n+        writer.writeCharacters(Boolean.toString(rc.controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetDeadband\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetDeadband));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetValue\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetValue));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(cimNamespace, \"RegulatingControl.targetValueUnitMultiplier\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"resource\", cimNamespace + \"UnitMultiplier.\" + rc.targetValueUnitMultiplier);\n+        writer.writeEndElement();\n+    }\n+\n+    private static String regulatingControlClassname(RegulatingControlType type) {\n+        if (type == RegulatingControlType.TAP_CHANGER_CONTROL) {\n+            return \"TapChangerControl\";\n+        } else {\n+            return \"RegulatingControl\";\n+        }\n+    }\n+\n+    private static void writeTerminal(Terminal t, Connectable<?> c, String cimNamespace, XMLStreamWriter writer) {\n+        Optional<String> tid;\n+        if (c instanceof DanglingLine) {\n+            tid = c.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Network\");\n+        } else {\n+            int numt = 0;\n+            if (c.getTerminals().size() == 1) {\n+                numt = 1;\n+            } else {\n+                if (c instanceof Injection) {\n+                    // An injection should have only one terminal\n+                } else if (c instanceof Branch) {\n+                    switch (((Branch<?>) c).getSide(t)) {\n+                        case ONE:\n+                            numt = 1;\n+                            break;\n+                        case TWO:\n+                            numt = 2;\n+                            break;\n+                    }\n+                } else if (c instanceof ThreeWindingsTransformer) {\n+                    switch (((ThreeWindingsTransformer) c).getSide(t)) {\n+                        case ONE:\n+                            numt = 1;\n+                            break;\n+                        case TWO:\n+                            numt = 2;\n+                            break;\n+                        case THREE:\n+                            numt = 3;\n+                            break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2NjM5Ng==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r529666396", "createdAt": "2020-11-24T15:50:10Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String linearNonlinear;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    linearNonlinear = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    linearNonlinear = \"Nonlinear\";\n+                    break;\n+                default:\n+                    linearNonlinear = \"\";\n+                    break;\n+            }\n+            boolean controlEnabled = s.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, linearNonlinear + \"ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + s.getId());\n+            writer.writeStartElement(cimNamespace, \"ShuntCompensator.sections\");\n+            writer.writeCharacters(CgmesExportUtil.format(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+            addRegulatingControlView(s, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(ShuntCompensator s, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (s.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as discrete, with a certain targetDeadband\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = s.getProperty(REGULATING_CONTROL_PROPERTY);\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, true,\n+                s.isVoltageRegulatorOn(), s.getTargetDeadband(), s.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeSynchronousMachines(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (Generator g : network.getGenerators()) {\n+            boolean controlEnabled = g.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + g.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.p\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getP()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine.referencePriority\");\n+            // reference priority is used for angle reference selection (slack)\n+            writer.writeCharacters(isInSlackBus(g) ? \"1\" : \"0\");\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(cimNamespace, \"SynchronousMachine.operatingMode\");\n+            // All generators in PowSyBl are considered as generator, not motor\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, cimNamespace + \"SynchronousMachineOperatingMode.generator\");\n+            writer.writeEndElement();\n+\n+            addRegulatingControlView(g, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(Generator g, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (g.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as continuous and with targetDeadband of size 0\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = g.getProperty(REGULATING_CONTROL_PROPERTY);\n+            double targetDeadband = 0;\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                g.isVoltageRegulatorOn(), targetDeadband, g.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeStaticVarCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (StaticVarCompensator svc : network.getStaticVarCompensators()) {\n+            StaticVarCompensator.RegulationMode regulationMode = svc.getRegulationMode();\n+            boolean controlEnabled = regulationMode != StaticVarCompensator.RegulationMode.OFF;\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + svc.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(svc.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+\n+            if (svc.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+                String rcid = svc.getProperty(REGULATING_CONTROL_PROPERTY);\n+                double targetDeadband = 0;\n+                // Regulating control could be reactive power or voltage\n+                double targetValue;\n+                String multiplier;\n+                if (regulationMode == StaticVarCompensator.RegulationMode.VOLTAGE) {\n+                    targetValue = svc.getVoltageSetpoint();\n+                    multiplier = \"k\";\n+                } else if (regulationMode == StaticVarCompensator.RegulationMode.REACTIVE_POWER) {\n+                    targetValue = svc.getReactivePowerSetpoint();\n+                    multiplier = \"M\";\n+                } else {\n+                    targetValue = 0;\n+                    multiplier = \"k\";\n+                }\n+                RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                        controlEnabled, targetDeadband, targetValue, multiplier);\n+                regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static boolean isInSlackBus(Generator g) {\n+        VoltageLevel vl = g.getTerminal().getVoltageLevel();\n+        SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+        if (slackTerminal != null) {\n+            Bus slackBus = slackTerminal.getTerminal().getBusBreakerView().getBus();\n+            if (slackBus == g.getTerminal().getBusBreakerView().getBus()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void writeTapChanger(String type, String id, TapChanger<?, ?> tc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writeTapChanger(type, id, tc.isRegulating(), tc.getTapPosition(), cimNamespace, writer);\n+    }\n+\n+    private static void writeTapChanger(String type, String id, boolean controlEnabled, int step, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, type);\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + id);\n+        writer.writeStartElement(cimNamespace, \"TapChanger.controlEnabled\");\n+        writer.writeCharacters(Boolean.toString(controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"TapChanger.step\");\n+        writer.writeCharacters(CgmesExportUtil.format(step));\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void addRegulatingControlView(TapChanger tc, String tcId, Identifiable<?> eq, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        // Multiple tap changers can be stored at the same equipment\n+        // We use the tap changer id as part of the key for storing the tap changer control id\n+        String key = String.format(\"%s%s.TapChangerControl\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId);\n+        if (eq.hasProperty(key)) {\n+            String controlId = eq.getProperty(key);\n+            RegulatingControlView rcv = null;\n+            if (tc instanceof RatioTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((RatioTapChanger) tc).getTargetV(),\n+                        // Unit multiplier is k for ratio tap changers (regulation value is a voltage in kV)\n+                        \"k\");\n+            } else if (tc instanceof PhaseTapChanger) {\n+                rcv = new RegulatingControlView(controlId,\n+                        RegulatingControlType.TAP_CHANGER_CONTROL,\n+                        true,\n+                        tc.isRegulating(),\n+                        tc.getTargetDeadband(),\n+                        ((PhaseTapChanger) tc).getRegulationValue(),\n+                        // Unit multiplier is M for phase tap changers (regulation value is an active power flow in MW)\n+                        \"M\");\n+            }\n+            if (rcv != null) {\n+                regulatingControlViews.computeIfAbsent(controlId, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static String cgmesTapChangerReferenceKey(String tcId, String property) {\n+        return String.format(\"%s%s.%s\", Conversion.CGMES_PREFIX_ALIAS_PROPERTIES, tcId, property);\n+    }\n+\n+    private static void writeHiddenTapChanger(Identifiable<?> eq, String tcId, String defaultType, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String key = cgmesTapChangerReferenceKey(tcId, \"hiddenTapChangerId\");\n+        if (!eq.hasProperty(key)) {\n+            return;\n+        }\n+        String hiddenTcId = eq.getProperty(key);\n+        int step = Integer.parseInt(eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"step\")));\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(hiddenTcId, \"type\"), defaultType);\n+        writeTapChanger(type, hiddenTcId, false, step, cimNamespace, writer);\n+    }\n+\n+    private static void writeRegulatingControls(Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        for (List<RegulatingControlView> views : regulatingControlViews.values()) {\n+            writeRegulatingControl(combineRegulatingControlViews(views), cimNamespace, writer);\n+        }\n+    }\n+\n+    private static RegulatingControlView combineRegulatingControlViews(List<RegulatingControlView> rcs) {\n+        RegulatingControlView combined = rcs.get(0);\n+        if (rcs.size() > 1) {\n+            LOG.warn(\"Multiple views ({}) for regulating control {} are combined\", rcs.size(), rcs.get(0).id);\n+        }\n+        for (int k = 1; k < rcs.size(); k++) {\n+            RegulatingControlView current = rcs.get(k);\n+            if (combined.targetDeadband == 0 && current.targetDeadband > 0) {\n+                combined.targetDeadband = current.targetDeadband;\n+            }\n+            if (!combined.discrete && current.discrete) {\n+                combined.discrete = true;\n+            }\n+            if (!combined.controlEnabled && current.controlEnabled) {\n+                combined.controlEnabled = true;\n+            }\n+        }\n+        return combined;\n+    }\n+\n+    private static void writeRegulatingControl(RegulatingControlView rc, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(cimNamespace, regulatingControlClassname(rc.type));\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + rc.id);\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.discrete\");\n+        writer.writeCharacters(Boolean.toString(rc.discrete));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.enabled\");\n+        writer.writeCharacters(Boolean.toString(rc.controlEnabled));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetDeadband\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetDeadband));\n+        writer.writeEndElement();\n+        writer.writeStartElement(cimNamespace, \"RegulatingControl.targetValue\");\n+        writer.writeCharacters(CgmesExportUtil.format(rc.targetValue));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(cimNamespace, \"RegulatingControl.targetValueUnitMultiplier\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"resource\", cimNamespace + \"UnitMultiplier.\" + rc.targetValueUnitMultiplier);\n+        writer.writeEndElement();\n+    }\n+\n+    private static String regulatingControlClassname(RegulatingControlType type) {\n+        if (type == RegulatingControlType.TAP_CHANGER_CONTROL) {\n+            return \"TapChangerControl\";\n+        } else {\n+            return \"RegulatingControl\";\n+        }\n+    }\n+\n+    private static void writeTerminal(Terminal t, Connectable<?> c, String cimNamespace, XMLStreamWriter writer) {\n+        Optional<String> tid;\n+        if (c instanceof DanglingLine) {\n+            tid = c.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Network\");\n+        } else {\n+            int numt = 0;\n+            if (c.getTerminals().size() == 1) {\n+                numt = 1;\n+            } else {\n+                if (c instanceof Injection) {\n+                    // An injection should have only one terminal\n+                } else if (c instanceof Branch) {\n+                    switch (((Branch<?>) c).getSide(t)) {\n+                        case ONE:\n+                            numt = 1;\n+                            break;\n+                        case TWO:\n+                            numt = 2;\n+                            break;\n+                    }\n+                } else if (c instanceof ThreeWindingsTransformer) {\n+                    switch (((ThreeWindingsTransformer) c).getSide(t)) {\n+                        case ONE:\n+                            numt = 1;\n+                            break;\n+                        case TWO:\n+                            numt = 2;\n+                            break;\n+                        case THREE:\n+                            numt = 3;\n+                            break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MjgxOQ=="}, "originalCommit": {"oid": "b8b6a783de1222ce8136f1387a966fd633eb37a2"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNTA2MDEzOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNzo1NToxMlrOH5m7bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTowMzowMVrOH5pUJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2ODY4NQ==", "bodyText": "I think it is not the case when this method is called but the defaultType should be tabular", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r530168685", "createdAt": "2020-11-25T07:55:12Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "991cb69ac2bf2780c1ac4e0eb1775e350253ea3e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIwNzc4MA==", "bodyText": "You are right, I was using PhaseTapChanger as default type for phase tap changers, but that is an abstract class in CGMES and can not . The right default value por tap changers, if no type information is provided in properties, should be PhaseTapChangerTabular.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r530207780", "createdAt": "2020-11-25T09:03:01Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2ODY4NQ=="}, "originalCommit": {"oid": "991cb69ac2bf2780c1ac4e0eb1775e350253ea3e"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDQyNzE1OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTozOToxNVrOH_WUmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTozOToxNVrOH_WUmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE4ODA1Ng==", "bodyText": "I think that to be coherent with the other parameters, it is better to choose use-only-network. Documentation has to be updated. I can make it if you want.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r536188056", "createdAt": "2020-12-04T15:39:15Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/CgmesExport.java", "diffHunk": "@@ -59,4 +107,22 @@ public String getComment() {\n     public String getFormat() {\n         return \"CGMES\";\n     }\n+\n+    public static final String USING_ONLY_NETWORK = \"iidm.export.cgmes.using-only-network\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b03be2d1e2d38912d1a01f686403a088c7d4ef07"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDQ4MzMwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo1MToyNlrOH_W2Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo1MToyNlrOH_W2Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NjY1NQ==", "bodyText": "Indeed this could lead to strong differences during the import, as you did for generators and tap changers. It would be better to have this in a separate PR. If not, for sure I have to perform functional tests to evalaute the impact on the import.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r536196655", "createdAt": "2020-12-04T15:51:26Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/RegulatingControlMappingForShuntCompensators.java", "diffHunk": "@@ -85,16 +100,20 @@ private void setDefaultRegulatingControl(ShuntCompensator shuntCompensator) {\n                 .setVoltageRegulatorOn(true); // SSH controlEnabled attribute is true when this method is called\n     }\n \n-    private void setRegulatingControl(ShuntCompensator shuntCompensator, RegulatingControl rc) {\n+    private void setRegulatingControl(ShuntCompensator shuntCompensator, String rcId, RegulatingControl rc, boolean controlEnabled) {\n         shuntCompensator.setTargetV(rc.targetValue)\n                 .setTargetDeadband(rc.targetDeadband);\n         if (rc.targetValue > 0) {\n-            shuntCompensator.setVoltageRegulatorOn(rc.enabled);\n+            // For the IIDM regulating control to be enabled\n+            // both the equipment participation in the control and\n+            // the regulating control itself should be enabled\n+            shuntCompensator.setVoltageRegulatorOn(rc.enabled && controlEnabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38b2967f085ecdf9db35727b4be50c063a5fecb3"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDQ4ODE1OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo1MjoyNFrOH_W5HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo1MjoyNFrOH_W5HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzQwNA==", "bodyText": "I think that I have to test that to be sure that the normalPF is what we expect as droop.", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r536197404", "createdAt": "2020-12-04T15:52:24Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SynchronousMachineConversion.java", "diffHunk": "@@ -60,6 +62,19 @@ public void convert() {\n         if (p.asInt(\"referencePriority\", 0) > 0) {\n             SlackTerminal.reset(g.getTerminal().getVoltageLevel(), g.getTerminal());\n         }\n+        if (p.containsKey(\"normalPF\")) {\n+            // Extension power control adder attribute \"droop\"\n+            // is documented as the participation factor when distributed slack is enabled\n+            // We map the normal participation factor from CGMES to droop\n+            g.newExtension(ActivePowerControlAdder.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38b2967f085ecdf9db35727b4be50c063a5fecb3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDUzMjI5OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjowMTo1MVrOH_XTEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjowMTo1MVrOH_XTEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIwNDA0OQ==", "bodyText": "I am not sure to get how we should model an open switch. Do we have to modify only the status and keep the terminals connected?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r536204049", "createdAt": "2020-12-04T16:01:51Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // FIXME open status of retained switches in bus-branch models\n+            writeSwitches(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeSwitches(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Switch sw : network.getSwitches()) {\n+            writeSwitch(sw, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static final String ALIAS_TYPE_TERMINAL_1 = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.TERMINAL + \"1\";\n+    private static final String ALIAS_TYPE_TERMINAL_2 = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.TERMINAL + \"2\";\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (Switch sw : network.getSwitches()) {\n+            // Terminals for switches are exported as always connected\n+            // The status of the switch is \"open\" if any of the original terminals were not connected\n+            // An original \"closed\" switch with any terminal disconnected\n+            // will be exported as \"open\" with terminals connected\n+            sw.getAliasFromType(ALIAS_TYPE_TERMINAL_1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38b2967f085ecdf9db35727b4be50c063a5fecb3"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDU3MDE0OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjoxMDo0N1rOH_XqJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjoxMDo0N1rOH_XqJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIwOTk1Ng==", "bodyText": "Is it working if the generator is not connected?", "url": "https://github.com/powsybl/powsybl-core/pull/1485#discussion_r536209956", "createdAt": "2020-12-04T16:10:47Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/export/SteadyStateHypothesisExport.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.export;\n+\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.ActivePowerControl;\n+import com.powsybl.iidm.network.extensions.LoadDetail;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import java.util.*;\n+\n+import static com.powsybl.cgmes.model.CgmesNamespace.RDF_NAMESPACE;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ */\n+public final class SteadyStateHypothesisExport {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(SteadyStateHypothesisExport.class);\n+\n+    private static final String REGULATING_CONTROL_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"RegulatingControl\";\n+    private static final String GENERATING_UNIT_PROPERTY = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"GeneratingUnit\";\n+\n+    private SteadyStateHypothesisExport() {\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        final Map<String, List<RegulatingControlView>> regulatingControlViews = new HashMap<>();\n+        String cimNamespace = context.getCimNamespace();\n+\n+        try {\n+            CgmesExportUtil.writeRdfRoot(context.getCimVersion(), writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                CgmesExportUtil.writeModelDescription(writer, context.getSshModelDescription(), context);\n+            }\n+\n+            writeEnergyConsumers(network, cimNamespace, writer);\n+            writeEquivalentInjections(network, cimNamespace, writer);\n+            writeTapChangers(network, cimNamespace, regulatingControlViews, writer);\n+            writeSynchronousMachines(network, cimNamespace, regulatingControlViews, writer);\n+            writeShuntCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeStaticVarCompensators(network, cimNamespace, regulatingControlViews, writer);\n+            writeRegulatingControls(regulatingControlViews, cimNamespace, writer);\n+            writeGeneratingUnitsParticitationFactors(network, cimNamespace, writer);\n+            // FIXME open status of retained switches in bus-branch models\n+            writeSwitches(network, cimNamespace, writer);\n+            // TODO writeControlAreas\n+            writeTerminals(network, cimNamespace, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeSwitches(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Switch sw : network.getSwitches()) {\n+            writeSwitch(sw, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static final String ALIAS_TYPE_TERMINAL_1 = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.TERMINAL + \"1\";\n+    private static final String ALIAS_TYPE_TERMINAL_2 = Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.TERMINAL + \"2\";\n+\n+    private static void writeTerminals(Network network, String cimNamespace, XMLStreamWriter writer) {\n+        for (Connectable<?> c : network.getConnectables()) {\n+            for (Terminal t : c.getTerminals()) {\n+                writeTerminal(t, c, cimNamespace, writer);\n+            }\n+        }\n+        for (Switch sw : network.getSwitches()) {\n+            // Terminals for switches are exported as always connected\n+            // The status of the switch is \"open\" if any of the original terminals were not connected\n+            // An original \"closed\" switch with any terminal disconnected\n+            // will be exported as \"open\" with terminals connected\n+            sw.getAliasFromType(ALIAS_TYPE_TERMINAL_1)\n+                .ifPresent(tid1 -> writeTerminal(tid1, true, cimNamespace, writer));\n+            sw.getAliasFromType(ALIAS_TYPE_TERMINAL_2)\n+                .ifPresent(tid2 -> writeTerminal(tid2, true, cimNamespace, writer));\n+        }\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            // Terminal for equivalent injection at boundary is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"EquivalentInjectionTerminal\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+            // Terminal for boundary side of original line/switch is always connected\n+            dl.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + \"Terminal_Boundary\")\n+                    .ifPresent(tid -> writeTerminal(tid, true, cimNamespace, writer));\n+        }\n+    }\n+\n+    private static void writeEquivalentInjections(Network network, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        // One equivalent injection for every dangling line\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            writeEquivalentInjection(dl, cimNamespace, writer);\n+        }\n+    }\n+\n+    private static void writeTapChangers(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, ptcId, twt.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER_TABULAR, regulatingControlViews, cimNamespace, writer);\n+            }\n+            if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 1)\n+                        .orElseGet(() -> twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeTapChanger(twt, rtcId, twt.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, ptcId, leg.getPhaseTapChanger(), CgmesNames.PHASE_TAP_CHANGER_TABULAR, regulatingControlViews, cimNamespace, writer);\n+                }\n+                if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(Conversion.CGMES_PREFIX_ALIAS_PROPERTIES + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeTapChanger(twt, rtcId, leg.getRatioTapChanger(), CgmesNames.RATIO_TAP_CHANGER, regulatingControlViews, cimNamespace, writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeTapChanger(Identifiable<?> eq, String tcId, TapChanger<?, ?> tc, String defaultType, Map<String, List<RegulatingControlView>> regulatingControlViews, String cimNamespace, XMLStreamWriter writer) throws XMLStreamException {\n+        String type = eq.getProperty(cgmesTapChangerReferenceKey(tcId, \"type\"), defaultType);\n+        writeTapChanger(type, tcId, tc, cimNamespace, writer);\n+        addRegulatingControlView(tc, tcId, eq, regulatingControlViews);\n+        writeHiddenTapChanger(eq, tcId, defaultType, cimNamespace, writer);\n+    }\n+\n+    private static void writeShuntCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            String shuntType;\n+            switch (s.getModelType()) {\n+                case LINEAR:\n+                    shuntType = \"Linear\";\n+                    break;\n+                case NON_LINEAR:\n+                    shuntType = \"Nonlinear\";\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected shunt model type: \" + s.getModelType());\n+            }\n+            boolean controlEnabled = s.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, shuntType + \"ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + s.getId());\n+            writer.writeStartElement(cimNamespace, \"ShuntCompensator.sections\");\n+            writer.writeCharacters(CgmesExportUtil.format(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+            addRegulatingControlView(s, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(ShuntCompensator s, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (s.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as discrete, with a certain targetDeadband\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = s.getProperty(REGULATING_CONTROL_PROPERTY);\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, true,\n+                s.isVoltageRegulatorOn(), s.getTargetDeadband(), s.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeSynchronousMachines(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (Generator g : network.getGenerators()) {\n+            boolean controlEnabled = g.isVoltageRegulatorOn();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + g.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.p\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getP()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"RotatingMachine.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(g.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"SynchronousMachine.referencePriority\");\n+            // reference priority is used for angle reference selection (slack)\n+            writer.writeCharacters(isInSlackBus(g) ? \"1\" : \"0\");\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(cimNamespace, \"SynchronousMachine.operatingMode\");\n+            // All generators in PowSyBl are considered as generator, not motor\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, cimNamespace + \"SynchronousMachineOperatingMode.generator\");\n+            writer.writeEndElement();\n+\n+            addRegulatingControlView(g, regulatingControlViews);\n+        }\n+    }\n+\n+    private static void addRegulatingControlView(Generator g, Map<String, List<RegulatingControlView>> regulatingControlViews) {\n+        if (g.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+            // PowSyBl has considered the control as continuous and with targetDeadband of size 0\n+            // The target value is stored in kV by PowSyBl, so unit multiplier is \"k\"\n+            String rcid = g.getProperty(REGULATING_CONTROL_PROPERTY);\n+            double targetDeadband = 0;\n+            RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                g.isVoltageRegulatorOn(), targetDeadband, g.getTargetV(), \"k\");\n+            regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+        }\n+    }\n+\n+    private static void writeStaticVarCompensators(Network network, String cimNamespace, Map<String, List<RegulatingControlView>> regulatingControlViews, XMLStreamWriter writer) throws XMLStreamException {\n+        for (StaticVarCompensator svc : network.getStaticVarCompensators()) {\n+            StaticVarCompensator.RegulationMode regulationMode = svc.getRegulationMode();\n+            boolean controlEnabled = regulationMode != StaticVarCompensator.RegulationMode.OFF;\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, \"about\", \"#\" + svc.getId());\n+            writer.writeStartElement(cimNamespace, \"RegulatingCondEq.controlEnabled\");\n+            writer.writeCharacters(Boolean.toString(controlEnabled));\n+            writer.writeEndElement();\n+            writer.writeStartElement(cimNamespace, \"StaticVarCompensator.q\");\n+            writer.writeCharacters(CgmesExportUtil.format(svc.getTerminal().getQ()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+\n+            if (svc.hasProperty(REGULATING_CONTROL_PROPERTY)) {\n+                String rcid = svc.getProperty(REGULATING_CONTROL_PROPERTY);\n+                double targetDeadband = 0;\n+                // Regulating control could be reactive power or voltage\n+                double targetValue;\n+                String multiplier;\n+                if (regulationMode == StaticVarCompensator.RegulationMode.VOLTAGE) {\n+                    targetValue = svc.getVoltageSetpoint();\n+                    multiplier = \"k\";\n+                } else if (regulationMode == StaticVarCompensator.RegulationMode.REACTIVE_POWER) {\n+                    targetValue = svc.getReactivePowerSetpoint();\n+                    multiplier = \"M\";\n+                } else {\n+                    targetValue = 0;\n+                    multiplier = \"k\";\n+                }\n+                RegulatingControlView rcv = new RegulatingControlView(rcid, RegulatingControlType.REGULATING_CONTROL, false,\n+                        controlEnabled, targetDeadband, targetValue, multiplier);\n+                regulatingControlViews.computeIfAbsent(rcid, k -> new ArrayList<>()).add(rcv);\n+            }\n+        }\n+    }\n+\n+    private static boolean isInSlackBus(Generator g) {\n+        VoltageLevel vl = g.getTerminal().getVoltageLevel();\n+        SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+        if (slackTerminal != null) {\n+            Bus slackBus = slackTerminal.getTerminal().getBusBreakerView().getBus();\n+            if (slackBus == g.getTerminal().getBusBreakerView().getBus()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38b2967f085ecdf9db35727b4be50c063a5fecb3"}, "originalPosition": 268}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 65, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}