{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwODg0NTk0", "number": 1480, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODo0MjoyOVrOEmccLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDozMTozNFrOEm-o2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzQ3MzExOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/AbstractConnectorConversion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODo0MjoyOVrOHWd69Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDowMjo0NFrOHXTFjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyMDk0OQ==", "bodyText": "I am not sure to get that line of code :-)", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493320949", "createdAt": "2020-09-23T08:42:29Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/AbstractConnectorConversion.java", "diffHunk": "@@ -99,7 +99,8 @@ public void convertToDanglingLine(int boundarySide, double r, double x, double g\n                 .add()\n                 .add();\n         }\n-        addAliases(dl);\n+        dl.addAlias(terminalId(boundarySide), \"CGMES.Terminal_Boundary\");\n+        dl.addAlias(terminalId(boundarySide == 1 ? 2 : 1), \"CGMES.Terminal_Network\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MjAxMg==", "bodyText": "For the dangling line, the terminals of the network side (the modelling authority side) and the boundary side (the side that lies in the boundary) have to be stored separately.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494192012", "createdAt": "2020-09-24T10:02:44Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/AbstractConnectorConversion.java", "diffHunk": "@@ -99,7 +99,8 @@ public void convertToDanglingLine(int boundarySide, double r, double x, double g\n                 .add()\n                 .add();\n         }\n-        addAliases(dl);\n+        dl.addAlias(terminalId(boundarySide), \"CGMES.Terminal_Boundary\");\n+        dl.addAlias(terminalId(boundarySide == 1 ? 2 : 1), \"CGMES.Terminal_Network\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyMDk0OQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzQ3NTM0OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/CgmesExportContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODo0Mjo1M1rOHWd8fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODo0Mjo1M1rOHWd8fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyMTM0MA==", "bodyText": "Yes.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493321340", "createdAt": "2020-09-23T08:42:53Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/CgmesExportContext.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.conversion.extensions.CgmesSvMetadata;\n+import com.powsybl.cgmes.conversion.extensions.CimCharacteristics;\n+import com.powsybl.iidm.network.Network;\n+import org.joda.time.DateTime;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public class CgmesExportContext {\n+\n+    private int cimVersion = 16;\n+    private CgmesTopologyKind topologyKind = CgmesTopologyKind.BUS_BRANCH;\n+\n+    private DateTime scenarioTime = DateTime.now();\n+\n+    private String svDescription = \"SV Model\";\n+    private int svVersion = 1;\n+    private final List<String> dependencies = new ArrayList<>();\n+    private String modelingAuthoritySet = \"powsybl.org\"; //FIXME is it an okay default value?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzUwNDcxOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODo0Nzo0M1rOHWePVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDowNzowNFrOHXTPog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyNjE2NQ==", "bodyText": "Why do you not use a parameter to this string ?", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493326165", "createdAt": "2020-09-23T08:47:43Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUxNjk0MA==", "bodyText": "Maybe it has to be confirmed with @zamarrenolm but it seems that this bit is not something that can be changed... We could make it a parameter though for possible future versions I guess", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493516940", "createdAt": "2020-09-23T12:14:29Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyNjE2NQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5NDU5NA==", "bodyText": "could be defined as a constant in the same module, for now", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494194594", "createdAt": "2020-09-24T10:07:04Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzMyNjE2NQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzcwODYzOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOToyMjoxNFrOHWgTxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDowOTo1MVrOHXTV4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2MDA2OQ==", "bodyText": "Maybe put as a comment that it works only for bus branch topology?", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493360069", "createdAt": "2020-09-23T09:22:14Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUxNzk5Ng==", "bodyText": "Not sure, if we do the TP file from scratch in node-breaker, we will probably reuse this method (it will work the same way)", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493517996", "createdAt": "2020-09-23T12:15:37Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2MDA2OQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5NjE5NA==", "bodyText": "The implementation is valid also if the IIDM model is node-breaker", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494196194", "createdAt": "2020-09-24T10:09:51Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2MDA2OQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzcyMjQ5OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOToyNDozNVrOHWgcxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoxNTo0M1rOHWp9Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2MjM3NA==", "bodyText": "Maybe put a comment to say that it works only for bus branch topology.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493362374", "createdAt": "2020-09-23T09:24:35Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUxODA5OQ==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493518099", "createdAt": "2020-09-23T12:15:43Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2MjM3NA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Nzc0MjAwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOToyNzozOVrOHWgpBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTo0OTo0NlrOHXhb9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2NTUxMA==", "bodyText": "I am not sure to get: what do you do if you have a NaN as v and angle? If you have that, I think that it could be nice to try to re-compute them as you do 2 lines below.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493365510", "createdAt": "2020-09-23T09:27:39Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyMDM4Ng==", "bodyText": "I'm not sure if this is the place to recompute. We should ignore NaN values though, I'm modifying the code to do this.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493520386", "createdAt": "2020-09-23T12:18:21Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2NTUxMA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyMjk4MA==", "bodyText": "Edit: when the value is NaN, we put 0.0 as the CGMES convention requires.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493522980", "createdAt": "2020-09-23T12:21:12Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2NTUxMA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNzEyNw==", "bodyText": "Ok !", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494427127", "createdAt": "2020-09-24T15:49:46Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM2NTUxMA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Nzc3OTE4OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOTozMzo0MVrOHWhBVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMToyODo1MlrOHX_0mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg==", "bodyText": "If you want to write here the updated values of P and Q at boundary point, I think that you cannot make it like that. In IIDM, after a power flow calculation, the only think that changes is P and Q of the terminal connected to the network. It means that we need to introduce new properties to be set by the power flow engine or re-computed them. This value will be use to update EquivalentInjection too. @zamarrenolm do you confirm?", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493371732", "createdAt": "2020-09-23T09:33:41Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MjMyNg==", "bodyText": "Indeed I made a mistake, this is for TieLine and not for dangling Line except for Dangling Line with generation.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493372326", "createdAt": "2020-09-23T09:34:19Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEwODEwNQ==", "bodyText": "You're right, I think this is only valid if generation is zero... @zamarrenolm Can you confirm?", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494108105", "createdAt": "2020-09-24T07:48:47Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5ODI1Mg==", "bodyText": "The flow at the boundary terminal is equal to the generation of the dangling line, but with opposite sign (p0, q0 are the values of the injection, with load sign convention, and the flow in the dangling line from the boundary to the network side is the same quantity, also with load sign convention)", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494198252", "createdAt": "2020-09-24T10:13:28Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyODg4NQ==", "bodyText": "Update: after a powerflow calculation, P0 and Q0 are considered as targets and are not updated in IIDM. But, after a balance ajustement, it should be updated and so, after topological merge + balance ajustement, these lines of codes will provide updated values.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494428885", "createdAt": "2020-09-24T15:52:19Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODY3Mw==", "bodyText": "After discussing it,  it seems a mistake to export p0 and q0 as calculated flows. We should introduce an object called middleBus or something which will contain the calculated flows, voltage and angle of the boundary fictitious terminal of the dangling line. For now, I think we should delete this line and put a TODO", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494858673", "createdAt": "2020-09-25T09:17:58Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkyNDk1Mg==", "bodyText": "(I did not delete the line but put a FIXME)", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494924952", "createdAt": "2020-09-25T11:28:52Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MTczMg=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Nzc5MTg2OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOTozNTo0MlrOHWhI9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOToxNDozN1rOHX7qdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MzY4NA==", "bodyText": "And the TERMINAL2 ?", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493373684", "createdAt": "2020-09-23T09:35:42Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyMTQ3Mw==", "bodyText": "This method is only used for injections which only have one terminal, which is why terminal2 is never called. I'm going to check what is done for branches/transformers (do you know @zamarrenolm @marqueslanauja ?)", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493521473", "createdAt": "2020-09-23T12:19:34Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MzY4NA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyOTMyOA==", "bodyText": "usually the flows for branches are not put in the SV output (they can always be easily recalculated, given the voltages and the impedances). We could export also these values, could be configurable.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494329328", "createdAt": "2020-09-24T13:44:44Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MzY4NA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1NjgyMA==", "bodyText": "I'm adding a TODO about this but I think we can not export them at first", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494856820", "createdAt": "2020-09-25T09:14:37Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MzY4NA=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzgxMDIxOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOTozODo1NlrOHWhUxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMToyMDo0NlrOHX_mwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3NjcwOQ==", "bodyText": "I am not sure to get why we introduce a new function here ? We already have a function to do that ? Or it is not the good place maybe.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r493376709", "createdAt": "2020-09-23T09:38:56Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);\n+        if (cgmesTerminal != null) {\n+            writePowerFlow(cgmesTerminal, terminal.getP(), terminal.getQ(), writer);\n+        } else if (terminal.getConnectable() instanceof Load && terminal.getConnectable().isFictitious()) {\n+            Load svInjection = (Load) terminal.getConnectable();\n+            writeSvInjection(svInjection, writer);\n+        } else {\n+            LOG.error(\"No defined CGMES terminal for {}\", terminal.getConnectable().getId());\n+        }\n+    }\n+\n+    private static void writePowerFlow(String terminal, double p, double q, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.p\");\n+            writer.writeCharacters(String.valueOf(p));\n+            writer.writeEndElement();\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.q\");\n+            writer.writeCharacters(String.valueOf(q));\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvPowerFlow.Terminal\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + terminal);\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeSvInjection(Load svInjection, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, svInjection.getId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection.pInjection\");\n+            writer.writeCharacters(String.valueOf(svInjection.getP0()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection.qInjection\");\n+            writer.writeCharacters(String.valueOf(svInjection.getQ0()));\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvInjection.TopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + svInjection.getTerminal().getBusBreakerView().getBus().getId());\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeShuntCompensatorSections(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvShuntCompensatorSections\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvShuntCompensatorSections.ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + s.getId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvShuntCompensatorSections.continuousSections\");\n+            writer.writeCharacters(is(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static void writeTapSteps(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + 1).orElseGet(() -> twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeSvTapStep(ptcId, twt.getPhaseTapChanger().getTapPosition(), writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + 1).orElseGet(() -> twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeSvTapStep(rtcId, twt.getRatioTapChanger().getTapPosition(), writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeSvTapStep(ptcId, leg.getPhaseTapChanger().getTapPosition(), writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeSvTapStep(rtcId, leg.getRatioTapChanger().getTapPosition(), writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeSvTapStep(String tapChangerId, int tapPosition, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvTapStep\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvTapStep.position\");\n+        writer.writeCharacters(is(tapPosition));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, \"SvTapStep.TapChanger\");\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tapChangerId);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeStatus(Network network, XMLStreamWriter writer) {\n+        // create SvStatus, iterate on Connectables, check Terminal status, add\n+        // to SvStatus\n+        network.getConnectableStream().forEach(c -> writeConnectableStatus((Connectable<?>) c, writer));\n+\n+        // RK: For dangling lines (boundaries), the AC Line Segment is considered in service if and only if it is connected on the network side.\n+        // If it is disconnected on the boundary side, it might not appear on the SV file.\n+    }\n+\n+    private static void writeConnectableStatus(Connectable<?> connectable, XMLStreamWriter writer) {\n+        writeStatus(Boolean.toString(connectable.getTerminals().stream().anyMatch(Terminal::isConnected)), connectable.getId(), writer);\n+    }\n+\n+    private static void writeStatus(String inService, String conductingEquipmentId, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvStatus\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvStatus.inService\");\n+            writer.writeCharacters(inService);\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvStatus.ConductingEquipment\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + conductingEquipmentId);\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static String getUniqueId() {\n+        return UUID.randomUUID().toString();\n+    }\n+\n+    // Avoid trailing zeros\n+    private static final DecimalFormat DOUBLE_FORMAT = new DecimalFormat(\"0.##############\", new DecimalFormatSymbols(Locale.US));\n+\n+    private static String fs(double value) {\n+        return Double.isNaN(value) ? DOUBLE_FORMAT.format(0.0) : DOUBLE_FORMAT.format(value);\n+    }\n+\n+    private static Complex complexVoltage(double r, double x, double g, double b,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkyMTQwOQ==", "bodyText": "I put it in CgmesExportUtil", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494921409", "createdAt": "2020-09-25T11:20:46Z", "author": {"login": "miovd"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);\n+        if (cgmesTerminal != null) {\n+            writePowerFlow(cgmesTerminal, terminal.getP(), terminal.getQ(), writer);\n+        } else if (terminal.getConnectable() instanceof Load && terminal.getConnectable().isFictitious()) {\n+            Load svInjection = (Load) terminal.getConnectable();\n+            writeSvInjection(svInjection, writer);\n+        } else {\n+            LOG.error(\"No defined CGMES terminal for {}\", terminal.getConnectable().getId());\n+        }\n+    }\n+\n+    private static void writePowerFlow(String terminal, double p, double q, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.p\");\n+            writer.writeCharacters(String.valueOf(p));\n+            writer.writeEndElement();\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.q\");\n+            writer.writeCharacters(String.valueOf(q));\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvPowerFlow.Terminal\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + terminal);\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeSvInjection(Load svInjection, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, svInjection.getId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection.pInjection\");\n+            writer.writeCharacters(String.valueOf(svInjection.getP0()));\n+            writer.writeEndElement();\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection.qInjection\");\n+            writer.writeCharacters(String.valueOf(svInjection.getQ0()));\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvInjection.TopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + svInjection.getTerminal().getBusBreakerView().getBus().getId());\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeShuntCompensatorSections(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (ShuntCompensator s : network.getShuntCompensators()) {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvShuntCompensatorSections\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvShuntCompensatorSections.ShuntCompensator\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + s.getId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvShuntCompensatorSections.continuousSections\");\n+            writer.writeCharacters(is(s.getSectionCount()));\n+            writer.writeEndElement();\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static void writeTapSteps(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (TwoWindingsTransformer twt : network.getTwoWindingsTransformers()) {\n+            if (twt.hasPhaseTapChanger()) {\n+                String ptcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + 1).orElseGet(() -> twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeSvTapStep(ptcId, twt.getPhaseTapChanger().getTapPosition(), writer);\n+            } else if (twt.hasRatioTapChanger()) {\n+                String rtcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + 1).orElseGet(() -> twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + 2).orElseThrow(PowsyblException::new));\n+                writeSvTapStep(rtcId, twt.getRatioTapChanger().getTapPosition(), writer);\n+            }\n+        }\n+\n+        for (ThreeWindingsTransformer twt : network.getThreeWindingsTransformers()) {\n+            int i = 1;\n+            for (ThreeWindingsTransformer.Leg leg : Arrays.asList(twt.getLeg1(), twt.getLeg2(), twt.getLeg3())) {\n+                if (leg.hasPhaseTapChanger()) {\n+                    String ptcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.PHASE_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeSvTapStep(ptcId, leg.getPhaseTapChanger().getTapPosition(), writer);\n+                } else if (leg.hasRatioTapChanger()) {\n+                    String rtcId = twt.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.RATIO_TAP_CHANGER + i).orElseThrow(PowsyblException::new);\n+                    writeSvTapStep(rtcId, leg.getRatioTapChanger().getTapPosition(), writer);\n+                }\n+                i++;\n+            }\n+        }\n+    }\n+\n+    private static void writeSvTapStep(String tapChangerId, int tapPosition, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvTapStep\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvTapStep.position\");\n+        writer.writeCharacters(is(tapPosition));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, \"SvTapStep.TapChanger\");\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tapChangerId);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeStatus(Network network, XMLStreamWriter writer) {\n+        // create SvStatus, iterate on Connectables, check Terminal status, add\n+        // to SvStatus\n+        network.getConnectableStream().forEach(c -> writeConnectableStatus((Connectable<?>) c, writer));\n+\n+        // RK: For dangling lines (boundaries), the AC Line Segment is considered in service if and only if it is connected on the network side.\n+        // If it is disconnected on the boundary side, it might not appear on the SV file.\n+    }\n+\n+    private static void writeConnectableStatus(Connectable<?> connectable, XMLStreamWriter writer) {\n+        writeStatus(Boolean.toString(connectable.getTerminals().stream().anyMatch(Terminal::isConnected)), connectable.getId(), writer);\n+    }\n+\n+    private static void writeStatus(String inService, String conductingEquipmentId, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvStatus\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvStatus.inService\");\n+            writer.writeCharacters(inService);\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvStatus.ConductingEquipment\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + conductingEquipmentId);\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static String getUniqueId() {\n+        return UUID.randomUUID().toString();\n+    }\n+\n+    // Avoid trailing zeros\n+    private static final DecimalFormat DOUBLE_FORMAT = new DecimalFormat(\"0.##############\", new DecimalFormatSymbols(Locale.US));\n+\n+    private static String fs(double value) {\n+        return Double.isNaN(value) ? DOUBLE_FORMAT.format(0.0) : DOUBLE_FORMAT.format(value);\n+    }\n+\n+    private static Complex complexVoltage(double r, double x, double g, double b,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3NjcwOQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5Mjk3MjA5OnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/AbstractConnectorConversion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDowMzo0MVrOHXTHjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDowMzo0MVrOHXTHjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MjUyNA==", "bodyText": "prefix CGMES. should be defined in Conversion module and used here and during export, to query the aliases", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494192524", "createdAt": "2020-09-24T10:03:41Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/AbstractConnectorConversion.java", "diffHunk": "@@ -99,7 +99,8 @@ public void convertToDanglingLine(int boundarySide, double r, double x, double g\n                 .add()\n                 .add();\n         }\n-        addAliases(dl);\n+        dl.addAlias(terminalId(boundarySide), \"CGMES.Terminal_Boundary\");\n+        dl.addAlias(terminalId(boundarySide == 1 ? 2 : 1), \"CGMES.Terminal_Network\");\n         dl.addAlias(boundaryNode, \"CGMES.\" + CgmesNames.TOPOLOGICAL_NODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzA3NjEwOnYy", "diffSide": "RIGHT", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDozMTozNFrOHXUF-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDozODoyMVrOHXUUNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwODUwNQ==", "bodyText": "in CGMES SvInjection is reserved for reporting mismatches in buses, not for reporting values of EquivalentInjections (of boundary nodes). The value of the equivalent injection at the boundary must be entered as a SvPowerFlow value at the corresponding Terminal of the EquivalentInjection. Change will be proposed in a later commit", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494208505", "createdAt": "2020-09-24T10:31:34Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);\n+        if (cgmesTerminal != null) {\n+            writePowerFlow(cgmesTerminal, terminal.getP(), terminal.getQ(), writer);\n+        } else if (terminal.getConnectable() instanceof Load && terminal.getConnectable().isFictitious()) {\n+            Load svInjection = (Load) terminal.getConnectable();\n+            writeSvInjection(svInjection, writer);\n+        } else {\n+            LOG.error(\"No defined CGMES terminal for {}\", terminal.getConnectable().getId());\n+        }\n+    }\n+\n+    private static void writePowerFlow(String terminal, double p, double q, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.p\");\n+            writer.writeCharacters(String.valueOf(p));\n+            writer.writeEndElement();\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.q\");\n+            writer.writeCharacters(String.valueOf(q));\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvPowerFlow.Terminal\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + terminal);\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeSvInjection(Load svInjection, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxMjE0OA==", "bodyText": "Writing SvInjections is ok, as we have converted to fictitious loads only the values that we have seen in the original CGMES input as SvInjections also. Sorry for the noise.", "url": "https://github.com/powsybl/powsybl-core/pull/1480#discussion_r494212148", "createdAt": "2020-09-24T10:38:21Z", "author": {"login": "zamarrenolm"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/update/StateVariablesExport.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.cgmes.conversion.update;\n+\n+import com.powsybl.cgmes.conversion.elements.CgmesTopologyKind;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.commons.exceptions.UncheckedXmlStreamException;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.network.extensions.SlackTerminal;\n+import com.powsybl.iidm.network.util.LinkData;\n+import org.apache.commons.math3.complex.Complex;\n+import org.apache.commons.math3.complex.ComplexUtils;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ */\n+public final class StateVariablesExport {\n+\n+    private static final String ENTSOE_NAMESPACE = \"http://entsoe.eu/CIM/SchemaExtension/3/1#\";\n+    private static final String RDF_NAMESPACE = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n+    private static final String CIM_NAMESPACE = \"http://iec.ch/TC57/2013/CIM-schema-cim16#\";\n+    private static final String MD_NAMESPACE = \"http://iec.ch/TC57/61970-552/ModelDescription/1#\";\n+\n+    private static final String CGMES_PREFIX_ALIAS = \"CGMES.\";\n+\n+    private static final String ID = \"ID\";\n+\n+    private static final String SV_VOLTAGE_ANGLE = \"SvVoltage.angle\";\n+    private static final String SV_VOLTAGE_V = \"SvVoltage.v\";\n+    private static final String SV_VOLTAGE_TOPOLOGICAL_NODE = \"SvVoltage.TopologicalNode\";\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(StateVariablesExport.class);\n+\n+    public static void write(Network network, XMLStreamWriter writer) {\n+        write(network, writer, new CgmesExportContext(network));\n+    }\n+\n+    public static void write(Network network, XMLStreamWriter writer, CgmesExportContext context) {\n+        try {\n+            writeRdf(writer);\n+\n+            if (context.getCimVersion() == 16) {\n+                writeSvModelDescription(writer, context);\n+                writeTopologicalIslands(network, writer, context);\n+            }\n+\n+            writeVoltagesForTopologicalNodes(network, writer, context);\n+            writeVoltagesForBoundaryNodes(network, writer);\n+            writePowerFlows(network, writer);\n+            writeShuntCompensatorSections(network, writer);\n+            writeTapSteps(network, writer);\n+            writeStatus(network, writer);\n+\n+            writer.writeEndDocument();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeRdf(XMLStreamWriter writer) throws XMLStreamException {\n+        writer.setPrefix(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.setPrefix(\"rdf\", RDF_NAMESPACE);\n+        writer.setPrefix(\"cim\", CIM_NAMESPACE);\n+        writer.setPrefix(\"md\", MD_NAMESPACE);\n+        writer.writeStartElement(RDF_NAMESPACE, \"RDF\");\n+        writer.writeNamespace(\"entsoe\", ENTSOE_NAMESPACE);\n+        writer.writeNamespace(\"rdf\", RDF_NAMESPACE);\n+        writer.writeNamespace(\"cim\", CIM_NAMESPACE);\n+        writer.writeNamespace(\"md\", MD_NAMESPACE);\n+    }\n+\n+    private static void writeSvModelDescription(XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        writer.writeStartElement(MD_NAMESPACE, \"FullModel\");\n+        writer.writeAttribute(RDF_NAMESPACE, \"about\", \"urn:uuid:\" + getUniqueId());\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.SCENARIO_TIME);\n+        writer.writeCharacters(context.getScenarioTime().toString(\"yyyy-MM-dd'T'HH:mm:ss\"));\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.CREATED);\n+        writer.writeCharacters(DateTime.now().toString());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.DESCRIPTION);\n+        writer.writeCharacters(context.getSvDescription());\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.VERSION);\n+        writer.writeCharacters(is(context.getSvVersion()));\n+        writer.writeEndElement();\n+        for (String dependency : context.getDependencies()) {\n+            writer.writeEmptyElement(MD_NAMESPACE, CgmesNames.DEPENDENT_ON);\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, dependency);\n+        }\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.PROFILE);\n+        writer.writeCharacters(\"http://entsoe.eu/CIM/StateVariables/4/1\");\n+        writer.writeEndElement();\n+        writer.writeStartElement(MD_NAMESPACE, CgmesNames.MODELING_AUTHORITY_SET);\n+        writer.writeCharacters(context.getModelingAuthoritySet());\n+        writer.writeEndElement();\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writeTopologicalIslands(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        Map<String, String> angleRefs = buildAngleRefs(network);\n+        Map<String, List<String>> islands = buildIslands(network);\n+        for (Map.Entry<String, List<String>> island : islands.entrySet()) {\n+            if (!angleRefs.containsKey(island.getKey())) {\n+                Supplier<String> log = () -> String.format(\"Synchronous component  %s does not have a defined slack bus: it is ignored\", island.getKey());\n+                LOG.info(log.get());\n+                continue;\n+            }\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.TOPOLOGICAL_ISLAND);\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, CgmesNames.NAME);\n+            writer.writeCharacters(getUniqueId()); // TODO do we need another name?\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.AngleRefTopologicalNode\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + angleRefs.get(island.getKey()));\n+            for (String tn : island.getValue()) {\n+                writer.writeEmptyElement(CIM_NAMESPACE, \"TopologicalIsland.TopologicalNodes\");\n+                writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + tn);\n+            }\n+            writer.writeEndElement();\n+        }\n+    }\n+\n+    private static Map<String, String> buildAngleRefs(Network network) {\n+        Map<String, String> angleRefs = new HashMap<>();\n+        for (VoltageLevel vl : network.getVoltageLevels()) {\n+            SlackTerminal slackTerminal = vl.getExtension(SlackTerminal.class);\n+            if (slackTerminal != null && slackTerminal.getTerminal() != null) {\n+                if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null && slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent() != null) {\n+                    String componentNum = String.valueOf(slackTerminal.getTerminal().getBusBreakerView().getBus().getSynchronousComponent().getNum());\n+                    if (angleRefs.containsKey(componentNum)) {\n+                        Supplier<String> log = () -> String.format(\"Several slack buses are defined for synchronous component %s: only first slack bus (%s) is taken into account\",\n+                                componentNum, angleRefs.get(componentNum));\n+                        LOG.info(log.get());\n+                        continue;\n+                    }\n+                    angleRefs.put(componentNum, slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else if (slackTerminal.getTerminal().getBusBreakerView().getBus() != null) {\n+                    angleRefs.put(slackTerminal.getTerminal().getBusBreakerView().getBus().getId(),\n+                            slackTerminal.getTerminal().getBusBreakerView().getBus().getId());\n+                } else {\n+                    Supplier<String> message = () -> String.format(\"Slack terminal at equipment %s is not connected and is not exported as slack terminal\", slackTerminal.getTerminal().getConnectable().getId());\n+                    LOG.info(message.get());\n+                }\n+            }\n+        }\n+        return angleRefs;\n+    }\n+\n+    private static Map<String, List<String>> buildIslands(Network network) {\n+        Map<String, List<String>> islands = new HashMap<>();\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            if (b.getSynchronousComponent() != null) {\n+                int num = b.getSynchronousComponent().getNum();\n+                islands.computeIfAbsent(String.valueOf(num), i -> new ArrayList<>());\n+                islands.get(String.valueOf(num)).add(b.getId());\n+            } else {\n+                islands.put(b.getId(), Collections.singletonList(b.getId()));\n+            }\n+        }\n+        return islands;\n+    }\n+\n+    private static void writeVoltagesForTopologicalNodes(Network network, XMLStreamWriter writer, CgmesExportContext context) throws XMLStreamException {\n+        if (context.getTopologyKind() == CgmesTopologyKind.NODE_BREAKER) {\n+            // TODO we need to export SV file data for NodeBraker\n+            LOG.warn(\"NodeBreaker view require further investigation to map correctly Topological Nodes\");\n+            return;\n+        }\n+        for (Bus b : network.getBusBreakerView().getBuses()) {\n+            writeVoltage(b.getId(), b.getV(), b.getAngle(), writer);\n+        }\n+    }\n+\n+    private static void writeVoltagesForBoundaryNodes(Network network, XMLStreamWriter writer) throws XMLStreamException {\n+        for (DanglingLine dl : network.getDanglingLines()) {\n+            Bus b = dl.getTerminal().getBusBreakerView().getBus();\n+            Optional<String> topologicalNode = dl.getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TOPOLOGICAL_NODE);\n+            if (topologicalNode.isPresent()) {\n+                if (dl.hasProperty(\"v\") && dl.hasProperty(\"angle\")) {\n+                    writeVoltage(topologicalNode.get(), Double.valueOf(dl.getProperty(\"v\", \"NaN\")), Double.valueOf(dl.getProperty(\"angle\", \"NaN\")), writer);\n+                } else if (b != null) {\n+                    // calculate complex voltage value: abs for VOLTAGE, degrees for ANGLE\n+                    Complex v2 = complexVoltage(dl.getR(), dl.getX(), dl.getG(), dl.getB(), b.getV(), b.getAngle(), dl.getP0(), dl.getQ0());\n+                    writeVoltage(topologicalNode.get(), v2.abs(), Math.toDegrees(v2.getArgument()), writer);\n+                } else {\n+                    writeVoltage(topologicalNode.get(), 0.0, 0.0, writer);\n+                }\n+            }\n+        }\n+        // Voltages at inner nodes of Tie Lines\n+        // (boundary nodes that have been left inside CGM)\n+        for (Line l : network.getLines()) {\n+            if (!l.isTieLine()) {\n+                continue;\n+            }\n+            TieLine tieLine = (TieLine) l;\n+            // FIXME(Luma) Obtain voltage at inner node\n+            LOG.error(\"Must export topologicalNode voltage for boundary Tie Line {}\", tieLine);\n+        }\n+    }\n+\n+    private static void writeVoltage(String topologicalNode, double v, double angle, XMLStreamWriter writer) throws XMLStreamException {\n+        writer.writeStartElement(CIM_NAMESPACE, \"SvVoltage\");\n+        writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_ANGLE);\n+        writer.writeCharacters(fs(angle));\n+        writer.writeEndElement();\n+        writer.writeStartElement(CIM_NAMESPACE, SV_VOLTAGE_V);\n+        writer.writeCharacters(fs(v));\n+        writer.writeEndElement();\n+        writer.writeEmptyElement(CIM_NAMESPACE, SV_VOLTAGE_TOPOLOGICAL_NODE);\n+        writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + topologicalNode);\n+        writer.writeEndElement();\n+    }\n+\n+    private static void writePowerFlows(Network network, XMLStreamWriter writer) {\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getLoadStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getGeneratorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getShuntCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getStaticVarCompensatorStream);\n+        writeInjectionPowerFlowToCgmes(network, writer, Network::getBatteryStream);\n+\n+        network.getDanglingLineStream().forEach(dl -> dl.getAliasFromType(CGMES_PREFIX_ALIAS + \"Terminal_Boundary\")\n+                .ifPresent(terminal -> writePowerFlow(terminal, dl.getP0(), dl.getQ0(), writer)));\n+        // TODO what about flows of dl's generations?\n+    }\n+\n+    private static <I extends Injection<I>> void writeInjectionPowerFlowToCgmes(Network network, XMLStreamWriter writer, Function<Network, Stream<I>> getInjectionStream) {\n+        getInjectionStream.apply(network).forEach(i -> writePowerFlow(i.getTerminal(), writer));\n+    }\n+\n+    private static void writePowerFlow(Terminal terminal, XMLStreamWriter writer) {\n+        String cgmesTerminal = ((Connectable<?>) terminal.getConnectable()).getAliasFromType(CGMES_PREFIX_ALIAS + CgmesNames.TERMINAL1).orElse(null);\n+        if (cgmesTerminal != null) {\n+            writePowerFlow(cgmesTerminal, terminal.getP(), terminal.getQ(), writer);\n+        } else if (terminal.getConnectable() instanceof Load && terminal.getConnectable().isFictitious()) {\n+            Load svInjection = (Load) terminal.getConnectable();\n+            writeSvInjection(svInjection, writer);\n+        } else {\n+            LOG.error(\"No defined CGMES terminal for {}\", terminal.getConnectable().getId());\n+        }\n+    }\n+\n+    private static void writePowerFlow(String terminal, double p, double q, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow\");\n+            writer.writeAttribute(RDF_NAMESPACE, ID, getUniqueId());\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.p\");\n+            writer.writeCharacters(String.valueOf(p));\n+            writer.writeEndElement();\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvPowerFlow.q\");\n+            writer.writeCharacters(String.valueOf(q));\n+            writer.writeEndElement();\n+            writer.writeEmptyElement(CIM_NAMESPACE, \"SvPowerFlow.Terminal\");\n+            writer.writeAttribute(RDF_NAMESPACE, CgmesNames.RESOURCE, \"#\" + terminal);\n+            writer.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            throw new UncheckedXmlStreamException(e);\n+        }\n+    }\n+\n+    private static void writeSvInjection(Load svInjection, XMLStreamWriter writer) {\n+        try {\n+            writer.writeStartElement(CIM_NAMESPACE, \"SvInjection\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwODUwNQ=="}, "originalCommit": {"oid": "bd36bb4cee107edd7cfe1e61897bbf4fb2e1e12c"}, "originalPosition": 288}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 52, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}