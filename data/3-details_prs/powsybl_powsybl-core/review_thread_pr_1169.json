{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzA0MTQ5", "number": 1169, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODoxMjoxOFrODhbVYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMDo1OFrODiuSvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Mzc3NDQwOnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODoxMjoxOFrOFsJpaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozNDozOFrOFscqJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTcyMQ==", "bodyText": "I think sonar cognitive complexity analyzer must be crying :)\nIt was already the case before the PR, but I think we should stick to the rule that lambda should be as much as possible one-liners, in particular for complex, asynchronous code.\nI think we should simply create more functions here.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381839721", "createdAt": "2020-02-20T08:12:18Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MTIwNA==", "bodyText": "Yes, we should. I didn't refactor to allow to compare to the previous version. If we decide to go this way, we should refactor", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382151204", "createdAt": "2020-02-20T17:34:38Z", "author": {"login": "jonenst"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTcyMQ=="}, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Mzg4MTE5OnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODo0ODoyM1rOFsKp_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozNTo1MlrOFscstA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NjI1Mg==", "bodyText": "Might look less weird to have a supplyAsync return the array of future chained with a .thenCompose(CompletableFuture::allOf).whenComplete(... ?", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381856252", "createdAt": "2020-02-20T08:48:23Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MTg2MA==", "bodyText": "yes, I refrained from refactoring as much as I could to keep the code comparable to the previous code", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382151860", "createdAt": "2020-02-20T17:35:52Z", "author": {"login": "jonenst"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NjI1Mg=="}, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDAxMzM1OnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNTo1OVrOFsL5lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozNjo0MlrOFscueQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NjYyOA==", "bodyText": "Here we should clone the workingStateId used for pre contingency computation.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381876628", "createdAt": "2020-02-20T09:25:59Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MjMxMw==", "bodyText": "Yes, I didn't change the original behavior in the first proposal because it was not related. It's now included", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382152313", "createdAt": "2020-02-20T17:36:42Z", "author": {"login": "jonenst"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NjYyOA=="}, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDAxODc5OnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNzoyNFrOFsL86w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzozNzoxNVrOFscvwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzQ4Mw==", "bodyText": "agreed with @mathbagu : Here we should clone the variant used for pre contingency computation, in order to restore the \"N\" situation before applying the contingency.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381877483", "createdAt": "2020-02-20T09:27:24Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture\n+                                        .supplyAsync(() -> {\n+                                            try {\n+                                                return queue.take();\n+                                            } catch (InterruptedException e) {\n+                                                Thread.currentThread().interrupt();\n+                                                throw new UncheckedInterruptedException(e);\n+                                            }\n+                                        }, computationManager.getExecutor())\n+                                        .thenCompose(workerId -> {\n+                                            String postContStateId = hash + \"_\" + workerId;\n+                                            return CompletableFuture\n+                                                    .runAsync(() -> {\n+                                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+                                                        // apply the contingency on the network\n+                                                        contingency.toTask().modify(network, computationManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MjY0MA==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382152640", "createdAt": "2020-02-20T17:37:15Z", "author": {"login": "jonenst"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture\n+                                        .supplyAsync(() -> {\n+                                            try {\n+                                                return queue.take();\n+                                            } catch (InterruptedException e) {\n+                                                Thread.currentThread().interrupt();\n+                                                throw new UncheckedInterruptedException(e);\n+                                            }\n+                                        }, computationManager.getExecutor())\n+                                        .thenCompose(workerId -> {\n+                                            String postContStateId = hash + \"_\" + workerId;\n+                                            return CompletableFuture\n+                                                    .runAsync(() -> {\n+                                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+                                                        // apply the contingency on the network\n+                                                        contingency.toTask().modify(network, computationManager);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzQ4Mw=="}, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Njc4MjczOnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTozNDoyOFrOFuCwtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTozNDoyOFrOFuCwtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyNDA1NQ==", "bodyText": "The name of the module could be default-security-analysis, because \"Default\" will be the name of this implementation (see PR#972)", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383824055", "createdAt": "2020-02-25T11:34:28Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -20,14 +21,39 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n \n /**\n  * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n  * @author Teofil Calin BANC <teofil-calin.banc at rte-france.com>\n  */\n public class SecurityAnalysisImpl extends AbstractSecurityAnalysis {\n \n+    /**\n+     * This executor is used to create the variants of the network, submit the tasks\n+     * for computing contingency loadflows and submit the tasks for checking for the\n+     * violations. Submitting tasks itself is blocking because we can only run a\n+     * limited number of loadflows in parallel because we need the memory for the\n+     * variant, and we don't want to submit tasks that would immediately block to\n+     * get an available variant (they hurt the performance of the executor who\n+     * excutes them)\n+     */\n+    private static final ExecutorService SCHEDULER_EXECUTOR = Executors\n+            .newFixedThreadPool(Integer.parseInt(PlatformConfig.defaultConfig()\n+                    .getOptionalModuleConfig(\"security-analysis-impl\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Njc4Mzk3OnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTozNDo1NVrOFuCxdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTozNDo1NVrOFuCxdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyNDI0Ng==", "bodyText": "Should we base this on the number of cores?", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383824246", "createdAt": "2020-02-25T11:34:55Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -20,14 +21,39 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n \n /**\n  * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n  * @author Teofil Calin BANC <teofil-calin.banc at rte-france.com>\n  */\n public class SecurityAnalysisImpl extends AbstractSecurityAnalysis {\n \n+    /**\n+     * This executor is used to create the variants of the network, submit the tasks\n+     * for computing contingency loadflows and submit the tasks for checking for the\n+     * violations. Submitting tasks itself is blocking because we can only run a\n+     * limited number of loadflows in parallel because we need the memory for the\n+     * variant, and we don't want to submit tasks that would immediately block to\n+     * get an available variant (they hurt the performance of the executor who\n+     * excutes them)\n+     */\n+    private static final ExecutorService SCHEDULER_EXECUTOR = Executors\n+            .newFixedThreadPool(Integer.parseInt(PlatformConfig.defaultConfig()\n+                    .getOptionalModuleConfig(\"security-analysis-impl\")\n+                    .flatMap(m -> m.getOptionalStringProperty(\"scheduler-pool-size\"))\n+                    .orElse(\"10\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM1MDQ2OnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNjo1NVrOFuIFKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNjo1NVrOFuIFKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMTIxMQ==", "bodyText": "I'm not sure this is a really good API design. The contingency method should create a PostContingencyResultBuilder that is thread safe. The endContingency should add the PostContingencyResult to the SAResult.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383911211", "createdAt": "2020-02-25T14:26:55Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -69,70 +97,120 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n         // start post contingency LF from pre-contingency state variables\n         LoadFlowParameters postContParameters = loadFlowParameters.copy().setVoltageInitMode(LoadFlowParameters.VoltageInitMode.PREVIOUS_VALUES);\n \n-        network.getVariantManager().allowVariantMultiThreadAccess(true);\n-\n-        return LoadFlow.runAsync(network, workingStateId, computationManager, loadFlowParameters) // run base load flow\n-                .thenComposeAsync(loadFlowResult -> {\n-                    network.getVariantManager().setWorkingVariant(workingStateId);\n-\n-                    SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n-\n-                    CompletableFuture<Void>[] futures;\n+        SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n \n+        return LoadFlow\n+                .runAsync(network, workingStateId, computationManager, loadFlowParameters)\n+                .thenCompose(loadFlowResult -> {\n                     if (loadFlowResult.isOk()) {\n+                        return CompletableFuture\n+                                .runAsync(() -> {\n+                                    network.getVariantManager().setWorkingVariant(workingStateId);\n+                                    setPreContigencyOkAndCheckViolations(resultBuilder);\n+                                }, computationManager.getExecutor())\n+                                .thenComposeAsync(\n+                                    aVoid -> submitAllLoadFlows(workingStateId, contingenciesProvider, postContParameters, resultBuilder),\n+                                    SCHEDULER_EXECUTOR);\n+                    } else {\n+                        return setPreContingencyKo(resultBuilder);\n+                    }\n+                }).thenApply(aVoid -> resultBuilder.build());\n+    }\n \n-                        resultBuilder.preContingency()\n-                                .setComputationOk(true);\n-                        violationDetector.checkAll(network, resultBuilder::addViolation);\n-                        resultBuilder.endPreContingency();\n-\n-                        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n-\n-                        futures = new CompletableFuture[contingencies.size()];\n-\n-                        String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n+    private void setPreContigencyOkAndCheckViolations(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(true);\n+        violationDetector.checkAll(network, resultBuilder::addViolation);\n+        resultBuilder.endPreContingency();\n+    }\n \n-                            String postContStateId = hash + \"_\" + contingency.getId();\n+    private CompletableFuture<Void> setPreContingencyKo(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(false).endPreContingency();\n+        return CompletableFuture.completedFuture(null);\n+    }\n \n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    private CompletableFuture<Void> submitAllLoadFlows(String workingStateId,\n+            ContingenciesProvider contingenciesProvider,\n+            LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder) {\n+        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n+        List<String> variantIds = makeWorkingVariantsNames(contingencies.size());\n+        BlockingQueue<String> queue = new ArrayBlockingQueue<>(variantIds.size(), false, variantIds);\n+        network.getVariantManager().cloneVariant(workingStateId, variantIds);\n+        return CompletableFuture.completedFuture(null).thenCompose(aaVoid -> {\n+            boolean previousMultiThreadAcces = network.getVariantManager()\n+                    .isVariantMultiThreadAccessAllowed();\n+            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+            return CompletableFuture\n+                    .allOf(contingencies.stream()\n+                            .map(contingency -> submitOneLoadFlow(workingStateId,\n+                                    contingency, postContParameters, resultBuilder,\n+                                    queue))\n+                            .toArray(CompletableFuture[]::new))\n+                    .whenComplete((aVoid, throwable) -> network.getVariantManager()\n+                            .allowVariantMultiThreadAccess(previousMultiThreadAcces));\n+        }).whenComplete((aVoid, throwable) ->\n+            variantIds.stream().forEach(network.getVariantManager()::removeVariant));\n+    }\n \n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n+    private List<String> makeWorkingVariantsNames(int contingencySize) {\n+        String hash = UUID.randomUUID().toString();\n+        int workerCount = Math.min(MAX_VARIANTS_PER_ANALYSIS,\n+                Math.min(computationManager.getResourcesStatus().getAvailableCores(),\n+                        contingencySize));\n+        return IntStream.range(0, workerCount)\n+                .mapToObj(i -> hash + \"_\" + i).collect(Collectors.toList());\n+    }\n \n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    // Block for an available variant, then submit a loadflow on this variant, then\n+    // make the variant available again\n+    private CompletableFuture<Void> submitOneLoadFlow(String workingStateId,\n+            Contingency contingency, LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder, BlockingQueue<String> queue) {\n+        return CompletableFuture.completedFuture(null).thenCompose(aaVoid -> {\n+            String postContStateId;\n+            try {\n+                postContStateId = queue.take();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new UncheckedInterruptedException(e);\n+            }\n+            return runOneLoadFlowAsync(workingStateId, postContStateId, postContParameters, resultBuilder, contingency)\n+                    .whenComplete((aVoid, throwable) -> queue.add(postContStateId));\n+        });\n+    }\n \n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n+    private CompletableFuture<Void> runOneLoadFlowAsync(String workingStateId,\n+            String postContStateId, LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder, Contingency contingency) {\n+        return CompletableFuture\n+                .runAsync(() -> applyContingency(workingStateId, postContStateId,\n+                        contingency), computationManager.getExecutor())\n+                .thenCompose(aVoid -> LoadFlow.runAsync(network, postContStateId,\n+                        computationManager, postContParameters))\n+                .thenApplyAsync(lfResult -> {\n+                    setContingencyOkAndCheckViolations(postContStateId, resultBuilder,\n+                            contingency, lfResult);\n+                    return null;\n+                }, computationManager.getExecutor());\n+    }\n \n-                                        return null;\n-                                    }, computationManager.getExecutor());\n-                        }\n-                    } else {\n-                        resultBuilder.preContingency()\n-                                .setComputationOk(false)\n-                                .endPreContingency()\n-                                .build();\n-                        futures = new CompletableFuture[0];\n-                    }\n+    private void setContingencyOkAndCheckViolations(String postContStateId,\n+            SecurityAnalysisResultBuilder resultBuilder, Contingency contingency,\n+            LoadFlowResult lfResult) {\n+        network.getVariantManager().setWorkingVariant(postContStateId);\n+        synchronized (resultBuilder) {\n+            resultBuilder.contingency(contingency)\n+                    .setComputationOk(lfResult.isOk());\n+            violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n+            resultBuilder.endContingency();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM2NjM4OnYy", "diffSide": "RIGHT", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMDo1OFrOFuIO_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMDo1OFrOFuIO_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMzcyNQ==", "bodyText": "You should not create a variant for all variant, but create 1 variant per worker. This is a regression on what you did yesterday?", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383913725", "createdAt": "2020-02-25T14:30:58Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -69,70 +97,120 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n         // start post contingency LF from pre-contingency state variables\n         LoadFlowParameters postContParameters = loadFlowParameters.copy().setVoltageInitMode(LoadFlowParameters.VoltageInitMode.PREVIOUS_VALUES);\n \n-        network.getVariantManager().allowVariantMultiThreadAccess(true);\n-\n-        return LoadFlow.runAsync(network, workingStateId, computationManager, loadFlowParameters) // run base load flow\n-                .thenComposeAsync(loadFlowResult -> {\n-                    network.getVariantManager().setWorkingVariant(workingStateId);\n-\n-                    SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n-\n-                    CompletableFuture<Void>[] futures;\n+        SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n \n+        return LoadFlow\n+                .runAsync(network, workingStateId, computationManager, loadFlowParameters)\n+                .thenCompose(loadFlowResult -> {\n                     if (loadFlowResult.isOk()) {\n+                        return CompletableFuture\n+                                .runAsync(() -> {\n+                                    network.getVariantManager().setWorkingVariant(workingStateId);\n+                                    setPreContigencyOkAndCheckViolations(resultBuilder);\n+                                }, computationManager.getExecutor())\n+                                .thenComposeAsync(\n+                                    aVoid -> submitAllLoadFlows(workingStateId, contingenciesProvider, postContParameters, resultBuilder),\n+                                    SCHEDULER_EXECUTOR);\n+                    } else {\n+                        return setPreContingencyKo(resultBuilder);\n+                    }\n+                }).thenApply(aVoid -> resultBuilder.build());\n+    }\n \n-                        resultBuilder.preContingency()\n-                                .setComputationOk(true);\n-                        violationDetector.checkAll(network, resultBuilder::addViolation);\n-                        resultBuilder.endPreContingency();\n-\n-                        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n-\n-                        futures = new CompletableFuture[contingencies.size()];\n-\n-                        String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n+    private void setPreContigencyOkAndCheckViolations(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(true);\n+        violationDetector.checkAll(network, resultBuilder::addViolation);\n+        resultBuilder.endPreContingency();\n+    }\n \n-                            String postContStateId = hash + \"_\" + contingency.getId();\n+    private CompletableFuture<Void> setPreContingencyKo(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(false).endPreContingency();\n+        return CompletableFuture.completedFuture(null);\n+    }\n \n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    private CompletableFuture<Void> submitAllLoadFlows(String workingStateId,\n+            ContingenciesProvider contingenciesProvider,\n+            LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder) {\n+        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n+        List<String> variantIds = makeWorkingVariantsNames(contingencies.size());\n+        BlockingQueue<String> queue = new ArrayBlockingQueue<>(variantIds.size(), false, variantIds);\n+        network.getVariantManager().cloneVariant(workingStateId, variantIds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 68, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}