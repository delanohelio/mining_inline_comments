{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzA0MTQ5", "number": 1169, "title": "SecurityAnalysisImpl multithread fixes alternative implementations", "bodyText": "Please check if the PR fulfills these requirements (please use '[x]' to check the checkboxes, or submit the PR and then click the checkboxes)\n\n The commit message follows our guidelines\n Tests for the changes have been added (for bug fixes / features)\n Docs have been added / updated (for bug fixes / features)\n\nDoes this PR already have an issue describing the problem ? If so, link to this issue using '#XXX' and skip the rest\n#1097 #1117\nOther information:\nThis is my proposed implementation. I tried to keep it as simple as I can while still beeing correct.\nIf we decide to go this way, I think we can do more refactoring to make this code more readable (extracting methods will allow to reduce heavy indentation; removing the synchronize on the ResultBuilder and merging the results at the end). This builds upon the work of yichen in #1097 #1117, thanks.\nMore tests are needed to prove that the many bugs fixed by this PR are real and correctly fixed and we don't have regressions..\nThe diff is best understood using a whitespace agnostic algorithm, as most of the code only change by indentation https://github.com/powsybl/powsybl-core/pull/1169/files?w=1", "createdAt": "2020-02-19T17:54:07Z", "url": "https://github.com/powsybl/powsybl-core/pull/1169", "merged": true, "mergeCommit": {"oid": "ddcf4d0c058a8a5e2e0772cade1f5baaabfab9e3"}, "closed": true, "closedAt": "2020-02-28T16:15:51Z", "author": {"login": "jonenst"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcF648sABqjMwNTI4ODE4Mzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIxFYRAFqTM2NjQ1MDA1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c96ef3a920f41868ecfdde1e3e51db091211874", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/8c96ef3a920f41868ecfdde1e3e51db091211874", "committedDate": "2020-02-19T17:40:11Z", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}, "afterCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/0776bc31f3342b9a0f01a14675d503495bdfaeb6", "committedDate": "2020-02-19T18:29:48Z", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzc2ODky", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-361376892", "createdAt": "2020-02-19T19:32:44Z", "commit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjk5NzQx", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-361699741", "createdAt": "2020-02-20T08:12:17Z", "commit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODoxMjoxOFrOFsJpaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODoxMjoxOFrOFsJpaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTcyMQ==", "bodyText": "I think sonar cognitive complexity analyzer must be crying :)\nIt was already the case before the PR, but I think we should stick to the rule that lambda should be as much as possible one-liners, in particular for complex, asynchronous code.\nI think we should simply create more functions here.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381839721", "createdAt": "2020-02-20T08:12:18Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzIwMTcx", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-361720171", "createdAt": "2020-02-20T08:48:23Z", "commit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODo0ODoyM1rOFsKp_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNzoyNFrOFsL86w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NjI1Mg==", "bodyText": "Might look less weird to have a supplyAsync return the array of future chained with a .thenCompose(CompletableFuture::allOf).whenComplete(... ?", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381856252", "createdAt": "2020-02-20T08:48:23Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NjYyOA==", "bodyText": "Here we should clone the workingStateId used for pre contingency computation.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381876628", "createdAt": "2020-02-20T09:25:59Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzQ4Mw==", "bodyText": "agreed with @mathbagu : Here we should clone the variant used for pre contingency computation, in order to restore the \"N\" situation before applying the contingency.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381877483", "createdAt": "2020-02-20T09:27:24Z", "author": {"login": "sylvlecl"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture\n+                                        .supplyAsync(() -> {\n+                                            try {\n+                                                return queue.take();\n+                                            } catch (InterruptedException e) {\n+                                                Thread.currentThread().interrupt();\n+                                                throw new UncheckedInterruptedException(e);\n+                                            }\n+                                        }, computationManager.getExecutor())\n+                                        .thenCompose(workerId -> {\n+                                            String postContStateId = hash + \"_\" + workerId;\n+                                            return CompletableFuture\n+                                                    .runAsync(() -> {\n+                                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+                                                        // apply the contingency on the network\n+                                                        contingency.toTask().modify(network, computationManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/0776bc31f3342b9a0f01a14675d503495bdfaeb6", "committedDate": "2020-02-19T18:29:48Z", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}, "afterCommit": {"oid": "7c06ede301fc4787196c39b2a45a1c2335abc021", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/7c06ede301fc4787196c39b2a45a1c2335abc021", "committedDate": "2020-02-20T10:40:02Z", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c0055ba67580070625a7399aadde0ed0671cb9f", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/5c0055ba67580070625a7399aadde0ed0671cb9f", "committedDate": "2020-02-21T11:07:23Z", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool"}, "afterCommit": {"oid": "c5a93a98cc68218b4248204dda974baf0f1dd30a", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/c5a93a98cc68218b4248204dda974baf0f1dd30a", "committedDate": "2020-02-21T11:09:48Z", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5a93a98cc68218b4248204dda974baf0f1dd30a", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/c5a93a98cc68218b4248204dda974baf0f1dd30a", "committedDate": "2020-02-21T11:09:48Z", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool"}, "afterCommit": {"oid": "ecba715043900572c45295179e2bee6fea8dc82a", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/ecba715043900572c45295179e2bee6fea8dc82a", "committedDate": "2020-02-21T12:30:01Z", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "991397eec22bdb9a3aba333cff79e1c417c13c04", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/991397eec22bdb9a3aba333cff79e1c417c13c04", "committedDate": "2020-02-24T11:00:51Z", "message": "SecurityAnalysisImpl: Add a parameter max-variants-per-analysis\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}, "afterCommit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "committedDate": "2020-02-24T11:22:29Z", "message": "SecurityAnalysisImpl: Add a parameter max-variants-per-analysis\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9b0359916b8c2b8cde0255683c5a736e9321130", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/d9b0359916b8c2b8cde0255683c5a736e9321130", "committedDate": "2020-02-24T19:53:21Z", "message": "SecurityAnalysisImpl: Clone a batch variants before the loadflows and delete them after\n\ncloneVariant is not thread safe, so it must be done before the computations.\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97f8e5e324dac47070953999e734d3751a0459ac", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/97f8e5e324dac47070953999e734d3751a0459ac", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: contingencyBuilder is not thread safe, synchronize access\n\nThis is the easy way to fix the problem. It's not great but not so terrible because\nthe code in the synchronzized block is not too slow compared to running the loadflows\n(checkAll scans all branches and voltage levels in the network once; it's not instantaneous\nbut fast than running a loadflow; the postContingencyResult interceptors are also run, are they long ?)\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05a9527c9851a3106780def9d7c5b14454c340e8", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/05a9527c9851a3106780def9d7c5b14454c340e8", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: don't build results twice when initial loadflow fails\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c359d9b5e6dfab10f52548b7b78a0c03c817739", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/2c359d9b5e6dfab10f52548b7b78a0c03c817739", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: cleanup, these do not need to be async\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "503cbd13772bf4b0ef31fdb4d4fe7e210da6613f", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/503cbd13772bf4b0ef31fdb4d4fe7e210da6613f", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: restore VariantMultiThreadAccess after the computation\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3070a55fb4afc984dedfc41eb972d2aabac376f", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/f3070a55fb4afc984dedfc41eb972d2aabac376f", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: only do multithread access if the initial loadflow worked\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e1d40ebb05d96ccffff8c8b5245058fb727d4de", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/9e1d40ebb05d96ccffff8c8b5245058fb727d4de", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: cleanup: supplyAsync return null -> runAsync\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cef42204984e5677a8c1bff239d4cb7227449094", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/cef42204984e5677a8c1bff239d4cb7227449094", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: don't swallow exceptions\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aac98bb36ebfcb9acea5dd2458a6f56e7874157", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/3aac98bb36ebfcb9acea5dd2458a6f56e7874157", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9cefb58088b630237b55f619f787ffd8b64336", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/1f9cefb58088b630237b55f619f787ffd8b64336", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: clone from workingStateId instead of INITIAL_VARIANT_ID\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6913279b7df7174c6746791ae9241d32dbf40b51", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/6913279b7df7174c6746791ae9241d32dbf40b51", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: Add TODO to parallelize initial loadflow violation check\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f2ccc39fb75371193b42901859d1049cfa84b8d", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/8f2ccc39fb75371193b42901859d1049cfa84b8d", "committedDate": "2020-02-24T19:53:22Z", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eacc480071ce2a06a2fb9397e969321f09f1378", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/8eacc480071ce2a06a2fb9397e969321f09f1378", "committedDate": "2020-02-25T08:27:26Z", "message": "SecurityAnalysisImpl: check the violations of the initial loadflow in the compute executor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fde441cdede91447fc8cac5f40d71e3a50181719", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/fde441cdede91447fc8cac5f40d71e3a50181719", "committedDate": "2020-02-25T08:27:26Z", "message": "SecurityAnalysisImpl: improve comments\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dc09d6bad70d9b398d51139d922552e64000a4b", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/9dc09d6bad70d9b398d51139d922552e64000a4b", "committedDate": "2020-02-25T08:27:26Z", "message": "SecurityAnalysisImpl: Add a parameter max-variants-per-analysis\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "197cbf75b2fd30b9ef3dd80d9e26fc066af3694a", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/197cbf75b2fd30b9ef3dd80d9e26fc066af3694a", "committedDate": "2020-02-25T12:10:09Z", "message": "SecurityAnalysisImpl: refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4951e2a36ac116e9daec1376ef259cd57713b67a", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/4951e2a36ac116e9daec1376ef259cd57713b67a", "committedDate": "2020-02-25T12:10:09Z", "message": "SecurityAnalysisImpl: don't run the checkviolations of the base loadflow in parallel\n\nThe network is not in isVariantMultiThreadAccessAllowed(true) yet\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/02e7da27913fc1d2308e756c584c6982d21afd78", "committedDate": "2020-02-25T12:10:09Z", "message": "SecurityAnalysisImpl: more refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "committedDate": "2020-02-24T11:22:29Z", "message": "SecurityAnalysisImpl: Add a parameter max-variants-per-analysis\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}, "afterCommit": {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/02e7da27913fc1d2308e756c584c6982d21afd78", "committedDate": "2020-02-25T12:10:09Z", "message": "SecurityAnalysisImpl: more refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MDcyMjI1", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-364072225", "createdAt": "2020-02-25T11:34:28Z", "commit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTozNDoyOFrOFuCwtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMDo1OFrOFuIO_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyNDA1NQ==", "bodyText": "The name of the module could be default-security-analysis, because \"Default\" will be the name of this implementation (see PR#972)", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383824055", "createdAt": "2020-02-25T11:34:28Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -20,14 +21,39 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n \n /**\n  * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n  * @author Teofil Calin BANC <teofil-calin.banc at rte-france.com>\n  */\n public class SecurityAnalysisImpl extends AbstractSecurityAnalysis {\n \n+    /**\n+     * This executor is used to create the variants of the network, submit the tasks\n+     * for computing contingency loadflows and submit the tasks for checking for the\n+     * violations. Submitting tasks itself is blocking because we can only run a\n+     * limited number of loadflows in parallel because we need the memory for the\n+     * variant, and we don't want to submit tasks that would immediately block to\n+     * get an available variant (they hurt the performance of the executor who\n+     * excutes them)\n+     */\n+    private static final ExecutorService SCHEDULER_EXECUTOR = Executors\n+            .newFixedThreadPool(Integer.parseInt(PlatformConfig.defaultConfig()\n+                    .getOptionalModuleConfig(\"security-analysis-impl\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyNDI0Ng==", "bodyText": "Should we base this on the number of cores?", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383824246", "createdAt": "2020-02-25T11:34:55Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -20,14 +21,39 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n \n /**\n  * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n  * @author Teofil Calin BANC <teofil-calin.banc at rte-france.com>\n  */\n public class SecurityAnalysisImpl extends AbstractSecurityAnalysis {\n \n+    /**\n+     * This executor is used to create the variants of the network, submit the tasks\n+     * for computing contingency loadflows and submit the tasks for checking for the\n+     * violations. Submitting tasks itself is blocking because we can only run a\n+     * limited number of loadflows in parallel because we need the memory for the\n+     * variant, and we don't want to submit tasks that would immediately block to\n+     * get an available variant (they hurt the performance of the executor who\n+     * excutes them)\n+     */\n+    private static final ExecutorService SCHEDULER_EXECUTOR = Executors\n+            .newFixedThreadPool(Integer.parseInt(PlatformConfig.defaultConfig()\n+                    .getOptionalModuleConfig(\"security-analysis-impl\")\n+                    .flatMap(m -> m.getOptionalStringProperty(\"scheduler-pool-size\"))\n+                    .orElse(\"10\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMTIxMQ==", "bodyText": "I'm not sure this is a really good API design. The contingency method should create a PostContingencyResultBuilder that is thread safe. The endContingency should add the PostContingencyResult to the SAResult.", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383911211", "createdAt": "2020-02-25T14:26:55Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -69,70 +97,120 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n         // start post contingency LF from pre-contingency state variables\n         LoadFlowParameters postContParameters = loadFlowParameters.copy().setVoltageInitMode(LoadFlowParameters.VoltageInitMode.PREVIOUS_VALUES);\n \n-        network.getVariantManager().allowVariantMultiThreadAccess(true);\n-\n-        return LoadFlow.runAsync(network, workingStateId, computationManager, loadFlowParameters) // run base load flow\n-                .thenComposeAsync(loadFlowResult -> {\n-                    network.getVariantManager().setWorkingVariant(workingStateId);\n-\n-                    SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n-\n-                    CompletableFuture<Void>[] futures;\n+        SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n \n+        return LoadFlow\n+                .runAsync(network, workingStateId, computationManager, loadFlowParameters)\n+                .thenCompose(loadFlowResult -> {\n                     if (loadFlowResult.isOk()) {\n+                        return CompletableFuture\n+                                .runAsync(() -> {\n+                                    network.getVariantManager().setWorkingVariant(workingStateId);\n+                                    setPreContigencyOkAndCheckViolations(resultBuilder);\n+                                }, computationManager.getExecutor())\n+                                .thenComposeAsync(\n+                                    aVoid -> submitAllLoadFlows(workingStateId, contingenciesProvider, postContParameters, resultBuilder),\n+                                    SCHEDULER_EXECUTOR);\n+                    } else {\n+                        return setPreContingencyKo(resultBuilder);\n+                    }\n+                }).thenApply(aVoid -> resultBuilder.build());\n+    }\n \n-                        resultBuilder.preContingency()\n-                                .setComputationOk(true);\n-                        violationDetector.checkAll(network, resultBuilder::addViolation);\n-                        resultBuilder.endPreContingency();\n-\n-                        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n-\n-                        futures = new CompletableFuture[contingencies.size()];\n-\n-                        String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n+    private void setPreContigencyOkAndCheckViolations(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(true);\n+        violationDetector.checkAll(network, resultBuilder::addViolation);\n+        resultBuilder.endPreContingency();\n+    }\n \n-                            String postContStateId = hash + \"_\" + contingency.getId();\n+    private CompletableFuture<Void> setPreContingencyKo(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(false).endPreContingency();\n+        return CompletableFuture.completedFuture(null);\n+    }\n \n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    private CompletableFuture<Void> submitAllLoadFlows(String workingStateId,\n+            ContingenciesProvider contingenciesProvider,\n+            LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder) {\n+        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n+        List<String> variantIds = makeWorkingVariantsNames(contingencies.size());\n+        BlockingQueue<String> queue = new ArrayBlockingQueue<>(variantIds.size(), false, variantIds);\n+        network.getVariantManager().cloneVariant(workingStateId, variantIds);\n+        return CompletableFuture.completedFuture(null).thenCompose(aaVoid -> {\n+            boolean previousMultiThreadAcces = network.getVariantManager()\n+                    .isVariantMultiThreadAccessAllowed();\n+            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+            return CompletableFuture\n+                    .allOf(contingencies.stream()\n+                            .map(contingency -> submitOneLoadFlow(workingStateId,\n+                                    contingency, postContParameters, resultBuilder,\n+                                    queue))\n+                            .toArray(CompletableFuture[]::new))\n+                    .whenComplete((aVoid, throwable) -> network.getVariantManager()\n+                            .allowVariantMultiThreadAccess(previousMultiThreadAcces));\n+        }).whenComplete((aVoid, throwable) ->\n+            variantIds.stream().forEach(network.getVariantManager()::removeVariant));\n+    }\n \n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n+    private List<String> makeWorkingVariantsNames(int contingencySize) {\n+        String hash = UUID.randomUUID().toString();\n+        int workerCount = Math.min(MAX_VARIANTS_PER_ANALYSIS,\n+                Math.min(computationManager.getResourcesStatus().getAvailableCores(),\n+                        contingencySize));\n+        return IntStream.range(0, workerCount)\n+                .mapToObj(i -> hash + \"_\" + i).collect(Collectors.toList());\n+    }\n \n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    // Block for an available variant, then submit a loadflow on this variant, then\n+    // make the variant available again\n+    private CompletableFuture<Void> submitOneLoadFlow(String workingStateId,\n+            Contingency contingency, LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder, BlockingQueue<String> queue) {\n+        return CompletableFuture.completedFuture(null).thenCompose(aaVoid -> {\n+            String postContStateId;\n+            try {\n+                postContStateId = queue.take();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new UncheckedInterruptedException(e);\n+            }\n+            return runOneLoadFlowAsync(workingStateId, postContStateId, postContParameters, resultBuilder, contingency)\n+                    .whenComplete((aVoid, throwable) -> queue.add(postContStateId));\n+        });\n+    }\n \n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n+    private CompletableFuture<Void> runOneLoadFlowAsync(String workingStateId,\n+            String postContStateId, LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder, Contingency contingency) {\n+        return CompletableFuture\n+                .runAsync(() -> applyContingency(workingStateId, postContStateId,\n+                        contingency), computationManager.getExecutor())\n+                .thenCompose(aVoid -> LoadFlow.runAsync(network, postContStateId,\n+                        computationManager, postContParameters))\n+                .thenApplyAsync(lfResult -> {\n+                    setContingencyOkAndCheckViolations(postContStateId, resultBuilder,\n+                            contingency, lfResult);\n+                    return null;\n+                }, computationManager.getExecutor());\n+    }\n \n-                                        return null;\n-                                    }, computationManager.getExecutor());\n-                        }\n-                    } else {\n-                        resultBuilder.preContingency()\n-                                .setComputationOk(false)\n-                                .endPreContingency()\n-                                .build();\n-                        futures = new CompletableFuture[0];\n-                    }\n+    private void setContingencyOkAndCheckViolations(String postContStateId,\n+            SecurityAnalysisResultBuilder resultBuilder, Contingency contingency,\n+            LoadFlowResult lfResult) {\n+        network.getVariantManager().setWorkingVariant(postContStateId);\n+        synchronized (resultBuilder) {\n+            resultBuilder.contingency(contingency)\n+                    .setComputationOk(lfResult.isOk());\n+            violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n+            resultBuilder.endContingency();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMzcyNQ==", "bodyText": "You should not create a variant for all variant, but create 1 variant per worker. This is a regression on what you did yesterday?", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383913725", "createdAt": "2020-02-25T14:30:58Z", "author": {"login": "mathbagu"}, "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -69,70 +97,120 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n         // start post contingency LF from pre-contingency state variables\n         LoadFlowParameters postContParameters = loadFlowParameters.copy().setVoltageInitMode(LoadFlowParameters.VoltageInitMode.PREVIOUS_VALUES);\n \n-        network.getVariantManager().allowVariantMultiThreadAccess(true);\n-\n-        return LoadFlow.runAsync(network, workingStateId, computationManager, loadFlowParameters) // run base load flow\n-                .thenComposeAsync(loadFlowResult -> {\n-                    network.getVariantManager().setWorkingVariant(workingStateId);\n-\n-                    SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n-\n-                    CompletableFuture<Void>[] futures;\n+        SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n \n+        return LoadFlow\n+                .runAsync(network, workingStateId, computationManager, loadFlowParameters)\n+                .thenCompose(loadFlowResult -> {\n                     if (loadFlowResult.isOk()) {\n+                        return CompletableFuture\n+                                .runAsync(() -> {\n+                                    network.getVariantManager().setWorkingVariant(workingStateId);\n+                                    setPreContigencyOkAndCheckViolations(resultBuilder);\n+                                }, computationManager.getExecutor())\n+                                .thenComposeAsync(\n+                                    aVoid -> submitAllLoadFlows(workingStateId, contingenciesProvider, postContParameters, resultBuilder),\n+                                    SCHEDULER_EXECUTOR);\n+                    } else {\n+                        return setPreContingencyKo(resultBuilder);\n+                    }\n+                }).thenApply(aVoid -> resultBuilder.build());\n+    }\n \n-                        resultBuilder.preContingency()\n-                                .setComputationOk(true);\n-                        violationDetector.checkAll(network, resultBuilder::addViolation);\n-                        resultBuilder.endPreContingency();\n-\n-                        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n-\n-                        futures = new CompletableFuture[contingencies.size()];\n-\n-                        String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n+    private void setPreContigencyOkAndCheckViolations(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(true);\n+        violationDetector.checkAll(network, resultBuilder::addViolation);\n+        resultBuilder.endPreContingency();\n+    }\n \n-                            String postContStateId = hash + \"_\" + contingency.getId();\n+    private CompletableFuture<Void> setPreContingencyKo(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(false).endPreContingency();\n+        return CompletableFuture.completedFuture(null);\n+    }\n \n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    private CompletableFuture<Void> submitAllLoadFlows(String workingStateId,\n+            ContingenciesProvider contingenciesProvider,\n+            LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder) {\n+        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n+        List<String> variantIds = makeWorkingVariantsNames(contingencies.size());\n+        BlockingQueue<String> queue = new ArrayBlockingQueue<>(variantIds.size(), false, variantIds);\n+        network.getVariantManager().cloneVariant(workingStateId, variantIds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fab5479d246419d28e21310831c04f90df3d9945", "author": {"user": {"login": "jonenst", "name": "Jon Harper"}}, "url": "https://github.com/powsybl/powsybl-core/commit/fab5479d246419d28e21310831c04f90df3d9945", "committedDate": "2020-02-25T16:08:48Z", "message": "SecurityAnalysisImpl: refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29c00e1837051f454158b2e36c8a62e71adadbd9", "author": {"user": {"login": "mathbagu", "name": "Mathieu BAGUE"}}, "url": "https://github.com/powsybl/powsybl-core/commit/29c00e1837051f454158b2e36c8a62e71adadbd9", "committedDate": "2020-02-27T16:03:05Z", "message": "Fix issues with new implementation\n\nSigned-off-by: Mathieu BAGUE <mathieu.bague@rte-france.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Mjk1OTgy", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-366295982", "createdAt": "2020-02-28T10:26:00Z", "commit": {"oid": "29c00e1837051f454158b2e36c8a62e71adadbd9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d648aad37f0816089640ee028ad018933b74ea4", "author": {"user": {"login": "geofjamg", "name": "Geoffroy Jamgotchian"}}, "url": "https://github.com/powsybl/powsybl-core/commit/7d648aad37f0816089640ee028ad018933b74ea4", "committedDate": "2020-02-28T11:09:08Z", "message": "Merge branch 'master' into securityanalysisparallel"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MzM2MjQ0", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-366336244", "createdAt": "2020-02-28T11:36:11Z", "commit": {"oid": "7d648aad37f0816089640ee028ad018933b74ea4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b42ec8960089fad5da7568e933395a76990d99ac", "author": {"user": {"login": "mathbagu", "name": "Mathieu BAGUE"}}, "url": "https://github.com/powsybl/powsybl-core/commit/b42ec8960089fad5da7568e933395a76990d99ac", "committedDate": "2020-02-28T14:28:29Z", "message": "Small fixes\n- Use a fixed thread pool executor with a keep alive timeout close to 0\n- Replace the synchronized by a ReentrantLock\n\nSigned-off-by: Mathieu BAGUE <mathieu.bague@rte-france.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ed97063e5124d1ecfacdd984d872b47a35af151", "author": {"user": {"login": "mathbagu", "name": "Mathieu BAGUE"}}, "url": "https://github.com/powsybl/powsybl-core/commit/0ed97063e5124d1ecfacdd984d872b47a35af151", "committedDate": "2020-02-28T14:30:48Z", "message": "Fix the visibility of the scheduler\n\nSigned-off-by: Mathieu BAGUE <mathieu.bague@rte-france.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15c77a26c91125ea8819378d970b67f929252c6a", "author": {"user": {"login": "mathbagu", "name": "Mathieu BAGUE"}}, "url": "https://github.com/powsybl/powsybl-core/commit/15c77a26c91125ea8819378d970b67f929252c6a", "committedDate": "2020-02-28T14:48:14Z", "message": "Merge branch 'master' into securityanalysisparallel"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDUwMDU2", "url": "https://github.com/powsybl/powsybl-core/pull/1169#pullrequestreview-366450056", "createdAt": "2020-02-28T14:48:43Z", "commit": {"oid": "0ed97063e5124d1ecfacdd984d872b47a35af151"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4408, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}