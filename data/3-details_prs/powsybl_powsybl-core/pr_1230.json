{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5OTAzMjY4", "number": 1230, "title": "Cgmes conversion hvdc", "bodyText": "Please check if the PR fulfills these requirements (please use '[x]' to check the checkboxes, or submit the PR and then click the checkboxes)\n\n The commit message follows our guidelines\n Tests for the changes have been added (for bug fixes / features)\n Docs have been added / updated (for bug fixes / features)\n\nDoes this PR already have an issue describing the problem ? If so, link to this issue using '#XXX' and skip the rest\nWhat kind of change does this PR introduce? (Bug fix, feature, docs update, ...)\nRefactoring.\nWhat is the current behavior? (You can also link to an open issue here)\nHvdc conversion is made in two independent steps. First acDcConverters are converted and then DCLinks.\nWhat is the new behavior (if this is a feature change)?\nFirst all hvdc configurations are identified, then each hvdc configuration is converted to IIDM.\nDoes this PR introduce a breaking change or deprecate an API? If yes, check the following:\n\n The Breaking Change or Deprecated label has been added\n The migration guide has been updated in the github wiki (What changes might users need to make in their application due to this PR?)\n\nOther information:\n(if any of the questions/checkboxes don't apply, please delete them entirely)\nClasses to identify hvdc configurations:\nAcDcConverterNodes: For each acDcConverter the associated acTopologicalNode and the list of associated dcTopologicalNodes are recorded.\nAdjacency: Calculate adjacency for all dcTopologicalNodes and adjacent acTopologicalNodes. Adjacent nodes are connected by acDcConverters, dcLineSegments or acTransformers.\nTPnodeEquipments: For each dcTopologicalNode and adjacent acTopologicalNode all equipment  connected to it is recorded (acDcConverters, dcLineSegments, and acTransformers).\nIslands: Calculate dc islands using the adjacency class. Islands include all dcTopologicalNodes and a few acTopologicalNodes (nodes at both ends of the transformer).\nIslandsEnd: Split previous islands in two bags, one bag at each side of the dcLineSegments.\nIslandEndHvdc: Identify the hvdc configuration at each islandEnd.\nHvdc:  Join the hvdc configuration of each end to get the final hvdc configuration.\nMapping classes:\nDcMapping: Catch the propertyBag for each acDcConverter and dcLineSegment. The attribute used is set if the acDcConverter (dcLineSegment) is converted to IIDM. A warning is printed for each acDcConverter or dcLineSegment not used.\nConversion classes:\nCgmesDcConversion: Main class. Get the hvdc configurations and convert them to IIDM.\nAcDcConverterConversion: Convert to IIDM an acDcConverter.\nDcLineSegmentConversion: Convert to IIDM ad dcLineSegment.\nLossFactor: Compute loss factor.", "createdAt": "2020-03-17T15:22:21Z", "url": "https://github.com/powsybl/powsybl-core/pull/1230", "merged": true, "mergeCommit": {"oid": "db1d2fe7236aec1d08de189f7323e444f982ab0d"}, "closed": true, "closedAt": "2020-04-15T08:03:50Z", "author": {"login": "marqueslanauja"}, "timelineItems": {"totalCount": 61, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-rjWnAH2gAyMzg5OTAzMjY4OjhhMjBmNTVkNTFkY2E1YmEzYzQ0ZWY4ODlhOTFiNjk3ODMyMDFmMzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXzA9mgFqTM5MzUyMDcwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8a20f55d51dca5ba3c44ef889a91b69783201f32", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/8a20f55d51dca5ba3c44ef889a91b69783201f32", "committedDate": "2020-01-28T06:42:46Z", "message": "Calculate DC-Islands\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25152317fcd7c2056032d3ff04a009fa4ed0e123", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/25152317fcd7c2056032d3ff04a009fa4ed0e123", "committedDate": "2020-01-30T15:44:09Z", "message": "Hvdc refac\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "945564c8091ba08320134ec9e6fb93cb82c7fe32", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/945564c8091ba08320134ec9e6fb93cb82c7fe32", "committedDate": "2020-01-31T06:42:19Z", "message": "Rename package\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c686792551171be054c773f99b362f42d3aee01", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/2c686792551171be054c773f99b362f42d3aee01", "committedDate": "2020-01-31T11:13:24Z", "message": "Common topologicalNode version\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7da7010c20d136cbb329eb11493a571cb5b2127b", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/7da7010c20d136cbb329eb11493a571cb5b2127b", "committedDate": "2020-02-03T13:33:15Z", "message": "Refac Hvdc\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ad1aa62777c4c70a2a1b3cb987d772b2fe18ea1", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/2ad1aa62777c4c70a2a1b3cb987d772b2fe18ea1", "committedDate": "2020-02-12T16:00:22Z", "message": "Get all DC configurations properly\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4a1daace52fd529ab0b59c2f02e9a4708e2d96b", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/f4a1daace52fd529ab0b59c2f02e9a4708e2d96b", "committedDate": "2020-02-17T08:02:27Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cbb542e20464496942226dd2fe4520cb8db382e", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/2cbb542e20464496942226dd2fe4520cb8db382e", "committedDate": "2020-02-17T14:23:42Z", "message": "AcDcConverterConversion and DcLineSegmentConversion\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2280476b08f2ab07cfcbcc8513f79c8e4f1d70bd", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/2280476b08f2ab07cfcbcc8513f79c8e4f1d70bd", "committedDate": "2020-02-20T13:01:36Z", "message": "Create IIDM Hvdc converters and links\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f36e234e4ff33c6e053cc92beec1db48a4a72aac", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/f36e234e4ff33c6e053cc92beec1db48a4a72aac", "committedDate": "2020-02-24T06:43:44Z", "message": "Fix some errors\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cceb42f2feac55ee0bbbd0895f17f9e212b6b7e2", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/cceb42f2feac55ee0bbbd0895f17f9e212b6b7e2", "committedDate": "2020-02-27T09:03:17Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6feff6b20d4bcc11804fe791ae1c99144783f752", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/6feff6b20d4bcc11804fe791ae1c99144783f752", "committedDate": "2020-03-03T06:53:05Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "514c0fad1a3b2a6d8ac68a2270839aa24b4f366f", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/514c0fad1a3b2a6d8ac68a2270839aa24b4f366f", "committedDate": "2020-03-13T08:50:28Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9bdc8aedb605bb08c84d9a243affa7fc1463338", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/d9bdc8aedb605bb08c84d9a243affa7fc1463338", "committedDate": "2020-03-16T23:08:54Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6ea8ed7024d030400a8e4d6cccc242d6968afac", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/f6ea8ed7024d030400a8e4d6cccc242d6968afac", "committedDate": "2020-03-17T07:23:58Z", "message": "Delete unnecessary code\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9d074a9bade75204935a958f622e267c6969731", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/e9d074a9bade75204935a958f622e267c6969731", "committedDate": "2020-03-17T15:12:25Z", "message": "Pretty code\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c33171bfa36f00479e972469b7eddb4106c2435d", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/c33171bfa36f00479e972469b7eddb4106c2435d", "committedDate": "2020-03-17T16:19:33Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-model/src/main/java/com/powsybl/cgmes/model/CgmesModel.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "136368ee5fab74a78e80ae2ebc690262981214c0", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/136368ee5fab74a78e80ae2ebc690262981214c0", "committedDate": "2020-03-19T00:05:35Z", "message": "Add a hvdc configuration without transformers.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71d726c0239ad06b071624875f25dcece67ae194", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/71d726c0239ad06b071624875f25dcece67ae194", "committedDate": "2020-03-19T00:06:48Z", "message": "Unitary tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47e367405e933c518ccff694411b78c3bb947a65", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/47e367405e933c518ccff694411b78c3bb947a65", "committedDate": "2020-03-19T15:03:41Z", "message": "Log under configuration\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d78cbbd032cbb2a4e97709db3cf20ed9b941756c", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/d78cbbd032cbb2a4e97709db3cf20ed9b941756c", "committedDate": "2020-03-19T15:05:30Z", "message": "Additional tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35b559c6d3bc715ba44b97bf2db314403be668cc", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/35b559c6d3bc715ba44b97bf2db314403be668cc", "committedDate": "2020-03-20T18:34:29Z", "message": "Additional tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/c1c5e45c91fa7f0a00d0ade62110da33225ad268", "committedDate": "2020-03-20T18:35:06Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDc0MDU1", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-379474055", "createdAt": "2020-03-23T14:20:20Z", "commit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "state": "COMMENTED", "comments": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyMDoyMFrOF6Hkiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjoxNDowNFrOF6M7CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NTc3MQ==", "bodyText": "Add Objects.requireNonNull()", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396485771", "createdAt": "2020-03-23T14:20:20Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -5,25 +5,34 @@\n  * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n  */\n \n-package com.powsybl.cgmes.conversion.elements;\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n \n import java.util.Objects;\n \n import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractConductingEquipmentConversion;\n import com.powsybl.iidm.network.HvdcConverterStation;\n import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.iidm.network.LccConverterStation;\n import com.powsybl.iidm.network.LccConverterStationAdder;\n import com.powsybl.iidm.network.VscConverterStationAdder;\n import com.powsybl.triplestore.api.PropertyBag;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n public class AcDcConverterConversion extends AbstractConductingEquipmentConversion {\n \n-    public AcDcConverterConversion(PropertyBag c, Context context) {\n+    enum VscRegulation {\n+        REACTIVE_POWER,\n+        VOLTAGE\n+    }\n+\n+    public AcDcConverterConversion(PropertyBag c, HvdcType converterType, double lossFactor, Context context) {\n         super(\"ACDCConverter\", c, context);\n-        converterType = decodeType(p.getLocal(\"type\"));\n+        this.converterType = converterType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjE4OA==", "bodyText": "can be final\nshould be private with a private-package getter returning an unmodifiable map", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396516188", "createdAt": "2020-03-23T15:00:08Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjk2OA==", "bodyText": "Method reference can be used instead of lambda:\n        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396516968", "createdAt": "2020-03-23T15:01:13Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODYyNg==", "bodyText": "When is this method used?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396518626", "createdAt": "2020-03-23T15:03:22Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxOTEzMA==", "bodyText": "You can directly use forEach on a map:\nconverterNodes.forEach((key, value) -> ....);", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396519130", "createdAt": "2020-03-23T15:04:01Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.entrySet()\n+            .forEach(entry -> LOG.info(\" {} {} {} {}\", entry.getKey(), entry.getValue().id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDE4OA==", "bodyText": "Can be final\nShould be private with a private-package getter returning an unmodifiable map", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396520188", "createdAt": "2020-03-23T15:05:31Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDgxNQ==", "bodyText": "Can they be final?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396520815", "createdAt": "2020-03-23T15:06:27Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.entrySet()\n+            .forEach(entry -> LOG.info(\" {} {} {} {}\", entry.getKey(), entry.getValue().id,\n+                entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+    }\n+\n+    static class AcDcConverterNode {\n+        String id;\n+        String acTopologicalNode;\n+        List<String> dcTopologicalNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTA1MQ==", "bodyText": "Maybe check Objects.requireNonNull()?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396521051", "createdAt": "2020-03-23T15:06:47Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.entrySet()\n+            .forEach(entry -> LOG.info(\" {} {} {} {}\", entry.getKey(), entry.getValue().id,\n+                entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+    }\n+\n+    static class AcDcConverterNode {\n+        String id;\n+        String acTopologicalNode;\n+        List<String> dcTopologicalNode;\n+\n+        AcDcConverterNode(String id, String acTopologicalNode) {\n+            this.id = id;\n+            this.acTopologicalNode = acTopologicalNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0MjQzNQ==", "bodyText": "You can directly use forEach on a map:\nacDcConverterNodes.getConverterNodes().forEach((key, value) -> ...);", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396542435", "createdAt": "2020-03-23T15:34:27Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTQ1OA==", "bodyText": "You can simplify:\naddTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode()));", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396545458", "createdAt": "2020-03-23T15:38:20Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTc4NQ==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396545785", "createdAt": "2020-03-23T15:38:43Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1NTkxOA==", "bodyText": "Method reference can be used here:\ntopologicalNodes.stream().anyMatch(this::containsAcDcConverter)", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396555918", "createdAt": "2020-03-23T15:51:28Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1Nzg3Nw==", "bodyText": "Not sure traces should be handled this way... In my opinion, those traces should always show up as DEBUG.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396557877", "createdAt": "2020-03-23T15:53:59Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTEyMA==", "bodyText": "Method reference can be used", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559120", "createdAt": "2020-03-23T15:55:34Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.info(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(ad -> ad.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTM3OA==", "bodyText": "forEach can be used directly on map", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559378", "createdAt": "2020-03-23T15:55:54Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTY3Nw==", "bodyText": "Maybe check Objects.requireNonNull()?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559677", "createdAt": "2020-03-23T15:56:16Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.info(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(ad -> ad.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));\n+    }\n+\n+    private void print(String node) {\n+        LOG.info(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.info(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }\n+\n+    static class Adjacent {\n+        AdjacentType type;\n+        String topologicalNode;\n+\n+        Adjacent(AdjacentType type, String topologicalNode) {\n+            this.type = type;\n+            this.topologicalNode = topologicalNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTk0NA==", "bodyText": "Use Objects.requireNonNull()", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559944", "createdAt": "2020-03-23T15:56:34Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NjgxNw==", "bodyText": "Same remark for logs", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396566817", "createdAt": "2020-03-23T16:05:23Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.islandsEndsNodes.forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.topologicalNodes1);\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.topologicalNodes2);\n+\n+            if (config.isHvdcConversionLogOn()) {\n+                adjacency.print(ien.topologicalNodes1);\n+                tpNodeEquipments.print(ien.topologicalNodes1);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes1);\n+\n+                adjacency.print(ien.topologicalNodes2);\n+                tpNodeEquipments.print(ien.topologicalNodes2);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes2);\n+\n+                islandEndHvdc1.print();\n+                islandEndHvdc2.print();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NzMzNw==", "bodyText": "Same remark for log", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396567337", "createdAt": "2020-03-23T16:06:03Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.islandsEndsNodes.forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.topologicalNodes1);\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.topologicalNodes2);\n+\n+            if (config.isHvdcConversionLogOn()) {\n+                adjacency.print(ien.topologicalNodes1);\n+                tpNodeEquipments.print(ien.topologicalNodes1);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes1);\n+\n+                adjacency.print(ien.topologicalNodes2);\n+                tpNodeEquipments.print(ien.topologicalNodes2);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes2);\n+\n+                islandEndHvdc1.print();\n+                islandEndHvdc2.print();\n+            }\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            hvdc.print();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2OTkxMw==", "bodyText": "can be final\nshould be private with a getter returning an unmodifiable list", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396569913", "createdAt": "2020-03-23T16:09:33Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MDI2Mw==", "bodyText": "Add a default case throwing an exception", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396570263", "createdAt": "2020-03-23T16:09:57Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MDg5Ng==", "bodyText": "can be final", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396570896", "createdAt": "2020-03-23T16:10:46Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_NONE:\n+                break;\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(ls -> hvdcEq.add(ls));\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    void print() {\n+        LOG.info(\"Hvdc\");\n+        hvdcData.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEquipment {\n+        List<HvdcConverter> converters;\n+        List<String> dcLineSegments;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTE0OQ==", "bodyText": "Maybe use Objects.requireNonNull()", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396571149", "createdAt": "2020-03-23T16:11:05Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_NONE:\n+                break;\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(ls -> hvdcEq.add(ls));\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    void print() {\n+        LOG.info(\"Hvdc\");\n+        hvdcData.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEquipment {\n+        List<HvdcConverter> converters;\n+        List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void print() {\n+            LOG.info(\"    Converters:\");\n+            this.converters.forEach(c -> c.print());\n+            LOG.info(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.info(\"    {} \", ls));\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    static class HvdcConverter {\n+        String acDcConvertersEnd1;\n+        String acDcConvertersEnd2;\n+\n+        HvdcConverter(String acDcConvertersEnd1, String acDcConvertersEnd2) {\n+            this.acDcConvertersEnd1 = acDcConvertersEnd1;\n+            this.acDcConvertersEnd2 = acDcConvertersEnd2;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTUzMg==", "bodyText": "can be final\nshould be private with a getter returning an unmodifiable set", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396571532", "createdAt": "2020-03-23T16:11:38Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTk5OQ==", "bodyText": "Maybe use Objects.requireNonNull()", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396571999", "createdAt": "2020-03-23T16:12:19Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.nodeEquipments.get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(ls -> hvdcEnd2.dcLineSegmentsEnd.contains(ls));\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandEndHvdc\");\n+        hvdc.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEnd {\n+        List<String> topologicalNodesEnd;\n+        Set<String> transformersEnd;\n+        Set<String> acDcConvertersEnd;\n+        Set<String> dcLineSegmentsEnd;\n+\n+        HvdcEnd(List<String> topologicalNodesEnd, Set<String> transformersEnd, Set<String> acDcConvertersEnd, Set<String> dcLineSegmentsEnd) {\n+            this.topologicalNodesEnd = topologicalNodesEnd;\n+            this.transformersEnd = transformersEnd;\n+            this.acDcConvertersEnd = acDcConvertersEnd;\n+            this.dcLineSegmentsEnd = dcLineSegmentsEnd;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjA4Mg==", "bodyText": "Can be final", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572082", "createdAt": "2020-03-23T16:12:25Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.nodeEquipments.get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(ls -> hvdcEnd2.dcLineSegmentsEnd.contains(ls));\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandEndHvdc\");\n+        hvdc.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEnd {\n+        List<String> topologicalNodesEnd;\n+        Set<String> transformersEnd;\n+        Set<String> acDcConvertersEnd;\n+        Set<String> dcLineSegmentsEnd;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjQzOQ==", "bodyText": "can be final\nshould be private with a getter returning an unmodifiable set if necessary", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572439", "createdAt": "2020-03-23T16:12:51Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    Set<List<String>> islandsNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjU5OA==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572598", "createdAt": "2020-03-23T16:13:02Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    Set<IslandEnd> islandsEndsNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3Mjg0OQ==", "bodyText": "Same remarks", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572849", "createdAt": "2020-03-23T16:13:22Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    Set<IslandEnd> islandsEndsNodes;\n+\n+    // The island includes dcTopologicalNodes and first acTopologicalNode\n+    IslandsEnds() {\n+        islandsEndsNodes = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, List<String> islandNodes) {\n+        if (islandNodes.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        String topologicalNodeEnd1 = islandNodes.get(0);\n+        List<String> adjacentTopologicalNodeEnd1 = computeAdjacentTopologicalNodes(topologicalNodeEnd1,\n+            adjacency, visitedTopologicalNodes);\n+\n+        String topologicalNodeEnd2 = getTopologicalNodeOtherEnd(islandNodes, visitedTopologicalNodes);\n+        if (topologicalNodeEnd2 == null) {\n+            return;\n+        }\n+        List<String> adjacentTopologicalNodeEnd2 = computeAdjacentTopologicalNodes(topologicalNodeEnd2,\n+            adjacency, visitedTopologicalNodes);\n+\n+        IslandEnd islandEnd = new IslandEnd(adjacentTopologicalNodeEnd1, adjacentTopologicalNodeEnd2);\n+\n+        islandsEndsNodes.add(islandEnd);\n+    }\n+\n+    private static String getTopologicalNodeOtherEnd(List<String> islandNodes, Set<String> visitedTopologicalNodes) {\n+        return islandNodes.stream()\n+            .filter(n -> !visitedTopologicalNodes.contains(n))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (Adjacency.isDcLineSegment(adjacent.type)) {\n+                        return;\n+                    }\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandsEnds\");\n+        islandsEndsNodes.forEach(islandEnd -> islandEnd.print());\n+    }\n+\n+    static class IslandEnd {\n+        List<String> topologicalNodes1;\n+        List<String> topologicalNodes2;\n+\n+        IslandEnd(List<String> topologicalNodes1, List<String> topologicalNodes2) {\n+            this.topologicalNodes1 = topologicalNodes1;\n+            this.topologicalNodes2 = topologicalNodes2;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MzEzMw==", "bodyText": "Use Objects.requireNonNull()", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396573133", "createdAt": "2020-03-23T16:13:42Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1, double poleLossP2) {\n+        this.mode = mode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MzQ0OA==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396573448", "createdAt": "2020-03-23T16:14:04Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    Map<String, List<TPnodeEquipment>> nodeEquipments;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6d41ddb0fbe29cb9e63569a7f5866298ad60bcd", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/c6d41ddb0fbe29cb9e63569a7f5866298ad60bcd", "committedDate": "2020-03-24T12:38:44Z", "message": "Apply reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "committedDate": "2020-03-24T12:38:56Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMjYwMjQ3", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-380260247", "createdAt": "2020-03-24T12:28:32Z", "commit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjoyODozMlrOF6t8KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjo1OTowN1rOF6vBfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNDQwOA==", "bodyText": "This modification is strange... You import something without using it. I'm surprised it compiles", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397114408", "createdAt": "2020-03-24T12:28:32Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Context.java", "diffHunk": "@@ -16,6 +16,7 @@\n \n import com.powsybl.cgmes.conversion.Conversion.Config;\n import com.powsybl.cgmes.conversion.elements.ACLineSegmentConversion;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcMapping;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNjEyNA==", "bodyText": "Should we change the lossFactor to a double?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397116124", "createdAt": "2020-03-24T12:31:48Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -59,10 +63,10 @@ public void convert() {\n                 reactivePowerSetpoint = -p.asDouble(\"targetQpcc\");\n             }\n             VscConverterStationAdder adder = voltageLevel().newVscConverterStation()\n-                    .setLossFactor(0.0f) // this attribute will be updated when the HVDC line attached to this station is imported\n-                    .setVoltageRegulatorOn(voltageRegulatorOn)\n-                    .setVoltageSetpoint(voltageSetpoint)\n-                    .setReactivePowerSetpoint(reactivePowerSetpoint);\n+                .setLossFactor((float) this.lossFactor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNzkyNA==", "bodyText": "You should throw an exception in the other cases?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397117924", "createdAt": "2020-03-24T12:34:56Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODgyOQ==", "bodyText": "Maybe you should change the signature of addTransformerAdajacency to pass a table: addTransformerAdjacency(t1.topologicalNode(), t2.topologicalNode());", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397118829", "createdAt": "2020-03-24T12:36:33Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTQ1OA=="}, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExOTg5MQ==", "bodyText": "Are you sure about the log level. In the CGMES converter there are a lot of informations printed, and it's hard to find an interesting information. If these logs are for debug, change the log level to debug.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397119891", "createdAt": "2020-03-24T12:38:30Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.info(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(ad -> ad.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));\n+    }\n+\n+    private void print(String node) {\n+        LOG.info(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.info(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }\n+\n+    static class Adjacent {\n+        AdjacentType type;\n+        String topologicalNode;\n+\n+        Adjacent(AdjacentType type, String topologicalNode) {\n+            this.type = type;\n+            this.topologicalNode = topologicalNode;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    {}  {}\", this.type, this.topologicalNode);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Adjacency.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMDI4MA==", "bodyText": "This is a bit uggly: why don't you add an isEmpty method to the Adjacency class?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397120280", "createdAt": "2020-03-24T12:39:10Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMDc4Mg==", "bodyText": "Then change the log level to debug", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397120782", "createdAt": "2020-03-24T12:40:07Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1Nzg3Nw=="}, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMTY4Mw==", "bodyText": "Is it allowed by the format? Depending on your answer, throw an exception or log a message (warn?)", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397121683", "createdAt": "2020-03-24T12:41:44Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.islandsEndsNodes.forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.topologicalNodes1);\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.topologicalNodes2);\n+\n+            if (config.isHvdcConversionLogOn()) {\n+                adjacency.print(ien.topologicalNodes1);\n+                tpNodeEquipments.print(ien.topologicalNodes1);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes1);\n+\n+                adjacency.print(ien.topologicalNodes2);\n+                tpNodeEquipments.print(ien.topologicalNodes2);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes2);\n+\n+                islandEndHvdc1.print();\n+                islandEndHvdc2.print();\n+            }\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            hvdc.print();\n+        }\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.hvdcData.forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId1, String dcLineSegmentId2) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId1);\n+        if (!ok) {\n+            return;\n+        }\n+        PropertyBag dcLineSegment2 = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId2);\n+        if (dcLineSegment2 == null) {\n+            return;\n+        }\n+        this.r = 1.0 / (1.0 / computeR(this.dcLineSegment) + 1.0 / computeR(dcLineSegment2));\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+            context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId2);\n+        }\n+    }\n+\n+    private void setCommonDataUsed() {\n+        context.dc().setCgmesConverterUsed(converter1Id);\n+        context.dc().setCgmesConverterUsed(converter2Id);\n+        context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId);\n+    }\n+\n+    private boolean convertCommonData(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        this.converter1Id = acDcConverterIdEnd1;\n+        this.cconverter1 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd1);\n+        this.converter2Id = acDcConverterIdEnd2;\n+        this.cconverter2 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd2);\n+        this.dcLineSegmentId = dcLineSegmentId;\n+        this.dcLineSegment = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId);\n+        if (this.cconverter1 == null || this.cconverter2 == null || this.dcLineSegment == null) {\n+            return false;\n+        }\n+        this.converterType = decodeType(this.cconverter1.getLocal(TYPE));\n+        if (this.converterType == null || converterType != decodeType(this.cconverter2.getLocal(TYPE))) {\n+            return false;\n+        }\n+        this.operatingMode = decodeMode(this.converterType, this.cconverter1, this.cconverter2);\n+        this.ratedUdc = computeRatedUdc(this.cconverter1, this.cconverter2);\n+\n+        return true;\n+    }\n+\n+    private static HvdcType decodeType(String stype) {\n+        if (stype.equals(\"VsConverter\")) {\n+            return HvdcType.VSC;\n+        } else if (stype.equals(\"CsConverter\")) {\n+            return HvdcType.LCC;\n+        }\n+        return null;\n+    }\n+\n+    private static HvdcLine.ConvertersMode decodeMode(HvdcType converterType, PropertyBag cconverter1, PropertyBag cconverter2) {\n+        String mode1 = cconverter1.getLocal(OPERATING_MODE);\n+        String mode2 = cconverter2.getLocal(OPERATING_MODE);\n+\n+        if (converterType.equals(HvdcConverterStation.HvdcType.LCC)) {\n+            if (inverter(mode1) && rectifier(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            } else if (rectifier(mode1) && inverter(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER;\n+            } else {\n+                // Default if both ends are rectifier or inverter\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDIyMQ==", "bodyText": "You should extract this constant. Where does this constant come from?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397124221", "createdAt": "2020-03-24T12:45:50Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;\n+    }\n+\n+    @Override\n+    public boolean valid() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void convert() {\n+\n+        // arbitrary value because there is no maxP attribute in CGMES\n+        double maxP = getMaxP(converter1.pAC, converter2.pAC, mode);\n+        missing(\"maxP\", maxP);\n+\n+        HvdcLineAdder adder = context.network().newHvdcLine()\n+            .setR(r)\n+            .setNominalV(ratedUdc)\n+            .setActivePowerSetpoint(\n+                getPDc(converter1.pAC, converter2.pAC, converter1.poleLossP, converter2.poleLossP, mode))\n+            .setMaxP(maxP)\n+            .setConvertersMode(mode)\n+            .setConverterStationId1(converter1.converterId)\n+            .setConverterStationId2(converter2.converterId);\n+        identify(adder);\n+        adder.add();\n+    }\n+\n+    private static double getMaxP(double pAC1, double pAC2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) {\n+            if (pAC1 != 0) {\n+                return 1.2 * pAC1;\n+            }\n+            return 1.2 * pAC2;\n+        }\n+        if (pAC2 != 0) {\n+            return 1.2 * pAC2;\n+        }\n+        return 1.2 * pAC1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDM1NQ==", "bodyText": "Assert for non null values when relevant", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397124355", "createdAt": "2020-03-24T12:46:04Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNTE0Mg==", "bodyText": "Same remark about log level", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397125142", "createdAt": "2020-03-24T12:47:27Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_NONE:\n+                break;\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(ls -> hvdcEq.add(ls));\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    void print() {\n+        LOG.info(\"Hvdc\");\n+        hvdcData.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEquipment {\n+        List<HvdcConverter> converters;\n+        List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void print() {\n+            LOG.info(\"    Converters:\");\n+            this.converters.forEach(c -> c.print());\n+            LOG.info(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.info(\"    {} \", ls));\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    static class HvdcConverter {\n+        String acDcConvertersEnd1;\n+        String acDcConvertersEnd2;\n+\n+        HvdcConverter(String acDcConvertersEnd1, String acDcConvertersEnd2) {\n+            this.acDcConvertersEnd1 = acDcConvertersEnd1;\n+            this.acDcConvertersEnd2 = acDcConvertersEnd2;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    End1: {} End2: {}\", this.acDcConvertersEnd1, this.acDcConvertersEnd2);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Hvdc.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNjg2NA==", "bodyText": "Are your sure about the i in simetric (I expect a y)?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397126864", "createdAt": "2020-03-24T12:50:28Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzIzNA==", "bodyText": "Same remark about log level", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397127234", "createdAt": "2020-03-24T12:51:07Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(ls -> hvdcEnd2.dcLineSegmentsEnd.contains(ls));\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandEndHvdc\");\n+        hvdc.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEnd {\n+        List<String> topologicalNodesEnd;\n+        Set<String> transformersEnd;\n+        Set<String> acDcConvertersEnd;\n+        Set<String> dcLineSegmentsEnd;\n+\n+        HvdcEnd(List<String> topologicalNodesEnd, Set<String> transformersEnd, Set<String> acDcConvertersEnd, Set<String> dcLineSegmentsEnd) {\n+            this.topologicalNodesEnd = topologicalNodesEnd;\n+            this.transformersEnd = transformersEnd;\n+            this.acDcConvertersEnd = acDcConvertersEnd;\n+            this.dcLineSegmentsEnd = dcLineSegmentsEnd;\n+        }\n+\n+        HvdcEndType computeType() {\n+            int t = this.transformersEnd.size();\n+            int c = this.acDcConvertersEnd.size();\n+            int ls = this.dcLineSegmentsEnd.size();\n+\n+            if (t == 0 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T0_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T1_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 2) {\n+                return HvdcEndType.HVDC_T1_C1_LS2;\n+            } else if (t == 2 && c == 2 && ls == 1) {\n+                return HvdcEndType.HVDC_T2_C2_LS1;\n+            } else if (t == c && c == ls && t > 1) {\n+                return HvdcEndType.HVDC_TN_CN_LSN;\n+            }\n+            return HvdcEndType.HVDC_NONE;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    topologicalNodesEnd: {}\", this.topologicalNodesEnd);\n+            LOG.info(\"    transformersEnd: {}\", this.transformersEnd);\n+            LOG.info(\"    acDcConvertersEnd: {}\", this.acDcConvertersEnd);\n+            LOG.info(\"    dcLineSegmentsEnd: {}\", this.dcLineSegmentsEnd);\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(IslandEndHvdc.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzc2MQ==", "bodyText": "Are you sure this is working properly? How is computed the hash on a List of String?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397127761", "createdAt": "2020-03-24T12:52:00Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final Set<List<String>> islandsNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODA3Ng==", "bodyText": "Is there a design issue with Adjacency class?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397128076", "createdAt": "2020-03-24T12:52:33Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final Set<List<String>> islandsNodes;\n+\n+    // The island includes dcTopologicalNodes and the acTopologicalNodes at both ends of the transformer\n+    Islands(Adjacency adjacency) {\n+        islandsNodes = new HashSet<>();\n+\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+        adjacency.adjacency.keySet().forEach(topologicalNodeId -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODM2Mg==", "bodyText": "Same remark about the log level", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397128362", "createdAt": "2020-03-24T12:53:00Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final Set<List<String>> islandsNodes;\n+\n+    // The island includes dcTopologicalNodes and the acTopologicalNodes at both ends of the transformer\n+    Islands(Adjacency adjacency) {\n+        islandsNodes = new HashSet<>();\n+\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+        adjacency.adjacency.keySet().forEach(topologicalNodeId -> {\n+            if (visitedTopologicalNodes.contains(topologicalNodeId)) {\n+                return;\n+            }\n+            List<String> adjacentTopologicalNodes = computeAdjacentTopologicalNodes(topologicalNodeId,\n+                adjacency, visitedTopologicalNodes);\n+            islandsNodes.add(adjacentTopologicalNodes);\n+        });\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    Set<List<String>> getIslandsNodes() {\n+        return islandsNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Islands\");\n+        islandsNodes.forEach(island -> LOG.info(\" {} \", island));\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Islands.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODc5NA==", "bodyText": "Same remark about log level", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397128794", "createdAt": "2020-03-24T12:53:42Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    private final Set<IslandEnd> islandsEndsNodes;\n+\n+    // The island includes dcTopologicalNodes and first acTopologicalNode\n+    IslandsEnds() {\n+        islandsEndsNodes = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, List<String> islandNodes) {\n+        if (islandNodes.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        String topologicalNodeEnd1 = islandNodes.get(0);\n+        List<String> adjacentTopologicalNodeEnd1 = computeAdjacentTopologicalNodes(topologicalNodeEnd1,\n+            adjacency, visitedTopologicalNodes);\n+\n+        String topologicalNodeEnd2 = getTopologicalNodeOtherEnd(islandNodes, visitedTopologicalNodes);\n+        if (topologicalNodeEnd2 == null) {\n+            return;\n+        }\n+        List<String> adjacentTopologicalNodeEnd2 = computeAdjacentTopologicalNodes(topologicalNodeEnd2,\n+            adjacency, visitedTopologicalNodes);\n+\n+        IslandEnd islandEnd = new IslandEnd(adjacentTopologicalNodeEnd1, adjacentTopologicalNodeEnd2);\n+\n+        islandsEndsNodes.add(islandEnd);\n+    }\n+\n+    private static String getTopologicalNodeOtherEnd(List<String> islandNodes, Set<String> visitedTopologicalNodes) {\n+        return islandNodes.stream()\n+            .filter(n -> !visitedTopologicalNodes.contains(n))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (Adjacency.isDcLineSegment(adjacent.type)) {\n+                        return;\n+                    }\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    Set<IslandEnd> getIslandsEndsNodes() {\n+        return islandsEndsNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandsEnds\");\n+        islandsEndsNodes.forEach(islandEnd -> islandEnd.print());\n+    }\n+\n+    static class IslandEnd {\n+        private final List<String> topologicalNodes1;\n+        private final List<String> topologicalNodes2;\n+\n+        IslandEnd(List<String> topologicalNodes1, List<String> topologicalNodes2) {\n+            this.topologicalNodes1 = topologicalNodes1;\n+            this.topologicalNodes2 = topologicalNodes2;\n+        }\n+\n+        List<String> getTopologicalNodes1() {\n+            return topologicalNodes1;\n+        }\n+\n+        List<String> getTopologicalNodes2() {\n+            return topologicalNodes2;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    topologicalNodes1: {}\", this.topologicalNodes1);\n+            LOG.info(\"    topologicalNodes2: {}\", this.topologicalNodes2);\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(IslandsEnds.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTk1Nw==", "bodyText": "Same remark about log level", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397129957", "createdAt": "2020-03-24T12:55:36Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    private final Map<String, List<TPnodeEquipment>> nodeEquipments;\n+\n+    TPnodeEquipments(CgmesModel cgmesModel, Adjacency adjacency) {\n+        nodeEquipments = new HashMap<>();\n+\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegment(cgmesModel, adjacency, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+\n+        acDcConverterNodes.getConverterNodes().entrySet()\n+            .forEach(entry -> addEquipment(adjacency, entry.getValue().id, entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode, EquipmentType.AC_DC_CONVERTER));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformer(cgmesModel, adjacency, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformer(cgmesModel, adjacency, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegment(CgmesModel cgmesModel, Adjacency adjacency, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+        String id = equipment.getId(\"DCLineSegment\");\n+        addEquipment(adjacency, id, t1.dcTopologicalNode(), t2.dcTopologicalNode(), EquipmentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeTwoWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void computeThreeWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String topologicalNodeId1, String topologicalNodeId2,\n+        EquipmentType type) {\n+        if (!adjacency.adjacency.containsKey(topologicalNodeId1)\n+            || !adjacency.adjacency.containsKey(topologicalNodeId2)) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(eq);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(eq);\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String acTopologicalNodeId,\n+        List<String> dcTopologicalNodeIds, EquipmentType type) {\n+        if (!adjacency.adjacency.containsKey(acTopologicalNodeId)) {\n+            return;\n+        }\n+        if (dcTopologicalNodeIds.stream().anyMatch(n -> !adjacency.adjacency.containsKey(n))) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(acTopologicalNodeId, k -> new ArrayList<>()).add(eq);\n+        dcTopologicalNodeIds.forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    private boolean isValidTransformer(Adjacency adjacency, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(n -> adjacency.containsAcDcConverter(n));\n+    }\n+\n+    private void addTransformer(Adjacency adjacency, String id, List<String> topologicalNodes, EquipmentType type) {\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        topologicalNodes.stream()\n+            .filter(n -> adjacency.adjacency.containsKey(n))\n+            .forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    boolean containsAnyTransformer(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.TRANSFORMER);\n+    }\n+\n+    boolean containsAnyAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.AC_DC_CONVERTER);\n+    }\n+\n+    boolean multiAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.type == EquipmentType.AC_DC_CONVERTER)\n+            .count() >= 2;\n+    }\n+\n+    boolean connectedEquipments(String equipment1, String equipment2, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(n -> connectedEquipment(n, equipment1, equipment2));\n+    }\n+\n+    private boolean connectedEquipment(String topologicalNode, String equipment1, String equipment2) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.equipmentId.equals(equipment1) || eq.equipmentId.equals(equipment2))\n+            .count() == 2;\n+    }\n+\n+    Map<String, List<TPnodeEquipment>> getNodeEquipments() {\n+        return nodeEquipments;\n+    }\n+\n+    void print() {\n+        LOG.info(\"TPnodeEquipments\");\n+        nodeEquipments.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String tpNodeId, List<TPnodeEquipment> listTPnodeEquipment) {\n+        LOG.info(\"TopologicalNodeId: {}\", tpNodeId);\n+        listTPnodeEquipment.forEach(tpne -> tpne.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));\n+    }\n+\n+    private void print(String node) {\n+        LOG.info(\"EQ. TopologicalNode {}\", node);\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node)\n+                .forEach(eq -> LOG.info(\"    {} {}\", eq.type, eq.equipmentId));\n+        }\n+    }\n+\n+    void printDcLs(List<String> lnodes) {\n+        lnodes.forEach(n -> printDcLs(n));\n+    }\n+\n+    private void printDcLs(String node) {\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node).stream()\n+                .filter(eq -> eq.type == TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT)\n+                .forEach(eq -> LOG.info(\"DcLineSegment {}\", eq.equipmentId));\n+        }\n+    }\n+\n+    static class TPnodeEquipment {\n+        EquipmentType type;\n+        String equipmentId;\n+\n+        TPnodeEquipment(EquipmentType type, String equipmentId) {\n+            this.type = type;\n+            this.equipmentId = equipmentId;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    {} {}\", this.type, this.equipmentId);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TPnodeEquipments.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMDU5MA==", "bodyText": "Why don't you assert directly the return value of the containsHvdcLine method, instead of storing the value in a variable?\nThis remark is global to this file.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397130590", "createdAt": "2020-03-24T12:56:36Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/HvdcConversionTest.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1Catalog;\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1ModifiedCatalog;\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesModelFactory;\n+import com.powsybl.cgmes.model.test.TestGridModel;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.VscConverterStation;\n+import com.powsybl.triplestore.api.TripleStoreFactory;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class HvdcConversionTest {\n+\n+    @Test\n+    public void smallNodeBreakerHvdc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMTAwMg==", "bodyText": "Replace by assertEquals.\nThis remark is global to this file.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397131002", "createdAt": "2020-03-24T12:57:17Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/HvdcConversionTest.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1Catalog;\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1ModifiedCatalog;\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesModelFactory;\n+import com.powsybl.cgmes.model.test.TestGridModel;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.VscConverterStation;\n+import com.powsybl.triplestore.api.TripleStoreFactory;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class HvdcConversionTest {\n+\n+    @Test\n+    public void smallNodeBreakerHvdc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMjE1OQ==", "bodyText": "Are you sure about the log level? not a debug? not a trace?\nThis remark is global to this file", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397132159", "createdAt": "2020-03-24T12:59:07Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/HvdcConversionTest.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1Catalog;\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1ModifiedCatalog;\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesModelFactory;\n+import com.powsybl.cgmes.model.test.TestGridModel;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.VscConverterStation;\n+import com.powsybl.triplestore.api.TripleStoreFactory;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class HvdcConversionTest {\n+\n+    @Test\n+    public void smallNodeBreakerHvdc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1inverter2rectifier() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1inverter2rectifier(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.49261084, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.49019608, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 101.50980392156863, 122.39999999999999);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1rectifier2inverter() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1rectifier2inverter(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.5, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.5025126, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 99.5, 120.0);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcDcLine2Inverter1Rectifier2() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcDcLine2Inverter1Rectifier2(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.49751243, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.4950495, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, -99.50248756218906, -120.0);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcVscReactiveQPcc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcVscReactiveQPcc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 0.0, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 0.0, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcMissingDCLineSegment() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcMissingDCLineSegment(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 0);\n+        assertTrue(n.getHvdcLineCount() == 0);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcMissingAcDcConverters() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcMissingAcDcConverters(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 0);\n+        assertTrue(n.getHvdcLineCount() == 0);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcNanTargetPpcc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcNanTargetPpcc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 0.0, 0.0);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.0, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.0, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 0.0, 0.0);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcTwoDcLineSegments() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcTwoDcLineSegments(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 5.60575, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcLogOn() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        config.setHvdcConversionLogOn(true);\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcTwoAcDcConvertersOneDcLineSegments() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        config.setHvdcConversionLogOn(true);\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcTwoAcDcConvertersOneDcLineSegments(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 6);\n+        assertTrue(n.getHvdcLineCount() == 3);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_7393a68f-c4e6-48dd-9347-543858363fdb\", \"Conv1b\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0#0\", 0.0, 0.8);\n+        assertTrue(ok);\n+\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118e-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2b\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0#0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0#0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68f-c4e6-48dd-9347-543858363fdb\", \"_9793118e-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    private Network networkModel(TestGridModel testGridModel, Conversion.Config config) throws IOException {\n+\n+        ReadOnlyDataSource ds = testGridModel.dataSource();\n+        String impl = TripleStoreFactory.defaultImplementation();\n+\n+        CgmesModel cgmes = CgmesModelFactory.create(ds, impl);\n+\n+        config.setConvertSvInjections(true);\n+        config.setProfileUsedForInitialStateValues(Conversion.Config.StateProfile.SSH.name());\n+        Conversion c = new Conversion(cgmes, config);\n+        Network n = c.convert();\n+\n+        return n;\n+    }\n+\n+    private boolean containsLccConverter(Network n, String id, String name,\n+        String hvdcLineId, double lossFactor, double powerFactor) {\n+        ReferenceHvdcConverter referenceHvdcConverter = new ReferenceHvdcConverter(id, HvdcConverterStation.HvdcType.LCC, name,\n+            hvdcLineId, lossFactor, powerFactor);\n+        return containsLccConverter(n, referenceHvdcConverter);\n+    }\n+\n+    private boolean containsLccConverter(Network n, ReferenceHvdcConverter referenceConverter) {\n+        LccConverterStation lccConverter = n.getLccConverterStation(referenceConverter.id);\n+        if (lccConverter == null) {\n+            LOG.info(\"HvdcConverterStation {} not found\", referenceConverter.id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4"}, "originalPosition": 326}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f82f0bd257897fefd9bd9acdbf710eaf00a11210", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/f82f0bd257897fefd9bd9acdbf710eaf00a11210", "committedDate": "2020-03-24T15:49:59Z", "message": "More reviewer comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccec8956e8bd4629539eae200128584187374e8b", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/ccec8956e8bd4629539eae200128584187374e8b", "committedDate": "2020-03-24T15:50:27Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65e0b7fbb154ed2db0b5df46726f11ea2a627d01", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/65e0b7fbb154ed2db0b5df46726f11ea2a627d01", "committedDate": "2020-03-26T11:48:29Z", "message": "Apply more reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "791f4dbe746fdb3a87537e39c06a26ec945f75ff", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/791f4dbe746fdb3a87537e39c06a26ec945f75ff", "committedDate": "2020-03-26T16:55:59Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4533d5e86d608260637946a662e48b291737a8e1", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/4533d5e86d608260637946a662e48b291737a8e1", "committedDate": "2020-03-26T17:07:33Z", "message": "fix checkstyle\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "author": {"user": {"login": "annetill", "name": "Anne Tilloy"}}, "url": "https://github.com/powsybl/powsybl-core/commit/3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "committedDate": "2020-03-27T11:56:18Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc3MDgy", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-382977082", "createdAt": "2020-03-27T15:44:30Z", "commit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo0NDozMFrOF829YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo0NDozMFrOF829YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1OTMyOA==", "bodyText": "What happens if only one is not NaN? Should we drop its result in any case?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r399359328", "createdAt": "2020-03-27T15:44:30Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1, double poleLossP2) {\n+        Objects.requireNonNull(mode);\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2(double pAC2, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // pAC2 > 0\n+            this.lossFactor2 = (poleLossP2 / pAC2) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && Math.abs(pAC2) + poleLossP2 != 0) { // pAC2 < 0\n+            this.lossFactor2 = (poleLossP2 / (Math.abs(pAC2) + poleLossP2)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor1FromPAC2(double pAC2, double poleLossP1, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && (Math.abs(pAC2) + poleLossP2 + poleLossP1) != 0) { // pAC2 < 0\n+            // lossFactor1 = poleLossP1 / pAC1 * 100\n+            // pAC1 = pDC + poleLossP1 = pAC2 + poleLossP2 + poleLossP1\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC2) + poleLossP2 + poleLossP1)) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && (pAC2 - poleLossP2) != 0) { // pAC2 > 0\n+            // lossFactor1 = poleLossP1 / pDC * 100\n+            // pDC = pAC2 - poleLossP2\n+            this.lossFactor1 = (poleLossP1 / (pAC2 - poleLossP2)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2FromPAC1(double pAC1, double poleLossP1, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && (pAC1 - poleLossP1) != 0) { // pAC1 > 0\n+            // lossFactor2 = poleLossP2 / pDC * 100\n+            // pDC = pAC1 - poleLossP1\n+            this.lossFactor2 = (poleLossP2 / (pAC1 - poleLossP1)) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && (Math.abs(pAC1) + poleLossP1 + poleLossP2) != 0) { // pAC1 < 0\n+            // lossFactor2 = poleLossP2 / (pDC + poleLossP2) * 100\n+            // pDC = pAC1 + poleLossP1\n+            this.lossFactor2 = (poleLossP2 / (Math.abs(pAC1) + poleLossP1 + poleLossP2)) * 100;\n+        }\n+    }\n+\n+    boolean isOk() {\n+        return !Double.isNaN(this.lossFactor1) && !Double.isNaN(this.lossFactor2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNTcyMTAz", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-383572103", "createdAt": "2020-03-30T06:54:28Z", "commit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NDoyOFrOF9bzlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1NDoyOFrOF9bzlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAzMQ==", "bodyText": "Hi Jos\u00e9 Antonio, I have performed some tests on small grid case (with HVDC lines) and it seems that the attributes of the LCC converters are nor correctly set. I understand that the power factor is at its default value. It seems that the loss factor is equal too zero in IIDM in my tests, but the poleLoss in CGMES is not equal to zero. Can you check again ?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r399963031", "createdAt": "2020-03-30T06:54:28Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -71,16 +79,21 @@ public void convert() {\n             // TODO: There are two modes of control: dcVoltage and activePower\n             // For dcVoltage, setpoint is targetUdc,\n             // For activePower, setpoint is targetPpcc\n+\n             LccConverterStationAdder adder = voltageLevel().newLccConverterStation()\n-                    .setLossFactor(0.0f)\n-                    .setPowerFactor(0.8f);\n+                .setLossFactor((float) this.lossFactor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDQzNjk5", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-386443699", "createdAt": "2020-04-02T13:49:02Z", "commit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDY3NzIy", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-387067722", "createdAt": "2020-04-03T08:45:49Z", "commit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0OTozMlrOGAL7kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1MDoyNlrOGAL-3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0ODY1Ng==", "bodyText": "@MioRtia can you put your name here as authors ?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r402848656", "createdAt": "2020-04-03T08:49:32Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0OTUwMw==", "bodyText": "@MioRtia can you add your name here as authors too ?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r402849503", "createdAt": "2020-04-03T08:50:26Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d261466ac7e3129ad2f01dc4b932ee1cbb222428", "author": {"user": {"login": "zamarrenolm", "name": "Luma"}}, "url": "https://github.com/powsybl/powsybl-core/commit/d261466ac7e3129ad2f01dc4b932ee1cbb222428", "committedDate": "2020-04-03T18:23:16Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTUxMjk3", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-387951297", "createdAt": "2020-04-06T05:59:37Z", "commit": {"oid": "d261466ac7e3129ad2f01dc4b932ee1cbb222428"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNTo1OTozN1rOGBIyyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNTo1OTozN1rOGBIyyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NTgzMw==", "bodyText": "@geofjamg and @mathbagu I think that MaxP should be always positive too as the active power set point ? It is not the case here. so we maybe have to fix the computation.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r403845833", "createdAt": "2020-04-06T05:59:37Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    private static final double DEFAULT_MAXP_FACTOR = 1.2;\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        Objects.requireNonNull(converter1);\n+        Objects.requireNonNull(converter2);\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;\n+    }\n+\n+    @Override\n+    public boolean valid() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void convert() {\n+\n+        // arbitrary value because there is no maxP attribute in CGMES\n+        double maxP = getMaxP(converter1.pAC, converter2.pAC, mode);\n+        missing(\"maxP\", maxP);\n+\n+        HvdcLineAdder adder = context.network().newHvdcLine()\n+            .setR(r)\n+            .setNominalV(ratedUdc)\n+            .setActivePowerSetpoint(\n+                getPDc(converter1.pAC, converter2.pAC, converter1.poleLossP, converter2.poleLossP, mode))\n+            .setMaxP(maxP)\n+            .setConvertersMode(mode)\n+            .setConverterStationId1(converter1.converterId)\n+            .setConverterStationId2(converter2.converterId);\n+        identify(adder);\n+        adder.add();\n+    }\n+\n+    private static double getMaxP(double pAC1, double pAC2, HvdcLine.ConvertersMode mode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d261466ac7e3129ad2f01dc4b932ee1cbb222428"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTUyNzI1", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-387952725", "createdAt": "2020-04-06T06:03:54Z", "commit": {"oid": "d261466ac7e3129ad2f01dc4b932ee1cbb222428"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjowMzo1NFrOGBI3hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjowMzo1NFrOGBI3hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NzA0Ng==", "bodyText": "Here have to fix the case SIDE_1_INVERTER_SIDE_2_RECTIFIER (pAC1 negative and PAC2 positive) so:\n\nreturn pAC2 - poleLossP2 ;\nreturn Math.abs(pAC1) + poleLossP1 ;\nWe in fact made the mistake before this PR...", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r403847046", "createdAt": "2020-04-06T06:03:54Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    private static final double DEFAULT_MAXP_FACTOR = 1.2;\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        Objects.requireNonNull(converter1);\n+        Objects.requireNonNull(converter2);\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;\n+    }\n+\n+    @Override\n+    public boolean valid() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void convert() {\n+\n+        // arbitrary value because there is no maxP attribute in CGMES\n+        double maxP = getMaxP(converter1.pAC, converter2.pAC, mode);\n+        missing(\"maxP\", maxP);\n+\n+        HvdcLineAdder adder = context.network().newHvdcLine()\n+            .setR(r)\n+            .setNominalV(ratedUdc)\n+            .setActivePowerSetpoint(\n+                getPDc(converter1.pAC, converter2.pAC, converter1.poleLossP, converter2.poleLossP, mode))\n+            .setMaxP(maxP)\n+            .setConvertersMode(mode)\n+            .setConverterStationId1(converter1.converterId)\n+            .setConverterStationId2(converter2.converterId);\n+        identify(adder);\n+        adder.add();\n+    }\n+\n+    private static double getMaxP(double pAC1, double pAC2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) {\n+            if (pAC1 != 0) {\n+                return DEFAULT_MAXP_FACTOR * pAC1;\n+            }\n+            return DEFAULT_MAXP_FACTOR * pAC2;\n+        }\n+        if (pAC2 != 0) {\n+            return DEFAULT_MAXP_FACTOR * pAC2;\n+        }\n+        return DEFAULT_MAXP_FACTOR * pAC1;\n+    }\n+\n+    private static double getPDc(double pAC1, double pAC2, double poleLossP1, double poleLossP2,\n+        HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) {\n+            if (pAC1 != 0) {\n+                return pAC1 - poleLossP1;\n+            } else if (pAC2 != 0) {\n+                return Math.abs(pAC2) + poleLossP2;\n+            }\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d261466ac7e3129ad2f01dc4b932ee1cbb222428"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c48fc9e1126d52ada8d719a05d5413524ed0c70", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/8c48fc9e1126d52ada8d719a05d5413524ed0c70", "committedDate": "2020-04-06T15:13:58Z", "message": "Change Log to debug\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e1f02bc9fd96d3e913a3e0fe75650ecfefc1c68", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/5e1f02bc9fd96d3e913a3e0fe75650ecfefc1c68", "committedDate": "2020-04-06T15:14:33Z", "message": "Merge branch 'cgmes_conversion_HVDC' of https://github.com/powsybl/powsybl-core into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/41602d6c75414f4f884d1d8297214218e85d59e7", "committedDate": "2020-04-06T22:21:42Z", "message": "Active power and maxP always positive.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODQ1MDEw", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-388845010", "createdAt": "2020-04-07T07:19:00Z", "commit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoxOTowMFrOGB2Gkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoxOTowMFrOGB2Gkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODE3OA==", "bodyText": "You have to remove the multiplying by 100.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588178", "createdAt": "2020-04-07T07:19:00Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODQ1NjE4", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-388845618", "createdAt": "2020-04-07T07:19:56Z", "commit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoxOTo1NlrOGB2IlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoxOTo1NlrOGB2IlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODY5Mg==", "bodyText": "You have to remove the multiplying by 100. We made a mistake before because the documentation is wrong. LossFactor is a ratio.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588692", "createdAt": "2020-04-07T07:19:56Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODQ1Nzkz", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-388845793", "createdAt": "2020-04-07T07:20:12Z", "commit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoyMDoxM1rOGB2JHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoyMDoxM1rOGB2JHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODgzMQ==", "bodyText": "Same remark.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588831", "createdAt": "2020-04-07T07:20:13Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2(double pAC2, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // pAC2 > 0\n+            this.lossFactor2 = (poleLossP2 / pAC2) * 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODQ1OTQx", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-388845941", "createdAt": "2020-04-07T07:20:27Z", "commit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoyMDoyN1rOGB2Jkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoyMDoyN1rOGB2Jkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODk0Ng==", "bodyText": "Same remark.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588946", "createdAt": "2020-04-07T07:20:27Z", "author": {"login": "annetill"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2(double pAC2, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // pAC2 > 0\n+            this.lossFactor2 = (poleLossP2 / pAC2) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && Math.abs(pAC2) + poleLossP2 != 0) { // pAC2 < 0\n+            this.lossFactor2 = (poleLossP2 / (Math.abs(pAC2) + poleLossP2)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor1FromPAC2(double pAC2, double poleLossP1, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && (Math.abs(pAC2) + poleLossP2 + poleLossP1) != 0) { // pAC2 < 0\n+            // lossFactor1 = poleLossP1 / pAC1 * 100", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a79e8ae46227cd8019579bdb58042c013ae0bc60", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/a79e8ae46227cd8019579bdb58042c013ae0bc60", "committedDate": "2020-04-07T11:22:59Z", "message": "LossFactor in the closed interval [0,1]. Fix flipflop between lossFactor and poleLoss.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a4824e099200b2c0b6798d7bf553c07879f7de2", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/6a4824e099200b2c0b6798d7bf553c07879f7de2", "committedDate": "2020-04-07T11:37:00Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/DcLineSegmentConversion.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "763e0ee7668f02cc0de8d93bc282ec7e82ecd854", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/763e0ee7668f02cc0de8d93bc282ec7e82ecd854", "committedDate": "2020-04-07T16:54:48Z", "message": "Fix code smell\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/a23322a7f7cac942277094313a3b74747d868b25", "committedDate": "2020-04-07T17:06:12Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzI0ODE5", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-389724819", "createdAt": "2020-04-08T07:41:30Z", "commit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5Nzg1NDkz", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-389785493", "createdAt": "2020-04-08T09:04:16Z", "commit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwOTowNDoxNlrOGCl3yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDoyNToxMFrOGCo6VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM3MDgyNg==", "bodyText": "Is this really INFO or DEBUG or TRACE?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405370826", "createdAt": "2020-04-08T09:04:16Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    Map<String, AcDcConverterNode> getConverterNodes() {\n+        return converterNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.forEach((key, value) -> LOG.info(\" {} {} {} {}\", key, value.id,\n+                value.acTopologicalNode, value.dcTopologicalNode));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NTIwNw==", "bodyText": "Since this constructor is public:\nthis.context = Objects.requireNonNull(context);", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405395207", "createdAt": "2020-04-08T09:42:28Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcMapping.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.*;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+public class DcMapping {\n+\n+    public DcMapping(Context context) {\n+        this.context = context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NjQ5Mg==", "bodyText": "maybe simply rename as used()? It is weird to have a set method without parameters.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405396492", "createdAt": "2020-04-08T09:44:28Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcMapping.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.*;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+public class DcMapping {\n+\n+    public DcMapping(Context context) {\n+        this.context = context;\n+        this.cgmesConverters = new HashMap<>();\n+        this.cgmesDcLineSegments = new HashMap<>();\n+    }\n+\n+    public void initialize() {\n+        context.cgmes().acDcConverters()\n+            .forEach(pb -> this.cgmesConverters.put(pb.getId(\"ACDCConverter\"), new CgmesConverter(pb)));\n+        context.cgmes().dcLineSegments()\n+            .forEach(pb -> this.cgmesDcLineSegments.put(pb.getId(\"DCLineSegment\"), new CgmesDcLineSegment(pb)));\n+    }\n+\n+    PropertyBag getCgmesConverterPropertyBag(String id) {\n+        CgmesConverter cgmesConverter = this.cgmesConverters.get(id);\n+        if (cgmesConverter != null) {\n+            return cgmesConverter.propertyBag;\n+        }\n+        return null;\n+    }\n+\n+    void setCgmesConverterUsed(String id) {\n+        CgmesConverter cgmesConverter = this.cgmesConverters.get(id);\n+        if (cgmesConverter != null) {\n+            cgmesConverter.setUsed();\n+        }\n+    }\n+\n+    void reportCgmesConvertersNotUsed() {\n+        this.cgmesConverters.entrySet().stream()\n+            .filter(c -> !c.getValue().used)\n+            .forEach(c -> {\n+                String what = String.format(\"AcDcConverter Id: %s\", c.getKey());\n+                context.ignored(what, \"Dc configuration not supported\");\n+            });\n+    }\n+\n+    PropertyBag getCgmesDcLineSegmentPropertyBag(String id) {\n+        CgmesDcLineSegment cgmesDcLineSegment = this.cgmesDcLineSegments.get(id);\n+        if (cgmesDcLineSegment != null) {\n+            return cgmesDcLineSegment.propertyBag;\n+        }\n+        return null;\n+    }\n+\n+    void setCgmesDcLineSegmentUsed(String id) {\n+        CgmesDcLineSegment cgmesDcLineSegment = this.cgmesDcLineSegments.get(id);\n+        if (cgmesDcLineSegment != null) {\n+            cgmesDcLineSegment.setUsed();\n+        }\n+    }\n+\n+    void reportCgmesDcLineSegmentNotUsed() {\n+        this.cgmesDcLineSegments.entrySet().stream()\n+            .filter(c -> !c.getValue().used)\n+            .forEach(c -> {\n+                String what = String.format(\"DcLineSegment Id: %s\", c.getKey());\n+                context.ignored(what, \"Ground DcLineSegment or Dc configuration not supported\");\n+            });\n+    }\n+\n+    private static class CgmesConverter {\n+        private PropertyBag propertyBag;\n+        private boolean used;\n+\n+        CgmesConverter(PropertyBag propertyBag) {\n+            this.propertyBag = propertyBag;\n+            this.used = false;\n+        }\n+\n+        void setUsed() {\n+            this.used = true;\n+        }\n+    }\n+\n+    private static class CgmesDcLineSegment {\n+        private PropertyBag propertyBag;\n+        private boolean used;\n+\n+        CgmesDcLineSegment(PropertyBag propertyBag) {\n+            this.propertyBag = propertyBag;\n+            this.used = false;\n+        }\n+\n+        void setUsed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxOTkyNw==", "bodyText": "You only use the values of entries here, can you just use getConverterNodes().values().forEach(...)?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405419927", "createdAt": "2020-04-08T10:23:55Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    private final Map<String, List<TPnodeEquipment>> nodeEquipments;\n+\n+    TPnodeEquipments(CgmesModel cgmesModel, Adjacency adjacency) {\n+        nodeEquipments = new HashMap<>();\n+\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegment(cgmesModel, adjacency, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+\n+        acDcConverterNodes.getConverterNodes().entrySet()\n+            .forEach(entry -> addEquipment(adjacency, entry.getValue().id, entry.getValue().acTopologicalNode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQyMDYyOA==", "bodyText": "More of a general remark but why is the test logback level at info?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405420628", "createdAt": "2020-04-08T10:25:10Z", "author": {"login": "MioRtia"}, "path": "cgmes/cgmes-conversion/src/test/resources/logback-test.xml", "diffHunk": "@@ -27,4 +27,12 @@\n         level=\"info\" />\n     <!-- To watch the properties of every object converted, level to debug -->\n     <logger name=\"com.powsybl.cgmes.conversion.Conversion\" level=\"info\" />\n+        <!-- To watch the Hvdc configurations after the topological analysis, level to debug -->\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.CgmesDcConversion\" level=\"info\" />\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.Adjacency\" level=\"info\" />\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments\" level=\"info\" />\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.Islands\" level=\"info\" />\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.IslandsEnds\" level=\"info\" />\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc\" level=\"info\" />\n+    <logger name=\"com.powsybl.cgmes.conversion.elements.hvdc.Hvdc\" level=\"info\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a23322a7f7cac942277094313a3b74747d868b25"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb707bc481d6a66fbb467c9ee824ae22915175f5", "author": {"user": {"login": "annetill", "name": "Anne Tilloy"}}, "url": "https://github.com/powsybl/powsybl-core/commit/cb707bc481d6a66fbb467c9ee824ae22915175f5", "committedDate": "2020-04-09T08:48:57Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "febd0943ea8eaa1a78db31084cf8ed798d0956ab", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/febd0943ea8eaa1a78db31084cf8ed798d0956ab", "committedDate": "2020-04-09T09:32:16Z", "message": "Apply reviewer comments.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/5724423fce1858f4b4319f14a72a54b2a45125f9", "committedDate": "2020-04-09T09:32:31Z", "message": "Merge branch 'cgmes_conversion_HVDC' of https://github.com/powsybl/powsybl-core into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzE0MDAy", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-391314002", "createdAt": "2020-04-10T07:48:00Z", "commit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo0ODowMFrOGDztlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDoxOTo1MlrOGD24sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjE2Nw==", "bodyText": "Write these two lines on a single line.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406646167", "createdAt": "2020-04-10T07:48:00Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -5,25 +5,39 @@\n  * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n  */\n \n-package com.powsybl.cgmes.conversion.elements;\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n \n import java.util.Objects;\n \n import com.powsybl.cgmes.conversion.Context;\n-import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.cgmes.conversion.elements.AbstractConductingEquipmentConversion;\n import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.iidm.network.LccConverterStation;\n import com.powsybl.iidm.network.LccConverterStationAdder;\n+import com.powsybl.iidm.network.VscConverterStation;\n import com.powsybl.iidm.network.VscConverterStationAdder;\n import com.powsybl.triplestore.api.PropertyBag;\n \n /**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n public class AcDcConverterConversion extends AbstractConductingEquipmentConversion {\n \n-    public AcDcConverterConversion(PropertyBag c, Context context) {\n+    private static final double DEFAULT_POWER_FACTOR = 0.8;\n+\n+    enum VscRegulation {\n+        REACTIVE_POWER,\n+        VOLTAGE\n+    }\n+\n+    public AcDcConverterConversion(PropertyBag c, HvdcType converterType, double lossFactor, Context context) {\n         super(\"ACDCConverter\", c, context);\n-        converterType = decodeType(p.getLocal(\"type\"));\n+\n+        Objects.requireNonNull(converterType);\n+        this.converterType = converterType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjUwMA==", "bodyText": "Is this method really private package? If it is used only in subclasses, make it protected. It is used only here, make it private.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406646500", "createdAt": "2020-04-10T07:48:57Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    Map<String, AcDcConverterNode> getConverterNodes() {\n+        return converterNodes;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0Njk1MQ==", "bodyText": "Refactor using computeIfPresent?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406646951", "createdAt": "2020-04-10T07:50:21Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NzA2NA==", "bodyText": "Are you sure about the visibility of this class?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406647064", "createdAt": "2020-04-10T07:50:41Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    Map<String, AcDcConverterNode> getConverterNodes() {\n+        return converterNodes;\n+    }\n+\n+    static class AcDcConverterNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0Nzg0NQ==", "bodyText": "Assert that debug is enabled to avoid performance issue", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406647845", "createdAt": "2020-04-10T07:53:08Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    private final Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.getConverterNodes()\n+            .forEach((key, value) -> computeAcDcConverterAdjacency(value.acTopologicalNode,\n+                value.dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else {\n+                throw new PowsyblException(String.format(\"Unexpected TransformerEnds: ends %d\", ends.size()));\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode()));\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode(), t3.topologicalNode()));\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(this::containsAcDcConverter)) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    Map<String, List<Adjacent>> get() {\n+        return adjacency;\n+    }\n+\n+    boolean isEmpty() {\n+        return adjacency.isEmpty();\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Adjacency\");\n+        adjacency.forEach(this::debug);\n+    }\n+\n+    private void debug(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.debug(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(Adjacent::debug);\n+    }\n+\n+    void debug(List<String> lnodes) {\n+        lnodes.forEach(this::debug);\n+    }\n+\n+    private void debug(String node) {\n+        LOG.debug(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.debug(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NzkwNg==", "bodyText": "Check that log is enabled", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406647906", "createdAt": "2020-04-10T07:53:20Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    private final Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.getConverterNodes()\n+            .forEach((key, value) -> computeAcDcConverterAdjacency(value.acTopologicalNode,\n+                value.dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else {\n+                throw new PowsyblException(String.format(\"Unexpected TransformerEnds: ends %d\", ends.size()));\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode()));\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode(), t3.topologicalNode()));\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(this::containsAcDcConverter)) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    Map<String, List<Adjacent>> get() {\n+        return adjacency;\n+    }\n+\n+    boolean isEmpty() {\n+        return adjacency.isEmpty();\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Adjacency\");\n+        adjacency.forEach(this::debug);\n+    }\n+\n+    private void debug(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.debug(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(Adjacent::debug);\n+    }\n+\n+    void debug(List<String> lnodes) {\n+        lnodes.forEach(this::debug);\n+    }\n+\n+    private void debug(String node) {\n+        LOG.debug(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.debug(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }\n+\n+    static class Adjacent {\n+        AdjacentType type;\n+        String topologicalNode;\n+\n+        Adjacent(AdjacentType type, String topologicalNode) {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(topologicalNode);\n+            this.type = type;\n+            this.topologicalNode = topologicalNode;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    {}  {}\", this.type, this.topologicalNode);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODI2NA==", "bodyText": "Merge these lines. Objects.requireNonNull() return the parameter value to make it possible to write: this.context = Objects.requireNonNull(context);", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406648264", "createdAt": "2020-04-10T07:54:23Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk1NQ==", "bodyText": "There is no need of the ok variable:\nif (!convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId)) {\n     return\n}\n\nand\nif (createHvdc()) {\n    setCommonDataUsed();\n}", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406648955", "createdAt": "2020-04-10T07:56:10Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTE1NQ==", "bodyText": "This remark could be applied globally to this file.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406649155", "createdAt": "2020-04-10T07:56:46Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk1NQ=="}, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTQ1Mg==", "bodyText": "Maybe we should throw an exception in that case", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406649452", "createdAt": "2020-04-10T07:57:39Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId1, String dcLineSegmentId2) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId1);\n+        if (!ok) {\n+            return;\n+        }\n+        PropertyBag dcLineSegment2 = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId2);\n+        if (dcLineSegment2 == null) {\n+            return;\n+        }\n+        this.r = 1.0 / (1.0 / computeR(this.dcLineSegment) + 1.0 / computeR(dcLineSegment2));\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+            context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId2);\n+        }\n+    }\n+\n+    private void setCommonDataUsed() {\n+        context.dc().setCgmesConverterUsed(converter1Id);\n+        context.dc().setCgmesConverterUsed(converter2Id);\n+        context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId);\n+    }\n+\n+    private boolean convertCommonData(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        this.converter1Id = acDcConverterIdEnd1;\n+        this.cconverter1 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd1);\n+        this.converter2Id = acDcConverterIdEnd2;\n+        this.cconverter2 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd2);\n+        this.dcLineSegmentId = dcLineSegmentId;\n+        this.dcLineSegment = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId);\n+        if (this.cconverter1 == null || this.cconverter2 == null || this.dcLineSegment == null) {\n+            return false;\n+        }\n+        this.converterType = decodeType(this.cconverter1.getLocal(TYPE));\n+        if (this.converterType == null || converterType != decodeType(this.cconverter2.getLocal(TYPE))) {\n+            return false;\n+        }\n+        this.operatingMode = decodeMode(this.converterType, this.cconverter1, this.cconverter2);\n+        this.ratedUdc = computeRatedUdc(this.cconverter1, this.cconverter2);\n+\n+        return true;\n+    }\n+\n+    private static HvdcType decodeType(String stype) {\n+        if (stype.equals(\"VsConverter\")) {\n+            return HvdcType.VSC;\n+        } else if (stype.equals(\"CsConverter\")) {\n+            return HvdcType.LCC;\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTg3NA==", "bodyText": "See above: maybe test the log level here", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406649874", "createdAt": "2020-04-10T07:58:46Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId1, String dcLineSegmentId2) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId1);\n+        if (!ok) {\n+            return;\n+        }\n+        PropertyBag dcLineSegment2 = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId2);\n+        if (dcLineSegment2 == null) {\n+            return;\n+        }\n+        this.r = 1.0 / (1.0 / computeR(this.dcLineSegment) + 1.0 / computeR(dcLineSegment2));\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+            context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId2);\n+        }\n+    }\n+\n+    private void setCommonDataUsed() {\n+        context.dc().setCgmesConverterUsed(converter1Id);\n+        context.dc().setCgmesConverterUsed(converter2Id);\n+        context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId);\n+    }\n+\n+    private boolean convertCommonData(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        this.converter1Id = acDcConverterIdEnd1;\n+        this.cconverter1 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd1);\n+        this.converter2Id = acDcConverterIdEnd2;\n+        this.cconverter2 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd2);\n+        this.dcLineSegmentId = dcLineSegmentId;\n+        this.dcLineSegment = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId);\n+        if (this.cconverter1 == null || this.cconverter2 == null || this.dcLineSegment == null) {\n+            return false;\n+        }\n+        this.converterType = decodeType(this.cconverter1.getLocal(TYPE));\n+        if (this.converterType == null || converterType != decodeType(this.cconverter2.getLocal(TYPE))) {\n+            return false;\n+        }\n+        this.operatingMode = decodeMode(this.converterType, this.cconverter1, this.cconverter2);\n+        this.ratedUdc = computeRatedUdc(this.cconverter1, this.cconverter2);\n+\n+        return true;\n+    }\n+\n+    private static HvdcType decodeType(String stype) {\n+        if (stype.equals(\"VsConverter\")) {\n+            return HvdcType.VSC;\n+        } else if (stype.equals(\"CsConverter\")) {\n+            return HvdcType.LCC;\n+        }\n+        return null;\n+    }\n+\n+    private static HvdcLine.ConvertersMode decodeMode(HvdcType converterType, PropertyBag cconverter1, PropertyBag cconverter2) {\n+        String mode1 = cconverter1.getLocal(OPERATING_MODE);\n+        String mode2 = cconverter2.getLocal(OPERATING_MODE);\n+\n+        if (converterType.equals(HvdcConverterStation.HvdcType.LCC)) {\n+            if (inverter(mode1) && rectifier(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            } else if (rectifier(mode1) && inverter(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER;\n+            } else if (cconverter1.asDouble(TARGET_PPCC) == 0 && cconverter2.asDouble(TARGET_PPCC) == 0) {\n+                // Both ends are rectifier or inverter\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            }\n+        } else {\n+            if (cconverter1.asDouble(TARGET_PPCC) > 0 || cconverter2.asDouble(TARGET_PPCC) < 0) {\n+                return HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER;\n+            } else {\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            }\n+        }\n+        throw new PowsyblException(\"Unexpected HVDC type: \" + converterType);\n+    }\n+\n+    private static boolean inverter(String operatingMode) {\n+        return operatingMode.toLowerCase().endsWith(\"inverter\");\n+    }\n+\n+    private static boolean rectifier(String operatingMode) {\n+        return operatingMode.toLowerCase().endsWith(\"rectifier\");\n+    }\n+\n+    private double computeR(PropertyBag dcLs) {\n+        double rDcLink = dcLs.asDouble(\"r\", 0);\n+        if (rDcLink < 0) {\n+            double rDcLink1 = 0.1;\n+            context.fixed(\"resistance\", \"was negative\", rDcLink, rDcLink1);\n+            rDcLink = rDcLink1;\n+        }\n+        return rDcLink;\n+    }\n+\n+    private static double computeRatedUdc(PropertyBag cconverter1, PropertyBag cconverter2) {\n+        double ratedUdc1 = cconverter1.asDouble(CgmesNames.RATED_UDC);\n+        double ratedUdc2 = cconverter2.asDouble(CgmesNames.RATED_UDC);\n+        if (ratedUdc1 != 0) {\n+            return ratedUdc1;\n+        }\n+        return ratedUdc2;\n+    }\n+\n+    private boolean createHvdc() {\n+\n+        // poleLossP is the active power loss at a DC Pole\n+        // for lossless operation: P(DC) = P(AC) => lossFactor = 0\n+        // for rectifier operation (conversion from AC to DC) with losses: P(DC) = P(AC) - poleLossP\n+        // In IIDM, for rectifier operation P(DC) / P(AC) = 1 - lossFactor\n+        // => P(DC) / P(AC) = 1 - poleLossP / P(AC) = 1 - lossFactor\n+        // for inverter operation (conversion from DC to AC) with losses: P(DC) = P(AC) + poleLossP\n+        // In IIDM, for inverter operation P(AC) / P(DC) = 1 - lossFactor\n+        // => P(AC) / P(DC) = 1 - poleLossP / P(DC) = 1 - poleLossP / (P(AC) + poleLossP) = 1 - lossFactor\n+\n+        double poleLossP1 = cconverter1.asDouble(POLE_LOSS_P);\n+        double poleLossP2 = cconverter2.asDouble(POLE_LOSS_P);\n+\n+        // load sign convention is used i.e. positive sign means flow out from a node\n+        // i.e. pACx >= 0 if converterx is rectifier and pACx <= 0 if converterx is\n+        // inverter\n+\n+        double pAC1 = getPAc(cconverter1);\n+        double pAC2 = getPAc(cconverter2);\n+\n+        LossFactor lossFactor = new LossFactor(context, operatingMode, pAC1, pAC2, poleLossP1, poleLossP2);\n+        lossFactor.compute();\n+\n+        AcDcConverterConversion acDcConverterConversion1 = new AcDcConverterConversion(cconverter1, converterType, lossFactor.getLossFactor1(), context);\n+        AcDcConverterConversion acDcConverterConversion2 = new AcDcConverterConversion(cconverter2, converterType, lossFactor.getLossFactor2(), context);\n+        DcLineSegmentConverter converter1 = new DcLineSegmentConverter(converter1Id, poleLossP1, pAC1);\n+        DcLineSegmentConverter converter2 = new DcLineSegmentConverter(converter2Id, poleLossP2, pAC2);\n+        DcLineSegmentConversion dcLineSegmentConversion = new DcLineSegmentConversion(dcLineSegment, operatingMode, r, ratedUdc, converter1, converter2, context);\n+\n+        if (!acDcConverterConversion1.valid() || !acDcConverterConversion2.valid() || !dcLineSegmentConversion.valid()) {\n+            return false;\n+        }\n+\n+        if (converterType == HvdcType.VSC) {\n+            acDcConverterConversion1.convert();\n+            acDcConverterConversion2.convert();\n+            dcLineSegmentConversion.convert();\n+\n+        } else { // LCC\n+            acDcConverterConversion1.convert();\n+            acDcConverterConversion2.convert();\n+            dcLineSegmentConversion.convert();\n+\n+            updatePowerFactor(acDcConverterConversion1);\n+            updatePowerFactor(acDcConverterConversion2);\n+        }\n+        return true;\n+    }\n+\n+    private static double getPAc(PropertyBag p) {\n+        // targetPpcc is the real power injection target in the AC grid in CGMES\n+        return Double.isNaN(p.asDouble(TARGET_PPCC)) ? 0 : p.asDouble(TARGET_PPCC);\n+    }\n+\n+    private static void updatePowerFactor(AcDcConverterConversion acDcConverterConversion) {\n+        if (acDcConverterConversion == null) {\n+            return;\n+        }\n+        LccConverterStation iconverter = acDcConverterConversion.getLccConverter();\n+        double powerFactor = getPowerFactor(iconverter);\n+        if (!Double.isNaN(powerFactor)) {\n+            acDcConverterConversion.setLccPowerFactor(powerFactor);\n+        }\n+    }\n+\n+    private static double getPowerFactor(LccConverterStation iconverter) {\n+        return iconverter.getTerminal().getP()\n+            / Math.hypot(iconverter.getTerminal().getP(), iconverter.getTerminal().getQ());\n+    }\n+\n+    private void debugHvdc(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Islands islands,\n+        IslandsEnds islandsEnds, Hvdc hvdc) {\n+\n+        hvdc.debug();\n+\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            islandEndHvdc1.debug();\n+            islandEndHvdc2.debug();\n+\n+            adjacency.debug(ien.getTopologicalNodes1());\n+            tpNodeEquipments.debugEq(ien.getTopologicalNodes1());\n+            tpNodeEquipments.debugDcLs(ien.getTopologicalNodes1());\n+\n+            adjacency.debug(ien.getTopologicalNodes2());\n+            tpNodeEquipments.debugEq(ien.getTopologicalNodes2());\n+            tpNodeEquipments.debugDcLs(ien.getTopologicalNodes2());\n+        });\n+\n+        islands.debug();\n+        islandsEnds.debug();\n+        adjacency.debug();\n+        tpNodeEquipments.debug();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4Nzk1NQ==", "bodyText": "This looks strange to me:\n\nDC_LINE_SEGMENT are used for DC lines -> OK\nAC_DC_CONVERTER are used between AC node and DC node (converter station I guess) -> OK\n\nBut I don't understand why do you connect all DC terminals to each others? And why this kind of links (if they are valid), are AC_DC_CONVERTER instead of DC_LINE_SEGMENT (DC <-> DC)", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406687955", "createdAt": "2020-04-10T09:48:05Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    private final Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.getConverterNodes()\n+            .forEach((key, value) -> computeAcDcConverterAdjacency(value.acTopologicalNode,\n+                value.dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else {\n+                throw new PowsyblException(String.format(\"Unexpected TransformerEnds: ends %d\", ends.size()));\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODU5OA==", "bodyText": "Consider log anything only if debug is enabled", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406688598", "createdAt": "2020-04-10T09:49:59Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    private final List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.getHvdc().forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSymmetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(hvdcEq::add);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    List<HvdcEquipment> getHvdcData() {\n+        return hvdcData;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Hvdc\");\n+        hvdcData.forEach(HvdcEquipment::debug);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODY0OQ==", "bodyText": "Same remark here", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406688649", "createdAt": "2020-04-10T09:50:08Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    private final List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.getHvdc().forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSymmetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(hvdcEq::add);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    List<HvdcEquipment> getHvdcData() {\n+        return hvdcData;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Hvdc\");\n+        hvdcData.forEach(HvdcEquipment::debug);\n+    }\n+\n+    static class HvdcEquipment {\n+        final List<HvdcConverter> converters;\n+        final List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    Converters:\");\n+            this.converters.forEach(HvdcConverter::debug);\n+            LOG.debug(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.debug(\"    {} \", ls));\n+            LOG.debug(\"---\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODcwOQ==", "bodyText": "Same remark here", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406688709", "createdAt": "2020-04-10T09:50:19Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    private final List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.getHvdc().forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSymmetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(hvdcEq::add);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    List<HvdcEquipment> getHvdcData() {\n+        return hvdcData;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Hvdc\");\n+        hvdcData.forEach(HvdcEquipment::debug);\n+    }\n+\n+    static class HvdcEquipment {\n+        final List<HvdcConverter> converters;\n+        final List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    Converters:\");\n+            this.converters.forEach(HvdcConverter::debug);\n+            LOG.debug(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.debug(\"    {} \", ls));\n+            LOG.debug(\"---\");\n+        }\n+    }\n+\n+    static class HvdcConverter {\n+        String acDcConvertersEnd1;\n+        String acDcConvertersEnd2;\n+\n+        HvdcConverter(String acDcConvertersEnd1, String acDcConvertersEnd2) {\n+            Objects.requireNonNull(acDcConvertersEnd1);\n+            Objects.requireNonNull(acDcConvertersEnd2);\n+            this.acDcConvertersEnd1 = acDcConvertersEnd1;\n+            this.acDcConvertersEnd2 = acDcConvertersEnd2;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    End1: {} End2: {}\", this.acDcConvertersEnd1, this.acDcConvertersEnd2);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTU4Nw==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406689587", "createdAt": "2020-04-10T09:52:55Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+import com.powsybl.commons.PowsyblException;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    private final List<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new ArrayList<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSymmetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(hvdcEnd2.dcLineSegmentsEnd::contains);\n+    }\n+\n+    List<HvdcEnd> getHvdc() {\n+        return hvdc;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"IslandEndHvdc\");\n+        hvdc.forEach(HvdcEnd::debug);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTcwOA==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406689708", "createdAt": "2020-04-10T09:53:14Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+import com.powsybl.commons.PowsyblException;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    private final List<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new ArrayList<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSymmetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(hvdcEnd2.dcLineSegmentsEnd::contains);\n+    }\n+\n+    List<HvdcEnd> getHvdc() {\n+        return hvdc;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"IslandEndHvdc\");\n+        hvdc.forEach(HvdcEnd::debug);\n+    }\n+\n+    static class HvdcEnd {\n+        final List<String> topologicalNodesEnd;\n+        final Set<String> transformersEnd;\n+        final Set<String> acDcConvertersEnd;\n+        final Set<String> dcLineSegmentsEnd;\n+\n+        HvdcEnd(List<String> topologicalNodesEnd, Set<String> transformersEnd, Set<String> acDcConvertersEnd, Set<String> dcLineSegmentsEnd) {\n+            Objects.requireNonNull(topologicalNodesEnd);\n+            Objects.requireNonNull(transformersEnd);\n+            Objects.requireNonNull(acDcConvertersEnd);\n+            Objects.requireNonNull(dcLineSegmentsEnd);\n+            this.topologicalNodesEnd = topologicalNodesEnd;\n+            this.transformersEnd = transformersEnd;\n+            this.acDcConvertersEnd = acDcConvertersEnd;\n+            this.dcLineSegmentsEnd = dcLineSegmentsEnd;\n+        }\n+\n+        HvdcEndType computeType() {\n+            int t = this.transformersEnd.size();\n+            int c = this.acDcConvertersEnd.size();\n+            int ls = this.dcLineSegmentsEnd.size();\n+\n+            if (t == 0 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T0_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T1_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 2) {\n+                return HvdcEndType.HVDC_T1_C1_LS2;\n+            } else if (t == 2 && c == 2 && ls == 1) {\n+                return HvdcEndType.HVDC_T2_C2_LS1;\n+            } else if (t == c && c == ls && t > 1) {\n+                return HvdcEndType.HVDC_TN_CN_LSN;\n+            }\n+\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Transformers %d Converters %d DcLineSegments %d\", t, c, ls));\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    topologicalNodesEnd: {}\", this.topologicalNodesEnd);\n+            LOG.debug(\"    transformersEnd: {}\", this.transformersEnd);\n+            LOG.debug(\"    acDcConvertersEnd: {}\", this.acDcConvertersEnd);\n+            LOG.debug(\"    dcLineSegmentsEnd: {}\", this.dcLineSegmentsEnd);\n+            LOG.debug(\"---\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTkxMQ==", "bodyText": "Coding style: two spaces are between final and List", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406689911", "createdAt": "2020-04-10T09:53:50Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final  List<ArrayList<String>> islandsNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5MDExOA==", "bodyText": "Same remark.", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406690118", "createdAt": "2020-04-10T09:54:26Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final  List<ArrayList<String>> islandsNodes;\n+\n+    // The island includes dcTopologicalNodes and the acTopologicalNodes at both ends of the transformer\n+    Islands(Adjacency adjacency) {\n+        islandsNodes = new ArrayList<>();\n+\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+        adjacency.get().keySet().forEach(topologicalNodeId -> {\n+            if (visitedTopologicalNodes.contains(topologicalNodeId)) {\n+                return;\n+            }\n+            ArrayList<String> adjacentTopologicalNodes = computeAdjacentTopologicalNodes(topologicalNodeId,\n+                adjacency, visitedTopologicalNodes);\n+            islandsNodes.add(adjacentTopologicalNodes);\n+        });\n+    }\n+\n+    private static ArrayList<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        ArrayList<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    List<ArrayList<String>> getIslandsNodes() {\n+        return islandsNodes;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Islands\");\n+        islandsNodes.forEach(island -> LOG.debug(\" {} \", island));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODAzMw==", "bodyText": "Same global remark about logging", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406698033", "createdAt": "2020-04-10T10:19:25Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    private final Map<String, List<TPnodeEquipment>> nodeEquipments;\n+\n+    TPnodeEquipments(CgmesModel cgmesModel, Adjacency adjacency) {\n+        nodeEquipments = new HashMap<>();\n+\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegment(cgmesModel, adjacency, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+\n+        acDcConverterNodes.getConverterNodes().values()\n+            .forEach(value -> addEquipment(adjacency, value.id, value.acTopologicalNode,\n+                value.dcTopologicalNode, EquipmentType.AC_DC_CONVERTER));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformer(cgmesModel, adjacency, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformer(cgmesModel, adjacency, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegment(CgmesModel cgmesModel, Adjacency adjacency, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+        String id = equipment.getId(\"DCLineSegment\");\n+        addEquipment(adjacency, id, t1.dcTopologicalNode(), t2.dcTopologicalNode(), EquipmentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeTwoWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void computeThreeWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String topologicalNodeId1, String topologicalNodeId2,\n+        EquipmentType type) {\n+        if (!adjacency.get().containsKey(topologicalNodeId1)\n+            || !adjacency.get().containsKey(topologicalNodeId2)) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(eq);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(eq);\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String acTopologicalNodeId,\n+        List<String> dcTopologicalNodeIds, EquipmentType type) {\n+        if (!adjacency.get().containsKey(acTopologicalNodeId)) {\n+            return;\n+        }\n+        if (dcTopologicalNodeIds.stream().anyMatch(n -> !adjacency.get().containsKey(n))) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(acTopologicalNodeId, k -> new ArrayList<>()).add(eq);\n+        dcTopologicalNodeIds.forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    private boolean isValidTransformer(Adjacency adjacency, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(adjacency::containsAcDcConverter);\n+    }\n+\n+    private void addTransformer(Adjacency adjacency, String id, List<String> topologicalNodes, EquipmentType type) {\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        topologicalNodes.stream()\n+            .filter(n -> adjacency.get().containsKey(n))\n+            .forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    boolean containsAnyTransformer(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.TRANSFORMER);\n+    }\n+\n+    boolean containsAnyAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.AC_DC_CONVERTER);\n+    }\n+\n+    boolean multiAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.type == EquipmentType.AC_DC_CONVERTER)\n+            .count() >= 2;\n+    }\n+\n+    boolean connectedEquipments(String equipment1, String equipment2, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(n -> connectedEquipment(n, equipment1, equipment2));\n+    }\n+\n+    private boolean connectedEquipment(String topologicalNode, String equipment1, String equipment2) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.equipmentId.equals(equipment1) || eq.equipmentId.equals(equipment2))\n+            .count() == 2;\n+    }\n+\n+    Map<String, List<TPnodeEquipment>> getNodeEquipments() {\n+        return nodeEquipments;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"TPnodeEquipments\");\n+        nodeEquipments.forEach(this::debug);\n+    }\n+\n+    private void debug(String tpNodeId, List<TPnodeEquipment> listTPnodeEquipment) {\n+        LOG.debug(\"TopologicalNodeId: {}\", tpNodeId);\n+        listTPnodeEquipment.forEach(TPnodeEquipment::debug);\n+    }\n+\n+    void debugEq(List<String> lnodes) {\n+        lnodes.forEach(this::debugEq);\n+    }\n+\n+    private void debugEq(String node) {\n+        LOG.debug(\"EQ. TopologicalNode {}\", node);\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node)\n+                .forEach(eq -> LOG.debug(\"    {} {}\", eq.type, eq.equipmentId));\n+        }\n+    }\n+\n+    void debugDcLs(List<String> lnodes) {\n+        lnodes.forEach(this::debugDcLs);\n+    }\n+\n+    private void debugDcLs(String node) {\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node).stream()\n+                .filter(eq -> eq.type == TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT)\n+                .forEach(eq -> LOG.debug(\"DcLineSegment {}\", eq.equipmentId));\n+        }\n+    }\n+\n+    static class TPnodeEquipment {\n+        EquipmentType type;\n+        String equipmentId;\n+\n+        TPnodeEquipment(EquipmentType type, String equipmentId) {\n+            this.type = type;\n+            this.equipmentId = equipmentId;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    {} {}\", this.type, this.equipmentId);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TPnodeEquipments.class);\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODE2MQ==", "bodyText": "Same global remark about logging", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406698161", "createdAt": "2020-04-10T10:19:52Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    private final List<IslandEnd> islandsEndsNodes;\n+\n+    // The island includes dcTopologicalNodes and first acTopologicalNode\n+    IslandsEnds() {\n+        islandsEndsNodes = new ArrayList<>();\n+    }\n+\n+    void add(Adjacency adjacency, List<String> islandNodes) {\n+        if (islandNodes.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        String topologicalNodeEnd1 = islandNodes.get(0);\n+        List<String> adjacentTopologicalNodeEnd1 = computeAdjacentTopologicalNodes(topologicalNodeEnd1,\n+            adjacency, visitedTopologicalNodes);\n+\n+        String topologicalNodeEnd2 = getTopologicalNodeOtherEnd(islandNodes, visitedTopologicalNodes);\n+        if (topologicalNodeEnd2 == null) {\n+            return;\n+        }\n+        List<String> adjacentTopologicalNodeEnd2 = computeAdjacentTopologicalNodes(topologicalNodeEnd2,\n+            adjacency, visitedTopologicalNodes);\n+\n+        IslandEnd islandEnd = new IslandEnd(adjacentTopologicalNodeEnd1, adjacentTopologicalNodeEnd2);\n+\n+        islandsEndsNodes.add(islandEnd);\n+    }\n+\n+    private static String getTopologicalNodeOtherEnd(List<String> islandNodes, Set<String> visitedTopologicalNodes) {\n+        return islandNodes.stream()\n+            .filter(n -> !visitedTopologicalNodes.contains(n))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (Adjacency.isDcLineSegment(adjacent.type)) {\n+                        return;\n+                    }\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    List<IslandEnd> getIslandsEndsNodes() {\n+        return islandsEndsNodes;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"IslandsEnds\");\n+        islandsEndsNodes.forEach(IslandEnd::debug);\n+    }\n+\n+    static class IslandEnd {\n+        private final List<String> topologicalNodes1;\n+        private final List<String> topologicalNodes2;\n+\n+        IslandEnd(List<String> topologicalNodes1, List<String> topologicalNodes2) {\n+            this.topologicalNodes1 = topologicalNodes1;\n+            this.topologicalNodes2 = topologicalNodes2;\n+        }\n+\n+        List<String> getTopologicalNodes1() {\n+            return topologicalNodes1;\n+        }\n+\n+        List<String> getTopologicalNodes2() {\n+            return topologicalNodes2;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    topologicalNodes1: {}\", this.topologicalNodes1);\n+            LOG.debug(\"    topologicalNodes2: {}\", this.topologicalNodes2);\n+            LOG.debug(\"---\");\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(IslandsEnds.class);\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5d71bce1f4ced0e104a20677e82e2355ede84b1", "author": {"user": {"login": "annetill", "name": "Anne Tilloy"}}, "url": "https://github.com/powsybl/powsybl-core/commit/c5d71bce1f4ced0e104a20677e82e2355ede84b1", "committedDate": "2020-04-14T06:12:04Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af92e0ef75a0bceca3c2f0468be26c3514e5a2f4", "author": {"user": {"login": "marqueslanauja", "name": null}}, "url": "https://github.com/powsybl/powsybl-core/commit/af92e0ef75a0bceca3c2f0468be26c3514e5a2f4", "committedDate": "2020-04-14T09:40:29Z", "message": "Reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92b07348f7abc0c0127374c9651d9fbb9b8101ad", "author": {"user": {"login": "annetill", "name": "Anne Tilloy"}}, "url": "https://github.com/powsybl/powsybl-core/commit/92b07348f7abc0c0127374c9651d9fbb9b8101ad", "committedDate": "2020-04-15T06:07:43Z", "message": "Merge branch 'master' into cgmes_conversion_HVDC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNTIwNzA5", "url": "https://github.com/powsybl/powsybl-core/pull/1230#pullrequestreview-393520709", "createdAt": "2020-04-15T07:29:58Z", "commit": {"oid": "92b07348f7abc0c0127374c9651d9fbb9b8101ad"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyOTo1OFrOGFtL0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyOTo1OFrOGFtL0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNjM3MQ==", "bodyText": "Where does this value come from?", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408636371", "createdAt": "2020-04-15T07:29:58Z", "author": {"login": "mathbagu"}, "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -5,25 +5,38 @@\n  * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n  */\n \n-package com.powsybl.cgmes.conversion.elements;\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n \n import java.util.Objects;\n \n import com.powsybl.cgmes.conversion.Context;\n-import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.cgmes.conversion.elements.AbstractConductingEquipmentConversion;\n import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.iidm.network.LccConverterStation;\n import com.powsybl.iidm.network.LccConverterStationAdder;\n+import com.powsybl.iidm.network.VscConverterStation;\n import com.powsybl.iidm.network.VscConverterStationAdder;\n import com.powsybl.triplestore.api.PropertyBag;\n \n /**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n public class AcDcConverterConversion extends AbstractConductingEquipmentConversion {\n \n-    public AcDcConverterConversion(PropertyBag c, Context context) {\n+    private static final double DEFAULT_POWER_FACTOR = 0.8;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b07348f7abc0c0127374c9651d9fbb9b8101ad"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4469, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}