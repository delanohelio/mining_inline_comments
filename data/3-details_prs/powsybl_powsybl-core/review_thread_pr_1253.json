{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2OTI3NTc3", "number": 1253, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxMzozOVrODyzuwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo1MDoxN1rODy0eMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjAyOTQ1OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerNetworkFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxMzozOVrOGHET_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowMDo1MVrOGJrh5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2Mzg2OQ==", "bodyText": "What is the license of the different cases (i.e. compatible with ours)?", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410063869", "createdAt": "2020-04-17T08:13:39Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerNetworkFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.powsybl.commons.datasource.ResourceDataSource;\n+import com.powsybl.commons.datasource.ResourceSet;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.NetworkFactory;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public final class MatpowerNetworkFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMzU1Nw==", "bodyText": "test cases are the same tests as the ones used in ieee-cdf module (cdf files converted to the matpower format by a MATLAB tool cdf2mpc), so their licenses should be OK, I suppose ...", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412803557", "createdAt": "2020-04-22T09:00:51Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerNetworkFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.powsybl.commons.datasource.ResourceDataSource;\n+import com.powsybl.commons.datasource.ResourceSet;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.NetworkFactory;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public final class MatpowerNetworkFactory {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2Mzg2OQ=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjAzMTk2OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxNDoyN1rOGHEVig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNDowMVrOGJrqvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDI2Ng==", "bodyText": "The default date should be the now()\nCoding style: a general remark about constant. The order we have is public first, then private constant.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410064266", "createdAt": "2020-04-17T08:14:27Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNTgyMg==", "bodyText": "thanks for your feedback,\n\nfixed the default date: now it's now()\naligned the constant declarations order to the coding style", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412805822", "createdAt": "2020-04-22T09:04:01Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDI2Ng=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjAzNTc4OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxNTozOFrOGHEX-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowODozN1rOGJr3eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDg5MA==", "bodyText": "Is it really interesting to ignore the base voltage? Do you have use cases where these values are inconsistent?\nBy convention, you should prefix this parameter name with a prefix to avoid clash. Have a look to XmlImporter, XmlExporter or UcteExporter: I would propose matpower.import.ignore-base-voltage.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410064890", "createdAt": "2020-04-17T08:15:38Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTA4MQ==", "bodyText": "again, I used the same test cases as the ieee-cdf importer, I thought it 'd be useful to provide the same options...\nI've changed the prefix for the parameter as you suggested", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412809081", "createdAt": "2020-04-22T09:08:37Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDg5MA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA0OTQyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoxOTo0NFrOGHEgWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MTowOVrOGQ0fzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NzAzMg==", "bodyText": "Question: is there non impedant branches in MatPower format? In that case, could their ends be in the same substation or not?", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410067032", "createdAt": "2020-04-17T08:19:44Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDUwOA==", "bodyText": "there are not, apparently. fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420290508", "createdAt": "2020-05-05T17:41:09Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NzAzMg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA2MDc1OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoyMzoyNFrOGHEn-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MToxNVrOGQ0gBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2ODk4NA==", "bodyText": "To be check, regarding my previous comment", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410068984", "createdAt": "2020-04-17T08:23:24Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDU2Ng==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420290566", "createdAt": "2020-05-05T17:41:15Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2ODk4NA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA2MjAyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoyMzo0OFrOGHEo4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MjoxMlrOGQ0ibQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2OTIxNg==", "bodyText": "Use BUS instead?", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410069216", "createdAt": "2020-04-17T08:23:48Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNTUyOA==", "bodyText": "my general remark for all the ID convention related feedbacks&suggestions: I tried to be as consistent as I could\nwith respect to the existing cdf importer approach (ref. the iidm in the ieee test resources ) in order to have the same generated IDs\n(and make it possible to directly compare the iidm, for example)", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412815528", "createdAt": "2020-04-22T09:17:46Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2OTIxNg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTE4MQ==", "bodyText": "fixed: used a prefix, consistently", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291181", "createdAt": "2020-05-05T17:42:12Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2OTIxNg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA3MDI3OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoyNjoxOVrOGHEuWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MjozMlrOGQ0jLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MDYxNg==", "bodyText": "All generators are regulating? Could getVoltageMagnitudeSetpoint() be 0, in that case, maybe we should set voltageRegulatorOn to false.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410070616", "createdAt": "2020-04-17T08:26:19Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTM3Mg==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291372", "createdAt": "2020-05-05T17:42:32Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MDYxNg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA3MzMyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoyNzoxNVrOGHEwUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0Mjo0MFrOGQ0jnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MTEyMg==", "bodyText": "Should be move in the else block of the next if statement", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410071122", "createdAt": "2020-04-17T08:27:15Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTQ4Nw==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291487", "createdAt": "2020-05-05T17:42:40Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MTEyMg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA3OTM3OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODoyOTowMVrOGHE0VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0Mjo0OFrOGQ0j5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MjE0OA==", "bodyText": "To be consistent with generators (and maybe the rest of this importer), you should set the name for all the identifiables to the ID, or never set it.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410072148", "createdAt": "2020-04-17T08:29:01Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTU1OQ==", "bodyText": "fixed: used a prefix, consistently", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291559", "createdAt": "2020-05-05T17:42:48Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MjE0OA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA4NjYzOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozMTowOFrOGHE4rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMDozOVrOGJsYcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzI2Mg==", "bodyText": "Is it OK regarding the sign convention? (same question for all equipments)", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410073262", "createdAt": "2020-04-17T08:31:08Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNzUyMw==", "bodyText": "it seems OK (consistent with the ieee-cdf importer)", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412817523", "createdAt": "2020-04-22T09:20:39Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzI2Mg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA4OTAyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozMTo1M1rOGHE6LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MzowMlrOGQ0kaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzY0NQ==", "bodyText": "Why don't you use the ensureUniqueId feature of IdentifiableAdder?", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410073645", "createdAt": "2020-04-17T08:31:53Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTY4OQ==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291689", "createdAt": "2020-05-05T17:43:02Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzY0NQ=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA5MjQ3OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozMjo1OFrOGHE8UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MzowOVrOGQ0kpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDE5Mg==", "bodyText": "The naming convention is different for generator: for generator you use a prefix, but for loads and shunts you use a post-fix", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410074192", "createdAt": "2020-04-17T08:32:58Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTc0OQ==", "bodyText": "fixed: used a prefix, consistently", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291749", "createdAt": "2020-05-05T17:43:09Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDE5Mg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA5NTEwOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozMzo0OFrOGHE-Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMToxMFrOGJsaOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDY1NA==", "bodyText": "I'm not sure Math.pow is really efficient to compute a square... use voltageLevel.getNominalV() * voltageLevel.getNominalV() / perUnitContext.getBaseMva())", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410074654", "createdAt": "2020-04-17T08:33:48Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNzk3OA==", "bodyText": "you're right! done.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412817978", "createdAt": "2020-04-22T09:21:10Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDY1NA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA5NzExOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozNDoyMVrOGHE_Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MzoyM1rOGQ0lPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDk4Mg==", "bodyText": "Same question about ensureUniqueId", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410074982", "createdAt": "2020-04-17T08:34:21Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTkwMg==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291902", "createdAt": "2020-05-05T17:43:23Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDk4Mg=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA5ODYyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozNDo0OVrOGHFAaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MzozMFrOGQ0llg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTI0Mw==", "bodyText": "For branches (lines and transformers), you use a prefix also. See above, try to be consistent", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410075243", "createdAt": "2020-04-17T08:34:49Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTk5MA==", "bodyText": "fixed: used a prefix, consistently", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291990", "createdAt": "2020-05-05T17:43:30Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTI0Mw=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjA5OTM2OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozNTowMVrOGHFA4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0Mzo0NVrOGQ0mPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTM2MA==", "bodyText": "Same remark", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410075360", "createdAt": "2020-04-17T08:35:01Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);\n+        String bus1Id = getBusId(branch.getFrom());\n+        String bus2Id = getBusId(branch.getTo());\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(branch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(branch.getTo());\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjE1Ng==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420292156", "createdAt": "2020-05-05T17:43:45Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);\n+        String bus1Id = getBusId(branch.getFrom());\n+        String bus2Id = getBusId(branch.getTo());\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(branch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(branch.getTo());\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTM2MA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjEwMzc2OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozNjoxMVrOGHFDhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0Mzo1MVrOGQ0maA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NjAzOA==", "bodyText": "To be consistent, maybe you should also log bus1 and bus2 like for transformers", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410076038", "createdAt": "2020-04-17T08:36:11Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxODI5MA==", "bodyText": "done.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412818290", "createdAt": "2020-04-22T09:21:35Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NjAzOA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjIwMA==", "bodyText": "fixed: used a prefix, consistently", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420292200", "createdAt": "2020-05-05T17:43:51Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NjAzOA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjExMDM2OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozODowOFrOGHFHsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMzoxMlrOGJsfsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NzEwNA==", "bodyText": "See above, the default date is now. For round trip, you have to set-up a post-processor maybe to fix the date. I'm pretty sure this is the reason why you fix the date!?", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410077104", "createdAt": "2020-04-17T08:38:08Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);\n+        String bus1Id = getBusId(branch.getFrom());\n+        String bus2Id = getBusId(branch.getTo());\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(branch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(branch.getTo());\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();\n+        boolean isInService = isInService(branch);\n+        network.newLine()\n+                .setId(lineId)\n+                .setBus1(isInService ? bus1Id : null)\n+                .setConnectableBus1(bus1Id)\n+                .setVoltageLevel1(voltageLevel1Id)\n+                .setBus2(isInService ? bus2Id : null)\n+                .setConnectableBus2(bus2Id)\n+                .setVoltageLevel2(voltageLevel2Id)\n+                .setR(branch.getR() * zb)\n+                .setX(branch.getX() * zb)\n+                .setG1(0)\n+                .setB1(branch.getB() / zb / 2)\n+                .setG2(0)\n+                .setB2(branch.getB() / zb / 2)\n+                .add();\n+    }\n+\n+    private static TwoWindingsTransformer createTransformer(MBranch mBranch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String id = getBranchId('T', mBranch.getFrom(), mBranch.getTo(), network);\n+\n+        String bus1Id = getBusId(mBranch.getFrom());\n+        String bus2Id = getBusId(mBranch.getTo());\n+\n+        LOGGER.debug(\"Creating two winding transformer {} {} {}\", id, bus1Id, bus2Id);\n+\n+        // taps at from bus\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(mBranch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(mBranch.getTo());\n+        VoltageLevel voltageLevel1 = network.getVoltageLevel(voltageLevel1Id);\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();\n+        boolean isInService = isInService(mBranch);\n+        return voltageLevel2.getSubstation().newTwoWindingsTransformer()\n+                .setId(id)\n+                .setBus1(isInService ? bus1Id : null)\n+                .setConnectableBus1(bus1Id)\n+                .setVoltageLevel1(voltageLevel1Id)\n+                .setBus2(isInService ? bus2Id : null)\n+                .setConnectableBus2(bus2Id)\n+                .setVoltageLevel2(voltageLevel2Id)\n+                .setRatedU1(voltageLevel1.getNominalV() * mBranch.getRatio())\n+                .setRatedU2(voltageLevel2.getNominalV())\n+                .setR(mBranch.getR() * zb)\n+                .setX(mBranch.getX() * zb)\n+                .setG(0)\n+                .setB(mBranch.getB() / zb)\n+            .add();\n+    }\n+\n+    private static void createBranches(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getRatio() == 0) {\n+                createLine(mBranch, containerMapping, network, perUnitContext);\n+            } else {\n+                createTransformer(mBranch, containerMapping, network, perUnitContext);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String getFormat() {\n+        return FORMAT;\n+    }\n+\n+    @Override\n+    public List<Parameter> getParameters() {\n+        return Collections.singletonList(IGNORE_BASE_VOLTAGE_PARAMETER);\n+    }\n+\n+    @Override\n+    public String getComment() {\n+        return \"MATPOWER Format to IIDM converter\";\n+    }\n+\n+    private String findExtension(ReadOnlyDataSource dataSource, boolean throwException) throws IOException {\n+        for (String ext : EXTENSIONS) {\n+            if (dataSource.exists(null, ext)) {\n+                return ext;\n+            }\n+        }\n+        if (throwException) {\n+            throw new MatpowerException(\"File \" + dataSource.getBaseName()\n+                    + \".\" + String.join(\"|\", EXTENSIONS) + \" not found\");\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean exists(ReadOnlyDataSource dataSource) {\n+        try {\n+            String ext = findExtension(dataSource, false);\n+            return dataSource.exists(null, ext);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void copy(ReadOnlyDataSource fromDataSource, DataSource toDataSource) {\n+        Objects.requireNonNull(fromDataSource);\n+        Objects.requireNonNull(toDataSource);\n+        try {\n+            String extFrom = findExtension(fromDataSource, false);\n+            String extTo = findExtension(toDataSource, false);\n+            try (InputStream is = fromDataSource.newInputStream(null, extFrom);\n+                 OutputStream os = toDataSource.newOutputStream(null, extTo, false)) {\n+                ByteStreams.copy(is, os);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public Network importData(ReadOnlyDataSource dataSource, NetworkFactory networkFactory, Properties parameters) {\n+        Objects.requireNonNull(dataSource);\n+        Objects.requireNonNull(networkFactory);\n+        Network network = networkFactory.createNetwork(dataSource.getBaseName(), FORMAT);\n+\n+        // no info abount time & date from the matpower file, set a  default\n+        ZonedDateTime caseDateTime = DEFAULTDATE.atStartOfDay(ZoneOffset.UTC.normalized());\n+        network.setCaseDate(new DateTime(caseDateTime.toInstant().toEpochMilli(), DateTimeZone.UTC));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxOTM3Nw==", "bodyText": "done: I've fixed the date in the test, before the check takes place.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412819377", "createdAt": "2020-04-22T09:23:12Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);\n+        String bus1Id = getBusId(branch.getFrom());\n+        String bus2Id = getBusId(branch.getTo());\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(branch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(branch.getTo());\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();\n+        boolean isInService = isInService(branch);\n+        network.newLine()\n+                .setId(lineId)\n+                .setBus1(isInService ? bus1Id : null)\n+                .setConnectableBus1(bus1Id)\n+                .setVoltageLevel1(voltageLevel1Id)\n+                .setBus2(isInService ? bus2Id : null)\n+                .setConnectableBus2(bus2Id)\n+                .setVoltageLevel2(voltageLevel2Id)\n+                .setR(branch.getR() * zb)\n+                .setX(branch.getX() * zb)\n+                .setG1(0)\n+                .setB1(branch.getB() / zb / 2)\n+                .setG2(0)\n+                .setB2(branch.getB() / zb / 2)\n+                .add();\n+    }\n+\n+    private static TwoWindingsTransformer createTransformer(MBranch mBranch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String id = getBranchId('T', mBranch.getFrom(), mBranch.getTo(), network);\n+\n+        String bus1Id = getBusId(mBranch.getFrom());\n+        String bus2Id = getBusId(mBranch.getTo());\n+\n+        LOGGER.debug(\"Creating two winding transformer {} {} {}\", id, bus1Id, bus2Id);\n+\n+        // taps at from bus\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(mBranch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(mBranch.getTo());\n+        VoltageLevel voltageLevel1 = network.getVoltageLevel(voltageLevel1Id);\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();\n+        boolean isInService = isInService(mBranch);\n+        return voltageLevel2.getSubstation().newTwoWindingsTransformer()\n+                .setId(id)\n+                .setBus1(isInService ? bus1Id : null)\n+                .setConnectableBus1(bus1Id)\n+                .setVoltageLevel1(voltageLevel1Id)\n+                .setBus2(isInService ? bus2Id : null)\n+                .setConnectableBus2(bus2Id)\n+                .setVoltageLevel2(voltageLevel2Id)\n+                .setRatedU1(voltageLevel1.getNominalV() * mBranch.getRatio())\n+                .setRatedU2(voltageLevel2.getNominalV())\n+                .setR(mBranch.getR() * zb)\n+                .setX(mBranch.getX() * zb)\n+                .setG(0)\n+                .setB(mBranch.getB() / zb)\n+            .add();\n+    }\n+\n+    private static void createBranches(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getRatio() == 0) {\n+                createLine(mBranch, containerMapping, network, perUnitContext);\n+            } else {\n+                createTransformer(mBranch, containerMapping, network, perUnitContext);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String getFormat() {\n+        return FORMAT;\n+    }\n+\n+    @Override\n+    public List<Parameter> getParameters() {\n+        return Collections.singletonList(IGNORE_BASE_VOLTAGE_PARAMETER);\n+    }\n+\n+    @Override\n+    public String getComment() {\n+        return \"MATPOWER Format to IIDM converter\";\n+    }\n+\n+    private String findExtension(ReadOnlyDataSource dataSource, boolean throwException) throws IOException {\n+        for (String ext : EXTENSIONS) {\n+            if (dataSource.exists(null, ext)) {\n+                return ext;\n+            }\n+        }\n+        if (throwException) {\n+            throw new MatpowerException(\"File \" + dataSource.getBaseName()\n+                    + \".\" + String.join(\"|\", EXTENSIONS) + \" not found\");\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean exists(ReadOnlyDataSource dataSource) {\n+        try {\n+            String ext = findExtension(dataSource, false);\n+            return dataSource.exists(null, ext);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void copy(ReadOnlyDataSource fromDataSource, DataSource toDataSource) {\n+        Objects.requireNonNull(fromDataSource);\n+        Objects.requireNonNull(toDataSource);\n+        try {\n+            String extFrom = findExtension(fromDataSource, false);\n+            String extTo = findExtension(toDataSource, false);\n+            try (InputStream is = fromDataSource.newInputStream(null, extFrom);\n+                 OutputStream os = toDataSource.newOutputStream(null, extTo, false)) {\n+                ByteStreams.copy(is, os);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public Network importData(ReadOnlyDataSource dataSource, NetworkFactory networkFactory, Properties parameters) {\n+        Objects.requireNonNull(dataSource);\n+        Objects.requireNonNull(networkFactory);\n+        Network network = networkFactory.createNetwork(dataSource.getBaseName(), FORMAT);\n+\n+        // no info abount time & date from the matpower file, set a  default\n+        ZonedDateTime caseDateTime = DEFAULTDATE.atStartOfDay(ZoneOffset.UTC.normalized());\n+        network.setCaseDate(new DateTime(caseDateTime.toInstant().toEpochMilli(), DateTimeZone.UTC));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NzEwNA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 425}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjEyMjkzOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MBusTypeConversion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0MTo1MlrOGHFPow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTo0ODoyMVrOGLmxEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTEzOQ==", "bodyText": "Why don't you use the fromInt() and getValue() methods? If there are useless, remove them?", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410079139", "createdAt": "2020-04-17T08:41:52Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MBusTypeConversion.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.conversions.ObjectConversion;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MBusTypeConversion extends ObjectConversion<MBus.Type> {\n+    @Override\n+    protected MBus.Type fromString(String s) {\n+        return MBus.Type.values()[Integer.parseInt(s.trim()) - 1];\n+    }\n+\n+    @Override\n+    public String revert(MBus.Type type) {\n+        return Integer.toString(type.ordinal() + 1);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMjY3NA==", "bodyText": "fixed", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r414822674", "createdAt": "2020-04-24T19:48:21Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MBusTypeConversion.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.conversions.ObjectConversion;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MBusTypeConversion extends ObjectConversion<MBus.Type> {\n+    @Override\n+    protected MBus.Type fromString(String s) {\n+        return MBus.Type.values()[Integer.parseInt(s.trim()) - 1];\n+    }\n+\n+    @Override\n+    public String revert(MBus.Type type) {\n+        return Integer.toString(type.ordinal() + 1);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTEzOQ=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjEyNjE5OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0Mjo0NVrOGHFRqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMzoyM1rOGJsgSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTY1OQ==", "bodyText": "See my previous comment about constant order.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410079659", "createdAt": "2020-04-17T08:42:45Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.MatFile;\n+import us.hebi.matlab.mat.types.Matrix;\n+import us.hebi.matlab.mat.types.Sources;\n+import us.hebi.matlab.mat.types.Struct;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.powsybl.matpower.model.MatpowerReader.MATPOWER_SUPPORTED_VERSION;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerBinReader.class);\n+    public static final String MATPOWER_STRUCT_NAME = \"mpc\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxOTUzMA==", "bodyText": "done.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412819530", "createdAt": "2020-04-22T09:23:23Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.MatFile;\n+import us.hebi.matlab.mat.types.Matrix;\n+import us.hebi.matlab.mat.types.Sources;\n+import us.hebi.matlab.mat.types.Struct;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.powsybl.matpower.model.MatpowerReader.MATPOWER_SUPPORTED_VERSION;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerBinReader.class);\n+    public static final String MATPOWER_STRUCT_NAME = \"mpc\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTY1OQ=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjEyODM4OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0MzoyN1rOGHFTFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNTozOFrOGJsmUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDAyMA==", "bodyText": "This is not the proper way to initialize a set from a list of constants. Use Sets.of", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410080020", "createdAt": "2020-04-17T08:43:27Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.MatFile;\n+import us.hebi.matlab.mat.types.Matrix;\n+import us.hebi.matlab.mat.types.Sources;\n+import us.hebi.matlab.mat.types.Struct;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.powsybl.matpower.model.MatpowerReader.MATPOWER_SUPPORTED_VERSION;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerBinReader.class);\n+    public static final String MATPOWER_STRUCT_NAME = \"mpc\";\n+\n+    public MatpowerModel read(InputStream iStream, String caseName) throws IOException {\n+        MatpowerModel model = null;\n+        try (MatFile mat = Mat5.newReader(Sources.wrapInputStream(iStream)).setEntryFilter(entry -> entry.getName().equals(MATPOWER_STRUCT_NAME)).readMat()) {\n+            if (mat.getNumEntries() == 0) {\n+                throw new IllegalStateException(\"not a MATPOWER stream: a structure named '\" + MATPOWER_STRUCT_NAME + \"' is expected.\");\n+            }\n+            Struct mpcStruct = mat.getStruct(MATPOWER_STRUCT_NAME);\n+            Set<String> mpcNames = new HashSet<>(Arrays.asList(\"version\", \"baseMVA\", \"bus\", \"gen\", \"branch\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTA3Mg==", "bodyText": "isn't Sets.of java9?  I changed it with a guava method, instead.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412821072", "createdAt": "2020-04-22T09:25:38Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.MatFile;\n+import us.hebi.matlab.mat.types.Matrix;\n+import us.hebi.matlab.mat.types.Sources;\n+import us.hebi.matlab.mat.types.Struct;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.powsybl.matpower.model.MatpowerReader.MATPOWER_SUPPORTED_VERSION;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerBinReader.class);\n+    public static final String MATPOWER_STRUCT_NAME = \"mpc\";\n+\n+    public MatpowerModel read(InputStream iStream, String caseName) throws IOException {\n+        MatpowerModel model = null;\n+        try (MatFile mat = Mat5.newReader(Sources.wrapInputStream(iStream)).setEntryFilter(entry -> entry.getName().equals(MATPOWER_STRUCT_NAME)).readMat()) {\n+            if (mat.getNumEntries() == 0) {\n+                throw new IllegalStateException(\"not a MATPOWER stream: a structure named '\" + MATPOWER_STRUCT_NAME + \"' is expected.\");\n+            }\n+            Struct mpcStruct = mat.getStruct(MATPOWER_STRUCT_NAME);\n+            Set<String> mpcNames = new HashSet<>(Arrays.asList(\"version\", \"baseMVA\", \"bus\", \"gen\", \"branch\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDAyMA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjEzMjE2OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0NDo0NVrOGHFVsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNjowOFrOGJsnsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDY4OA==", "bodyText": "It's old school code to use I/O ? Does a version with Path exists?\nWe should have an overload with a Path that call the version with the OutputStream (Files.newOutputStream(path))", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410080688", "createdAt": "2020-04-17T08:44:45Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.*;\n+import us.hebi.matlab.mat.util.Casts;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinWriter {\n+\n+    private final MatpowerModel model;\n+\n+    public MatpowerBinWriter(MatpowerModel model) {\n+        this.model = Objects.requireNonNull(model);\n+    }\n+\n+    private Struct fillMatStruct(Struct struct) {\n+        List<MBus> buses = model.getBuses();\n+        Matrix busesM = Mat5.newMatrix(buses.size(), 13);\n+        for (int row = 0; row < buses.size(); row++) {\n+            busesM.setDouble(row, 0, buses.get(row).getNumber());\n+            busesM.setDouble(row, 1, buses.get(row).getType().getValue());\n+            busesM.setDouble(row, 2, buses.get(row).getRealPowerDemand());\n+            busesM.setDouble(row, 3, buses.get(row).getReactivePowerDemand());\n+            busesM.setDouble(row, 4, buses.get(row).getShuntConductance());\n+            busesM.setDouble(row, 5, buses.get(row).getShuntSusceptance());\n+            busesM.setDouble(row, 6, buses.get(row).getAreaNumber());\n+            busesM.setDouble(row, 7, buses.get(row).getVoltageMagnitude());\n+            busesM.setDouble(row, 8, buses.get(row).getVoltageAngle());\n+            busesM.setDouble(row, 9, buses.get(row).getBaseVoltage());\n+            busesM.setDouble(row, 10, buses.get(row).getLossZone());\n+            busesM.setDouble(row, 11, buses.get(row).getMaximumVoltageMagnitude());\n+            busesM.setDouble(row, 12, buses.get(row).getMinimumVoltageMagnitude());\n+        }\n+\n+        List<MGen> gens = model.getGenerators();\n+        Matrix gensM = Mat5.newMatrix(gens.size(), 21);\n+        for (int row = 0; row < gens.size(); row++) {\n+            gensM.setDouble(row, 0, gens.get(row).getNumber());\n+            gensM.setDouble(row, 1, gens.get(row).getRealPowerOutput());\n+            gensM.setDouble(row, 2, gens.get(row).getReactivePowerOutput());\n+            gensM.setDouble(row, 3, gens.get(row).getMaximumReactivePowerOutput());\n+            gensM.setDouble(row, 4, gens.get(row).getMinimumReactivePowerOutput());\n+            gensM.setDouble(row, 5, gens.get(row).getVoltageMagnitudeSetpoint());\n+            gensM.setDouble(row, 6, gens.get(row).getTotalMbase());\n+            gensM.setDouble(row, 7, gens.get(row).getStatus());\n+            gensM.setDouble(row, 8, gens.get(row).getMaximumRealPowerOutput());\n+            gensM.setDouble(row, 9, gens.get(row).getMinimumRealPowerOutput());\n+            gensM.setDouble(row, 10, gens.get(row).getPc1());\n+            gensM.setDouble(row, 11, gens.get(row).getPc2());\n+            gensM.setDouble(row, 12, gens.get(row).getQc1Min());\n+            gensM.setDouble(row, 13, gens.get(row).getQc1Max());\n+            gensM.setDouble(row, 14, gens.get(row).getQc2Min());\n+            gensM.setDouble(row, 15, gens.get(row).getQc2Max());\n+            gensM.setDouble(row, 16, gens.get(row).getRampAgc());\n+            gensM.setDouble(row, 17, gens.get(row).getRampTenMinutes());\n+            gensM.setDouble(row, 18, gens.get(row).getRampThirtyMinutes());\n+            gensM.setDouble(row, 19, gens.get(row).getRampQ());\n+            gensM.setDouble(row, 20, gens.get(row).getApf());\n+        }\n+\n+        List<MBranch> branches = model.getBranches();\n+        Matrix branchesM = Mat5.newMatrix(branches.size(), 13);\n+        for (int row = 0; row < branches.size(); row++) {\n+            branchesM.setDouble(row, 0, branches.get(row).getFrom());\n+            branchesM.setDouble(row, 1, branches.get(row).getTo());\n+            branchesM.setDouble(row, 2, branches.get(row).getR());\n+            branchesM.setDouble(row, 3, branches.get(row).getX());\n+            branchesM.setDouble(row, 4, branches.get(row).getB());\n+            branchesM.setDouble(row, 5, branches.get(row).getRateA());\n+            branchesM.setDouble(row, 6, branches.get(row).getRateB());\n+            branchesM.setDouble(row, 7, branches.get(row).getRateC());\n+            branchesM.setDouble(row, 8, branches.get(row).getRatio());\n+            branchesM.setDouble(row, 9, branches.get(row).getPhaseShiftAngle());\n+            branchesM.setDouble(row, 10, branches.get(row).getStatus());\n+            branchesM.setDouble(row, 11, branches.get(row).getAngMin());\n+            branchesM.setDouble(row, 12, branches.get(row).getAngMax());\n+        }\n+\n+        struct.set(\"version\", Mat5.newString(\"2\"))\n+                .set(\"baseMVA\", Mat5.newScalar(100))\n+                .set(\"bus\", busesM)\n+                .set(\"gen\", gensM)\n+                .set(\"branch\", branchesM);\n+        return struct;\n+    }\n+\n+    public void write(File oFile) throws IOException {\n+        try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+            try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                Mat5.writeToFile(matFile, oFile);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTQyNw==", "bodyText": "done.", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412821427", "createdAt": "2020-04-22T09:26:08Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.*;\n+import us.hebi.matlab.mat.util.Casts;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinWriter {\n+\n+    private final MatpowerModel model;\n+\n+    public MatpowerBinWriter(MatpowerModel model) {\n+        this.model = Objects.requireNonNull(model);\n+    }\n+\n+    private Struct fillMatStruct(Struct struct) {\n+        List<MBus> buses = model.getBuses();\n+        Matrix busesM = Mat5.newMatrix(buses.size(), 13);\n+        for (int row = 0; row < buses.size(); row++) {\n+            busesM.setDouble(row, 0, buses.get(row).getNumber());\n+            busesM.setDouble(row, 1, buses.get(row).getType().getValue());\n+            busesM.setDouble(row, 2, buses.get(row).getRealPowerDemand());\n+            busesM.setDouble(row, 3, buses.get(row).getReactivePowerDemand());\n+            busesM.setDouble(row, 4, buses.get(row).getShuntConductance());\n+            busesM.setDouble(row, 5, buses.get(row).getShuntSusceptance());\n+            busesM.setDouble(row, 6, buses.get(row).getAreaNumber());\n+            busesM.setDouble(row, 7, buses.get(row).getVoltageMagnitude());\n+            busesM.setDouble(row, 8, buses.get(row).getVoltageAngle());\n+            busesM.setDouble(row, 9, buses.get(row).getBaseVoltage());\n+            busesM.setDouble(row, 10, buses.get(row).getLossZone());\n+            busesM.setDouble(row, 11, buses.get(row).getMaximumVoltageMagnitude());\n+            busesM.setDouble(row, 12, buses.get(row).getMinimumVoltageMagnitude());\n+        }\n+\n+        List<MGen> gens = model.getGenerators();\n+        Matrix gensM = Mat5.newMatrix(gens.size(), 21);\n+        for (int row = 0; row < gens.size(); row++) {\n+            gensM.setDouble(row, 0, gens.get(row).getNumber());\n+            gensM.setDouble(row, 1, gens.get(row).getRealPowerOutput());\n+            gensM.setDouble(row, 2, gens.get(row).getReactivePowerOutput());\n+            gensM.setDouble(row, 3, gens.get(row).getMaximumReactivePowerOutput());\n+            gensM.setDouble(row, 4, gens.get(row).getMinimumReactivePowerOutput());\n+            gensM.setDouble(row, 5, gens.get(row).getVoltageMagnitudeSetpoint());\n+            gensM.setDouble(row, 6, gens.get(row).getTotalMbase());\n+            gensM.setDouble(row, 7, gens.get(row).getStatus());\n+            gensM.setDouble(row, 8, gens.get(row).getMaximumRealPowerOutput());\n+            gensM.setDouble(row, 9, gens.get(row).getMinimumRealPowerOutput());\n+            gensM.setDouble(row, 10, gens.get(row).getPc1());\n+            gensM.setDouble(row, 11, gens.get(row).getPc2());\n+            gensM.setDouble(row, 12, gens.get(row).getQc1Min());\n+            gensM.setDouble(row, 13, gens.get(row).getQc1Max());\n+            gensM.setDouble(row, 14, gens.get(row).getQc2Min());\n+            gensM.setDouble(row, 15, gens.get(row).getQc2Max());\n+            gensM.setDouble(row, 16, gens.get(row).getRampAgc());\n+            gensM.setDouble(row, 17, gens.get(row).getRampTenMinutes());\n+            gensM.setDouble(row, 18, gens.get(row).getRampThirtyMinutes());\n+            gensM.setDouble(row, 19, gens.get(row).getRampQ());\n+            gensM.setDouble(row, 20, gens.get(row).getApf());\n+        }\n+\n+        List<MBranch> branches = model.getBranches();\n+        Matrix branchesM = Mat5.newMatrix(branches.size(), 13);\n+        for (int row = 0; row < branches.size(); row++) {\n+            branchesM.setDouble(row, 0, branches.get(row).getFrom());\n+            branchesM.setDouble(row, 1, branches.get(row).getTo());\n+            branchesM.setDouble(row, 2, branches.get(row).getR());\n+            branchesM.setDouble(row, 3, branches.get(row).getX());\n+            branchesM.setDouble(row, 4, branches.get(row).getB());\n+            branchesM.setDouble(row, 5, branches.get(row).getRateA());\n+            branchesM.setDouble(row, 6, branches.get(row).getRateB());\n+            branchesM.setDouble(row, 7, branches.get(row).getRateC());\n+            branchesM.setDouble(row, 8, branches.get(row).getRatio());\n+            branchesM.setDouble(row, 9, branches.get(row).getPhaseShiftAngle());\n+            branchesM.setDouble(row, 10, branches.get(row).getStatus());\n+            branchesM.setDouble(row, 11, branches.get(row).getAngMin());\n+            branchesM.setDouble(row, 12, branches.get(row).getAngMax());\n+        }\n+\n+        struct.set(\"version\", Mat5.newString(\"2\"))\n+                .set(\"baseMVA\", Mat5.newScalar(100))\n+                .set(\"bus\", busesM)\n+                .set(\"gen\", gensM)\n+                .set(\"branch\", branchesM);\n+        return struct;\n+    }\n+\n+    public void write(File oFile) throws IOException {\n+        try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+            try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                Mat5.writeToFile(matFile, oFile);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDY4OA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjEzODg5OnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0Njo0MVrOGHFaBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzozMFrOGJsrqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MTc5Ng==", "bodyText": "Could be static", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410081796", "createdAt": "2020-04-17T08:46:41Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.*;\n+import us.hebi.matlab.mat.util.Casts;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinWriter {\n+\n+    private final MatpowerModel model;\n+\n+    public MatpowerBinWriter(MatpowerModel model) {\n+        this.model = Objects.requireNonNull(model);\n+    }\n+\n+    private Struct fillMatStruct(Struct struct) {\n+        List<MBus> buses = model.getBuses();\n+        Matrix busesM = Mat5.newMatrix(buses.size(), 13);\n+        for (int row = 0; row < buses.size(); row++) {\n+            busesM.setDouble(row, 0, buses.get(row).getNumber());\n+            busesM.setDouble(row, 1, buses.get(row).getType().getValue());\n+            busesM.setDouble(row, 2, buses.get(row).getRealPowerDemand());\n+            busesM.setDouble(row, 3, buses.get(row).getReactivePowerDemand());\n+            busesM.setDouble(row, 4, buses.get(row).getShuntConductance());\n+            busesM.setDouble(row, 5, buses.get(row).getShuntSusceptance());\n+            busesM.setDouble(row, 6, buses.get(row).getAreaNumber());\n+            busesM.setDouble(row, 7, buses.get(row).getVoltageMagnitude());\n+            busesM.setDouble(row, 8, buses.get(row).getVoltageAngle());\n+            busesM.setDouble(row, 9, buses.get(row).getBaseVoltage());\n+            busesM.setDouble(row, 10, buses.get(row).getLossZone());\n+            busesM.setDouble(row, 11, buses.get(row).getMaximumVoltageMagnitude());\n+            busesM.setDouble(row, 12, buses.get(row).getMinimumVoltageMagnitude());\n+        }\n+\n+        List<MGen> gens = model.getGenerators();\n+        Matrix gensM = Mat5.newMatrix(gens.size(), 21);\n+        for (int row = 0; row < gens.size(); row++) {\n+            gensM.setDouble(row, 0, gens.get(row).getNumber());\n+            gensM.setDouble(row, 1, gens.get(row).getRealPowerOutput());\n+            gensM.setDouble(row, 2, gens.get(row).getReactivePowerOutput());\n+            gensM.setDouble(row, 3, gens.get(row).getMaximumReactivePowerOutput());\n+            gensM.setDouble(row, 4, gens.get(row).getMinimumReactivePowerOutput());\n+            gensM.setDouble(row, 5, gens.get(row).getVoltageMagnitudeSetpoint());\n+            gensM.setDouble(row, 6, gens.get(row).getTotalMbase());\n+            gensM.setDouble(row, 7, gens.get(row).getStatus());\n+            gensM.setDouble(row, 8, gens.get(row).getMaximumRealPowerOutput());\n+            gensM.setDouble(row, 9, gens.get(row).getMinimumRealPowerOutput());\n+            gensM.setDouble(row, 10, gens.get(row).getPc1());\n+            gensM.setDouble(row, 11, gens.get(row).getPc2());\n+            gensM.setDouble(row, 12, gens.get(row).getQc1Min());\n+            gensM.setDouble(row, 13, gens.get(row).getQc1Max());\n+            gensM.setDouble(row, 14, gens.get(row).getQc2Min());\n+            gensM.setDouble(row, 15, gens.get(row).getQc2Max());\n+            gensM.setDouble(row, 16, gens.get(row).getRampAgc());\n+            gensM.setDouble(row, 17, gens.get(row).getRampTenMinutes());\n+            gensM.setDouble(row, 18, gens.get(row).getRampThirtyMinutes());\n+            gensM.setDouble(row, 19, gens.get(row).getRampQ());\n+            gensM.setDouble(row, 20, gens.get(row).getApf());\n+        }\n+\n+        List<MBranch> branches = model.getBranches();\n+        Matrix branchesM = Mat5.newMatrix(branches.size(), 13);\n+        for (int row = 0; row < branches.size(); row++) {\n+            branchesM.setDouble(row, 0, branches.get(row).getFrom());\n+            branchesM.setDouble(row, 1, branches.get(row).getTo());\n+            branchesM.setDouble(row, 2, branches.get(row).getR());\n+            branchesM.setDouble(row, 3, branches.get(row).getX());\n+            branchesM.setDouble(row, 4, branches.get(row).getB());\n+            branchesM.setDouble(row, 5, branches.get(row).getRateA());\n+            branchesM.setDouble(row, 6, branches.get(row).getRateB());\n+            branchesM.setDouble(row, 7, branches.get(row).getRateC());\n+            branchesM.setDouble(row, 8, branches.get(row).getRatio());\n+            branchesM.setDouble(row, 9, branches.get(row).getPhaseShiftAngle());\n+            branchesM.setDouble(row, 10, branches.get(row).getStatus());\n+            branchesM.setDouble(row, 11, branches.get(row).getAngMin());\n+            branchesM.setDouble(row, 12, branches.get(row).getAngMax());\n+        }\n+\n+        struct.set(\"version\", Mat5.newString(\"2\"))\n+                .set(\"baseMVA\", Mat5.newScalar(100))\n+                .set(\"bus\", busesM)\n+                .set(\"gen\", gensM)\n+                .set(\"branch\", branchesM);\n+        return struct;\n+    }\n+\n+    public void write(File oFile) throws IOException {\n+        try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+            try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                Mat5.writeToFile(matFile, oFile);\n+            }\n+        }\n+    }\n+\n+    public void write(OutputStream oStream) throws IOException {\n+        try (WritableByteChannel channel = Channels.newChannel(oStream)) {\n+            try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+                try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                    ByteBuffer bBuffer = getByteBuffer(matFile);\n+                    channel.write(bBuffer);\n+                }\n+            }\n+        }\n+    }\n+\n+    private ByteBuffer getByteBuffer(MatFile matFile) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjQ0Mw==", "bodyText": "done:  changed this class' methods to static", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822443", "createdAt": "2020-04-22T09:27:30Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.*;\n+import us.hebi.matlab.mat.util.Casts;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinWriter {\n+\n+    private final MatpowerModel model;\n+\n+    public MatpowerBinWriter(MatpowerModel model) {\n+        this.model = Objects.requireNonNull(model);\n+    }\n+\n+    private Struct fillMatStruct(Struct struct) {\n+        List<MBus> buses = model.getBuses();\n+        Matrix busesM = Mat5.newMatrix(buses.size(), 13);\n+        for (int row = 0; row < buses.size(); row++) {\n+            busesM.setDouble(row, 0, buses.get(row).getNumber());\n+            busesM.setDouble(row, 1, buses.get(row).getType().getValue());\n+            busesM.setDouble(row, 2, buses.get(row).getRealPowerDemand());\n+            busesM.setDouble(row, 3, buses.get(row).getReactivePowerDemand());\n+            busesM.setDouble(row, 4, buses.get(row).getShuntConductance());\n+            busesM.setDouble(row, 5, buses.get(row).getShuntSusceptance());\n+            busesM.setDouble(row, 6, buses.get(row).getAreaNumber());\n+            busesM.setDouble(row, 7, buses.get(row).getVoltageMagnitude());\n+            busesM.setDouble(row, 8, buses.get(row).getVoltageAngle());\n+            busesM.setDouble(row, 9, buses.get(row).getBaseVoltage());\n+            busesM.setDouble(row, 10, buses.get(row).getLossZone());\n+            busesM.setDouble(row, 11, buses.get(row).getMaximumVoltageMagnitude());\n+            busesM.setDouble(row, 12, buses.get(row).getMinimumVoltageMagnitude());\n+        }\n+\n+        List<MGen> gens = model.getGenerators();\n+        Matrix gensM = Mat5.newMatrix(gens.size(), 21);\n+        for (int row = 0; row < gens.size(); row++) {\n+            gensM.setDouble(row, 0, gens.get(row).getNumber());\n+            gensM.setDouble(row, 1, gens.get(row).getRealPowerOutput());\n+            gensM.setDouble(row, 2, gens.get(row).getReactivePowerOutput());\n+            gensM.setDouble(row, 3, gens.get(row).getMaximumReactivePowerOutput());\n+            gensM.setDouble(row, 4, gens.get(row).getMinimumReactivePowerOutput());\n+            gensM.setDouble(row, 5, gens.get(row).getVoltageMagnitudeSetpoint());\n+            gensM.setDouble(row, 6, gens.get(row).getTotalMbase());\n+            gensM.setDouble(row, 7, gens.get(row).getStatus());\n+            gensM.setDouble(row, 8, gens.get(row).getMaximumRealPowerOutput());\n+            gensM.setDouble(row, 9, gens.get(row).getMinimumRealPowerOutput());\n+            gensM.setDouble(row, 10, gens.get(row).getPc1());\n+            gensM.setDouble(row, 11, gens.get(row).getPc2());\n+            gensM.setDouble(row, 12, gens.get(row).getQc1Min());\n+            gensM.setDouble(row, 13, gens.get(row).getQc1Max());\n+            gensM.setDouble(row, 14, gens.get(row).getQc2Min());\n+            gensM.setDouble(row, 15, gens.get(row).getQc2Max());\n+            gensM.setDouble(row, 16, gens.get(row).getRampAgc());\n+            gensM.setDouble(row, 17, gens.get(row).getRampTenMinutes());\n+            gensM.setDouble(row, 18, gens.get(row).getRampThirtyMinutes());\n+            gensM.setDouble(row, 19, gens.get(row).getRampQ());\n+            gensM.setDouble(row, 20, gens.get(row).getApf());\n+        }\n+\n+        List<MBranch> branches = model.getBranches();\n+        Matrix branchesM = Mat5.newMatrix(branches.size(), 13);\n+        for (int row = 0; row < branches.size(); row++) {\n+            branchesM.setDouble(row, 0, branches.get(row).getFrom());\n+            branchesM.setDouble(row, 1, branches.get(row).getTo());\n+            branchesM.setDouble(row, 2, branches.get(row).getR());\n+            branchesM.setDouble(row, 3, branches.get(row).getX());\n+            branchesM.setDouble(row, 4, branches.get(row).getB());\n+            branchesM.setDouble(row, 5, branches.get(row).getRateA());\n+            branchesM.setDouble(row, 6, branches.get(row).getRateB());\n+            branchesM.setDouble(row, 7, branches.get(row).getRateC());\n+            branchesM.setDouble(row, 8, branches.get(row).getRatio());\n+            branchesM.setDouble(row, 9, branches.get(row).getPhaseShiftAngle());\n+            branchesM.setDouble(row, 10, branches.get(row).getStatus());\n+            branchesM.setDouble(row, 11, branches.get(row).getAngMin());\n+            branchesM.setDouble(row, 12, branches.get(row).getAngMax());\n+        }\n+\n+        struct.set(\"version\", Mat5.newString(\"2\"))\n+                .set(\"baseMVA\", Mat5.newScalar(100))\n+                .set(\"bus\", busesM)\n+                .set(\"gen\", gensM)\n+                .set(\"branch\", branchesM);\n+        return struct;\n+    }\n+\n+    public void write(File oFile) throws IOException {\n+        try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+            try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                Mat5.writeToFile(matFile, oFile);\n+            }\n+        }\n+    }\n+\n+    public void write(OutputStream oStream) throws IOException {\n+        try (WritableByteChannel channel = Channels.newChannel(oStream)) {\n+            try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+                try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                    ByteBuffer bBuffer = getByteBuffer(matFile);\n+                    channel.write(bBuffer);\n+                }\n+            }\n+        }\n+    }\n+\n+    private ByteBuffer getByteBuffer(MatFile matFile) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MTc5Ng=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjE0MDkwOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0NzoyMFrOGHFbWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzozOFrOGJssAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjEzNw==", "bodyText": "Put these methods after the constructor", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082137", "createdAt": "2020-04-17T08:47:20Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerModel {\n+\n+    private final String caseName;\n+    private Double baseMva;\n+\n+    private List<MBus> buses = new ArrayList<>();\n+\n+    private List<MGen> generators = new ArrayList<>();\n+\n+    private List<MBranch> branches = new ArrayList<>();\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public void setVersion(String version) {\n+        this.version = version;\n+    }\n+\n+    private String version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjUzMQ==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822531", "createdAt": "2020-04-22T09:27:38Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerModel {\n+\n+    private final String caseName;\n+    private Double baseMva;\n+\n+    private List<MBus> buses = new ArrayList<>();\n+\n+    private List<MGen> generators = new ArrayList<>();\n+\n+    private List<MBranch> branches = new ArrayList<>();\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public void setVersion(String version) {\n+        this.version = version;\n+    }\n+\n+    private String version;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjEzNw=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjE0MTUyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0NzozMFrOGHFbug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzo0NFrOGJssSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjIzNA==", "bodyText": "Should be final", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082234", "createdAt": "2020-04-17T08:47:30Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerModel {\n+\n+    private final String caseName;\n+    private Double baseMva;\n+\n+    private List<MBus> buses = new ArrayList<>();\n+\n+    private List<MGen> generators = new ArrayList<>();\n+\n+    private List<MBranch> branches = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjYwMQ==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822601", "createdAt": "2020-04-22T09:27:44Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerModel {\n+\n+    private final String caseName;\n+    private Double baseMva;\n+\n+    private List<MBus> buses = new ArrayList<>();\n+\n+    private List<MGen> generators = new ArrayList<>();\n+\n+    private List<MBranch> branches = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjIzNA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjE0MzMyOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0ODowM1rOGHFc4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzo1MFrOGJssig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjUzMA==", "bodyText": "See my comment about constants", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082530", "createdAt": "2020-04-17T08:48:03Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjY2Ng==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822666", "createdAt": "2020-04-22T09:27:50Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjUzMA=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjE0NTcwOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo0ODo0M1rOGHFeUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzo1N1rOGJssyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mjg5Nw==", "bodyText": "To be check if some or all of these functions could be static", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082897", "createdAt": "2020-04-17T08:48:43Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";\n+\n+    private String processCaseName(String str) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjczMA==", "bodyText": "done:  changed this class' methods to static", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822730", "createdAt": "2020-04-22T09:27:57Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";\n+\n+    private String processCaseName(String str) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mjg5Nw=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjE1MDkxOnYy", "diffSide": "RIGHT", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODo1MDoxN1rOGHFhxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyODowNFrOGJstHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mzc4MQ==", "bodyText": "Use a double instead of a Double", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410083781", "createdAt": "2020-04-17T08:50:17Z", "author": {"login": "mathbagu"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";\n+\n+    private String processCaseName(String str) {\n+        String str2 = str.replace(';', ' ');\n+        final StringTokenizer st = new StringTokenizer(str2, \" \");\n+        st.nextToken(); // function\n+        st.nextToken(); // mpc\n+        st.nextToken(); // =\n+        return st.nextToken();\n+    }\n+\n+    private String processMatlabAssignment(String str) {\n+        Objects.requireNonNull(str);\n+        String str2 = str.replace(';', ' ');\n+        final StringTokenizer st = new StringTokenizer(str2, \" \");\n+        st.nextToken(); // mpc.XYZ\n+        st.nextToken(); // =\n+        return st.nextToken();\n+    }\n+\n+    private String processMatlabStringAssignment(String str) {\n+        return processMatlabAssignment(str).replace(\"'\", \"\");\n+    }\n+\n+    public MatpowerModel read(InputStream iStream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(iStream))) {\n+            return read(reader);\n+        }\n+    }\n+\n+    private boolean canSkipLine(String line) {\n+        return line.startsWith(\"%\") || (line.trim().length() == 0);\n+    }\n+\n+    public MatpowerModel read(BufferedReader reader) throws IOException {\n+        String line = reader.readLine();\n+\n+        String title = processCaseName(line);\n+        MatpowerModel model = new MatpowerModel(title);\n+\n+        MatpowerSection section = null;\n+        List<String> lines = new ArrayList<>();\n+        while ((line = reader.readLine()) != null) {\n+            if (canSkipLine(line)) {\n+                //skip comments and empty lines\n+            } else if (line.startsWith(\"mpc.version \")) {\n+                processVersion(line, model);\n+            }  else if (line.startsWith(\"mpc.baseMVA \")) {\n+                processBaseMva(line, model);\n+            } else if (line.startsWith(\"mpc.bus \")) {\n+                section = MatpowerSection.BUS;\n+            } else if (line.startsWith(\"mpc.gen \")) {\n+                section = MatpowerSection.GENERATOR;\n+            } else if (line.startsWith(\"mpc.branch \")) {\n+                section = MatpowerSection.BRANCH;\n+            } else if (line.startsWith(\"];\")) {\n+                section = processEndSection(model, section, lines);\n+            } else {\n+                if (section != null) {\n+                    lines.add(line);\n+                }\n+            }\n+        }\n+\n+        return model;\n+    }\n+\n+    private void processBaseMva(String line, MatpowerModel model) {\n+        Double baseMva = Double.parseDouble(processMatlabAssignment(line));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjgxMw==", "bodyText": "done", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822813", "createdAt": "2020-04-22T09:28:04Z", "author": {"login": "CBiasuzzi"}, "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";\n+\n+    private String processCaseName(String str) {\n+        String str2 = str.replace(';', ' ');\n+        final StringTokenizer st = new StringTokenizer(str2, \" \");\n+        st.nextToken(); // function\n+        st.nextToken(); // mpc\n+        st.nextToken(); // =\n+        return st.nextToken();\n+    }\n+\n+    private String processMatlabAssignment(String str) {\n+        Objects.requireNonNull(str);\n+        String str2 = str.replace(';', ' ');\n+        final StringTokenizer st = new StringTokenizer(str2, \" \");\n+        st.nextToken(); // mpc.XYZ\n+        st.nextToken(); // =\n+        return st.nextToken();\n+    }\n+\n+    private String processMatlabStringAssignment(String str) {\n+        return processMatlabAssignment(str).replace(\"'\", \"\");\n+    }\n+\n+    public MatpowerModel read(InputStream iStream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(iStream))) {\n+            return read(reader);\n+        }\n+    }\n+\n+    private boolean canSkipLine(String line) {\n+        return line.startsWith(\"%\") || (line.trim().length() == 0);\n+    }\n+\n+    public MatpowerModel read(BufferedReader reader) throws IOException {\n+        String line = reader.readLine();\n+\n+        String title = processCaseName(line);\n+        MatpowerModel model = new MatpowerModel(title);\n+\n+        MatpowerSection section = null;\n+        List<String> lines = new ArrayList<>();\n+        while ((line = reader.readLine()) != null) {\n+            if (canSkipLine(line)) {\n+                //skip comments and empty lines\n+            } else if (line.startsWith(\"mpc.version \")) {\n+                processVersion(line, model);\n+            }  else if (line.startsWith(\"mpc.baseMVA \")) {\n+                processBaseMva(line, model);\n+            } else if (line.startsWith(\"mpc.bus \")) {\n+                section = MatpowerSection.BUS;\n+            } else if (line.startsWith(\"mpc.gen \")) {\n+                section = MatpowerSection.GENERATOR;\n+            } else if (line.startsWith(\"mpc.branch \")) {\n+                section = MatpowerSection.BRANCH;\n+            } else if (line.startsWith(\"];\")) {\n+                section = processEndSection(model, section, lines);\n+            } else {\n+                if (section != null) {\n+                    lines.add(line);\n+                }\n+            }\n+        }\n+\n+        return model;\n+    }\n+\n+    private void processBaseMva(String line, MatpowerModel model) {\n+        Double baseMva = Double.parseDouble(processMatlabAssignment(line));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mzc4MQ=="}, "originalCommit": {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 151, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}