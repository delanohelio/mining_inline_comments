{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1NDgzMTAx", "number": 8791, "title": "[remoteopenhab] Remote openHAB binding - initial contribution", "bodyText": "Fix #8407\nSigned-off-by: Laurent Garnier lg.hc@free.fr\nHere is what is already done and what remains to do:\n\n Discover any openHAB remote servers using mDNS\n Detect the version of a remote server, set the thing to OFFLINE for OH1 servers\n Build dynamically one channel for each item (or group with state) on the remote server\n Consider state options from the remote item\n Receive item states from SSE and update the local channel for all of the remote item types (String, Number, DateTime, ...)\n Receive item states from SSE and update the local channel for remote item of type Number with a dimension like Number:Temperature\n Receive item states from SSE and update the local channel for remote item of type Group (having a state)\n Transfer any command to the remote server\n Detect the changes of items in the remote server and update accordingly the channels in the local thing\n Check connection to the remote server and handle reconnection\n Allow REST API with access token as an option for remote OH3 servers\n Write the documentation", "createdAt": "2020-10-18T14:37:42Z", "url": "https://github.com/openhab/openhab-addons/pull/8791", "merged": true, "mergeCommit": {"oid": "4646ea68c3a2a61fcd3e075253504b87ffdacdcb"}, "closed": true, "closedAt": "2020-10-26T21:39:20Z", "author": {"login": "lolodomo"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTxpvOABqjM4OTAzNzE4MDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdWbZJCAFqTUxNzE5NTYwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "891aad6631609ee4b40d1d09b5b43364726928d8", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/891aad6631609ee4b40d1d09b5b43364726928d8", "committedDate": "2020-10-18T14:33:39Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "023b3589c4f2f270c9a07e5f0771115b70942832", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/023b3589c4f2f270c9a07e5f0771115b70942832", "committedDate": "2020-10-18T15:52:08Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "023b3589c4f2f270c9a07e5f0771115b70942832", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/023b3589c4f2f270c9a07e5f0771115b70942832", "committedDate": "2020-10-18T15:52:08Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "committedDate": "2020-10-18T16:36:44Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/e37762b0baf13b94ab257e5f9f0696a1ecf5eedf", "committedDate": "2020-10-18T16:36:44Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "332da34cd131b5797a00aa8b48d8fd5110013422", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/332da34cd131b5797a00aa8b48d8fd5110013422", "committedDate": "2020-10-19T22:51:30Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "332da34cd131b5797a00aa8b48d8fd5110013422", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/332da34cd131b5797a00aa8b48d8fd5110013422", "committedDate": "2020-10-19T22:51:30Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "5e078b7c3c989058f6c29adce34e9ea5886df99b", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/5e078b7c3c989058f6c29adce34e9ea5886df99b", "committedDate": "2020-10-19T23:11:18Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e078b7c3c989058f6c29adce34e9ea5886df99b", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/5e078b7c3c989058f6c29adce34e9ea5886df99b", "committedDate": "2020-10-19T23:11:18Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "335f18e30dddff63ee31f101dd58b9cda870055a", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/335f18e30dddff63ee31f101dd58b9cda870055a", "committedDate": "2020-10-19T23:45:49Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "335f18e30dddff63ee31f101dd58b9cda870055a", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/335f18e30dddff63ee31f101dd58b9cda870055a", "committedDate": "2020-10-19T23:45:49Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "committedDate": "2020-10-20T12:34:43Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/a8e914959e42b92a45aacbfb9fac8a7c1fb2333e", "committedDate": "2020-10-20T12:34:43Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "d752da047f972112f9a3ac01e557acc150b205c8", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d752da047f972112f9a3ac01e557acc150b205c8", "committedDate": "2020-10-20T12:46:46Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d752da047f972112f9a3ac01e557acc150b205c8", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d752da047f972112f9a3ac01e557acc150b205c8", "committedDate": "2020-10-20T12:46:46Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "committedDate": "2020-10-20T18:32:21Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/35cdf41c5e5c1ab5c3bf900ac975a12918c09068", "committedDate": "2020-10-20T18:32:21Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "a95bdbfa2b6335e53d419720ad294a8c38078acc", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/a95bdbfa2b6335e53d419720ad294a8c38078acc", "committedDate": "2020-10-21T21:14:45Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a95bdbfa2b6335e53d419720ad294a8c38078acc", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/a95bdbfa2b6335e53d419720ad294a8c38078acc", "committedDate": "2020-10-21T21:14:45Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "978d18e87a8056157d3ab3963b676727b1c8a744", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/978d18e87a8056157d3ab3963b676727b1c8a744", "committedDate": "2020-10-21T22:47:55Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "978d18e87a8056157d3ab3963b676727b1c8a744", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/978d18e87a8056157d3ab3963b676727b1c8a744", "committedDate": "2020-10-21T22:47:55Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "committedDate": "2020-10-22T11:27:34Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d66d0c7d2aa633cdd435c73c2be2b7a8fed69568", "committedDate": "2020-10-22T11:27:34Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "b623bd4cc53f5fe6b10ef91ce0be832b67748003", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/b623bd4cc53f5fe6b10ef91ce0be832b67748003", "committedDate": "2020-10-22T18:27:58Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/3dc867e53fe095f9925c318f8b1963318874020d", "committedDate": "2020-10-23T20:12:45Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b623bd4cc53f5fe6b10ef91ce0be832b67748003", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/b623bd4cc53f5fe6b10ef91ce0be832b67748003", "committedDate": "2020-10-22T18:27:58Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/3dc867e53fe095f9925c318f8b1963318874020d", "committedDate": "2020-10-23T20:12:45Z", "message": "[remoteopenhab] Remote openhab binding - initial contributionn\n\nFix #8407\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MTU2MDEx", "url": "https://github.com/openhab/openhab-addons/pull/8791#pullrequestreview-516156011", "createdAt": "2020-10-24T03:42:56Z", "commit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMzo0Mjo1NlrOHnnE_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNDowNzo0NVrOHnnn5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njc2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    createChannels(items, false);\n          \n          \n            \n                    createChannels(List.of(item), false);", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296767", "createdAt": "2020-10-24T03:42:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5Njg0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Item> items = new ArrayList<>();\n          \n          \n            \n                    items.add(item);\n          \n          \n            \n                    removeChannels(items);\n          \n          \n            \n                    removeChannels(List.of(item));", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511296843", "createdAt": "2020-10-24T03:43:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDI1NA==", "bodyText": "In this circumstance it would be better to synchronize on the client itself rather than 'this'.\nAlso it seems wasteful to remove and re-add yourself as a listener every time you restart the client so I've adjusted the restartStreamingUpdates code accordingly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    synchronized (this) {\n          \n          \n            \n                        stopStreamingUpdates();\n          \n          \n            \n                        startStreamingUpdates();\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (this) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void restartStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized(client){\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void startStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.addStreamingDataListener(this);\n          \n          \n            \n                            client.start();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void stopStreamingUpdates() {\n          \n          \n            \n                    RemoteopenhabRestClient client = restClient;\n          \n          \n            \n                    if (client != null) {\n          \n          \n            \n                        synchronized (client) {\n          \n          \n            \n                            client.stop();\n          \n          \n            \n                            client.removeStreamingDataListener(this);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300254", "createdAt": "2020-10-24T03:53:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMDY0NA==", "bodyText": "Might as well cover all your bases.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n          \n          \n            \n                    if (localCheckConnectionJob == null || localCheckConnectionJob.isDone()) {", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511300644", "createdAt": "2020-10-24T03:54:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwMzE2OA==", "bodyText": "Please cache channelState.toFullString() to a local variable.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511303168", "createdAt": "2020-10-24T04:01:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private String getRestUrl() {\n+        String url = config.restUrl.trim();\n+        if (url.endsWith(\"/\")) {\n+            url = url.substring(0, url.length() - 1);\n+        }\n+        return url;\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        synchronized (this) {\n+            stopStreamingUpdates();\n+            startStreamingUpdates();\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (this) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        createChannels(items, false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        List<Item> items = new ArrayList<>();\n+        items.add(item);\n+        removeChannels(items);\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);\n+        } else {\n+            logger.trace(\"Updated remote item {} ignored because item type {} is unchanged\", newItem.name,\n+                    newItem.type);\n+        }\n+    }\n+\n+    private void updateChannelState(String itemName, @Nullable String stateType, String state) {\n+        Channel channel = getThing().getChannel(itemName);\n+        if (channel == null) {\n+            logger.trace(\"No channel for item {}\", itemName);\n+            return;\n+        }\n+        String acceptedItemType = channel.getAcceptedItemType();\n+        if (acceptedItemType == null) {\n+            logger.trace(\"Channel without accepted item type for item {}\", itemName);\n+            return;\n+        }\n+        if (!isLinked(channel.getUID())) {\n+            logger.trace(\"Unlinked channel {}\", channel.getUID());\n+            return;\n+        }\n+        State channelState = null;\n+        if (stateType == null && \"NULL\".equals(state)) {\n+            channelState = UnDefType.NULL;\n+        } else if (stateType == null && \"UNDEF\".equals(state)) {\n+            channelState = UnDefType.UNDEF;\n+        } else if (\"UnDef\".equals(stateType)) {\n+            switch (state) {\n+                case \"NULL\":\n+                    channelState = UnDefType.NULL;\n+                    break;\n+                case \"UNDEF\":\n+                    channelState = UnDefType.UNDEF;\n+                    break;\n+                default:\n+                    logger.debug(\"Invalid UnDef value {} for item {}\", state, itemName);\n+                    break;\n+            }\n+        } else if (acceptedItemType.startsWith(CoreItemFactory.NUMBER + \":\")) {\n+            // Item type Number with dimension\n+            if (checkStateType(itemName, stateType, \"Quantity\")) {\n+                List<Class<? extends State>> stateTypes = Collections.singletonList(QuantityType.class);\n+                channelState = TypeParser.parseState(stateTypes, state);\n+            }\n+        } else {\n+            switch (acceptedItemType) {\n+                case CoreItemFactory.STRING:\n+                    if (checkStateType(itemName, stateType, \"String\")) {\n+                        channelState = new StringType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.NUMBER:\n+                    if (checkStateType(itemName, stateType, \"Decimal\")) {\n+                        channelState = new DecimalType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.SWITCH:\n+                    if (checkStateType(itemName, stateType, \"OnOff\")) {\n+                        channelState = \"ON\".equals(state) ? OnOffType.ON : OnOffType.OFF;\n+                    }\n+                    break;\n+                case CoreItemFactory.CONTACT:\n+                    if (checkStateType(itemName, stateType, \"OpenClosed\")) {\n+                        channelState = \"OPEN\".equals(state) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                    }\n+                    break;\n+                case CoreItemFactory.DIMMER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.COLOR:\n+                    if (checkStateType(itemName, stateType, \"HSB\")) {\n+                        channelState = HSBType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.DATETIME:\n+                    if (checkStateType(itemName, stateType, \"DateTime\")) {\n+                        try {\n+                            channelState = new DateTimeType(ZonedDateTime.parse(state, FORMATTER_DATE));\n+                        } catch (DateTimeParseException e) {\n+                            logger.debug(\"Failed to parse date {} for item {}\", state, itemName);\n+                            channelState = null;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.LOCATION:\n+                    if (checkStateType(itemName, stateType, \"Point\")) {\n+                        channelState = new PointType(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.IMAGE:\n+                    if (checkStateType(itemName, stateType, \"Raw\")) {\n+                        channelState = RawType.valueOf(state);\n+                    }\n+                    break;\n+                case CoreItemFactory.PLAYER:\n+                    if (checkStateType(itemName, stateType, \"PlayPause\")) {\n+                        switch (state) {\n+                            case \"PLAY\":\n+                                channelState = PlayPauseType.PLAY;\n+                                break;\n+                            case \"PAUSE\":\n+                                channelState = PlayPauseType.PAUSE;\n+                                break;\n+                            default:\n+                                logger.debug(\"Unexpected value {} for item {}\", state, itemName);\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                case CoreItemFactory.ROLLERSHUTTER:\n+                    if (checkStateType(itemName, stateType, \"Percent\")) {\n+                        channelState = new PercentType(state);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"Item type {} is not yet supported\", acceptedItemType);\n+                    break;\n+            }\n+        }\n+        if (channelState != null) {\n+            updateState(channel.getUID(), channelState);\n+            logger.debug(\"updateState {} with {}\", channel.getUID(),\n+                    channelState.toFullString().length() < 50 ? channelState.toFullString()\n+                            : channelState.toFullString().substring(0, 50) + \"...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTEyNQ==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305125", "createdAt": "2020-10-24T04:06:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabThingHandler extends BaseThingHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabThingHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabThingHandler(Thing thing, ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(thing);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB thing handler\");\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        String url = getRestUrl();\n+        if (url.length() == 0 || !url.startsWith(\"http:\")) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Please setup a HTTP REST URL in the thing configuration\");\n+        } else {\n+            logger.debug(\"REST URL = {}\", url);\n+\n+            RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                    config.token, url);\n+            restClient = client;\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            startCheckConnectionJob(client);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB thing handler\");\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        command.toFullString().length() < 50 ? command.toFullString()\n+                                : command.toFullString().substring(0, 50) + \"...\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMwNTcwMQ==", "bodyText": "I think this javadoc needs to be updated", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511305701", "createdAt": "2020-10-24T04:07:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabThingHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This bridge handler connects to Nest and handles all the API requests. It pulls down the\n+ * updated data, polls the system and does all the co-ordination with the other handlers\n+ * to get the data updated to the correct things.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc867e53fe095f9925c318f8b1963318874020d"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "678d76ffde124beb440c5e418f35fc593b5a03e6", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/678d76ffde124beb440c5e418f35fc593b5a03e6", "committedDate": "2020-10-24T08:43:56Z", "message": "Review comment: List.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "184d00e637e6dd7da2a314c15899a43ebaddd92e", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/184d00e637e6dd7da2a314c15899a43ebaddd92e", "committedDate": "2020-10-24T08:52:31Z", "message": "Review comment: synchronized on restClient rather than thingHandler\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4de2cc7da1d3442ca277a69c47169b5e26a4bbe", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/b4de2cc7da1d3442ca277a69c47169b5e26a4bbe", "committedDate": "2020-10-24T09:09:21Z", "message": "Review comment: cache channelState.toFullString() and command.toFullString() to local variables\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0f4e3f868826a1d85926fc598fb356d81a55e66", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/e0f4e3f868826a1d85926fc598fb356d81a55e66", "committedDate": "2020-10-24T09:17:10Z", "message": "Review comment: class description (thing handler)\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/81f2e2faf5d54ee22f8c579d08c37ef95508e197", "committedDate": "2020-10-24T09:59:57Z", "message": "Switch the thing to a bridge to prepare the near future\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mjk4ODQy", "url": "https://github.com/openhab/openhab-addons/pull/8791#pullrequestreview-516298842", "createdAt": "2020-10-24T18:47:31Z", "commit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MzA5MDYx", "url": "https://github.com/openhab/openhab-addons/pull/8791#pullrequestreview-516309061", "createdAt": "2020-10-24T21:42:02Z", "commit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo0MjowM1rOHn0ikw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMTo1MzowMFrOHn0mVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzMzMQ==", "bodyText": "May I ask why? Could that maybe be an optional configuration parameter, if people would like to have encrypted traffic in their local network?", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517331", "createdAt": "2020-10-24T21:42:03Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzUxMg==", "bodyText": "I would find it much more straight forward to simply have the ip address (or hostname) as a configuration parameter - it is imho much more convenient for users when doing textual configuration. Furthermore, that's the standard way we also identify other devices/services on the network.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517512", "createdAt": "2020-10-24T21:44:53Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzcyMg==", "bodyText": "I'd suggest this change to make it clearer that \"Date\" is just some item name here (and not a type or keyword):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }\n          \n          \n            \n            DateTime MyDate \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:MyDate\" }", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517722", "createdAt": "2020-10-24T21:46:29Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/README.md", "diffHunk": "@@ -0,0 +1,64 @@\n+# Remote openHAB Binding\n+\n+The Remote openHAB binding allows to communicate with remote openHAB servers.\n+The communication is bidirectional.\n+The binding on the local server listens to any item state updates on the remote server and updates accordingly the linked channel on the local server.\n+It also transfers any item command from the local server to the remote server.\n+\n+One first usage is the distribution of your home automation system on a set of openHAB servers.\n+\n+A second usage is for users having old openHAB v1 bindings running that were not migrated to openHAB v2 or openHAB v3.\n+They can keep an openHAB v2 server to run their old openHAB v1 bindings and setup a new openHAB v3 server for everything else.\n+The Remote openHAB binding installed on the openHAB v3 server will then allow to use the openHAB v1 bindings through communication with the openHAB v2 server.\n+\n+A third usage is for users that would like to keep unchanged an existing openHAB v2 server but would like to use the new UI from openHAB v3; they can simply setup a new openHAB v3 server with the Remote openHAB binding linked to their openHAB v2 server.\n+\n+## Supported Things\n+\n+There is one unique supported thing : the `server` bridge thing \n+\n+## Discovery\n+\n+All openHAB servers in the local network are automatically discovered (through mDNS) by the binding.\n+You will find in the inbox one discovery thing per remote server interface.\n+So if your remote server has one IPv4 address and one IPv6 address, you will discover two things in the inbox.\n+Just choose one of the two things.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter | Required | Description                                                                                            |\n+|-----------|-------------------------------------------------------------------------------------------------------------------|\n+| restUrl   | yes      | The REST URL of the remote openHAB server.                                                             |\n+| token     | no       | The token to use when the remote openHAB server is setup to require authorization to run its REST API. |\n+\n+## Channels\n+\n+The channels are built dynamically and automatically by the binding.\n+One channel is created for each item from the remote server.\n+Only basic groups (with no state) are ignored.\n+The channel id of the built channel corresponds to the name of the item on the remote server.\n+\n+## Limitations\n+\n+* The binding will not try to communicate with an openHAB v1 server.\n+* The binding only uses the HTTP protocol for the communications with the remote server (not HTTPS).\n+\n+## Example\n+\n+### demo.things:\n+\n+```\n+Bridge remoteopenhab:server:oh2 \"OH2 server\" [ restUrl=\"http://192.168.0.100:8080/rest\" ]\n+```\n+\n+### demo.items:\n+\n+```\n+DateTime Date \"Date [%1$tA %1$td %1$tR]\" <calendar> { channel=\"remoteopenhab:server:oh2:Date\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzc5OQ==", "bodyText": "Please at least one line of JavaDoc.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517799", "createdAt": "2020-10-24T21:47:19Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/RemoteopenhabChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeProvider;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNzk4Nw==", "bodyText": "Don't add the IP to the label, but make it the representation property instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n          \n          \n            \n                        String label = \"openHAB Server\";", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511517987", "createdAt": "2020-10-24T21:49:47Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODAxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n          \n          \n            \n                        logger.debug(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518011", "createdAt": "2020-10-24T21:49:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxODI5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Remote Server</label>\n          \n          \n            \n            \t\t<label>Remote openHAB Server</label>", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511518295", "createdAt": "2020-10-24T21:53:00Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,28 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"remoteopenhab\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"server\">\n+\t\t<label>Remote Server</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81f2e2faf5d54ee22f8c579d08c37ef95508e197"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/761b31eb8795e521e507859e4b4b381028b4d905", "committedDate": "2020-10-24T22:15:48Z", "message": "Do not create discovery results for the local server\n\nImproved checking of the configuration setting validity at thing handler initialization\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9117730f3bd25575e616742680cf13c691bd5c70", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/9117730f3bd25575e616742680cf13c691bd5c70", "committedDate": "2020-10-24T22:45:22Z", "message": "Review comment: Item example changed in the documentation\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MzExMDg4", "url": "https://github.com/openhab/openhab-addons/pull/8791#pullrequestreview-516311088", "createdAt": "2020-10-24T22:26:20Z", "commit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjoyNjoyMFrOHn0waA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMjozOTo0OVrOHn0z-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMDg3Mg==", "bodyText": "This suggestion will be automated by openhab/static-code-analysis#395:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n          \n          \n            \n            <features name=\"org.openhab.binding.remoteopenhab-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511520872", "createdAt": "2020-10-24T22:26:20Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.nest-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTMxMQ==", "bodyText": "This can be a one liner in Java 11:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new HashMap<>(1);\n          \n          \n            \n                        properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);\n          \n          \n            \n                        Map<String, Object> properties = Map.of(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521311", "createdAt": "2020-10-24T22:32:29Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/discovery/RemoteopenhabDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.discovery;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RemoteopenhabDiscoveryParticipant} is responsible for discovering\n+ * the remote openHAB servers using mDNS discovery service.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MDNSDiscoveryParticipant.class, configurationPid = \"mdnsdiscovery.remoteopenhab\")\n+public class RemoteopenhabDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private static final String SERVICE_TYPE = \"_openhab-server._tcp.local.\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return SERVICE_TYPE;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getThingUID(ServiceInfo service) {\n+        // We use the first host address as thing ID\n+        // Host address matching a local IP address are ignored\n+        if (getServiceType().equals(service.getType()) && service.getHostAddresses() != null\n+                && service.getHostAddresses().length > 0 && !service.getHostAddresses()[0].isEmpty()\n+                && !matchLocalIpAddress(service.getHostAddresses()[0])) {\n+            return new ThingUID(BRIDGE_TYPE_SERVER, service.getHostAddresses()[0].replaceAll(\"[^A-Za-z0-9_]\", \"_\"));\n+        }\n+        return null;\n+    }\n+\n+    private boolean matchLocalIpAddress(String serviceHostAddress) {\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        return localIpAddresses.contains(serviceHostAddress.replaceAll(\"\\\\[|\\\\]\", \"\"));\n+    }\n+\n+    @Override\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n+        logger.debug(\"createResult ServiceInfo: {}\", service);\n+        DiscoveryResult result = null;\n+        String url = null;\n+        if (service.getURLs() != null && service.getURLs().length > 0 && !service.getURLs()[0].isEmpty()) {\n+            url = service.getURLs()[0];\n+        }\n+        String restPath = service.getPropertyString(\"uri\");\n+        ThingUID thingUID = getThingUID(service);\n+        if (thingUID != null && url != null && restPath != null) {\n+            String label = \"openHAB server IP \" + service.getHostAddresses()[0];\n+            logger.info(\"Created a DiscoveryResult for remote openHAB server {} with REST URL {}\", thingUID,\n+                    url + restPath);\n+            Map<String, Object> properties = new HashMap<>(1);\n+            properties.put(RemoteopenhabInstanceConfiguration.REST_URL, url + restPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTU1Ng==", "bodyText": "Can you turn the magic number 50 into a constant with a descriptive name? It's also used below on line 541.", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521556", "createdAt": "2020-10-24T22:36:06Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyMTc4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Item> items = new ArrayList<>();\n          \n          \n            \n                        items.add(newItem);\n          \n          \n            \n                        createChannels(items, false);\n          \n          \n            \n                        createChannels(List.of(newItem), false);", "url": "https://github.com/openhab/openhab-addons/pull/8791#discussion_r511521784", "createdAt": "2020-10-24T22:39:49Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.remoteopenhab/src/main/java/org/openhab/binding/remoteopenhab/internal/handler/RemoteopenhabBridgeHandler.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.remoteopenhab.internal.handler;\n+\n+import static org.openhab.binding.remoteopenhab.internal.RemoteopenhabBindingConstants.BINDING_ID;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabChannelTypeProvider;\n+import org.openhab.binding.remoteopenhab.internal.RemoteopenhabStateDescriptionOptionProvider;\n+import org.openhab.binding.remoteopenhab.internal.config.RemoteopenhabInstanceConfiguration;\n+import org.openhab.binding.remoteopenhab.internal.data.Item;\n+import org.openhab.binding.remoteopenhab.internal.data.Option;\n+import org.openhab.binding.remoteopenhab.internal.data.StateDescription;\n+import org.openhab.binding.remoteopenhab.internal.exceptions.RemoteopenhabException;\n+import org.openhab.binding.remoteopenhab.internal.listener.RemoteopenhabStreamingDataListener;\n+import org.openhab.binding.remoteopenhab.internal.rest.RemoteopenhabRestClient;\n+import org.openhab.core.library.CoreItemFactory;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.PlayPauseType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.thing.type.AutoUpdatePolicy;\n+import org.openhab.core.thing.type.ChannelKind;\n+import org.openhab.core.thing.type.ChannelType;\n+import org.openhab.core.thing.type.ChannelTypeBuilder;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RemoteopenhabBridgeHandler} is responsible for handling commands and updating states\n+ * using the REST API of the remote openHAB server.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RemoteopenhabBridgeHandler extends BaseBridgeHandler implements RemoteopenhabStreamingDataListener {\n+\n+    private static final String DATE_FORMAT_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN);\n+\n+    private static final long CONNECTION_TIMEOUT_MILLIS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n+\n+    private final Logger logger = LoggerFactory.getLogger(RemoteopenhabBridgeHandler.class);\n+\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final RemoteopenhabChannelTypeProvider channelTypeProvider;\n+    private final RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final Gson jsonParser;\n+\n+    private final Object updateThingLock = new Object();\n+\n+    private @NonNullByDefault({}) RemoteopenhabInstanceConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> checkConnectionJob;\n+    private @Nullable RemoteopenhabRestClient restClient;\n+\n+    public RemoteopenhabBridgeHandler(Bridge bridge, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, RemoteopenhabChannelTypeProvider channelTypeProvider,\n+            RemoteopenhabStateDescriptionOptionProvider stateDescriptionProvider, final Gson jsonParser) {\n+        super(bridge);\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.channelTypeProvider = channelTypeProvider;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.jsonParser = jsonParser;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing remote openHAB handler for bridge {}\", getThing().getUID());\n+\n+        config = getConfigAs(RemoteopenhabInstanceConfiguration.class);\n+\n+        if (config.restUrl.trim().length() == 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Undefined REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        URL url;\n+        try {\n+            url = new URL(config.restUrl.trim());\n+        } catch (MalformedURLException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        if (!\"http\".equals(url.getProtocol())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Use HTTP protocol for the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+        List<String> localIpAddresses = NetUtil.getAllInterfaceAddresses().stream()\n+                .filter(a -> !a.getAddress().isLinkLocalAddress())\n+                .map(a -> a.getAddress().getHostAddress().split(\"%\")[0]).collect(Collectors.toList());\n+        if (localIpAddresses.contains(url.getHost().replaceAll(\"\\\\[|\\\\]\", \"\"))) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Do not link the local server with the REST URL setting in the thing configuration\");\n+            return;\n+        }\n+\n+        String urlStr = url.toString();\n+        if (urlStr.endsWith(\"/\")) {\n+            urlStr = urlStr.substring(0, urlStr.length() - 1);\n+        }\n+        logger.debug(\"REST URL = {}\", urlStr);\n+\n+        RemoteopenhabRestClient client = new RemoteopenhabRestClient(clientBuilder, eventSourceFactory, jsonParser,\n+                config.token, urlStr);\n+        restClient = client;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startCheckConnectionJob(client);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing remote openHAB handler for bridge {}\", getThing().getUID());\n+        stopStreamingUpdates();\n+        stopCheckConnectionJob();\n+        this.restClient = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+        RemoteopenhabRestClient client = restClient;\n+        if (client == null) {\n+            return;\n+        }\n+\n+        try {\n+            if (command instanceof RefreshType) {\n+                String state = client.getRemoteItemState(channelUID.getId());\n+                updateChannelState(channelUID.getId(), null, state);\n+            } else if (isLinked(channelUID)) {\n+                client.sendCommandToRemoteItem(channelUID.getId(), command);\n+                String commandStr = command.toFullString();\n+                logger.debug(\"Sending command {} to remote item {} succeeded\",\n+                        commandStr.length() < 50 ? commandStr : commandStr.substring(0, 50) + \"...\",\n+                        channelUID.getId());\n+            }\n+        } catch (RemoteopenhabException e) {\n+            logger.debug(\"{}\", e.getMessage());\n+        }\n+    }\n+\n+    private void createChannels(List<Item> items, boolean replace) {\n+        synchronized (updateThingLock) {\n+            int nbGroups = 0;\n+            List<Channel> channels = new ArrayList<>();\n+            for (Item item : items) {\n+                String itemType = item.type;\n+                if (\"Group\".equals(itemType)) {\n+                    if (item.groupType.isEmpty()) {\n+                        // Standard groups are ignored\n+                        nbGroups++;\n+                        continue;\n+                    } else {\n+                        itemType = item.groupType;\n+                    }\n+                }\n+                String channelTypeId = String.format(\"item%s\", itemType.replace(\":\", \"\"));\n+                ChannelTypeUID channelTypeUID = new ChannelTypeUID(BINDING_ID, channelTypeId);\n+                ChannelType channelType = channelTypeProvider.getChannelType(channelTypeUID, null);\n+                String label;\n+                String description;\n+                if (channelType == null) {\n+                    logger.trace(\"Create the channel type {} for item type {}\", channelTypeUID, itemType);\n+                    label = String.format(\"Remote %s Item\", itemType);\n+                    description = String.format(\"An item of type %s from the remote server.\", itemType);\n+                    channelType = ChannelTypeBuilder.state(channelTypeUID, label, itemType).withDescription(description)\n+                            .withAutoUpdatePolicy(AutoUpdatePolicy.VETO).build();\n+                    channelTypeProvider.addChannelType(channelType);\n+                }\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), item.name);\n+                logger.trace(\"Create the channel {} of type {}\", channelUID, channelTypeUID);\n+                label = item.name;\n+                description = String.format(\"Item %s from the remote server.\", item.name);\n+                channels.add(ChannelBuilder.create(channelUID, itemType).withType(channelTypeUID)\n+                        .withKind(ChannelKind.STATE).withLabel(label).withDescription(description).build());\n+            }\n+            ThingBuilder thingBuilder = editThing();\n+            if (replace) {\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels defined for the thing {} (from {} items including {} groups)\",\n+                        channels.size(), getThing().getUID(), items.size(), nbGroups);\n+            } else if (channels.size() > 0) {\n+                int nbRemoved = 0;\n+                for (Channel channel : channels) {\n+                    if (getThing().getChannel(channel.getUID()) != null) {\n+                        thingBuilder.withoutChannel(channel.getUID());\n+                        nbRemoved++;\n+                    }\n+                }\n+                if (nbRemoved > 0) {\n+                    logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                            items.size());\n+                }\n+                for (Channel channel : channels) {\n+                    thingBuilder.withChannel(channel);\n+                }\n+                updateThing(thingBuilder.build());\n+                if (nbGroups > 0) {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items including {} groups)\",\n+                            channels.size(), getThing().getUID(), items.size(), nbGroups);\n+                } else {\n+                    logger.debug(\"{} channels added for the thing {} (from {} items)\", channels.size(),\n+                            getThing().getUID(), items.size());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void removeChannels(List<Item> items) {\n+        synchronized (updateThingLock) {\n+            int nbRemoved = 0;\n+            ThingBuilder thingBuilder = editThing();\n+            for (Item item : items) {\n+                Channel channel = getThing().getChannel(item.name);\n+                if (channel != null) {\n+                    thingBuilder.withoutChannel(channel.getUID());\n+                    nbRemoved++;\n+                }\n+            }\n+            if (nbRemoved > 0) {\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{} channels removed for the thing {} (from {} items)\", nbRemoved, getThing().getUID(),\n+                        items.size());\n+            }\n+        }\n+    }\n+\n+    private void setStateOptions(List<Item> items) {\n+        for (Item item : items) {\n+            Channel channel = getThing().getChannel(item.name);\n+            StateDescription descr = item.stateDescription;\n+            List<Option> options = descr == null ? null : descr.options;\n+            if (channel != null && options != null && options.size() > 0) {\n+                List<StateOption> stateOptions = new ArrayList<>();\n+                for (Option option : options) {\n+                    stateOptions.add(new StateOption(option.value, option.label));\n+                }\n+                stateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions);\n+                logger.trace(\"{} options set for the channel {}\", options.size(), channel.getUID());\n+            }\n+        }\n+    }\n+\n+    public void checkConnection(RemoteopenhabRestClient client) {\n+        logger.debug(\"Try the root REST API...\");\n+        try {\n+            client.tryApi();\n+            if (client.getRestApiVersion() == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"OH 1.x server not supported by the binding\");\n+            } else {\n+                List<Item> items = client.getRemoteItems();\n+\n+                createChannels(items, true);\n+                setStateOptions(items);\n+                for (Item item : items) {\n+                    updateChannelState(item.name, null, item.state);\n+                }\n+\n+                updateStatus(ThingStatus.ONLINE);\n+\n+                restartStreamingUpdates();\n+            }\n+        } catch (RemoteopenhabException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            stopStreamingUpdates();\n+        }\n+    }\n+\n+    private void startCheckConnectionJob(RemoteopenhabRestClient client) {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob == null || localCheckConnectionJob.isCancelled()) {\n+            checkConnectionJob = scheduler.scheduleWithFixedDelay(() -> {\n+                long millisSinceLastEvent = System.currentTimeMillis() - client.getLastEventTimestamp();\n+                if (millisSinceLastEvent > CONNECTION_TIMEOUT_MILLIS) {\n+                    logger.debug(\"Check: Disconnected from streaming events, millisSinceLastEvent={}\",\n+                            millisSinceLastEvent);\n+                    checkConnection(client);\n+                } else {\n+                    logger.debug(\"Check: Receiving streaming events, millisSinceLastEvent={}\", millisSinceLastEvent);\n+                }\n+            }, 0, CONNECTION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void stopCheckConnectionJob() {\n+        ScheduledFuture<?> localCheckConnectionJob = checkConnectionJob;\n+        if (localCheckConnectionJob != null) {\n+            localCheckConnectionJob.cancel(true);\n+            checkConnectionJob = null;\n+        }\n+    }\n+\n+    private void restartStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                stopStreamingUpdates();\n+                startStreamingUpdates();\n+            }\n+        }\n+    }\n+\n+    private void startStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.addStreamingDataListener(this);\n+                client.start();\n+            }\n+        }\n+    }\n+\n+    private void stopStreamingUpdates() {\n+        RemoteopenhabRestClient client = restClient;\n+        if (client != null) {\n+            synchronized (client) {\n+                client.stop();\n+                client.removeStreamingDataListener(this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void onError(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void onItemStateEvent(String itemName, String stateType, String state) {\n+        updateChannelState(itemName, stateType, state);\n+    }\n+\n+    @Override\n+    public void onItemAdded(Item item) {\n+        createChannels(List.of(item), false);\n+    }\n+\n+    @Override\n+    public void onItemRemoved(Item item) {\n+        removeChannels(List.of(item));\n+    }\n+\n+    @Override\n+    public void onItemUpdated(Item newItem, Item oldItem) {\n+        if (!newItem.type.equals(oldItem.type)) {\n+            List<Item> items = new ArrayList<>();\n+            items.add(newItem);\n+            createChannels(items, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "761b31eb8795e521e507859e4b4b381028b4d905"}, "originalPosition": 415}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ca8e3aaf97d29bc08c126f607df1d09634e009a", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/1ca8e3aaf97d29bc08c126f607df1d09634e009a", "committedDate": "2020-10-24T22:52:59Z", "message": "Review comment: description added to class RemoteopenhabChannelTypeProvider\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffa1344f0aa9e12540fd42e380ede6ca4add5a0c", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/ffa1344f0aa9e12540fd42e380ede6ca4add5a0c", "committedDate": "2020-10-24T22:56:11Z", "message": "Review comment: log level in the discovery service\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f39558be54080a90cefaa3042ffe703724cd062", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/8f39558be54080a90cefaa3042ffe703724cd062", "committedDate": "2020-10-24T22:57:59Z", "message": "Review comment: change the label of the thing type\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee33d72d2567c5025bb67ae13d9e9fc975899b2a", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/ee33d72d2567c5025bb67ae13d9e9fc975899b2a", "committedDate": "2020-10-24T23:05:12Z", "message": "Review comment: fix feature.xml\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4b108bece16ef4579d391a62a9555f237fe469a", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/f4b108bece16ef4579d391a62a9555f237fe469a", "committedDate": "2020-10-24T23:08:06Z", "message": "Review comment: use Map.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41e50467840cd74bb1a4a6316b9a1e70bb5d8c4c", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/41e50467840cd74bb1a4a6316b9a1e70bb5d8c4c", "committedDate": "2020-10-24T23:10:52Z", "message": "Review comment: define MAX_STATE_SIZE_FOR_LOGGING\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d75c42e1eeee7aed1b2f4e56cd1dc412fd6e5293", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d75c42e1eeee7aed1b2f4e56cd1dc412fd6e5293", "committedDate": "2020-10-24T23:13:51Z", "message": "Review comment: another List.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a010df21d2d1863aac75c444c92979d21da911e", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/6a010df21d2d1863aac75c444c92979d21da911e", "committedDate": "2020-10-25T10:27:59Z", "message": "Review comment: Change thing configuration settings\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ffc257e79da5c6fbdca81d1bcb699ed97c91fc9", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/3ffc257e79da5c6fbdca81d1bcb699ed97c91fc9", "committedDate": "2020-10-25T19:13:09Z", "message": "Take into consideration the read only property of an item\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1d1c6d8e1a20bb3d7d9c0510ea8d4b014bde1f5", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d1d1c6d8e1a20bb3d7d9c0510ea8d4b014bde1f5", "committedDate": "2020-10-25T22:39:01Z", "message": "Review comment: add the host as representation property and simplify the discovery result label\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8fd8b3b3e7897940e8db33fc04288e3e03f7933", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d8fd8b3b3e7897940e8db33fc04288e3e03f7933", "committedDate": "2020-10-25T22:54:00Z", "message": "Restore the use of Map.of\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NTE4MDUy", "url": "https://github.com/openhab/openhab-addons/pull/8791#pullrequestreview-516518052", "createdAt": "2020-10-26T07:30:32Z", "commit": {"oid": "d8fd8b3b3e7897940e8db33fc04288e3e03f7933"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTk1NjA2", "url": "https://github.com/openhab/openhab-addons/pull/8791#pullrequestreview-517195606", "createdAt": "2020-10-26T21:38:28Z", "commit": {"oid": "d8fd8b3b3e7897940e8db33fc04288e3e03f7933"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4315, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}