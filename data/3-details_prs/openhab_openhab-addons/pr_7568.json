{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0OTEwOTQy", "number": 7568, "title": "[kaleidescape] Kaleidescape Movie Player Binding - initial contribution", "bodyText": "[kaleidescape] Initial contribution\nThis is the initial implementation of a Binding to control and retrieve information from a Kaleidescape movie player. All movie player components including the original K-Player series, M Class Players, Cinema One, Alto, and Strato are supported.  As there are many good control options already available for these components, this binding focuses primarily on retrieving information for display purposes and to use in rules for controlling other Things such lighting, projector lens control, masking, etc. Any feedback or suggestions for improvement are welcome.", "createdAt": "2020-05-07T20:46:29Z", "url": "https://github.com/openhab/openhab-addons/pull/7568", "merged": true, "mergeCommit": {"oid": "197276bd39fea39f86858d433f67786e9b75457e"}, "closed": true, "closedAt": "2020-09-15T11:23:14Z", "author": {"login": "mlobstein"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXUds4gH2gAyNDE0OTEwOTQyOjI5NDAwYjUxNmEzMGMyZWYyYzJjZmFiMzg2Y2Q1ODYzYjkzNWNkYTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJGAu1gFqTQ4ODU4MTYzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "committedDate": "2020-04-13T19:56:53Z", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "committedDate": "2020-04-19T18:41:08Z", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f0e2bade7dc06284758cdcc26ff36899ba02488", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0f0e2bade7dc06284758cdcc26ff36899ba02488", "committedDate": "2020-05-07T20:40:03Z", "message": "Kaleidescape Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36dfe97a267794bb17cc03d73451c44bbe5aa740", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/36dfe97a267794bb17cc03d73451c44bbe5aa740", "committedDate": "2020-05-22T16:29:21Z", "message": "Cleanup before review\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f6e1ecaf31194fa0f9a606de2259413b00f06fc", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7f6e1ecaf31194fa0f9a606de2259413b00f06fc", "committedDate": "2020-05-23T04:52:22Z", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1184774907b31ec792aec1cacb475591849843df", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1184774907b31ec792aec1cacb475591849843df", "committedDate": "2020-05-26T05:36:03Z", "message": "Start removing org.apache.commons.lang dependencies\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "committedDate": "2020-05-27T03:57:29Z", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecf44b9b4239b0cfcb2d8beb429ebaedc4976f21", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ecf44b9b4239b0cfcb2d8beb429ebaedc4976f21", "committedDate": "2020-05-27T05:07:21Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3df77150d61f52d701d86c1ae0e64121eb28b4b2", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3df77150d61f52d701d86c1ae0e64121eb28b4b2", "committedDate": "2020-05-27T05:37:05Z", "message": "pmd and spotless cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89fedefae83bb3f1c6eaf8318856ab441d1394b4", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/89fedefae83bb3f1c6eaf8318856ab441d1394b4", "committedDate": "2020-05-27T22:02:04Z", "message": "Http client and Label cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fbfa46a9ba5526e6593e20c0760c995354c7550", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9fbfa46a9ba5526e6593e20c0760c995354c7550", "committedDate": "2020-06-01T05:16:01Z", "message": "pre-review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d5c5b8f14d888e4f4ca7a6146e9d881af2449b", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/76d5c5b8f14d888e4f4ca7a6146e9d881af2449b", "committedDate": "2020-06-01T16:00:57Z", "message": "Add ThingAction\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "committedDate": "2020-06-04T21:19:29Z", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7be08b18a617477f50757943e0355ca9c29ad30e", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7be08b18a617477f50757943e0355ca9c29ad30e", "committedDate": "2020-06-10T22:19:48Z", "message": "implement review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "781abb069dfa38e0551313800def39717b1a0a28", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/781abb069dfa38e0551313800def39717b1a0a28", "committedDate": "2020-06-15T04:29:20Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "committedDate": "2020-06-24T13:47:17Z", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90b374d59aa8c4ac1207694e0349bb8096008440", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/90b374d59aa8c4ac1207694e0349bb8096008440", "committedDate": "2020-06-24T14:39:20Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e9bb0c62ecbd339f2673025318166a4d05a8981", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5e9bb0c62ecbd339f2673025318166a4d05a8981", "committedDate": "2020-06-24T20:26:52Z", "message": "review changes from other pr\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d231205b20fcfeb22ee493bd1f0a5ea205f4ae5", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/8d231205b20fcfeb22ee493bd1f0a5ea205f4ae5", "committedDate": "2020-06-25T21:31:10Z", "message": "improvements and review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85", "committedDate": "2020-06-26T21:26:22Z", "message": "remove InterruptedIOException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNzAwODk2", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-442700896", "createdAt": "2020-07-05T19:29:48Z", "commit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxOToyOTo0OFrOGtEXSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMTowMToyMVrOGtE1gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMDYwMQ==", "bodyText": "Dou you want to add a link here?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449910601", "createdAt": "2020-07-05T19:29:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/README.md", "diffHunk": "@@ -0,0 +1,437 @@\n+# Kaleidescape Binding\n+\n+This binding is used to control and retrieve information from a Kaleidescape movie player.\n+All movie player components including the original K-Player series, M Class Players, Cinema One, Alto, and Strato are supported.\n+The 4 zone audio only KMUSIC-4000 is not supported at this time.\n+As there are many good control options already available for these components, this binding focuses primarily on retrieving information\n+ for display purposes and to use in rules for controlling other Things such lighting, projector lens control, masking, etc.\n+Basic playback transport controls are provided and any other command that is supported by the control protocol can be sent to the component through rules based commands.\n+See Kaleidescape-System-Control-Protocol-Reference-Manual.pdf for a reference of available commands.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMDg1Nw==", "bodyText": "Since PaperUI will be replaced in OH3, can you remove the reference to PaperUI and express it a bit more abstract?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449910857", "createdAt": "2020-07-05T19:32:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/README.md", "diffHunk": "@@ -0,0 +1,437 @@\n+# Kaleidescape Binding\n+\n+This binding is used to control and retrieve information from a Kaleidescape movie player.\n+All movie player components including the original K-Player series, M Class Players, Cinema One, Alto, and Strato are supported.\n+The 4 zone audio only KMUSIC-4000 is not supported at this time.\n+As there are many good control options already available for these components, this binding focuses primarily on retrieving information\n+ for display purposes and to use in rules for controlling other Things such lighting, projector lens control, masking, etc.\n+Basic playback transport controls are provided and any other command that is supported by the control protocol can be sent to the component through rules based commands.\n+See Kaleidescape-System-Control-Protocol-Reference-Manual.pdf for a reference of available commands.\n+To simplify the design of the binding code, a different Thing instance is created for each component\n+ in a multi-zone system and each Thing maintains its own socket connection to the target component.\n+Overall this binding supports the majority of information and commands available in the Kaleidescape control protocol but is by no means exhaustive.\n+Any feedback or suggestions for improvement are welcome.\n+\n+The binding supports two different kinds of connections:\n+\n+* direct IP connection (preferred),\n+* serial connection (19200-8-N-1)\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents an individual Kaleidescape component.\n+It has the `player` id.\n+\n+## Discovery\n+\n+Manually initiated Auto-discovery is supported if Kaleidescape components are accessible on the same IP subnet of the openHAB server.\n+Since discovery involves scanning all IP addresses in the subnet range for an open socket, the discovery must be initiated by the user.\n+In the Paper UI Inbox, select Search For Things at the bottom and then choose the Kaleidescape System Binding to initiate discovery.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMTAwNA==", "bodyText": "Can you add a reference, that this parameter is explained in detail below?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449911004", "createdAt": "2020-07-05T19:34:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/README.md", "diffHunk": "@@ -0,0 +1,437 @@\n+# Kaleidescape Binding\n+\n+This binding is used to control and retrieve information from a Kaleidescape movie player.\n+All movie player components including the original K-Player series, M Class Players, Cinema One, Alto, and Strato are supported.\n+The 4 zone audio only KMUSIC-4000 is not supported at this time.\n+As there are many good control options already available for these components, this binding focuses primarily on retrieving information\n+ for display purposes and to use in rules for controlling other Things such lighting, projector lens control, masking, etc.\n+Basic playback transport controls are provided and any other command that is supported by the control protocol can be sent to the component through rules based commands.\n+See Kaleidescape-System-Control-Protocol-Reference-Manual.pdf for a reference of available commands.\n+To simplify the design of the binding code, a different Thing instance is created for each component\n+ in a multi-zone system and each Thing maintains its own socket connection to the target component.\n+Overall this binding supports the majority of information and commands available in the Kaleidescape control protocol but is by no means exhaustive.\n+Any feedback or suggestions for improvement are welcome.\n+\n+The binding supports two different kinds of connections:\n+\n+* direct IP connection (preferred),\n+* serial connection (19200-8-N-1)\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents an individual Kaleidescape component.\n+It has the `player` id.\n+\n+## Discovery\n+\n+Manually initiated Auto-discovery is supported if Kaleidescape components are accessible on the same IP subnet of the openHAB server.\n+Since discovery involves scanning all IP addresses in the subnet range for an open socket, the discovery must be initiated by the user.\n+In the Paper UI Inbox, select Search For Things at the bottom and then choose the Kaleidescape System Binding to initiate discovery.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label        | Parameter ID  | Description                                                      | Accepted values                                        |\n+|------------------------|---------------|------------------------------------------------------------------|--------------------------------------------------------|\n+| Component type         | componentType | The type of Kaleidescape component                               | 'Player', 'Cinema One', 'Alto', or 'Strato'          | |\n+| Address                | host          | Host name or IP address of the Kaleidescape component            | A host name or IP address                            | |\n+| Port                   | port          | Communication port of the IP connection                          | 10000 (default - should not need to change)          | |\n+| Serial Port            | serialPort    | Serial port for connecting directly a component                  | Serial port name (optional)                          | |\n+| Update Period          | updatePeriod  | Tells the component how often time status updates should be sent | 0 or 1 are the currently accepted values (default 0) | |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMTY5NA==", "bodyText": "It's good practice to append the unit to the field name e.g. DISCOVERY_DEFAULT_TIMEOUT_RATE_MS", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449911694", "createdAt": "2020-07-05T19:42:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/KaleidescapeBindingConstants.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link KaleidescapeBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeBindingConstants {\n+    public static final String BINDING_ID = \"kaleidescape\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_PLAYER_ZONE = new ThingTypeUID(BINDING_ID, \"player\");\n+\n+    public static final int DEFAULT_API_PORT = 10000;\n+    public static final short DISCOVERY_SUBNET_MASK = 24;\n+    public static final int DISCOVERY_THREAD_POOL_SIZE = 15;\n+    public static final boolean DISCOVERY_DEFAULT_AUTO_DISCOVER = false;\n+    public static final int DISCOVERY_DEFAULT_TIMEOUT_RATE = 500;\n+    public static final int DISCOVERY_DEFAULT_IP_TIMEOUT_RATE = 750;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMjU0Ng==", "bodyText": "Are you aware of this bug openhab/openhab-core#1265?\nIf you want, you can add a workaround like this:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449912546", "createdAt": "2020-07-05T19:52:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/KaleidescapeThingActions.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.kaleidescape.internal.handler.KaleidescapeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Some automation actions to be used with a {@link KaleidescapeThingActions}\n+ *\n+ * @author Michael Lobstein - initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"kaleidescape\")\n+@NonNullByDefault\n+public class KaleidescapeThingActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeThingActions.class);\n+\n+    private @Nullable KaleidescapeHandler handler;\n+\n+    @SuppressWarnings(\"null\")\n+    @RuleAction(label = \"sendKCommand\", description = \"Action that sends raw command to the kaleidescape zone\")\n+    public void sendKCommand(@ActionInput(name = \"sendKCommand\") @Nullable String kCommand) {\n+        if (handler != null && kCommand != null) {\n+            handler.handleRawCommand(kCommand);\n+            logger.debug(\"sendKCommand called with command: {}\", kCommand);\n+        } else {\n+            logger.debug(\"sendKCommand called with null command, ignoring\");\n+        }\n+    }\n+\n+    public static void sendKCommand(@Nullable ThingActions actions, @Nullable String kCommand)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMjcwMw==", "bodyText": "Is this necessary?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449912703", "createdAt": "2020-07-05T19:54:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/KaleidescapeThingActions.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.kaleidescape.internal.handler.KaleidescapeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Some automation actions to be used with a {@link KaleidescapeThingActions}\n+ *\n+ * @author Michael Lobstein - initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"kaleidescape\")\n+@NonNullByDefault\n+public class KaleidescapeThingActions implements ThingActions {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeThingActions.class);\n+\n+    private @Nullable KaleidescapeHandler handler;\n+\n+    @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzAwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // I.e. characters with accent, umulat, etc., they need to be restored to the correct character\n          \n          \n            \n                        // I.e. characters with accent, umlaut, etc., they need to be restored to the correct character", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449913000", "createdAt": "2020-07-05T19:57:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeFormatter.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link KaleidescapeFormatter} is a utility class with formatting methods for Kaleidescape strings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeFormatter {\n+    public static String formatString(String input) {\n+        if (!input.equals(\"\")) {\n+            // convert || back to :\n+            input = input.replace(\"||\", \":\");\n+\n+            // fix escaped :\n+            input = input.replace(\"\\\\:\", \":\");\n+\n+            // fix escaped /\n+            input = input.replace(\"\\\\/\", \"/\");\n+\n+            // convert \\r into comma space\n+            input = input.replace(\"\\\\r\", \", \");\n+\n+            // convert \\d146 from review text into apostrophe\n+            input = input.replace(\"\\\\d146\", \"'\");\n+            // convert \\d147 & \\d148 from review text into double quote\n+            input = input.replace(\"\\\\d147\", \"\\\"\");\n+            input = input.replace(\"\\\\d148\", \"\\\"\");\n+\n+            // fix the encoding for k mangled extended ascii characters (chars coming in as \\dnnn)\n+            // I.e. characters with accent, umulat, etc., they need to be restored to the correct character", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxMzM0OQ==", "bodyText": "Can you add Apache Commons as a dependency to the pom.xml?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449913349", "createdAt": "2020-07-05T20:01:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeFormatter.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import org.apache.commons.lang.StringEscapeUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link KaleidescapeFormatter} is a utility class with formatting methods for Kaleidescape strings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeFormatter {\n+    public static String formatString(String input) {\n+        if (!input.equals(\"\")) {\n+            // convert || back to :\n+            input = input.replace(\"||\", \":\");\n+\n+            // fix escaped :\n+            input = input.replace(\"\\\\:\", \":\");\n+\n+            // fix escaped /\n+            input = input.replace(\"\\\\/\", \"/\");\n+\n+            // convert \\r into comma space\n+            input = input.replace(\"\\\\r\", \", \");\n+\n+            // convert \\d146 from review text into apostrophe\n+            input = input.replace(\"\\\\d146\", \"'\");\n+            // convert \\d147 & \\d148 from review text into double quote\n+            input = input.replace(\"\\\\d147\", \"\\\"\");\n+            input = input.replace(\"\\\\d148\", \"\\\"\");\n+\n+            // fix the encoding for k mangled extended ascii characters (chars coming in as \\dnnn)\n+            // I.e. characters with accent, umulat, etc., they need to be restored to the correct character\n+            // example: Noel (with umulat 'o') comes in as N\\d246el\n+            input = input.replaceAll(\"(?i)\\\\\\\\d([0-9]{3})\", \"\\\\&#$1;\"); // first convert to html escaped codes\n+            // then convert with unescapeHtml, not sure how to do this without the Apache libraries :(\n+            return StringEscapeUtils.unescapeHtml(input);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDE1NQ==", "bodyText": "Do you expect something else than a UnknownHostException? Can you specify it explicitly?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449914155", "createdAt": "2020-07-05T20:10:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryJob.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryJob} class allow manual discovery of\n+ * Kaleidescape components for a single IP address. This is used\n+ * for threading to make discovery faster.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+public class KaleidescapeDiscoveryJob implements Runnable {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryJob.class);\n+\n+    private KaleidescapeDiscoveryService discoveryClass;\n+\n+    private String ipAddress = EMPTY;\n+    private String componentType = EMPTY;\n+    private String friendlyName = EMPTY;\n+    private String serialNumber = EMPTY;\n+\n+    public KaleidescapeDiscoveryJob(KaleidescapeDiscoveryService service, String ip) {\n+        this.discoveryClass = service;\n+        this.ipAddress = ip;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (hasKaleidescapeDevice(this.ipAddress)) {\n+            discoveryClass.submitDiscoveryResults(this.ipAddress, this.componentType, this.friendlyName,\n+                    this.serialNumber);\n+        }\n+    }\n+\n+    /**\n+     * Determines if a Kaleidescape component with a movie player zone is available at a given IP address.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @return True if a component is found, false if not.\n+     */\n+    private boolean hasKaleidescapeDevice(String ip) {\n+        try {\n+            InetAddress address = InetAddress.getByName(ip);\n+\n+            if (isKaleidescapeDevice(address, DEFAULT_API_PORT)) {\n+                return true;\n+            } else {\n+                logger.debug(\"No Kaleidescape component found at IP address ({})\", ip);\n+                return false;\n+            }\n+        } catch (Exception exp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDk4MA==", "bodyText": "Better do not rely on the validity of the incoming data, but check the length of the array before accessing it.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449914980", "createdAt": "2020-07-05T20:20:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryJob.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryJob} class allow manual discovery of\n+ * Kaleidescape components for a single IP address. This is used\n+ * for threading to make discovery faster.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+public class KaleidescapeDiscoveryJob implements Runnable {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryJob.class);\n+\n+    private KaleidescapeDiscoveryService discoveryClass;\n+\n+    private String ipAddress = EMPTY;\n+    private String componentType = EMPTY;\n+    private String friendlyName = EMPTY;\n+    private String serialNumber = EMPTY;\n+\n+    public KaleidescapeDiscoveryJob(KaleidescapeDiscoveryService service, String ip) {\n+        this.discoveryClass = service;\n+        this.ipAddress = ip;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (hasKaleidescapeDevice(this.ipAddress)) {\n+            discoveryClass.submitDiscoveryResults(this.ipAddress, this.componentType, this.friendlyName,\n+                    this.serialNumber);\n+        }\n+    }\n+\n+    /**\n+     * Determines if a Kaleidescape component with a movie player zone is available at a given IP address.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @return True if a component is found, false if not.\n+     */\n+    private boolean hasKaleidescapeDevice(String ip) {\n+        try {\n+            InetAddress address = InetAddress.getByName(ip);\n+\n+            if (isKaleidescapeDevice(address, DEFAULT_API_PORT)) {\n+                return true;\n+            } else {\n+                logger.debug(\"No Kaleidescape component found at IP address ({})\", ip);\n+                return false;\n+            }\n+        } catch (Exception exp) {\n+            logger.debug(\"No Kaleidescape component found at IP address ({}) because of error: {}\", ip,\n+                    exp.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to establish a connection to a hostname and port and then interrogate the component\n+     *\n+     * @param host Hostname or IP address to connect to.\n+     * @param port Port to attempt to connect to.\n+     * @return True if the component found is one the binding supports\n+     */\n+    private boolean isKaleidescapeDevice(InetAddress host, int port) {\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(host, port), DISCOVERY_DEFAULT_IP_TIMEOUT_RATE);\n+\n+            OutputStream output = socket.getOutputStream();\n+            PrintWriter writer = new PrintWriter(output, true);\n+\n+            // query the component to see if it has video zones, the device type, friendly name, and serial number\n+            writer.println(\"01/1/GET_NUM_ZONES:\");\n+            writer.println(\"01/1/GET_DEVICE_TYPE_NAME:\");\n+            writer.println(\"01/1/GET_FRIENDLY_NAME:\");\n+            writer.println(\"01/1/GET_DEVICE_INFO:\");\n+\n+            InputStream input = socket.getInputStream();\n+\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n+\n+            String line;\n+            String videoZone = null;\n+            String audioZone = null;\n+            int lineCount = 0;\n+\n+            while ((line = reader.readLine()) != null) {\n+                String[] strArr = line.split(\":\");\n+\n+                switch (strArr[1]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTE2Ng==", "bodyText": "Actually these are not needed, since the try block closes the socket automatically and closing the socket, will close all I/O streams, which close the reader. See https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html#close()", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449915166", "createdAt": "2020-07-05T20:22:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryJob.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryJob} class allow manual discovery of\n+ * Kaleidescape components for a single IP address. This is used\n+ * for threading to make discovery faster.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+public class KaleidescapeDiscoveryJob implements Runnable {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryJob.class);\n+\n+    private KaleidescapeDiscoveryService discoveryClass;\n+\n+    private String ipAddress = EMPTY;\n+    private String componentType = EMPTY;\n+    private String friendlyName = EMPTY;\n+    private String serialNumber = EMPTY;\n+\n+    public KaleidescapeDiscoveryJob(KaleidescapeDiscoveryService service, String ip) {\n+        this.discoveryClass = service;\n+        this.ipAddress = ip;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (hasKaleidescapeDevice(this.ipAddress)) {\n+            discoveryClass.submitDiscoveryResults(this.ipAddress, this.componentType, this.friendlyName,\n+                    this.serialNumber);\n+        }\n+    }\n+\n+    /**\n+     * Determines if a Kaleidescape component with a movie player zone is available at a given IP address.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @return True if a component is found, false if not.\n+     */\n+    private boolean hasKaleidescapeDevice(String ip) {\n+        try {\n+            InetAddress address = InetAddress.getByName(ip);\n+\n+            if (isKaleidescapeDevice(address, DEFAULT_API_PORT)) {\n+                return true;\n+            } else {\n+                logger.debug(\"No Kaleidescape component found at IP address ({})\", ip);\n+                return false;\n+            }\n+        } catch (Exception exp) {\n+            logger.debug(\"No Kaleidescape component found at IP address ({}) because of error: {}\", ip,\n+                    exp.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to establish a connection to a hostname and port and then interrogate the component\n+     *\n+     * @param host Hostname or IP address to connect to.\n+     * @param port Port to attempt to connect to.\n+     * @return True if the component found is one the binding supports\n+     */\n+    private boolean isKaleidescapeDevice(InetAddress host, int port) {\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(host, port), DISCOVERY_DEFAULT_IP_TIMEOUT_RATE);\n+\n+            OutputStream output = socket.getOutputStream();\n+            PrintWriter writer = new PrintWriter(output, true);\n+\n+            // query the component to see if it has video zones, the device type, friendly name, and serial number\n+            writer.println(\"01/1/GET_NUM_ZONES:\");\n+            writer.println(\"01/1/GET_DEVICE_TYPE_NAME:\");\n+            writer.println(\"01/1/GET_FRIENDLY_NAME:\");\n+            writer.println(\"01/1/GET_DEVICE_INFO:\");\n+\n+            InputStream input = socket.getInputStream();\n+\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n+\n+            String line;\n+            String videoZone = null;\n+            String audioZone = null;\n+            int lineCount = 0;\n+\n+            while ((line = reader.readLine()) != null) {\n+                String[] strArr = line.split(\":\");\n+\n+                switch (strArr[1]) {\n+                    case \"NUM_ZONES\":\n+                        videoZone = strArr[2];\n+                        audioZone = strArr[3];\n+                        break;\n+                    case \"DEVICE_TYPE_NAME\":\n+                        componentType = strArr[2];\n+                        break;\n+                    case \"FRIENDLY_NAME\":\n+                        friendlyName = strArr[2];\n+                        break;\n+                    case \"DEVICE_INFO\":\n+                        serialNumber = strArr[3].trim(); // take off leading zeros\n+                        break;\n+                }\n+\n+                lineCount++;\n+\n+                // stop after reading four lines\n+                if (lineCount > 3) {\n+                    break;\n+                }\n+            }\n+\n+            reader.close();\n+            input.close();\n+            output.close();\n+            socket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTg4OQ==", "bodyText": "It's a bit hard to scan the whole subnet and spawn 15 threads for DNS resolution, but I don't have any better idea. Did you test this on a computer with low resources like a raspi?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449915889", "createdAt": "2020-07-05T20:32:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNTk2OA==", "bodyText": "Can you add a representation property like \"host\"?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449915968", "createdAt": "2020-07-05T20:33:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);\n+\n+            for (String ip : ipList) {\n+                discoverySearchPool.execute(new KaleidescapeDiscoveryJob(this, ip));\n+            }\n+\n+            discoverySearchPool.shutdown();\n+        } catch (Exception exp) {\n+            logger.debug(\"Kaleidescape discovery service encountered an error while scanning for components: {}\",\n+                    exp.getMessage());\n+        }\n+\n+        logger.debug(\"Completed discovery of Kaleidescape components.\");\n+    }\n+\n+    /**\n+     * Create a new Thing with an IP address and Component type given. Uses default port.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @param componentType Type of Kaleidescape component as a string.\n+     * @param friendlyName Name of Kaleidescape component as a string.\n+     * @param serialNumber Serial Number of Kaleidescape component as a string.\n+     */\n+    public void submitDiscoveryResults(String ip, String componentType, String friendlyName, String serialNumber) {\n+        ThingUID uid = new ThingUID(THING_TYPE_PLAYER_ZONE, serialNumber);\n+\n+        HashMap<String, Object> properties = new HashMap<>();\n+\n+        properties.put(\"host\", ip);\n+        properties.put(\"port\", DEFAULT_API_PORT);\n+        properties.put(\"componentType\", componentType);\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(uid).withProperties(properties)\n+                .withLabel(componentType + \" (\" + friendlyName + \")\").build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjAxNA==", "bodyText": "You might want to log that the ipv6 interface is ignored during discovery.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916014", "createdAt": "2020-07-05T20:34:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);\n+\n+            for (String ip : ipList) {\n+                discoverySearchPool.execute(new KaleidescapeDiscoveryJob(this, ip));\n+            }\n+\n+            discoverySearchPool.shutdown();\n+        } catch (Exception exp) {\n+            logger.debug(\"Kaleidescape discovery service encountered an error while scanning for components: {}\",\n+                    exp.getMessage());\n+        }\n+\n+        logger.debug(\"Completed discovery of Kaleidescape components.\");\n+    }\n+\n+    /**\n+     * Create a new Thing with an IP address and Component type given. Uses default port.\n+     *\n+     * @param ip IP address of the Kaleidescape component as a string.\n+     * @param componentType Type of Kaleidescape component as a string.\n+     * @param friendlyName Name of Kaleidescape component as a string.\n+     * @param serialNumber Serial Number of Kaleidescape component as a string.\n+     */\n+    public void submitDiscoveryResults(String ip, String componentType, String friendlyName, String serialNumber) {\n+        ThingUID uid = new ThingUID(THING_TYPE_PLAYER_ZONE, serialNumber);\n+\n+        HashMap<String, Object> properties = new HashMap<>();\n+\n+        properties.put(\"host\", ip);\n+        properties.put(\"port\", DEFAULT_API_PORT);\n+        properties.put(\"componentType\", componentType);\n+\n+        thingDiscovered(DiscoveryResultBuilder.create(uid).withProperties(properties)\n+                .withLabel(componentType + \" (\" + friendlyName + \")\").build());\n+    }\n+\n+    /**\n+     * Provide a string list of all the IP addresses associated with the network interfaces on\n+     * this machine.\n+     *\n+     * @return String list of IP addresses.\n+     * @throws UnknownHostException\n+     * @throws SocketException\n+     */\n+    private List<String> getIpAddressScanList() throws UnknownHostException, SocketException {\n+        List<String> results = new ArrayList<>();\n+\n+        InetAddress localHost = InetAddress.getLocalHost();\n+        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(localHost);\n+\n+        for (InterfaceAddress address : networkInterface.getInterfaceAddresses()) {\n+            InetAddress ipAddress = address.getAddress();\n+\n+            String cidrSubnet = ipAddress.getHostAddress() + \"/\" + DISCOVERY_SUBNET_MASK;\n+\n+            /* Apache Subnet Utils only supports IP v4 for creating string list of IP's */\n+            if (ipAddress instanceof Inet4Address) {\n+                logger.debug(\"Found interface IPv4 address to scan: {}\", cidrSubnet);\n+\n+                SubnetUtils utils = new SubnetUtils(cidrSubnet);\n+\n+                results.addAll(Arrays.asList(utils.getInfo().getAllAddresses())); // not sure how to do this without the\n+                                                                                  // Apache libraries\n+            } else if (ipAddress instanceof Inet6Address) {\n+                logger.debug(\"Found interface IPv6 address to scan: {}\", cidrSubnet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjAzNg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916036", "createdAt": "2020-07-05T20:34:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjIxOA==", "bodyText": "You could store the config to a local variable (additionally) to eliminate the null supression.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n          \n          \n            \n                    KaleidescapeThingConfiguration localConfig = config = getConfigAs(KaleidescapeThingConfiguration.class);", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916218", "createdAt": "2020-07-05T20:36:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjMzNA==", "bodyText": "The compiler is more intelligent on local variables, so this could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916334", "createdAt": "2020-07-05T20:38:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n          \n          \n            \n                        this.updateState(VOLUME, new PercentType(this.volume));", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916437", "createdAt": "2020-07-05T20:39:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNjYyMw==", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently).\nThis should be invoked after scheduling the jobs. Otherwise the jobs could be scheduled after dispose() is invoked.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449916623", "createdAt": "2020-07-05T20:41:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzA5NA==", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n          \n          \n            \n                                                    GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n          \n          \n            \n                                            initialCommands.addAll(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n          \n          \n            \n                                                    GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE));", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917094", "createdAt": "2020-07-05T20:46:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzQ2Ng==", "bodyText": "If I understand correctly, you expect the connection as failed, if one poll failed. Is it reasonable to be a bit more tolerant, like when two consecutive poll requests fail?", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917466", "createdAt": "2020-07-05T20:51:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzUzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateState(channel, new PercentType(BigDecimal.valueOf(this.volume)));\n          \n          \n            \n                            updateState(channel, new PercentType(this.volume));", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917539", "createdAt": "2020-07-05T20:51:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL * 1.25 * 1000)) {\n+                        logger.warn(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, POLLING_INTERVAL, POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    private void handleControlCommand(Command command) throws KaleidescapeException {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connector.sendCommand(PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connector.sendCommand(PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connector.sendCommand(NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connector.sendCommand(PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                connector.sendCommand(SCAN_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                connector.sendCommand(SCAN_REVERSE);\n+            }\n+        } else {\n+            logger.warn(\"Unknown control command: {}\", command);\n+        }\n+    }\n+\n+    private void handleRefresh(String channel) throws KaleidescapeException {\n+        switch (channel) {\n+            case POWER:\n+                connector.sendCommand(GET_DEVICE_POWER_STATE);\n+                break;\n+            case VOLUME:\n+                updateState(channel, new PercentType(BigDecimal.valueOf(this.volume)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNzk2Nw==", "bodyText": "OpenHAB's scheduler thread could be blocked by this timeout. You could use Jetty's async API or decrease the timeout to e.g. 10sec.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449917967", "createdAt": "2020-07-05T20:56:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeMessageHandler.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeFormatter;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeStatusCodes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeMessageHandler} class processes all messages received\n+ * by the event listener and then updates the appropriate states\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum KaleidescapeMessageHandler {\n+    UI_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.UI_STATE, new StringType(message));\n+        }\n+    },\n+    HIGHLIGHTED_SELECTION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.HIGHLIGHTED_SELECTION, new StringType(message));\n+        }\n+    },\n+    DEVICE_POWER_STATE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 1:1\n+        // power_state, zone 1 state, zone n state\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(POWER, (ONE).equals(matcher.group(1)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"DEVICE_POWER_STATE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    TITLE_NAME {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.TITLE_NAME,\n+                    new StringType(KaleidescapeFormatter.formatString(message)));\n+        }\n+    },\n+    PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 0:0:00:00000:00000:000:00000:00000\n+        // mode, speed, title_num, title_length, title_loc, chapter_num, chapter_length, chapter_loc\n+        private final Pattern p = Pattern\n+                .compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{2}):(\\\\d{5}):(\\\\d{5}):(\\\\d{3}):(\\\\d{5}):(\\\\d{5})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(TITLE_NUM, new DecimalType(Integer.parseInt(matcher.group(3))));\n+\n+                handler.updateChannel(TITLE_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(TITLE_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(5)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_NUM, new DecimalType(Integer.parseInt(matcher.group(6))));\n+\n+                handler.updateChannel(CHAPTER_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(7)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(8)), handler.apiSecondUnit));\n+            } else {\n+                logger.debug(\"PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MOVIE_MEDIA_TYPE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_MEDIA_TYPE,\n+                    new StringType(KaleidescapeStatusCodes.MEDIA_TYPE.get(message)));\n+        }\n+    },\n+    MOVIE_LOCATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_LOCATION,\n+                    new StringType(KaleidescapeStatusCodes.MOVIE_LOCATION.get(message)));\n+        }\n+    },\n+    VIDEO_MODE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00:00:00\n+        // composite, component, hdmi\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_MODE, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_MODE_COMPOSITE,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(VIDEO_MODE_COMPONENT,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(2))));\n+\n+                handler.updateChannel(VIDEO_MODE_HDMI,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(3))));\n+            } else {\n+                logger.debug(\"VIDEO_MODE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    VIDEO_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"VIDEO_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    CONTENT_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CONTENT_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(CONTENT_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"CONTENT_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    SCALE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCALE_MODE, new StringType(message));\n+        }\n+    },\n+    SCREEN_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK, new StringType(message));\n+\n+            // per API reference rev 3.3.1, ASPECT_RATIO message should not be used\n+            // the first element of SCREEN_MASK now provides this info\n+            if (!message.equals(EMPTY)) {\n+                String[] msgSplit = message.split(\":\", 2);\n+                handler.updateChannel(KaleidescapeBindingConstants.ASPECT_RATIO,\n+                        new StringType(KaleidescapeStatusCodes.ASPECT_RATIO.get(msgSplit[0])));\n+            }\n+        }\n+    },\n+    SCREEN_MASK2 {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK2, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MASK, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MODE, new StringType(message));\n+        }\n+    },\n+    CHILD_MODE_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CHILD_MODE_STATE, new StringType(message));\n+        }\n+    },\n+    MUSIC_TITLE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: You:Radiohead:Pablo Honey:1.9b5f4d786d7e2c49-t301_577:1.R_1493833:2.200c5\n+        // track, artist, album, track handle, album handle, now playing handle\n+        private final Pattern p = Pattern.compile(\"^(.*):(.*):(.*):(.*):(.*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // first replace delimited : in track/artist/album name with ||, fix it later in formatString()\n+            Matcher matcher = p.matcher(message.replace(\"\\\\:\", \"||\"));\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_TRACK,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_ARTIST,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(2))));\n+\n+                handler.updateChannel(MUSIC_ALBUM,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(3))));\n+\n+                handler.updateChannel(MUSIC_TRACK_HANDLE, new StringType(matcher.group(4)));\n+\n+                handler.updateChannel(MUSIC_ALBUM_HANDLE, new StringType(matcher.group(5)));\n+\n+                handler.updateChannel(MUSIC_NOWPLAY_HANDLE, new StringType(matcher.group(6)));\n+            } else {\n+                logger.debug(\"MUSIC_TITLE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 2:0:00207:+00000:000.00\n+        // 2:0:00331:+00183:055.29\n+        // mode, speed, track length, track position, track progress %\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{5}):(.\\\\d{5}):(\\\\d{3}\\\\.\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(MUSIC_TRACK_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(3)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_POSITION,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_PROGRESS,\n+                        new DecimalType(BigDecimal.valueOf(Math.round(Double.parseDouble(matcher.group(5))))));\n+            } else {\n+                logger.debug(\"MUSIC_PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_NOW_PLAYING_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00013:00000:0:0:0000000238:2.200c5\n+        // total # tracks in list, list index, repeat, random, generation, now_playing handle\n+        // only using repeat & random right now\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{5}):(\\\\d{5}):(\\\\d{1}):(\\\\d{1}):(\\\\d{10}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                // update REPEAT switch state\n+                handler.updateChannel(MUSIC_REPEAT, (ONE).equals(matcher.group(3)) ? OnOffType.ON : OnOffType.OFF);\n+\n+                // update RANDOM switch state\n+                handler.updateChannel(MUSIC_RANDOM, (ONE).equals(matcher.group(4)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"MUSIC_NOW_PLAYING_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    PLAYING_MUSIC_INFORMATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: R_1493833:Radiohead - Pablo Honey\n+            // album handle, artist - album\n+            // do nothing; redundant\n+        }\n+    },\n+    CONTENT_DETAILS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // g1=meta id, g2=meta type, g3=data\n+        // example: 6:Year:1995\n+        // or: 10:Genres:Pop\\/Rock\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1,2}):([^:^/]*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                String metaType = matcher.group(2).toLowerCase();\n+                String value = KaleidescapeFormatter.formatString(matcher.group(3));\n+\n+                // the CONTENT_DETAILS message with id=1 tells us what type of meta data is coming\n+                if (ONE.equals(matcher.group(1))) {\n+                    if ((CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(MOVIE));\n+                        handler.metaRuntimeMultiple = 60;\n+\n+                        // null out album specific\n+                        handler.updateDetailChannel(DETAIL_ALBUM_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ARTIST, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_REVIEW, UnDefType.NULL);\n+\n+                    } else if ((ALBUM_CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(ALBUM));\n+                        handler.metaRuntimeMultiple = 1;\n+\n+                        // null out movie specific\n+                        handler.updateDetailChannel(DETAIL_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ACTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_DIRECTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING_REASON, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_SYNOPSIS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COLOR_DESCRIPTION, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COUNTRY, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ASPECT_RATIO, UnDefType.NULL);\n+\n+                    } else {\n+                        handler.updateDetailChannel(DETAIL_TYPE, UnDefType.UNDEF);\n+                    }\n+                    // otherwise update the channel if it is one we care about\n+                } else if (METADATA_CHANNELS.contains(metaType)) {\n+                    // special case for cover art image\n+                    if (DETAIL_COVER_URL.equals(metaType)) {\n+                        handler.updateDetailChannel(metaType, new StringType(value));\n+                        if (!value.isEmpty()) {\n+                            try {\n+                                ContentResponse contentResponse = handler.httpClient.newRequest(value).method(GET)\n+                                        .timeout(20, TimeUnit.SECONDS).send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxODEzNA==", "bodyText": "You could write the comment in a separate line to prevent the auto formatter from garbling it.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449918134", "createdAt": "2020-07-05T20:59:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeMessageHandler.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RawType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeFormatter;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeStatusCodes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeMessageHandler} class processes all messages received\n+ * by the event listener and then updates the appropriate states\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum KaleidescapeMessageHandler {\n+    UI_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.UI_STATE, new StringType(message));\n+        }\n+    },\n+    HIGHLIGHTED_SELECTION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.HIGHLIGHTED_SELECTION, new StringType(message));\n+        }\n+    },\n+    DEVICE_POWER_STATE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 1:1\n+        // power_state, zone 1 state, zone n state\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(POWER, (ONE).equals(matcher.group(1)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"DEVICE_POWER_STATE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    TITLE_NAME {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.TITLE_NAME,\n+                    new StringType(KaleidescapeFormatter.formatString(message)));\n+        }\n+    },\n+    PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 0:0:00:00000:00000:000:00000:00000\n+        // mode, speed, title_num, title_length, title_loc, chapter_num, chapter_length, chapter_loc\n+        private final Pattern p = Pattern\n+                .compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{2}):(\\\\d{5}):(\\\\d{5}):(\\\\d{3}):(\\\\d{5}):(\\\\d{5})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(TITLE_NUM, new DecimalType(Integer.parseInt(matcher.group(3))));\n+\n+                handler.updateChannel(TITLE_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(TITLE_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(5)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_NUM, new DecimalType(Integer.parseInt(matcher.group(6))));\n+\n+                handler.updateChannel(CHAPTER_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(7)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(CHAPTER_LOC,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(8)), handler.apiSecondUnit));\n+            } else {\n+                logger.debug(\"PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MOVIE_MEDIA_TYPE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_MEDIA_TYPE,\n+                    new StringType(KaleidescapeStatusCodes.MEDIA_TYPE.get(message)));\n+        }\n+    },\n+    MOVIE_LOCATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.MOVIE_LOCATION,\n+                    new StringType(KaleidescapeStatusCodes.MOVIE_LOCATION.get(message)));\n+        }\n+    },\n+    VIDEO_MODE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00:00:00\n+        // composite, component, hdmi\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_MODE, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_MODE_COMPOSITE,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(VIDEO_MODE_COMPONENT,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(2))));\n+\n+                handler.updateChannel(VIDEO_MODE_HDMI,\n+                        new StringType(KaleidescapeStatusCodes.VIDEO_MODE.get(matcher.group(3))));\n+            } else {\n+                logger.debug(\"VIDEO_MODE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    VIDEO_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.VIDEO_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(VIDEO_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"VIDEO_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    CONTENT_COLOR {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 02:01:24:01\n+        // eotf, color_space, color_depth, color_sampling\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(\\\\d{2}):(\\\\d{2}):(\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CONTENT_COLOR, new StringType(message));\n+\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(CONTENT_COLOR_EOTF,\n+                        new StringType(KaleidescapeStatusCodes.EOTF.get(matcher.group(1))));\n+            } else {\n+                logger.debug(\"CONTENT_COLOR - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    SCALE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCALE_MODE, new StringType(message));\n+        }\n+    },\n+    SCREEN_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK, new StringType(message));\n+\n+            // per API reference rev 3.3.1, ASPECT_RATIO message should not be used\n+            // the first element of SCREEN_MASK now provides this info\n+            if (!message.equals(EMPTY)) {\n+                String[] msgSplit = message.split(\":\", 2);\n+                handler.updateChannel(KaleidescapeBindingConstants.ASPECT_RATIO,\n+                        new StringType(KaleidescapeStatusCodes.ASPECT_RATIO.get(msgSplit[0])));\n+            }\n+        }\n+    },\n+    SCREEN_MASK2 {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.SCREEN_MASK2, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MASK {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MASK, new StringType(message));\n+        }\n+    },\n+    CINEMASCAPE_MODE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CINEMASCAPE_MODE, new StringType(message));\n+        }\n+    },\n+    CHILD_MODE_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            handler.updateChannel(KaleidescapeBindingConstants.CHILD_MODE_STATE, new StringType(message));\n+        }\n+    },\n+    MUSIC_TITLE {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: You:Radiohead:Pablo Honey:1.9b5f4d786d7e2c49-t301_577:1.R_1493833:2.200c5\n+        // track, artist, album, track handle, album handle, now playing handle\n+        private final Pattern p = Pattern.compile(\"^(.*):(.*):(.*):(.*):(.*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // first replace delimited : in track/artist/album name with ||, fix it later in formatString()\n+            Matcher matcher = p.matcher(message.replace(\"\\\\:\", \"||\"));\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_TRACK,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_ARTIST,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(2))));\n+\n+                handler.updateChannel(MUSIC_ALBUM,\n+                        new StringType(KaleidescapeFormatter.formatString(matcher.group(3))));\n+\n+                handler.updateChannel(MUSIC_TRACK_HANDLE, new StringType(matcher.group(4)));\n+\n+                handler.updateChannel(MUSIC_ALBUM_HANDLE, new StringType(matcher.group(5)));\n+\n+                handler.updateChannel(MUSIC_NOWPLAY_HANDLE, new StringType(matcher.group(6)));\n+            } else {\n+                logger.debug(\"MUSIC_TITLE - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_PLAY_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 2:0:00207:+00000:000.00\n+        // 2:0:00331:+00183:055.29\n+        // mode, speed, track length, track position, track progress %\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1}):(\\\\d{1}):(\\\\d{5}):(.\\\\d{5}):(\\\\d{3}\\\\.\\\\d{2})$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateChannel(MUSIC_PLAY_MODE,\n+                        new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1))));\n+\n+                handler.updateChannel(MUSIC_PLAY_SPEED, new StringType(matcher.group(2)));\n+\n+                handler.updateChannel(MUSIC_TRACK_LENGTH,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(3)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_POSITION,\n+                        new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit));\n+\n+                handler.updateChannel(MUSIC_TRACK_PROGRESS,\n+                        new DecimalType(BigDecimal.valueOf(Math.round(Double.parseDouble(matcher.group(5))))));\n+            } else {\n+                logger.debug(\"MUSIC_PLAY_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    MUSIC_NOW_PLAYING_STATUS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 00013:00000:0:0:0000000238:2.200c5\n+        // total # tracks in list, list index, repeat, random, generation, now_playing handle\n+        // only using repeat & random right now\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{5}):(\\\\d{5}):(\\\\d{1}):(\\\\d{1}):(\\\\d{10}):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                // update REPEAT switch state\n+                handler.updateChannel(MUSIC_REPEAT, (ONE).equals(matcher.group(3)) ? OnOffType.ON : OnOffType.OFF);\n+\n+                // update RANDOM switch state\n+                handler.updateChannel(MUSIC_RANDOM, (ONE).equals(matcher.group(4)) ? OnOffType.ON : OnOffType.OFF);\n+            } else {\n+                logger.debug(\"MUSIC_NOW_PLAYING_STATUS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    PLAYING_MUSIC_INFORMATION {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: R_1493833:Radiohead - Pablo Honey\n+            // album handle, artist - album\n+            // do nothing; redundant\n+        }\n+    },\n+    CONTENT_DETAILS {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // g1=meta id, g2=meta type, g3=data\n+        // example: 6:Year:1995\n+        // or: 10:Genres:Pop\\/Rock\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{1,2}):([^:^/]*):(.*)$\");\n+\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                String metaType = matcher.group(2).toLowerCase();\n+                String value = KaleidescapeFormatter.formatString(matcher.group(3));\n+\n+                // the CONTENT_DETAILS message with id=1 tells us what type of meta data is coming\n+                if (ONE.equals(matcher.group(1))) {\n+                    if ((CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(MOVIE));\n+                        handler.metaRuntimeMultiple = 60;\n+\n+                        // null out album specific\n+                        handler.updateDetailChannel(DETAIL_ALBUM_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ARTIST, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_REVIEW, UnDefType.NULL);\n+\n+                    } else if ((ALBUM_CONTENT_HANDLE).equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_TYPE, new StringType(ALBUM));\n+                        handler.metaRuntimeMultiple = 1;\n+\n+                        // null out movie specific\n+                        handler.updateDetailChannel(DETAIL_TITLE, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ACTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_DIRECTORS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_RATING_REASON, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_SYNOPSIS, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COLOR_DESCRIPTION, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_COUNTRY, UnDefType.NULL);\n+                        handler.updateDetailChannel(DETAIL_ASPECT_RATIO, UnDefType.NULL);\n+\n+                    } else {\n+                        handler.updateDetailChannel(DETAIL_TYPE, UnDefType.UNDEF);\n+                    }\n+                    // otherwise update the channel if it is one we care about\n+                } else if (METADATA_CHANNELS.contains(metaType)) {\n+                    // special case for cover art image\n+                    if (DETAIL_COVER_URL.equals(metaType)) {\n+                        handler.updateDetailChannel(metaType, new StringType(value));\n+                        if (!value.isEmpty()) {\n+                            try {\n+                                ContentResponse contentResponse = handler.httpClient.newRequest(value).method(GET)\n+                                        .timeout(20, TimeUnit.SECONDS).send();\n+                                int httpStatus = contentResponse.getStatus();\n+                                if (httpStatus == OK_200) {\n+                                    handler.updateDetailChannel(DETAIL_COVER_ART,\n+                                            new RawType(contentResponse.getContent()));\n+                                } else {\n+                                    handler.updateDetailChannel(DETAIL_COVER_ART, UnDefType.NULL);\n+                                }\n+                            } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+                                logger.debug(\"Error updating Cover Art Image channel for url: {}\", value);\n+                                handler.updateDetailChannel(DETAIL_COVER_ART, UnDefType.NULL);\n+                            }\n+                        } else {\n+                            handler.updateDetailChannel(DETAIL_COVER_ART, UnDefType.NULL);\n+                        }\n+                        // special case for running time to create a QuantityType<Time>\n+                    } else if (DETAIL_RUNNING_TIME.equals(metaType)) {\n+                        handler.updateDetailChannel(DETAIL_RUNNING_TIME, new QuantityType<Time>(\n+                                Integer.parseInt(value) * handler.metaRuntimeMultiple, handler.apiSecondUnit));\n+                        // everything else just send it as a string\n+                    } else {\n+                        handler.updateDetailChannel(metaType, new StringType(value));\n+                    }\n+                }\n+            } else {\n+                logger.debug(\"CONTENT_DETAILS - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    TIME {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // do nothing\n+        }\n+    },\n+    STATUS_CUE_PERIOD {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // do nothing\n+        }\n+    },\n+    ASPECT_RATIO {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // per API reference rev 3.3.1, ASPECT_RATIO message should not be used\n+            // the first element of SCREEN_MASK now provides this info\n+        }\n+    },\n+    USER_DEFINED_EVENT {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: SELECT_KALEIDESCAPE_INPUT\n+            try {\n+                switch (message) {\n+                    // when the ipad or phone app is started up, it sends a VOLUME_QUERY,\n+                    // so we respond to enable volume controls and set the initial volume and mute\n+                    case \"VOLUME_QUERY\":\n+                        if (handler.volumeEnabled) {\n+                            synchronized (handler.sequenceLock) {\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_CAPABILITIES_15);\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + handler.volume);\n+                                handler.connector.sendCommand(SEND_EVENT_MUTE + (handler.isMuted ? MUTE_ON : MUTE_OFF));\n+                            }\n+                        }\n+                        break;\n+                    case \"VOLUME_UP\":\n+                        if (handler.volumeEnabled) {\n+                            synchronized (handler.sequenceLock) {\n+                                handler.volume++;\n+                                handler.updateChannel(VOLUME, new PercentType(BigDecimal.valueOf(handler.volume)));\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + handler.volume);\n+                            }\n+                        }\n+                        break;\n+                    case \"VOLUME_DOWN\":\n+                        if (handler.volumeEnabled) {\n+                            synchronized (handler.sequenceLock) {\n+                                handler.volume--;\n+                                handler.updateChannel(VOLUME, new PercentType(BigDecimal.valueOf(handler.volume)));\n+                                handler.connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + handler.volume);\n+                            }\n+                        }\n+                        break;\n+                    case \"TOGGLE_MUTE\":\n+                        State state = UnDefType.UNDEF;\n+                        synchronized (handler.sequenceLock) {\n+                            if (handler.isMuted) {\n+                                state = OnOffType.OFF;\n+                                handler.isMuted = false;\n+                            } else {\n+                                state = OnOffType.ON;\n+                                handler.isMuted = true;\n+                            }\n+                            handler.connector.sendCommand(SEND_EVENT_MUTE + (handler.isMuted ? MUTE_ON : MUTE_OFF));\n+                            handler.updateChannel(MUTE, state);\n+                        }\n+                        break;\n+                    // the default is to just publish all other USER_DEFINED_EVENTs\n+                    default:\n+                        handler.updateChannel(KaleidescapeBindingConstants.USER_DEFINED_EVENT, new StringType(message));\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.debug(\"USER_DEFINED_EVENT - exception on message: {}\", message);\n+            }\n+        }\n+    },\n+    USER_INPUT {\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: 01:Search for title:ABC\n+            handler.updateChannel(KaleidescapeBindingConstants.USER_INPUT, new StringType(message));\n+        }\n+    },\n+    USER_INPUT_PROMPT {\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example: 00:00::00:0:1\n+            handler.updateChannel(KaleidescapeBindingConstants.USER_INPUT, new StringType(message));\n+        }\n+    },\n+    SYSTEM_READINESS_STATE {\n+        @Override\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            // example 1, 2 or 3\n+            handler.updateChannel(KaleidescapeBindingConstants.SYSTEM_READINESS_STATE,\n+                    new StringType(KaleidescapeStatusCodes.READINESS_STATE.get(message)));\n+        }\n+    },\n+    SYSTEM_VERSION {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 16:8.6.0-21023\n+        // protocol version, kOS version\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(.*)$\");\n+\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateThingProperty(PROPERTY_PROTOCOL_VERSION, matcher.group(1));\n+                handler.updateThingProperty(PROPERTY_SYSTEM_VERSION, matcher.group(2));\n+            } else {\n+                logger.debug(\"SYSTEM_VERSION - no match on message: {}\", message);\n+            }\n+        }\n+    },\n+    DEVICE_INFO {\n+        private final Logger logger = LoggerFactory.getLogger(KaleidescapeMessageHandler.class);\n+\n+        // example: 07:000000000000558F:00:192.168.001.100\n+        // device type (deprecated), serial number, cpdid, ip address\n+        private final Pattern p = Pattern.compile(\"^(\\\\d{2}):(.*):(\\\\d{2}):(.*)$\");\n+\n+        public void handleMessage(String message, KaleidescapeHandler handler) {\n+            Matcher matcher = p.matcher(message);\n+            if (matcher.find()) {\n+                handler.updateThingProperty(PROPERTY_SERIAL_NUMBER, matcher.group(2).replaceFirst(\"^0+(?!$)\", EMPTY)); // take\n+                                                                                                                       // off\n+                                                                                                                       // leading\n+                                                                                                                       // zeros", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 550}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxODMzNw==", "bodyText": "Only labels should be capitalized. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r449918337", "createdAt": "2020-07-05T21:01:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,655 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"kaleidescape\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Kaleidescape Movie Player Thing -->\n+\t<thing-type id=\"player\">\n+\t\t<label>Kaleidescape</label>\n+\t\t<description>\n+\t\t\tA Movie Player Zone in a Kaleidescape System\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"ui\" typeId=\"ui\">\n+\t\t\t\t<label>User Interface</label>\n+\t\t\t\t<description>Controls and Information for the Player's On Screen Interface</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"music\" typeId=\"music\">\n+\t\t\t\t<label>Music Zone</label>\n+\t\t\t\t<description>Controls and Information for the Player's Music Zone</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"detail\" typeId=\"detail\">\n+\t\t\t\t<label>Content Details</label>\n+\t\t\t\t<description>Contains Metadata About a Selected Item</description>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Component Type\">unknown</property>\n+\t\t\t<property name=\"Friendly Name\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Control Protocol ID\">unknown</property>\n+\t\t\t<property name=\"System Version\">unknown</property>\n+\t\t\t<property name=\"Protocol Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"componentType\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Component Type</label>\n+\t\t\t\t<description>Choose Type of Kaleidescape Component</description>\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"Player\">Premiere (Any KPlayer, M Class [M300, M500, M700]) or Cinema One 1st Gen</option>\n+\t\t\t\t\t<option value=\"Cinema One\">Cinema One 2nd Gen</option>\n+\t\t\t\t\t<option value=\"Alto\">Alto</option>\n+\t\t\t\t\t<option value=\"Strato\">Strato</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>Player</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Kaleidescape Component.</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"false\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Communication Port for IP Connection to the Kaleidescape Component.</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>(Optional) Serial Port to Use for Connecting Directly to an Individual Kaleidescape Component.</description>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"updatePeriod\" type=\"integer\" min=\"0\" max=\"1\" unit=\"s\" required=\"false\">\n+\t\t\t\t<label>Update Period</label>\n+\t\t\t\t<description>Tells the Component How Often Time Status Updates Should Be Sent; Values Greater Than 1 Are Not Yet\n+\t\t\t\t\tImplmented by the Protocol. Setting to 1 May Impact openHAB System Performance Due\n+\t\t\t\t\tto Constant Updates While Content\n+\t\t\t\t\tPlaying.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45bf4f68b9d7cad93cf1cb63669a3a692244b5c6", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/45bf4f68b9d7cad93cf1cb63669a3a692244b5c6", "committedDate": "2020-07-07T02:52:52Z", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNTI4NDM2", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-443528436", "createdAt": "2020-07-07T02:56:26Z", "commit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMjo1NjoyNlrOGtteBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMjo1NjoyNlrOGtteBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA==", "bodyText": "@fwolter It is possible that these are not needed since I have implemented the \"REFRESH\" actions for the channels? If the channels all refresh on reboot, they would cause all these same commands to be sent.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r450584068", "createdAt": "2020-07-07T02:56:26Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 376}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b2bbdade4823ebb6974be26038d220e0f5c764a", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5b2bbdade4823ebb6974be26038d220e0f5c764a", "committedDate": "2020-07-07T03:01:43Z", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MDgzNzQ2", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-445083746", "createdAt": "2020-07-08T19:55:12Z", "commit": {"oid": "5b2bbdade4823ebb6974be26038d220e0f5c764a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c08523aa8e0587306243d261e1d280702aaad1c1", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c08523aa8e0587306243d261e1d280702aaad1c1", "committedDate": "2020-07-08T22:16:16Z", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c3a1755977c02184ce94ac1ade28123a80f37fc", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9c3a1755977c02184ce94ac1ade28123a80f37fc", "committedDate": "2020-07-16T21:33:59Z", "message": "Add ThingActions bug workaround\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "committedDate": "2020-07-16T21:38:23Z", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb5329643407a367391a2224328311997f14a3f8", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/bb5329643407a367391a2224328311997f14a3f8", "committedDate": "2020-07-17T21:49:05Z", "message": "[kaleidescape] Workaround for thing actions bug\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b579193ad576302dc462c6574b4890746be2025", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "committedDate": "2020-07-25T03:38:33Z", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78f69778930aba426a203feec98c17aee188a536", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/78f69778930aba426a203feec98c17aee188a536", "committedDate": "2020-07-28T15:24:48Z", "message": "Merge pull request #8 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe2e96a8b02c7692f02c2f5e19f7f45f6cd56f16", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/fe2e96a8b02c7692f02c2f5e19f7f45f6cd56f16", "committedDate": "2020-07-29T14:01:30Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "538098533700b32473c6a712c0b94ecd1ef30179", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/538098533700b32473c6a712c0b94ecd1ef30179", "committedDate": "2020-07-29T14:26:35Z", "message": "update version and review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjYzMjY5", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-460263269", "createdAt": "2020-08-03T18:51:05Z", "commit": {"oid": "538098533700b32473c6a712c0b94ecd1ef30179"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODo1MTowNVrOG7E6ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODo1MTowNVrOG7E6ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5OTczOA==", "bodyText": "It's planned to provide a replacement for the string escaping functions in the core of OH3. The plan is to change the Apache Commons invocations to core functions when OH3 is being released. So, these dependencies won't be necessary at all and should be removed, in contrary to my previous recommendation.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r464599738", "createdAt": "2020-08-03T18:51:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.kaleidescape/pom.xml", "diffHunk": "@@ -0,0 +1,36 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.8-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.kaleidescape</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: Kaleidescape Binding</name>\n+\n+  <properties>\n+    <dep.noembedding>commons-net,commons-lang3</dep.noembedding>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>commons-net</groupId>\n+      <artifactId>commons-net</artifactId>\n+      <version>3.3</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.8.1</version>\n+      <scope>compile</scope>\n+    </dependency>\n+  </dependencies>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "538098533700b32473c6a712c0b94ecd1ef30179"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ede36af231a0a9697e9f0cf373a46a37fe13f143", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ede36af231a0a9697e9f0cf373a46a37fe13f143", "committedDate": "2020-08-14T02:45:34Z", "message": "removed unused dependencies\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4606089923324ea3ee66e434f8221e3259d2910c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/4606089923324ea3ee66e434f8221e3259d2910c", "committedDate": "2020-08-14T18:35:52Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f49106bbf897956459a88243323fc5d64a4b3223", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f49106bbf897956459a88243323fc5d64a4b3223", "committedDate": "2020-08-22T01:32:17Z", "message": "Merge pull request #9 from openhab/2.5.x\n\nUpdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fd1b3d52e605d6f59d9eb7d5dad7a82ebad7c3c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5fd1b3d52e605d6f59d9eb7d5dad7a82ebad7c3c", "committedDate": "2020-08-25T02:08:34Z", "message": "Roll forward a few review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94e4815acfab18936bf860d9780cce0af0f7b9f7", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/94e4815acfab18936bf860d9780cce0af0f7b9f7", "committedDate": "2020-08-26T13:30:01Z", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce6b1b83511266993e7e74b54122b54654265a79", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ce6b1b83511266993e7e74b54122b54654265a79", "committedDate": "2020-08-26T15:39:12Z", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf93c068b57bdd21e214921b2b8a833db876de24", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/bf93c068b57bdd21e214921b2b8a833db876de24", "committedDate": "2020-08-26T17:38:13Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ad93130f407d635fcbe3fd1198a869baa1856cb2", "committedDate": "2020-08-26T19:05:12Z", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31227c502d4697366429850b34557b7cebf44831", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/31227c502d4697366429850b34557b7cebf44831", "committedDate": "2020-08-26T20:01:12Z", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b502d6be82aa91b659c9a6bfcfa0c57cb11fd3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/91b502d6be82aa91b659c9a6bfcfa0c57cb11fd3", "committedDate": "2020-08-26T20:03:09Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a5327cb44c5f0ed3f4640a439df62954d8ab33", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/86a5327cb44c5f0ed3f4640a439df62954d8ab33", "committedDate": "2020-09-03T00:24:02Z", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6496680c4bc78b0baec704969179b033b21197f", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a6496680c4bc78b0baec704969179b033b21197f", "committedDate": "2020-09-03T13:33:02Z", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61abc1f55cfa645afd9c6f3e2119e9f7ed6fb09d", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/61abc1f55cfa645afd9c6f3e2119e9f7ed6fb09d", "committedDate": "2020-09-03T13:33:30Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzgyNTU1", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-484382555", "createdAt": "2020-09-08T18:13:33Z", "commit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzgyODY2", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-484382866", "createdAt": "2020-09-08T18:14:01Z", "commit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05fbbaf25a713e8147387b05c02fe2b2005d61da", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/05fbbaf25a713e8147387b05c02fe2b2005d61da", "committedDate": "2020-09-09T13:34:56Z", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a45901a01798dfd1342d4c8c7b85e8964321b48c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a45901a01798dfd1342d4c8c7b85e8964321b48c", "committedDate": "2020-09-09T14:20:56Z", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "803c0bb644614b715606cce56997f5061aadd685", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/803c0bb644614b715606cce56997f5061aadd685", "committedDate": "2020-09-09T15:14:23Z", "message": "Merge branch '2.5.x' into Kaleidescape"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDYyOTc2", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-487062976", "createdAt": "2020-09-11T19:17:08Z", "commit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxOToxNzowOFrOHQq1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxOTo1NzowNVrOHQsCgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI0MTA0NA==", "bodyText": "You should still log something here at the very least.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487241044", "createdAt": "2020-09-11T19:17:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeSerialConnector.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the Kaleidescape component through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ */\n+@NonNullByDefault\n+public class KaleidescapeSerialConnector extends KaleidescapeConnector {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeSerialConnector.class);\n+\n+    private final String serialPortName;\n+    private final SerialPortManager serialPortManager;\n+    private final String uid;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     * @param uid the thing uid string\n+     */\n+    public KaleidescapeSerialConnector(SerialPortManager serialPortManager, String serialPortName, String uid) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+        this.uid = uid;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws KaleidescapeException {\n+        logger.debug(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                throw new KaleidescapeException(\"Opening serial connection failed: No Such Port\");\n+            }\n+\n+            SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000);\n+\n+            commPort.setSerialPortParams(19200, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(100);\n+            commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\n+\n+            InputStream dataIn = commPort.getInputStream();\n+            OutputStream dataOut = commPort.getOutputStream();\n+\n+            if (dataOut != null) {\n+                dataOut.flush();\n+            }\n+            if (dataIn != null && dataIn.markSupported()) {\n+                try {\n+                    dataIn.reset();\n+                } catch (IOException e) {\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1NTAxMw==", "bodyText": "Should probably check whether any of the channels have been removed before you edit the thing.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487255013", "createdAt": "2020-09-11T19:45:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,610 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1ODA4NQ==", "bodyText": "Don't use the default thread factory here. You should name the threads in some way so that the can be identified as part of this binding, also make sure that the threads you create are daemon.\nYou can use a NamedThreadFactory instance as an additional parameter to newFixedThreadPool.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487258085", "createdAt": "2020-09-11T19:51:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n+public class KaleidescapeDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeDiscoveryService.class);\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_PLAYER_ZONE);\n+\n+    @Activate\n+    public KaleidescapeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_DEFAULT_TIMEOUT_RATE_MS, DISCOVERY_DEFAULT_AUTO_DISCOVER);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting discovery of Kaleidescape components.\");\n+\n+        try {\n+            List<String> ipList = getIpAddressScanList();\n+\n+            ExecutorService discoverySearchPool = Executors.newFixedThreadPool(DISCOVERY_THREAD_POOL_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI2MDgwMg==", "bodyText": "make sure the add the apache dependencies here if you don't plan on removing the code that uses it.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487260802", "createdAt": "2020-09-11T19:57:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.kaleidescape/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.9-SNAPSHOT</version>\n+  </parent>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad93130f407d635fcbe3fd1198a869baa1856cb2"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/da75f58615c1b8ac27134f1585b40a8cbfd7bc08", "committedDate": "2020-09-11T22:13:40Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3Njg0NTU3", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-487684557", "createdAt": "2020-09-14T12:04:58Z", "commit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjowNDo1OVrOHRQjuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjozNTowN1rOHRRnWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1OTEyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.kaleidescape\")", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487859128", "createdAt": "2020-09-14T12:04:59Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/discovery/KaleidescapeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.discovery;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeDiscoveryService} class allow manual discovery of Kaleidescape components.\n+ *\n+ * @author Chris Graham - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Kaleidescape binding\n+ * \n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.kaleidescape\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Mjg0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(KaleidescapeMessageEvent event);\n          \n          \n            \n                void onNewMessageEvent(KaleidescapeMessageEvent event);", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487862840", "createdAt": "2020-09-14T12:11:43Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/communication/KaleidescapeMessageEventListener.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.communication;\n+\n+import java.util.EventListener;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Kaleidescape Event Listener interface. Handles incoming Kaleidescape message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface KaleidescapeMessageEventListener extends EventListener {\n+    /**\n+     * Event handler method for incoming Kaleidescape message events\n+     *\n+     * @param event the KaleidescapeMessageEvent object\n+     */\n+    public void onNewMessageEvent(KaleidescapeMessageEvent event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NDMyNA==", "bodyText": "I wonder if you would create a thing with volum disabled and than edit the thing to enable the volume if the channels will come back? Not sure if that works? You might need to recreate them.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487864324", "createdAt": "2020-09-14T12:14:28Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2NjI4Mg==", "bodyText": "It would be cleaner to use separate thing definitions for these different models. The UI initially just reads the xml and then would show all channels even if not available if one would create the thing manually in the ui. You would not need to specify the component type as parameter. The xml will become a bit larger. Although you can use a config reference to point to a single configuration.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487866282", "createdAt": "2020-09-14T12:18:01Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Njg4MQ==", "bodyText": "If you also set the status this can be debug. You could set the command and message in the status to give the user this information directly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n          \n          \n            \n                            logger.debug(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487866881", "createdAt": "2020-09-14T12:19:09Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        if (channelsRemoved) {\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort, uid);\n+        } else if (port != null) {\n+            connector = new KaleidescapeIpConnector(host, port, uid);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MjgxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateState(channel, new StringType(EMPTY));\n          \n          \n            \n                            updateState(channel, StringType.EMPTY);", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487872816", "createdAt": "2020-09-14T12:29:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        if (channelsRemoved) {\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort, uid);\n+        } else if (port != null) {\n+            connector = new KaleidescapeIpConnector(host, port, uid);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL_S * 1.25 * 1000)) {\n+                        logger.warn(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, POLLING_INTERVAL_S, POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    private void handleControlCommand(Command command) throws KaleidescapeException {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connector.sendCommand(PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connector.sendCommand(PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connector.sendCommand(NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connector.sendCommand(PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                connector.sendCommand(SCAN_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                connector.sendCommand(SCAN_REVERSE);\n+            }\n+        } else {\n+            logger.warn(\"Unknown control command: {}\", command);\n+        }\n+    }\n+\n+    private void handleRefresh(String channel) throws KaleidescapeException {\n+        switch (channel) {\n+            case POWER:\n+                connector.sendCommand(GET_DEVICE_POWER_STATE);\n+                break;\n+            case VOLUME:\n+                updateState(channel, new PercentType(this.volume));\n+                break;\n+            case MUTE:\n+                updateState(channel, this.isMuted ? OnOffType.ON : OnOffType.OFF);\n+                break;\n+            case TITLE_NAME:\n+                connector.sendCommand(GET_PLAYING_TITLE_NAME);\n+                break;\n+            case PLAY_MODE:\n+            case PLAY_SPEED:\n+            case TITLE_NUM:\n+            case TITLE_LENGTH:\n+            case TITLE_LOC:\n+            case CHAPTER_NUM:\n+            case CHAPTER_LENGTH:\n+            case CHAPTER_LOC:\n+                connector.sendCommand(GET_PLAY_STATUS);\n+                break;\n+            case MOVIE_MEDIA_TYPE:\n+                connector.sendCommand(GET_MOVIE_MEDIA_TYPE);\n+                break;\n+            case MOVIE_LOCATION:\n+                connector.sendCommand(GET_MOVIE_LOCATION);\n+                break;\n+            case VIDEO_MODE:\n+            case VIDEO_MODE_COMPOSITE:\n+            case VIDEO_MODE_COMPONENT:\n+            case VIDEO_MODE_HDMI:\n+                connector.sendCommand(GET_VIDEO_MODE);\n+                break;\n+            case VIDEO_COLOR:\n+            case VIDEO_COLOR_EOTF:\n+                connector.sendCommand(GET_VIDEO_COLOR);\n+                break;\n+            case CONTENT_COLOR:\n+            case CONTENT_COLOR_EOTF:\n+                connector.sendCommand(GET_CONTENT_COLOR);\n+                break;\n+            case SCALE_MODE:\n+                connector.sendCommand(GET_SCALE_MODE);\n+                break;\n+            case ASPECT_RATIO:\n+            case SCREEN_MASK:\n+                connector.sendCommand(GET_SCREEN_MASK);\n+                break;\n+            case SCREEN_MASK2:\n+                connector.sendCommand(GET_SCREEN_MASK2);\n+                break;\n+            case CINEMASCAPE_MASK:\n+                connector.sendCommand(GET_CINEMASCAPE_MASK);\n+                break;\n+            case CINEMASCAPE_MODE:\n+                connector.sendCommand(GET_CINEMASCAPE_MODE);\n+                break;\n+            case UI_STATE:\n+                connector.sendCommand(GET_UI_STATE);\n+                break;\n+            case CHILD_MODE_STATE:\n+                connector.sendCommand(GET_CHILD_MODE_STATE);\n+                break;\n+            case SYSTEM_READINESS_STATE:\n+                connector.sendCommand(GET_SYSTEM_READINESS_STATE);\n+                break;\n+            case HIGHLIGHTED_SELECTION:\n+                connector.sendCommand(GET_HIGHLIGHTED_SELECTION);\n+                break;\n+            case USER_DEFINED_EVENT:\n+            case USER_INPUT:\n+            case USER_INPUT_PROMPT:\n+                updateState(channel, new StringType(EMPTY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 572}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3Mjk2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateState(channel, new StringType(EMPTY));\n          \n          \n            \n                            updateState(channel, StringType.EMPTY);", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487872960", "createdAt": "2020-09-14T12:29:27Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_S = 60;\n+    private static final long POLLING_INTERVAL_S = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final String uid = this.getThing().getUID().getAsString();\n+        KaleidescapeThingConfiguration config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        final String componentType = config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        final String serialPort = config.serialPort;\n+        final String host = config.host;\n+        final Integer port = config.port;\n+        final Integer updatePeriod = config.updatePeriod;\n+\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (host == null || host.isEmpty()) {\n+            if (serialPort != null && serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+\n+        if (updatePeriod != null) {\n+            this.updatePeriod = updatePeriod;\n+        }\n+\n+        boolean channelsRemoved = false;\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(this.volume));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channelsRemoved = true;\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        if (channelsRemoved) {\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort, uid);\n+        } else if (port != null) {\n+            connector = new KaleidescapeIpConnector(host, port, uid);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR));\n+                            }\n+\n+                            initialCommands.forEach(command -> {\n+                                try {\n+                                    connector.sendCommand(command);\n+                                } catch (KaleidescapeException e) {\n+                                    logger.debug(\"{}: {}\", \"Error sending initial commands\", e.getMessage());\n+                                }\n+                            });\n+\n+                            if (this.updatePeriod == 1) {\n+                                connector.sendCommand(SET_STATUS_CUE_PERIOD_1);\n+                            }\n+                        } catch (KaleidescapeException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (!error.equals(EMPTY)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+                    lastEventReceived = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the component for updated status...\");\n+                    try {\n+                        connector.ping();\n+                    } catch (KaleidescapeException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last successful polling update was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL_S * 1.25 * 1000)) {\n+                        logger.warn(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, POLLING_INTERVAL_S, POLLING_INTERVAL_S, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    private void handleControlCommand(Command command) throws KaleidescapeException {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connector.sendCommand(PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connector.sendCommand(PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connector.sendCommand(NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connector.sendCommand(PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                connector.sendCommand(SCAN_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                connector.sendCommand(SCAN_REVERSE);\n+            }\n+        } else {\n+            logger.warn(\"Unknown control command: {}\", command);\n+        }\n+    }\n+\n+    private void handleRefresh(String channel) throws KaleidescapeException {\n+        switch (channel) {\n+            case POWER:\n+                connector.sendCommand(GET_DEVICE_POWER_STATE);\n+                break;\n+            case VOLUME:\n+                updateState(channel, new PercentType(this.volume));\n+                break;\n+            case MUTE:\n+                updateState(channel, this.isMuted ? OnOffType.ON : OnOffType.OFF);\n+                break;\n+            case TITLE_NAME:\n+                connector.sendCommand(GET_PLAYING_TITLE_NAME);\n+                break;\n+            case PLAY_MODE:\n+            case PLAY_SPEED:\n+            case TITLE_NUM:\n+            case TITLE_LENGTH:\n+            case TITLE_LOC:\n+            case CHAPTER_NUM:\n+            case CHAPTER_LENGTH:\n+            case CHAPTER_LOC:\n+                connector.sendCommand(GET_PLAY_STATUS);\n+                break;\n+            case MOVIE_MEDIA_TYPE:\n+                connector.sendCommand(GET_MOVIE_MEDIA_TYPE);\n+                break;\n+            case MOVIE_LOCATION:\n+                connector.sendCommand(GET_MOVIE_LOCATION);\n+                break;\n+            case VIDEO_MODE:\n+            case VIDEO_MODE_COMPOSITE:\n+            case VIDEO_MODE_COMPONENT:\n+            case VIDEO_MODE_HDMI:\n+                connector.sendCommand(GET_VIDEO_MODE);\n+                break;\n+            case VIDEO_COLOR:\n+            case VIDEO_COLOR_EOTF:\n+                connector.sendCommand(GET_VIDEO_COLOR);\n+                break;\n+            case CONTENT_COLOR:\n+            case CONTENT_COLOR_EOTF:\n+                connector.sendCommand(GET_CONTENT_COLOR);\n+                break;\n+            case SCALE_MODE:\n+                connector.sendCommand(GET_SCALE_MODE);\n+                break;\n+            case ASPECT_RATIO:\n+            case SCREEN_MASK:\n+                connector.sendCommand(GET_SCREEN_MASK);\n+                break;\n+            case SCREEN_MASK2:\n+                connector.sendCommand(GET_SCREEN_MASK2);\n+                break;\n+            case CINEMASCAPE_MASK:\n+                connector.sendCommand(GET_CINEMASCAPE_MASK);\n+                break;\n+            case CINEMASCAPE_MODE:\n+                connector.sendCommand(GET_CINEMASCAPE_MODE);\n+                break;\n+            case UI_STATE:\n+                connector.sendCommand(GET_UI_STATE);\n+                break;\n+            case CHILD_MODE_STATE:\n+                connector.sendCommand(GET_CHILD_MODE_STATE);\n+                break;\n+            case SYSTEM_READINESS_STATE:\n+                connector.sendCommand(GET_SYSTEM_READINESS_STATE);\n+                break;\n+            case HIGHLIGHTED_SELECTION:\n+                connector.sendCommand(GET_HIGHLIGHTED_SELECTION);\n+                break;\n+            case USER_DEFINED_EVENT:\n+            case USER_INPUT:\n+            case USER_INPUT_PROMPT:\n+                updateState(channel, new StringType(EMPTY));\n+                break;\n+            case MUSIC_REPEAT:\n+            case MUSIC_RANDOM:\n+                connector.sendCommand(GET_MUSIC_NOW_PLAYING_STATUS);\n+                break;\n+            case MUSIC_TRACK:\n+            case MUSIC_ARTIST:\n+            case MUSIC_ALBUM:\n+            case MUSIC_TRACK_HANDLE:\n+            case MUSIC_ALBUM_HANDLE:\n+            case MUSIC_NOWPLAY_HANDLE:\n+                connector.sendCommand(GET_MUSIC_TITLE);\n+                break;\n+            case MUSIC_PLAY_MODE:\n+            case MUSIC_PLAY_SPEED:\n+            case MUSIC_TRACK_LENGTH:\n+            case MUSIC_TRACK_POSITION:\n+            case MUSIC_TRACK_PROGRESS:\n+                connector.sendCommand(GET_MUSIC_PLAY_STATUS);\n+                break;\n+            case DETAIL_TYPE:\n+            case DETAIL_TITLE:\n+            case DETAIL_ALBUM_TITLE:\n+            case DETAIL_COVER_ART:\n+            case DETAIL_COVER_URL:\n+            case DETAIL_HIRES_COVER_URL:\n+            case DETAIL_RATING:\n+            case DETAIL_YEAR:\n+            case DETAIL_RUNNING_TIME:\n+            case DETAIL_ACTORS:\n+            case DETAIL_ARTIST:\n+            case DETAIL_DIRECTORS:\n+            case DETAIL_GENRES:\n+            case DETAIL_RATING_REASON:\n+            case DETAIL_SYNOPSIS:\n+            case DETAIL_REVIEW:\n+            case DETAIL_COLOR_DESCRIPTION:\n+            case DETAIL_COUNTRY:\n+            case DETAIL_ASPECT_RATIO:\n+            case DETAIL_DISC_LOCATION:\n+                updateState(channel, new StringType(EMPTY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da75f58615c1b8ac27134f1585b40a8cbfd7bc08"}, "originalPosition": 613}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NjQ0MA==", "bodyText": "I have used ExpiringCache with a small timout, like 3 seconds. When the cache expires it will call the method passed. You could use this channels have the same command, such that when multiple of these channels are updated they are not all sending the command. And when using a cache you can probably iterate over the channels here, check if the channel is linked (i.e. if it actually make sense to update the channel) and then call handleRefresh with the channel instead of directly sending the command here. There is also an ExpiringCacheMap to handle multiple caches.", "url": "https://github.com/openhab/openhab-addons/pull/7568#discussion_r487876440", "createdAt": "2020-09-14T12:35:07Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.kaleidescape/src/main/java/org/openhab/binding/kaleidescape/internal/handler/KaleidescapeHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.kaleidescape.internal.handler;\n+\n+import static org.openhab.binding.kaleidescape.internal.KaleidescapeBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeException;\n+import org.openhab.binding.kaleidescape.internal.KaleidescapeThingActions;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeDefaultConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeIpConnector;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEvent;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeMessageEventListener;\n+import org.openhab.binding.kaleidescape.internal.communication.KaleidescapeSerialConnector;\n+import org.openhab.binding.kaleidescape.internal.configuration.KaleidescapeThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KaleidescapeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KaleidescapeHandler extends BaseThingHandler implements KaleidescapeMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(KaleidescapeHandler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    protected final HttpClient httpClient;\n+    protected final Unit<Time> apiSecondUnit = SmartHomeUnits.SECOND;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable KaleidescapeThingConfiguration config;\n+    private long lastEventReceived = 0;\n+    private int updatePeriod = 0;\n+    private String componentType = EMPTY;\n+\n+    protected KaleidescapeConnector connector = new KaleidescapeDefaultConnector();\n+    protected int metaRuntimeMultiple = 1;\n+    protected int volume = 0;\n+    protected boolean volumeEnabled = false;\n+    protected boolean isMuted = false;\n+    protected String friendlyName = EMPTY;\n+    protected Object sequenceLock = new Object();\n+\n+    public KaleidescapeHandler(Thing thing, SerialPortManager serialPortManager, HttpClient httpClient) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+        this.httpClient = httpClient;\n+    }\n+\n+    protected void updateChannel(String channelUID, State state) {\n+        this.updateState(channelUID, state);\n+    }\n+\n+    protected void updateDetailChannel(String channelUID, State state) {\n+        this.updateState(DETAIL + channelUID, state);\n+    }\n+\n+    protected void updateThingProperty(String name, String value) {\n+        thing.setProperty(name, value);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(KaleidescapeThingConfiguration.class);\n+        @Nullable\n+        String componentType = this.config.componentType;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (componentType != null) {\n+            this.componentType = componentType;\n+        }\n+        this.updatePeriod = this.config.updatePeriod;\n+\n+        List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+        // check if volume is enabled, if not remove the volume & mute channels\n+        if (config.volumeEnabled) {\n+            this.volumeEnabled = true;\n+            this.volume = config.initialVolume;\n+            this.updateState(VOLUME, new PercentType(BigDecimal.valueOf(this.volume)));\n+            this.updateState(MUTE, OnOffType.OFF);\n+        } else {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VOLUME)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(MUTE)));\n+        }\n+\n+        // remove music channels if we are not a Premiere Player or Cinema One\n+        if (!(PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType))) {\n+            channels.removeIf(c -> (c.getUID().getId().contains(MUSIC)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ALBUM_TITLE)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_ARTIST)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(DETAIL + DETAIL_REVIEW)));\n+        }\n+\n+        // premiere players do not support SYSTEM_READINESS_STATE\n+        if (PLAYER.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(SYSTEM_READINESS_STATE)));\n+        }\n+\n+        // remove VIDEO_COLOR and CONTENT_COLOR if not a Strato\n+        if (!STRATO.equals(this.componentType)) {\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(VIDEO_COLOR_EOTF)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(CONTENT_COLOR_EOTF)));\n+        }\n+\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new KaleidescapeSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new KaleidescapeIpConnector(config.host, config.port);\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(KaleidescapeThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"K Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                if (command instanceof RefreshType) {\n+                    handleRefresh(channel);\n+                    return;\n+                }\n+\n+                switch (channel) {\n+                    case POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? LEAVE_STANDBY : ENTER_STANDBY);\n+                        }\n+                        break;\n+                    case VOLUME:\n+                        if (command instanceof PercentType) {\n+                            this.volume = (int) ((PercentType) command).doubleValue();\n+                            logger.debug(\"Got volume command {}\", this.volume);\n+                            connector.sendCommand(SEND_EVENT_VOLUME_LEVEL_EQ + this.volume);\n+                        }\n+                        break;\n+                    case MUTE:\n+                        if (command instanceof OnOffType) {\n+                            this.isMuted = command == OnOffType.ON ? true : false;\n+                        }\n+                        connector.sendCommand(SEND_EVENT_MUTE + (this.isMuted ? MUTE_ON : MUTE_OFF));\n+                        break;\n+                    case MUSIC_REPEAT:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_REPEAT_ON : MUSIC_REPEAT_OFF);\n+                        }\n+                        break;\n+                    case MUSIC_RANDOM:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(command == OnOffType.ON ? MUSIC_RANDOM_ON : MUSIC_RANDOM_OFF);\n+                        }\n+                        break;\n+                    case CONTROL:\n+                    case MUSIC_CONTROL:\n+                        handleControlCommand(command);\n+                        break;\n+                    default:\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+            } catch (KaleidescapeException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Kaleidescape component\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (KaleidescapeException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Kaleidescape component\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(KaleidescapeMessageEvent evt) {\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        // check if we are in standby\n+        if (STANDBY_MSG.equals(evt.getKey())) {\n+            if (!ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.BRIDGE_OFFLINE, STANDBY_MSG);\n+            }\n+            return;\n+        }\n+        try {\n+            // Use the Enum valueOf to handle the message based on the event key. Otherwise there would be a huge\n+            // case statement here\n+            KaleidescapeMessageHandler.valueOf(evt.getKey()).handleMessage(evt.getValue(), this);\n+\n+            if (ThingStatusDetail.BRIDGE_OFFLINE.equals(thing.getStatusInfo().getStatusDetail())) {\n+                // no longer in standby, update the status\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.friendlyName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"Unhandled message: key {} = {}\", evt.getKey(), evt.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = EMPTY;\n+                    if (openConnection()) {\n+                        try {\n+                            Set<String> initialCommands = new HashSet<String>(Arrays.asList(GET_DEVICE_TYPE_NAME,\n+                                    GET_FRIENDLY_NAME, GET_DEVICE_INFO, GET_SYSTEM_VERSION, GET_DEVICE_POWER_STATE,\n+                                    GET_CINEMASCAPE_MASK, GET_CINEMASCAPE_MODE, GET_SCALE_MODE, GET_SCREEN_MASK,\n+                                    GET_SCREEN_MASK2, GET_VIDEO_MODE, GET_UI_STATE, GET_HIGHLIGHTED_SELECTION,\n+                                    GET_CHILD_MODE_STATE, GET_PLAY_STATUS, GET_MOVIE_LOCATION, GET_MOVIE_MEDIA_TYPE,\n+                                    GET_PLAYING_TITLE_NAME));\n+\n+                            // Premiere Players and Cinema One support music\n+                            if (PLAYER.equals(this.componentType) || CINEMA_ONE.equals(this.componentType)) {\n+                                initialCommands.addAll(new ArrayList<String>(Arrays.asList(GET_MUSIC_NOW_PLAYING_STATUS,\n+                                        GET_MUSIC_PLAY_STATUS, GET_MUSIC_TITLE)));\n+                            }\n+\n+                            // everything after Premiere Player supports GET_SYSTEM_READINESS_STATE\n+                            if (!PLAYER.equals(this.componentType)) {\n+                                initialCommands.add(GET_SYSTEM_READINESS_STATE);\n+                            }\n+\n+                            // only Strato supports the GET_*_COLOR commands\n+                            if (STRATO.equals(this.componentType)) {\n+                                initialCommands.addAll(\n+                                        new ArrayList<String>(Arrays.asList(GET_VIDEO_COLOR, GET_CONTENT_COLOR)));\n+                            }\n+\n+                            initialCommands.forEach(command -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NDA2OA=="}, "originalCommit": {"oid": "6cd55e702fa1ddd98c1cdef4fe16cfee14a86b85"}, "originalPosition": 376}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1d99857260e30163bd2a6460bfd1f2c71361378", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e1d99857260e30163bd2a6460bfd1f2c71361378", "committedDate": "2020-09-14T23:28:19Z", "message": "implement thing per model and caching\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NTgxNjM0", "url": "https://github.com/openhab/openhab-addons/pull/7568#pullrequestreview-488581634", "createdAt": "2020-09-15T11:22:47Z", "commit": {"oid": "e1d99857260e30163bd2a6460bfd1f2c71361378"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 746, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}