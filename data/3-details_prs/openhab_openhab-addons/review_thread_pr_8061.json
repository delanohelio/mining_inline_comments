{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MTUyODAx", "number": 8061, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOToyNjo0MVrOESLVWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxOToyNDoxMFrOES9FWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk1NTE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOToyNjo0MVrOG3OmZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozMzozM1rOG3skyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDA3MA==", "bodyText": "Can you express this more abstract, as PaperUI will be removed in OH3?", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460564070", "createdAt": "2020-07-26T19:26:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NTE3OQ==", "bodyText": "Ok. Will do.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461055179", "createdAt": "2020-07-27T17:33:33Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDA3MA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk2MDE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/README.md", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOTozMzowN1rOG3Oovg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODoxMDozOVrOG4YkSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDY3MA==", "bodyText": "Can this be done periodically by the binding? Beside the usability aspect, this seems more like a ThingAction  rather a Channel. Alternatively, the user could disable and re-enable the Thing, which would trigger a REFRESH command.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460564670", "createdAt": "2020-07-26T19:33:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4Mjg4OQ==", "bodyText": "Can this be done periodically by the binding?\n\nYes, I did think about doing it automatically periodically. But my thinking was as follows..\nThe binding polls the hub at 60 seconds interval, so one approach would be to do such a \"hard refresh\" on every poll. But my observations (with only three shades in my house) show that whereas a soft poll takes only milliseconds, by contrast a hard refresh takes several seconds. I am concerned that if there were 10..15 shades, then the hard refresh time would exceed the polling interval. Also a hard refresh will wake the shades out of sleep, and since many of Hunter Douglas shades are battery powered, it risks to seriously reduce battery lifetime.\nFor the above reasons it is clear that, if the binding were to do hard refreshes periodically, then the interval must be significantly longer than the soft polling interval. My choice therefore was to make the hard refresh interval = \"infinite\". i.e. to do it manually at the discretion of the user. (And the user could set up their own rule to do it periodically, if they want to).\nNote that hard refreshes are only needed in the case that the user uses a wireless remote (which talks to the shades without informing the hub). If the user would only being using OpenHAB to command the shades, then the hub is always \"in the loop\" so hard requests are not required.\nNotwithstanding the above, I am amenable to changing the approach and doing hard refreshes periodically. There would then be a Config Param for hard refresh interval, that could be set to 0 to disable it. => But before making such a change, I would appreciate having inputs for my \"testing team\" => @berland and @mstroeve => what are your thoughts?\n\nBeside the usability aspect, this seems more like a ThingAction rather a Channel.\n\nI don't agree. If the hard refresh is to be done manually then it needs a UI; so it is logical to have an item linked to a channel as below..\n\n\nAlternatively, the user could disable and re-enable the Thing, which would trigger a REFRESH command.\n\nAargh!! IMHO that would NOT be an elegant solution at all :(", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461082889", "createdAt": "2020-07-27T18:22:41Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDY3MA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNjg4OA==", "bodyText": "What a shame. It seems like a conceptual issue that the shades don't send their states on itself when changed. I think the periodic hard refresh option would be a good solution, if it can be disabled by the user.\n\nI don't agree. If the hard refresh is to be done manually then it needs a UI; so it is logical to have an item linked to a channel as below..\n\nI don't agree, that you don't agree :) Channels are defined to have a state. Whether it should be accessible via the UI is not a pro or con for a Channel or an Action.\nHowever, Actions/Rules can be triggered by an Item, which make them accessible via UI. Although, I agree, that the ThingActions are not really user friendly configureable currently.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461116888", "createdAt": "2020-07-27T19:25:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDY3MA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczMjY4Ng==", "bodyText": "I really really really would like to keep this as a Channel. Please? Since its functionality would be identical to the Scene Channels (and the Scene Channels are not new features, but have always been implemented as Channels in prior versions of the binding). See also the comment below..", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461732686", "createdAt": "2020-07-28T16:58:51Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDY3MA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNzkyNg==", "bodyText": "You know what? I think I will implement this as an auto refresh function. So in that case we don't need a Channel...", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461737926", "createdAt": "2020-07-28T17:07:48Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDY3MA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3NTk0NQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461775945", "createdAt": "2020-07-28T18:10:39Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDY3MA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk2MjM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/README.md", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOTozNTo1MlrOG3OpwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODoxNTo0NFrOG4Yvfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDkyOA==", "bodyText": "Since it is stateless, this would be an Action, too.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460564928", "createdAt": "2020-07-26T19:35:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4NTMzMA==", "bodyText": "There are two reasons for NOT changing this..\n\nThe prior version of the binding already had Scenes = Channels. So changing the paradigm now would be a \"breaking change\" for existing users.\nSimilar argument concerning UI access to the commands as mentioned in the topic \"hard refresh above\" (see also the BasicUI screenshot above)", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461085330", "createdAt": "2020-07-27T18:26:54Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDkyOA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEyMTY2OQ==", "bodyText": "I understood that every scene Channel gets an additional Channel in the bridge, which is a new feature. I don't understand why changing this new feature would break the existing Channels.\nCan the user set the scene ID to refresh?", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461121669", "createdAt": "2020-07-27T19:34:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDkyOA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyOTQyMA==", "bodyText": "I understood that every scene Channel gets an additional Channel in the bridge, which is a new feature.\n\nNo. This is not a new feature. The original binding was always that way.\nThe new feature is that in addition to having one Channel in the hub for each scene, there is now also one more Channel for the hard refresh. I don't want to change the functioning of the Scene Channels, since that would be a breaking change. I would like to keep the added hard refresh function as a Channel since it would function identically to the Scene Channels, making it easier for the average user to understand.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461729420", "createdAt": "2020-07-28T16:53:26Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDkyOA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1MzY4OQ==", "bodyText": "Ok, you have your reasons to stick to it. I don't want to push you in any direction.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461753689", "createdAt": "2020-07-28T17:33:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDkyOA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3ODgxNA==", "bodyText": "I deleted the hard refresh Channel. And I have left the Scene Channels \"not broken\" as they were.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461778814", "createdAt": "2020-07-28T18:15:44Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDkyOA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk2ODA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOTo0MzoxMFrOG3OsYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozMjozMFrOG3siiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NTYwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            However  shades can also be moved manually without the hub\u2019s knowledge.\n          \n          \n            \n            However shades can also be moved manually without the hub\u2019s knowledge.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460565603", "createdAt": "2020-07-26T19:43:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+### Channels for PowerView Shade\n+\n+A shade always implements a roller shutter channel `position` which controls the vertical position of the shade's (primary) rail.\n+If the shade has slats or rotatable vanes, there is also a dimmer channel `vane` which controls the slat / vane position.\n+If it is a dual action (top-down plus bottom-up) shade, there is also a roller shutter channel `secondary` which controls the vertical position of the secondary rail.\n+All of these channels appear in the binding, but only those which have a physical implementation in the shade, will have any physical effect.\n+\n+| Channel    | Item Type     | Description |\n+|------------|---------------|------------|\n+| position   | Rollershutter | The vertical position of the shade's rail -- _(see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ Up/Down commands will move the rail completely up or completely down. Percentage commands will move the rail to an intermediate position. Stop commands will halt any current movement of the rail. |\n+| secondary  | Rollershutter | The vertical position of the secondary rail (if any). Its function is basically identical to the `position` channel above -- _(but see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ |\n+| vane       | Dimmer        | The degree of opening of the slats or vanes. Setting this to a non-zero value will first move the shade `position` fully down, since the slats or vanes can only have a defined state if the shade is in its down position -- _(see chapter \"**Inter-dependency between Position and Vane Channels**\" below)._ |\n+| batteryLow | Switch        | Indicates ON when the battery level of the shade is low, as determined by the hub's internal rules. |\n+\n+### Roller Shutter Up/Down Position vs. Open/Close State\n+\n+The `position` and `secondary` channels are Rollershutter types.\n+For vertical shades, the binding maps the vertical position of the \"rail\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+And for horizontal shades, it maps the horizontal position of the \"truck\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+\n+Depending on whether the shade is a top-down, bottom-up, left-right, right-left, or dual action shade, the `OPEN` and `CLOSED` position of the shades may differ from the \u25b2 / \u25bc commands follows..\n+\n+| Type of Shade            | Channel           | Rollershutter Command | Motion direction | Shade State    | Percent |\n+|--------------------------|-------------------|-----------------------|------------------|----------------|---------|\n+| Single action bottom-up  | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Single action top-down   | `position`        | \u25b2                     | Up               | ***`CLOSED`*** | 0%      |\n+|                          |                   | \u25bc                     | Down             | ***`OPEN`***   | 100%    |\n+| Single action right-left | `position`        | \u25b2                     | ***Left***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Right***      | `CLOSED`       | 100%    |\n+| Single action left-right | `position`        | \u25b2                     | ***Right***      | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Left***       | `CLOSED`       | 100%    |\n+| Dual action (lower rail) | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Dual action (upper rail) | ***`secondary`*** | \u25b2                     | ***Down***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Up***         | `CLOSED`       | 100%    |\n+\n+### Interdependency between Channel positions\n+\n+On some types of shades with movable vanes, the vanes cannot be moved unless the shade is down.\n+So there is an interdependency between the value of `vane` and the value of `position` as follows..\n+\n+| Case                       | State of `position` | State of `vane` |\n+|----------------------------|---------------------|-----------------|\n+| Shade up                   | 0% = `UP`           | `UNDEFINED`     |\n+| Shade 50% down             | 50%                 | `UNDEFINED`     |\n+| Shade 100% down, Vane 0%   | 100% = `DOWN`       | 0%              |\n+| Shade 100% down, Vane 50%  | 100% = `DOWN`       | 50%             |\n+| Shade 100% down, Vane 100% | 100% = `DOWN`       | 100%            |\n+\n+On dual action shades, the top rail cannot move below the position of the bottom rail.\n+So the value of `secondary` may be constrained by the value of `position`.\n+\n+## Refreshing the PowerView Hub Cache\n+\n+The hub maintains a cache of the last known state of its shades, and this binding delivers those values.\n+Usually the shades will be moved by this binding, so since the hub is always involved in the moving process, it updates this cache accordingly.\n+\n+However  shades can also be moved manually without the hub\u2019s knowledge.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NDYwMQ==", "bodyText": "Ok. Will do.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461054601", "createdAt": "2020-07-27T17:32:30Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+### Channels for PowerView Shade\n+\n+A shade always implements a roller shutter channel `position` which controls the vertical position of the shade's (primary) rail.\n+If the shade has slats or rotatable vanes, there is also a dimmer channel `vane` which controls the slat / vane position.\n+If it is a dual action (top-down plus bottom-up) shade, there is also a roller shutter channel `secondary` which controls the vertical position of the secondary rail.\n+All of these channels appear in the binding, but only those which have a physical implementation in the shade, will have any physical effect.\n+\n+| Channel    | Item Type     | Description |\n+|------------|---------------|------------|\n+| position   | Rollershutter | The vertical position of the shade's rail -- _(see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ Up/Down commands will move the rail completely up or completely down. Percentage commands will move the rail to an intermediate position. Stop commands will halt any current movement of the rail. |\n+| secondary  | Rollershutter | The vertical position of the secondary rail (if any). Its function is basically identical to the `position` channel above -- _(but see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ |\n+| vane       | Dimmer        | The degree of opening of the slats or vanes. Setting this to a non-zero value will first move the shade `position` fully down, since the slats or vanes can only have a defined state if the shade is in its down position -- _(see chapter \"**Inter-dependency between Position and Vane Channels**\" below)._ |\n+| batteryLow | Switch        | Indicates ON when the battery level of the shade is low, as determined by the hub's internal rules. |\n+\n+### Roller Shutter Up/Down Position vs. Open/Close State\n+\n+The `position` and `secondary` channels are Rollershutter types.\n+For vertical shades, the binding maps the vertical position of the \"rail\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+And for horizontal shades, it maps the horizontal position of the \"truck\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+\n+Depending on whether the shade is a top-down, bottom-up, left-right, right-left, or dual action shade, the `OPEN` and `CLOSED` position of the shades may differ from the \u25b2 / \u25bc commands follows..\n+\n+| Type of Shade            | Channel           | Rollershutter Command | Motion direction | Shade State    | Percent |\n+|--------------------------|-------------------|-----------------------|------------------|----------------|---------|\n+| Single action bottom-up  | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Single action top-down   | `position`        | \u25b2                     | Up               | ***`CLOSED`*** | 0%      |\n+|                          |                   | \u25bc                     | Down             | ***`OPEN`***   | 100%    |\n+| Single action right-left | `position`        | \u25b2                     | ***Left***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Right***      | `CLOSED`       | 100%    |\n+| Single action left-right | `position`        | \u25b2                     | ***Right***      | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Left***       | `CLOSED`       | 100%    |\n+| Dual action (lower rail) | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Dual action (upper rail) | ***`secondary`*** | \u25b2                     | ***Down***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Up***         | `CLOSED`       | 100%    |\n+\n+### Interdependency between Channel positions\n+\n+On some types of shades with movable vanes, the vanes cannot be moved unless the shade is down.\n+So there is an interdependency between the value of `vane` and the value of `position` as follows..\n+\n+| Case                       | State of `position` | State of `vane` |\n+|----------------------------|---------------------|-----------------|\n+| Shade up                   | 0% = `UP`           | `UNDEFINED`     |\n+| Shade 50% down             | 50%                 | `UNDEFINED`     |\n+| Shade 100% down, Vane 0%   | 100% = `DOWN`       | 0%              |\n+| Shade 100% down, Vane 50%  | 100% = `DOWN`       | 50%             |\n+| Shade 100% down, Vane 100% | 100% = `DOWN`       | 100%            |\n+\n+On dual action shades, the top rail cannot move below the position of the bottom rail.\n+So the value of `secondary` may be constrained by the value of `position`.\n+\n+## Refreshing the PowerView Hub Cache\n+\n+The hub maintains a cache of the last known state of its shades, and this binding delivers those values.\n+Usually the shades will be moved by this binding, so since the hub is always involved in the moving process, it updates this cache accordingly.\n+\n+However  shades can also be moved manually without the hub\u2019s knowledge.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NTYwMw=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk3MTM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOTo0NzoyNlrOG3Ot7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozMTozOFrOG3sgdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NTk5Nw==", "bodyText": "To be concise in the documentation, I would only use this one and remove the import version.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460565997", "createdAt": "2020-07-26T19:47:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+### Channels for PowerView Shade\n+\n+A shade always implements a roller shutter channel `position` which controls the vertical position of the shade's (primary) rail.\n+If the shade has slats or rotatable vanes, there is also a dimmer channel `vane` which controls the slat / vane position.\n+If it is a dual action (top-down plus bottom-up) shade, there is also a roller shutter channel `secondary` which controls the vertical position of the secondary rail.\n+All of these channels appear in the binding, but only those which have a physical implementation in the shade, will have any physical effect.\n+\n+| Channel    | Item Type     | Description |\n+|------------|---------------|------------|\n+| position   | Rollershutter | The vertical position of the shade's rail -- _(see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ Up/Down commands will move the rail completely up or completely down. Percentage commands will move the rail to an intermediate position. Stop commands will halt any current movement of the rail. |\n+| secondary  | Rollershutter | The vertical position of the secondary rail (if any). Its function is basically identical to the `position` channel above -- _(but see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ |\n+| vane       | Dimmer        | The degree of opening of the slats or vanes. Setting this to a non-zero value will first move the shade `position` fully down, since the slats or vanes can only have a defined state if the shade is in its down position -- _(see chapter \"**Inter-dependency between Position and Vane Channels**\" below)._ |\n+| batteryLow | Switch        | Indicates ON when the battery level of the shade is low, as determined by the hub's internal rules. |\n+\n+### Roller Shutter Up/Down Position vs. Open/Close State\n+\n+The `position` and `secondary` channels are Rollershutter types.\n+For vertical shades, the binding maps the vertical position of the \"rail\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+And for horizontal shades, it maps the horizontal position of the \"truck\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+\n+Depending on whether the shade is a top-down, bottom-up, left-right, right-left, or dual action shade, the `OPEN` and `CLOSED` position of the shades may differ from the \u25b2 / \u25bc commands follows..\n+\n+| Type of Shade            | Channel           | Rollershutter Command | Motion direction | Shade State    | Percent |\n+|--------------------------|-------------------|-----------------------|------------------|----------------|---------|\n+| Single action bottom-up  | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Single action top-down   | `position`        | \u25b2                     | Up               | ***`CLOSED`*** | 0%      |\n+|                          |                   | \u25bc                     | Down             | ***`OPEN`***   | 100%    |\n+| Single action right-left | `position`        | \u25b2                     | ***Left***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Right***      | `CLOSED`       | 100%    |\n+| Single action left-right | `position`        | \u25b2                     | ***Right***      | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Left***       | `CLOSED`       | 100%    |\n+| Dual action (lower rail) | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Dual action (upper rail) | ***`secondary`*** | \u25b2                     | ***Down***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Up***         | `CLOSED`       | 100%    |\n+\n+### Interdependency between Channel positions\n+\n+On some types of shades with movable vanes, the vanes cannot be moved unless the shade is down.\n+So there is an interdependency between the value of `vane` and the value of `position` as follows..\n+\n+| Case                       | State of `position` | State of `vane` |\n+|----------------------------|---------------------|-----------------|\n+| Shade up                   | 0% = `UP`           | `UNDEFINED`     |\n+| Shade 50% down             | 50%                 | `UNDEFINED`     |\n+| Shade 100% down, Vane 0%   | 100% = `DOWN`       | 0%              |\n+| Shade 100% down, Vane 50%  | 100% = `DOWN`       | 50%             |\n+| Shade 100% down, Vane 100% | 100% = `DOWN`       | 100%            |\n+\n+On dual action shades, the top rail cannot move below the position of the bottom rail.\n+So the value of `secondary` may be constrained by the value of `position`.\n+\n+## Refreshing the PowerView Hub Cache\n+\n+The hub maintains a cache of the last known state of its shades, and this binding delivers those values.\n+Usually the shades will be moved by this binding, so since the hub is always involved in the moving process, it updates this cache accordingly.\n+\n+However  shades can also be moved manually without the hub\u2019s knowledge.\n+A person can manually move a shade by pressing a button on the side of the shade or via a remote control.\n+In neither case will the hub be aware of the shade\u2019s new position.\n+\n+The hub implements the `refresh` Switch type channel _(see above)_ in order to overcome this issue.\n+\n+Note: You can also force the hub to refresh itself by sending a `Refresh` command in a rule to an item that is connected to a channel in the hub as follows:\n+\n+```\n+import org.eclipse.smarthome.core.types.RefreshType\n+\n+rule \"Hub Refresh (every 20 minutes)\"\n+when\n+    Time cron \"0 1/20 0 ? * * *\"\n+then\n+    sendCommand(HUB_ITEM_NAME, RefreshType.REFRESH) // refresh all shades in HUB\n+\n+    sendCommand(SHADE_ITEM_NAME, RefreshType.REFRESH) // refresh single shade that ITEM is bound to\n+end\n+```\n+\n+Alternate syntax (omitting the `org.eclipse.smarthome.core.types.RefreshType` import statement):\n+\n+```\n+sendCommand(ITEM_NAME, \"REFRESH\")\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NDA2OA==", "bodyText": "Ok. Will do.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461054068", "createdAt": "2020-07-27T17:31:38Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/README.md", "diffHunk": "@@ -1,69 +1,196 @@\n-# Hunter Douglas PowerView Binding\n+# Hunter Douglas (Luxaflex) PowerView Binding\n \n-This is an openHAB binding for the [Hunter Douglas PowerView Motorized Shades](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) via the PowerView Hub.\n+This is an openHAB binding for [Hunter Douglas PowerView](https://www.hunterdouglas.com/operating-systems/motorized/powerview-motorization/overview) motorized shades via their PowerView hub.\n+In some countries the PowerView system is sold under the brand name [Luxaflex](https://www.luxaflex.com/)\n \n-PowerView shades have motorization control for their vertical position, as well as vane controls on the shade's slats.\n-Make sure your Shades are visible in the dedicated PowerView app before attempting discovery.\n-This binding also supports Scenes that are defined via the PowerView app.\n-This helps to work around a limitation of the Hub - commands are executed serially with a several second delay between executions.\n-By using a Scene to control multiple shades at once, the shades will all begin moving at the same time.\n+![PowerView](doc/hdpowerview.png)\n+\n+PowerView shades have motorization control for their vertical position, and some also have vane controls to change the angle of their slats.\n+\n+This binding also supports scenes that are defined in the PowerView app.\n+This helps to work around a limitation of the hub; commands are executed serially with a several second delay between executions.\n+By using a scene to control multiple shades at once, the shades will all begin moving at the same time.\n \n ## Supported Things\n \n-| Thing           | Thing Type | Description                                                                                                                                          |\n-|-----------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| PowerView Hub   | Bridge     | The PowerView Hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n-| PowerView Shade | Thing      | A single motorized shade                                                                                                                             |\n+| Thing           | Thing Type | Description        |\n+|-----------------|------------|--------------------|\n+| PowerView Hub   | Bridge     | The PowerView hub provides the interface between your network and the shade's radio network. It also contains channels used to interact with scenes. |\n+| PowerView Shade | Thing      | A motorized shade. |\n \n ## Discovery\n \n-The PowerView Hub is discovered via a NetBIOS query.\n-This is the same method used by the dedicated PowerView app.\n-After the Hub is added, Shades and Scenes will be discovered by querying the Hub.\n+Make sure your shades are visible in the PowerView app before attempting discovery.\n+\n+The binding can automatically discover the PowerView hub.\n+The discovery process can be started by pressing the refresh button in the PaperUI Inbox.\n+However you can also manually create a (bridge) thing for the hub, and enter the required configuration parameters (see Thing Configuration below).\n+If the configuration parameters are all valid, the binding will then automatically attempt to connect to the hub.\n+If the connection succeeds, the hub will indicate its status as Online, otherwise it will show an error status. \n+\n+Once the hub thing has been created and successfully connected, the binding will automatically discover all shades and scenes that are in it.\n+\n+- For each shade discovered: the binding will create a new dedicated thing with its own channels.\n+- For each scene discovered: the binding will create a new channel dynamically within the hub thing.\n+\n+If in the future, you add additional shades or scenes to your system, the binding will discover them too.\n \n ## Thing Configuration\n \n-PowerView things should be configured via discovery - it would be difficult to configure manually as the IDs of the shades and scenes are not exposed via the dedicated app.\n+### Thing Configuration for PowerView Hub\n+\n+| Configuration Parameter | Description   |\n+|-------------------------|---------------|\n+| host                    | The host name or IP address of the hub on your network. |\n+| refresh                 | The number of milli-seconds between fetches of the PowerView hub's shade state (default 60'000 one minute). |\n+\n+### Thing Configuration for PowerView Shades\n+\n+PowerView shades should preferably be configured via the automatic discovery process.\n+It is quite difficult to configure manually as the `id` of the shade is not exposed in the PowerView app.\n However, the configuration parameters are described below:\n \n-<table>\n- <tr>\n-  <td><b>Thing</b></td>\n-  <td><b>Configuration Parameters</b></td>\n- </tr>\n- <tr>\n-  <td>PowerView Hub</td>\n-  <td>\n-   <table>\n-    <tr><td><b>host</b> - the hostname or IP address of the Hub on your network.</td></tr>\n-    <tr><td><b>refresh</b> - the number of milliseconds between fetches of the PowerView Hub's shade state. Defaults to 60,000 (one minute).</td></tr>\n-   </table>\n-  </td>\n- </tr>\n- <tr>\n-  <td>PowerView Shade</td>\n-  <td>\n-   <table>\n-    <tr><td><b>id</b> - the ID of the PowerView Shade on the Hub.</td></tr>\n-   </table>\n-  </td>\n- </tr>\n-</table>\n+| Configuration Parameter | Description                                                   |\n+|-------------------------|---------------------------------------------------------------|\n+| id                      | The ID of the PowerView shade in the app. Must be an integer. |\n \n ## Channels\n \n-### PowerView Shade\n+### Channels for PowerView Hub\n+\n+The hub always has one fixed channel as below:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| refresh  | Switch    | If you switch on this channel, it will make the hub scan all shades and update its cache state -- _see \"**Refreshing the PowerView Hub Cache**\" below_. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+In addition, scene channels will be added dynamically to the binding as they are discovered in the hub.\n+Each scene channel will have an entry in the hub as shown below, whereby different scenes have different `id` values:\n+\n+| Channel  | Item Type | Description |\n+|----------|-----------| ------------|\n+| id | Switch | Turning this to ON will activate the scene. Scenes are stateless in the PowerView hub; they have no on/off state. Note: include `{autoupdate=\"false\"}` in the item configuration to avoid having to reset it to off after use. |\n+\n+### Channels for PowerView Shade\n+\n+A shade always implements a roller shutter channel `position` which controls the vertical position of the shade's (primary) rail.\n+If the shade has slats or rotatable vanes, there is also a dimmer channel `vane` which controls the slat / vane position.\n+If it is a dual action (top-down plus bottom-up) shade, there is also a roller shutter channel `secondary` which controls the vertical position of the secondary rail.\n+All of these channels appear in the binding, but only those which have a physical implementation in the shade, will have any physical effect.\n+\n+| Channel    | Item Type     | Description |\n+|------------|---------------|------------|\n+| position   | Rollershutter | The vertical position of the shade's rail -- _(see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ Up/Down commands will move the rail completely up or completely down. Percentage commands will move the rail to an intermediate position. Stop commands will halt any current movement of the rail. |\n+| secondary  | Rollershutter | The vertical position of the secondary rail (if any). Its function is basically identical to the `position` channel above -- _(but see chapter \"**Roller Shutter Up/Down Position vs. Open/Close State**\" below)._ |\n+| vane       | Dimmer        | The degree of opening of the slats or vanes. Setting this to a non-zero value will first move the shade `position` fully down, since the slats or vanes can only have a defined state if the shade is in its down position -- _(see chapter \"**Inter-dependency between Position and Vane Channels**\" below)._ |\n+| batteryLow | Switch        | Indicates ON when the battery level of the shade is low, as determined by the hub's internal rules. |\n+\n+### Roller Shutter Up/Down Position vs. Open/Close State\n+\n+The `position` and `secondary` channels are Rollershutter types.\n+For vertical shades, the binding maps the vertical position of the \"rail\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+And for horizontal shades, it maps the horizontal position of the \"truck\" to the Rollershutter \u25b2 / \u25bc commands, and its respective percent value.\n+\n+Depending on whether the shade is a top-down, bottom-up, left-right, right-left, or dual action shade, the `OPEN` and `CLOSED` position of the shades may differ from the \u25b2 / \u25bc commands follows..\n+\n+| Type of Shade            | Channel           | Rollershutter Command | Motion direction | Shade State    | Percent |\n+|--------------------------|-------------------|-----------------------|------------------|----------------|---------|\n+| Single action bottom-up  | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Single action top-down   | `position`        | \u25b2                     | Up               | ***`CLOSED`*** | 0%      |\n+|                          |                   | \u25bc                     | Down             | ***`OPEN`***   | 100%    |\n+| Single action right-left | `position`        | \u25b2                     | ***Left***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Right***      | `CLOSED`       | 100%    |\n+| Single action left-right | `position`        | \u25b2                     | ***Right***      | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Left***       | `CLOSED`       | 100%    |\n+| Dual action (lower rail) | `position`        | \u25b2                     | Up               | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | Down             | `CLOSED`       | 100%    |\n+| Dual action (upper rail) | ***`secondary`*** | \u25b2                     | ***Down***       | `OPEN`         | 0%      |\n+|                          |                   | \u25bc                     | ***Up***         | `CLOSED`       | 100%    |\n+\n+### Interdependency between Channel positions\n+\n+On some types of shades with movable vanes, the vanes cannot be moved unless the shade is down.\n+So there is an interdependency between the value of `vane` and the value of `position` as follows..\n+\n+| Case                       | State of `position` | State of `vane` |\n+|----------------------------|---------------------|-----------------|\n+| Shade up                   | 0% = `UP`           | `UNDEFINED`     |\n+| Shade 50% down             | 50%                 | `UNDEFINED`     |\n+| Shade 100% down, Vane 0%   | 100% = `DOWN`       | 0%              |\n+| Shade 100% down, Vane 50%  | 100% = `DOWN`       | 50%             |\n+| Shade 100% down, Vane 100% | 100% = `DOWN`       | 100%            |\n+\n+On dual action shades, the top rail cannot move below the position of the bottom rail.\n+So the value of `secondary` may be constrained by the value of `position`.\n+\n+## Refreshing the PowerView Hub Cache\n+\n+The hub maintains a cache of the last known state of its shades, and this binding delivers those values.\n+Usually the shades will be moved by this binding, so since the hub is always involved in the moving process, it updates this cache accordingly.\n+\n+However  shades can also be moved manually without the hub\u2019s knowledge.\n+A person can manually move a shade by pressing a button on the side of the shade or via a remote control.\n+In neither case will the hub be aware of the shade\u2019s new position.\n+\n+The hub implements the `refresh` Switch type channel _(see above)_ in order to overcome this issue.\n+\n+Note: You can also force the hub to refresh itself by sending a `Refresh` command in a rule to an item that is connected to a channel in the hub as follows:\n+\n+```\n+import org.eclipse.smarthome.core.types.RefreshType\n+\n+rule \"Hub Refresh (every 20 minutes)\"\n+when\n+    Time cron \"0 1/20 0 ? * * *\"\n+then\n+    sendCommand(HUB_ITEM_NAME, RefreshType.REFRESH) // refresh all shades in HUB\n+\n+    sendCommand(SHADE_ITEM_NAME, RefreshType.REFRESH) // refresh single shade that ITEM is bound to\n+end\n+```\n+\n+Alternate syntax (omitting the `org.eclipse.smarthome.core.types.RefreshType` import statement):\n+\n+```\n+sendCommand(ITEM_NAME, \"REFRESH\")\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NTk5Nw=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk3NTM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxOTo1MjoxNVrOG3OvxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODozMTo0NlrOG4ZTbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ==", "bodyText": "The annotation has no effect and can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460566469", "createdAt": "2020-07-26T19:52:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2MDQ5MA==", "bodyText": "Hmm. If I remove the suppression, then the Eclipse IDE does give me a warning as follows..\nUnsafe interpretation of method return type as '@NonNull' based on substitution 'T=@NonNull String'.\nDeclaring type 'Response' doesn't seem to be designed with null type annotations in mind\n\nAnd Eclipse IDE QuickFix suggests the solution \"Add @SuppressWarnings 'null' to xyz\"", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461060490", "createdAt": "2020-07-27T17:43:07Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2NDYwNA==", "bodyText": "Basically I added @SuppressWarnings in all cases where the Eclipse IDE instructed me to do that (and I did it ONLY where it instructed me to do that).", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461064604", "createdAt": "2020-07-27T17:50:27Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEyNDk1OA==", "bodyText": "I don't see this info (not a warning) in eclipse, but with maven. The reason for this info is, that Response has no null annotations. As readEntity() doesn't return null by javadoc, this info can safely be ignored.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461124958", "createdAt": "2020-07-27T19:41:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNDk4OA==", "bodyText": "I don't see this info (not a warning) in eclipse, but with maven.\n\nIndeed. The problem is that Maven's Null analysis is different than Eclipse's. Personally I like to have a clean compile in BOTH Maven and Eclipse. And AFAIK the only way to make both compilers happy is to Suppress warnings. :)", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461734988", "createdAt": "2020-07-28T17:02:37Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1MzAxMQ==", "bodyText": "Suppress Warning annotations are not inteded to suppress infos. Beside that, the unnecessary suppression causes eclipse to generate an info... Additionally, the origin of the info message is not in your code. I'd go for removing them. This makes it also consistent with most of the other bindings.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461753011", "createdAt": "2020-07-28T17:32:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3NjY1NQ==", "bodyText": "I just turned off these warnings in Eclipse ;) and so have deleted the suppression too :)", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461776655", "createdAt": "2020-07-28T18:11:57Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4ODAxNQ==", "bodyText": "PS actually, with the suppressions removed, Maven also gives an INFO (not a WARNING), but I have committed the changes anyway..", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461788015", "createdAt": "2020-07-28T18:31:46Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/HDPowerViewWebTargets.java", "diffHunk": "@@ -33,82 +37,205 @@\n import com.google.gson.JsonParseException;\n \n /**\n- * JAX-RS targets for communicating with the HD Power View Hub\n+ * JAX-RS targets for communicating with an HD PowerView hub\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewWebTargets {\n \n+    private static final String PUT = \"PUT\";\n+    private static final String GET = \"GET\";\n+    private static final String SCENE_ID = \"sceneId\";\n+    private static final String ID = \"id\";\n+    private static final String REFRESH = \"refresh\";\n+    private static final String CONN_HDR = \"Connection\";\n+    private static final String CONN_VAL = \"close\"; // versus \"keep-alive\"\n+\n+    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n+\n+    /*\n+     * the hub returns a 423 error (resource locked) daily just after midnight;\n+     * which means it is temporarily undergoing maintenance; so we use \"soft\"\n+     * exception handling during the five minute maintenance period after a 423\n+     * error is received\n+     */\n+    private final int maintenancePeriod = 300;\n+    private Instant maintenanceScheduledEnd = Instant.now().minusSeconds(2 * maintenancePeriod);\n+\n     private WebTarget base;\n     private WebTarget shades;\n-    private WebTarget shadeMove;\n+    private WebTarget shade;\n     private WebTarget sceneActivate;\n     private WebTarget scenes;\n-    private final Logger logger = LoggerFactory.getLogger(HDPowerViewWebTargets.class);\n-    private final Gson gson;\n \n+    private final Gson gson = new Gson();\n+    \n+    /**\n+     * Initialize the web targets\n+     * \n+     * @param client    the Javax RS client (the binding)\n+     * @param ipAddress the IP address of the server (the hub)\n+     */\n     public HDPowerViewWebTargets(Client client, String ipAddress) {\n         base = client.target(\"http://\" + ipAddress + \"/api\");\n         shades = base.path(\"shades/\");\n-        shadeMove = base.path(\"shades/{id}\");\n+        shade = base.path(\"shades/{id}\");\n         sceneActivate = base.path(\"scenes\");\n         scenes = base.path(\"scenes/\");\n-        gson = new Gson();\n     }\n \n-    public Shades getShades() throws JsonParseException, IOException {\n-        Response response = invoke(shades.request().buildGet(), shades);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Shades.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all shades in the hub, and wraps it in\n+     * a Shades class instance\n+     * \n+     * @return Shades class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Shades getShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(shades.request().header(CONN_HDR, CONN_VAL).buildGet(), shades, null);\n+        return gson.fromJson(json, Shades.class);\n     }\n \n-    public Response moveShade(String shadeIdString, ShadePosition position) throws IOException {\n-        int shadeId = Integer.parseInt(shadeIdString);\n-        WebTarget target = shadeMove.resolveTemplate(\"id\", shadeId);\n-\n-        String body = gson.toJson(new ShadeMove(shadeId, position));\n-        return invoke(target.request().buildPut(Entity.entity(body, MediaType.APPLICATION_JSON_TYPE)), shadeMove);\n+    /**\n+     * Instructs the hub to move a specific shade\n+     * \n+     * @param shadeId  id of the shade to be moved\n+     * @param position instance of ShadePosition containing the new position\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void moveShade(int shadeId, ShadePosition position) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = shade.resolveTemplate(ID, shadeId);\n+        String json = gson.toJson(new ShadeMove(shadeId, position));\n+        invoke(target.request().header(CONN_HDR, CONN_VAL)\n+                .buildPut(Entity.entity(json, MediaType.APPLICATION_JSON_TYPE)), target, json);\n+        return;\n     }\n \n-    public Scenes getScenes() throws JsonParseException, IOException {\n-        Response response = invoke(scenes.request().buildGet(), scenes);\n-        if (response != null) {\n-            String result = response.readEntity(String.class);\n-            return gson.fromJson(result, Scenes.class);\n-        } else {\n-            return null;\n-        }\n+    /**\n+     * Fetches a JSON package that describes all scenes in the hub, and wraps it in\n+     * a Scenes class instance\n+     * \n+     * @return Scenes class instance\n+     * @throws JsonParseException      if there is a JSON parsing error\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public @Nullable Scenes getScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        String json = invoke(scenes.request().header(CONN_HDR, CONN_VAL).buildGet(), scenes, null);\n+        return gson.fromJson(json, Scenes.class);\n     }\n \n-    public void activateScene(int sceneId) {\n-        WebTarget target = sceneActivate.queryParam(\"sceneId\", sceneId);\n-        invoke(target.request().buildGet(), sceneActivate);\n+    /**\n+     * Instructs the hub to execute a specific scene\n+     * \n+     * @param sceneId id of the scene to be executed\n+     * @throws ProcessingException     if there is any processing error\n+     * @throws HubMaintenanceException if the hub is down for maintenance\n+     */\n+    public void activateScene(int sceneId) throws ProcessingException, HubMaintenanceException {\n+        WebTarget target = sceneActivate.queryParam(SCENE_ID, sceneId);\n+        invoke(target.request().header(CONN_HDR, CONN_VAL).buildGet(), target, null);\n     }\n \n-    private Response invoke(Invocation invocation, WebTarget target) throws ProcessingException {\n+    private synchronized String invoke(Invocation invocation, WebTarget target, @Nullable String jsonCommand)\n+            throws ProcessingException, HubMaintenanceException {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"API command {} {}\", jsonCommand == null ? GET : PUT, target.getUri());\n+            if (jsonCommand != null) {\n+                logger.trace(\"JSON command = {}\", jsonCommand);\n+            }\n+        }\n         Response response;\n-        synchronized (this) {\n+        try {\n             response = invocation.invoke();\n+        } catch (ProcessingException e) {\n+            if (Instant.now().isBefore(maintenanceScheduledEnd)) {\n+                // throw \"softer\" exception during maintenance window\n+                logger.debug(\"Hub still undergoing maintenance\");\n+                throw new HubMaintenanceException(\"Hub still undergoing maintenance\");\n+            }\n+            throw e;\n         }\n-\n-        if (response.getStatus() == 423) {\n-            // the hub seems to return a 423 error (resource locked) once per day around midnight\n-            // this is probably some kind of regular re-initialization process, so suppress the error log\n-            logger.debug(\"Bridge returned '423' while invoking {}\", target.getUri());\n-            return null;\n-        } else if (response.getStatus() != 200) {\n-            logger.warn(\"Bridge returned '{}' while invoking {} : {}\", response.getStatus(), target.getUri(),\n-                    response.readEntity(String.class));\n-            return null;\n-        } else if (!response.hasEntity()) {\n-            logger.warn(\"Bridge returned null response while invoking {}\", target.getUri());\n-            return null;\n+        int statusCode = response.getStatus();\n+        if (statusCode == 423) {\n+            // set end of maintenance window, and throw a \"softer\" exception\n+            maintenanceScheduledEnd = Instant.now().plusSeconds(maintenancePeriod);\n+            logger.debug(\"Hub undergoing maintenance\");\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new HubMaintenanceException(\"Hub undergoing maintenance\");\n+        }\n+        if (statusCode != 200) {\n+            logger.warn(\"Hub returned HTTP error '{}'\", statusCode);\n+            if (response.hasEntity()) {\n+                response.readEntity(String.class);\n+            }\n+            response.close();\n+            throw new ProcessingException(String.format(\"HTTP %d error\", statusCode));\n+        }\n+        if (!response.hasEntity()) {\n+            logger.warn(\"Hub returned no content\");\n+            response.close();\n+            throw new ProcessingException(\"Missing response entity\");\n         }\n+        @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NjQ2OQ=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk4NDE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQyMDowMzo0M1rOG3Ozvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzo0NDowMVrOG3s7XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzQ4Nw==", "bodyText": "These have no effect an can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460567487", "createdAt": "2020-07-26T20:03:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2MDk1Nw==", "bodyText": "..ditto above..", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461060957", "createdAt": "2020-07-27T17:44:01Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzQ4Nw=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk4NDc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQyMDowNDoyMlrOG3O0AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODoxNDowNVrOG4YryA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzU1Mw==", "bodyText": "This is not needed, as the compiler is intelligent enough with local variables.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460567553", "createdAt": "2020-07-26T20:04:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")\n+            String shadeId = item.getValue();\n+            @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2MjQ0MQ==", "bodyText": "If I remove the @Nullable then the Eclipse IDE does give a warning, and then QuickFix suggests the solution \"Add @SuppressWarnings 'null' to xyz\" analog to above..", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461062441", "createdAt": "2020-07-27T17:46:44Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")\n+            String shadeId = item.getValue();\n+            @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzU1Mw=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEyNjc3OA==", "bodyText": "Strange, I don't get a warning. You could declare the Map's values as Nullable if the Map can contain null values:\nMap<Thing, @Nullable String> ret = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461126778", "createdAt": "2020-07-27T19:44:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")\n+            String shadeId = item.getValue();\n+            @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzU1Mw=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3Nzg2NA==", "bodyText": "Done, as above..", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461777864", "createdAt": "2020-07-28T18:14:05Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")\n+            String shadeId = item.getValue();\n+            @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzU1Mw=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk4Nzc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQyMDowODowMlrOG3O1fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzo0OTo0M1rOG3tH0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzkzNA==", "bodyText": "The suppressions can be removed again.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460567934", "createdAt": "2020-07-26T20:08:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")\n+            String shadeId = item.getValue();\n+            @Nullable\n+            ShadeData shadeData = idShadeDataMap.get(shadeId);\n+            updateShadeThing(shadeId, thing, shadeData);\n+        }\n+    }\n+\n+    private void updateShadeThing(String shadeId, Thing thing, @Nullable ShadeData shadeData) {\n+        HDPowerViewShadeHandler thingHandler = ((HDPowerViewShadeHandler) thing.getHandler());\n+        if (thingHandler == null) {\n+            logger.debug(\"Shade '{}' handler not initialized\", shadeId);\n+            return;\n+        }\n+        if (shadeData == null) {\n+            logger.debug(\"Shade '{}' has no data in hub\", shadeId);\n         } else {\n-            logger.warn(\"No response to shade poll\");\n+            logger.debug(\"Updating shade '{}'\", shadeId);\n         }\n+        thingHandler.onReceiveUpdate(shadeData);\n     }\n \n-    private void pollScenes() throws JsonParseException, ProcessingException, IOException {\n+    private void pollScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Scenes scenes = webTargets.getScenes();\n-        if (scenes != null) {\n-            logger.debug(\"Received {} scenes\", scenes.sceneIds.size());\n-            Map<Integer, Channel> channels = getSceneChannelsById();\n-            for (Scene scene : scenes.sceneData) {\n-                // Remove existing scene from the map\n-                Channel existingChannel = channels.remove(scene.id);\n-                if (existingChannel == null) {\n-                    // Create the new scene\n-                    ChannelUID channelUID = new ChannelUID(getThing().getUID(), Integer.toString(scene.id, 10));\n-                    Channel channel = ChannelBuilder.create(channelUID, \"Switch\").withType(sceneChannelTypeUID)\n-                            .withLabel(scene.getName()).withDescription(\"Activates the scene \" + scene.getName())\n-                            .build();\n-                    updateThing(editThing().withChannel(channel).build());\n-                    logger.debug(\"Created new channel for scene {}\", scene.id);\n-                } else {\n-                    logger.debug(\"Skipping existing scene {}\", scene.id);\n-                }\n-            }\n+        if (scenes == null) {\n+            throw new JsonParseException(\"Missing 'scenes' element\");\n+        }\n \n-            // Remove any previously created channels that no longer exist\n-            if (!channels.isEmpty()) {\n-                logger.debug(\"Removing {} existing scenes\", channels.size());\n-                List<Channel> allChannels = new ArrayList<>(getThing().getChannels());\n-                allChannels.removeAll(channels.values());\n-                updateThing(editThing().withChannels(allChannels).build());\n+        List<Scene> sceneData = scenes.sceneData;\n+        if (sceneData == null) {\n+            throw new JsonParseException(\"Missing 'scenes.sceneData' element\");\n+        }\n+        logger.debug(\"Received data for {} scenes\", sceneData.size());\n+\n+        Map<String, Channel> idChannelMap = getIdChannelMap();\n+        for (Scene scene : sceneData) {\n+            // remove existing scene channel from the map\n+            String sceneId = Integer.toString(scene.id);\n+            if (idChannelMap.containsKey(sceneId)) {\n+                idChannelMap.remove(sceneId);\n+                logger.debug(\"Keeping channel for existing scene '{}'\", sceneId);\n+            } else {\n+                // create a new scene channel\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), sceneId);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Switch\").withType(sceneChannelTypeUID)\n+                        .withLabel(scene.getName()).withDescription(\"Activates the scene \" + scene.getName()).build();\n+                updateThing(editThing().withChannel(channel).build());\n+                logger.debug(\"Creating new channel for scene '{}'\", sceneId);\n             }\n-        } else {\n-            logger.warn(\"No response to scene poll\");\n+        }\n+\n+        // remove any previously created channels that no longer exist\n+        if (!idChannelMap.isEmpty()) {\n+            logger.debug(\"Removing {} orphan scene channels\", idChannelMap.size());\n+            List<Channel> allChannels = new ArrayList<>(getThing().getChannels());\n+            allChannels.removeAll(idChannelMap.values());\n+            updateThing(editThing().withChannels(allChannels).build());\n         }\n     }\n \n-    private Map<String, Thing> getThingsByShadeId() {\n-        Map<String, Thing> ret = new HashMap<>();\n+    private Map<Thing, String> getThingIdMap() {\n+        Map<Thing, String> ret = new HashMap<>();\n         for (Thing thing : getThing().getThings()) {\n-            if (thing.getThingTypeUID().equals(HDPowerViewBindingConstants.THING_TYPE_SHADE)) {\n-                String id = thing.getConfiguration().as(HDPowerViewShadeConfiguration.class).id;\n-                ret.put(id, thing);\n+            String id = thing.getConfiguration().as(HDPowerViewShadeConfiguration.class).id;\n+            if (id != null && !id.isEmpty()) {\n+                ret.put(thing, id);\n             }\n         }\n         return ret;\n     }\n \n-    private Map<Integer, Channel> getSceneChannelsById() {\n-        Map<Integer, Channel> ret = new HashMap<>();\n+    private Map<String, ShadeData> getIdShadeDataMap(List<ShadeData> shadeData) {\n+        Map<String, ShadeData> ret = new HashMap<>();\n+        for (ShadeData shade : shadeData) {\n+            if (shade.id != 0) {\n+                ret.put(Integer.toString(shade.id), shade);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    private Map<String, Channel> getIdChannelMap() {\n+        Map<String, Channel> ret = new HashMap<>();\n         for (Channel channel : getThing().getChannels()) {\n-            if (channel.getChannelTypeUID().equals(sceneChannelTypeUID)) {\n-                Integer id = Integer.parseInt(channel.getUID().getId());\n-                ret.put(id, channel);\n+            if (sceneChannelTypeUID.equals(channel.getChannelTypeUID())) {\n+                ret.put(channel.getUID().getId(), channel);\n             }\n         }\n         return ret;\n     }\n+\n+    private void requestRefreshShades() {\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            ThingHandler handler = thing.getHandler();\n+            if (handler instanceof HDPowerViewShadeHandler) {\n+                ((HDPowerViewShadeHandler) handler).requestRefreshShade();\n+            } else {\n+                @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 356}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2NDE0Nw==", "bodyText": "..ditto..", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461064147", "createdAt": "2020-07-27T17:49:43Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -138,89 +162,147 @@ private synchronized void poll() {\n             pollScenes();\n         } catch (JsonParseException e) {\n             logger.warn(\"Bridge returned a bad JSON response: {}\", e.getMessage());\n-        } catch (ProcessingException | IOException e) {\n+        } catch (ProcessingException e) {\n             logger.warn(\"Error connecting to bridge: {}\", e.getMessage());\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, e.getMessage());\n+        } catch (HubMaintenanceException e) {\n+            // exceptions are logged in HDPowerViewWebTargets\n         }\n     }\n \n-    private void pollShades() throws JsonParseException, ProcessingException, IOException {\n+    private void pollShades() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Shades shades = webTargets.getShades();\n+        if (shades == null) {\n+            throw new JsonParseException(\"Missing 'shades' element\");\n+        }\n+\n+        List<ShadeData> shadesData = shades.shadeData;\n+        if (shadesData == null) {\n+            throw new JsonParseException(\"Missing 'shades.shadeData' element\");\n+        }\n+\n         updateStatus(ThingStatus.ONLINE);\n-        if (shades != null) {\n-            Map<String, Thing> things = getThingsByShadeId();\n-            logger.debug(\"Found {} shades\", things.size());\n-            for (Shade shade : shades.shadeData) {\n-                Thing thing = things.get(shade.id);\n-                if (thing != null) {\n-                    HDPowerViewShadeHandler handler = ((HDPowerViewShadeHandler) thing.getHandler());\n-                    if (handler != null) {\n-                        logger.debug(\"Handling update for shade {}\", shade.id);\n-                        handler.onReceiveUpdate(shade);\n-                    } else {\n-                        logger.debug(\"Skipping shade with no handler {}\", shade.id);\n-                    }\n-                } else {\n-                    logger.debug(\"Skipping non-bound shade {}\", shade.id);\n-                }\n-            }\n+        logger.debug(\"Received data for {} shades\", shadesData.size());\n+\n+        Map<String, ShadeData> idShadeDataMap = getIdShadeDataMap(shadesData);\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            @SuppressWarnings(\"null\")\n+            String shadeId = item.getValue();\n+            @Nullable\n+            ShadeData shadeData = idShadeDataMap.get(shadeId);\n+            updateShadeThing(shadeId, thing, shadeData);\n+        }\n+    }\n+\n+    private void updateShadeThing(String shadeId, Thing thing, @Nullable ShadeData shadeData) {\n+        HDPowerViewShadeHandler thingHandler = ((HDPowerViewShadeHandler) thing.getHandler());\n+        if (thingHandler == null) {\n+            logger.debug(\"Shade '{}' handler not initialized\", shadeId);\n+            return;\n+        }\n+        if (shadeData == null) {\n+            logger.debug(\"Shade '{}' has no data in hub\", shadeId);\n         } else {\n-            logger.warn(\"No response to shade poll\");\n+            logger.debug(\"Updating shade '{}'\", shadeId);\n         }\n+        thingHandler.onReceiveUpdate(shadeData);\n     }\n \n-    private void pollScenes() throws JsonParseException, ProcessingException, IOException {\n+    private void pollScenes() throws JsonParseException, ProcessingException, HubMaintenanceException {\n+        HDPowerViewWebTargets webTargets = this.webTargets;\n+        if (webTargets == null) {\n+            throw new ProcessingException(\"Web targets not initialized\");\n+        }\n+\n         Scenes scenes = webTargets.getScenes();\n-        if (scenes != null) {\n-            logger.debug(\"Received {} scenes\", scenes.sceneIds.size());\n-            Map<Integer, Channel> channels = getSceneChannelsById();\n-            for (Scene scene : scenes.sceneData) {\n-                // Remove existing scene from the map\n-                Channel existingChannel = channels.remove(scene.id);\n-                if (existingChannel == null) {\n-                    // Create the new scene\n-                    ChannelUID channelUID = new ChannelUID(getThing().getUID(), Integer.toString(scene.id, 10));\n-                    Channel channel = ChannelBuilder.create(channelUID, \"Switch\").withType(sceneChannelTypeUID)\n-                            .withLabel(scene.getName()).withDescription(\"Activates the scene \" + scene.getName())\n-                            .build();\n-                    updateThing(editThing().withChannel(channel).build());\n-                    logger.debug(\"Created new channel for scene {}\", scene.id);\n-                } else {\n-                    logger.debug(\"Skipping existing scene {}\", scene.id);\n-                }\n-            }\n+        if (scenes == null) {\n+            throw new JsonParseException(\"Missing 'scenes' element\");\n+        }\n \n-            // Remove any previously created channels that no longer exist\n-            if (!channels.isEmpty()) {\n-                logger.debug(\"Removing {} existing scenes\", channels.size());\n-                List<Channel> allChannels = new ArrayList<>(getThing().getChannels());\n-                allChannels.removeAll(channels.values());\n-                updateThing(editThing().withChannels(allChannels).build());\n+        List<Scene> sceneData = scenes.sceneData;\n+        if (sceneData == null) {\n+            throw new JsonParseException(\"Missing 'scenes.sceneData' element\");\n+        }\n+        logger.debug(\"Received data for {} scenes\", sceneData.size());\n+\n+        Map<String, Channel> idChannelMap = getIdChannelMap();\n+        for (Scene scene : sceneData) {\n+            // remove existing scene channel from the map\n+            String sceneId = Integer.toString(scene.id);\n+            if (idChannelMap.containsKey(sceneId)) {\n+                idChannelMap.remove(sceneId);\n+                logger.debug(\"Keeping channel for existing scene '{}'\", sceneId);\n+            } else {\n+                // create a new scene channel\n+                ChannelUID channelUID = new ChannelUID(getThing().getUID(), sceneId);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Switch\").withType(sceneChannelTypeUID)\n+                        .withLabel(scene.getName()).withDescription(\"Activates the scene \" + scene.getName()).build();\n+                updateThing(editThing().withChannel(channel).build());\n+                logger.debug(\"Creating new channel for scene '{}'\", sceneId);\n             }\n-        } else {\n-            logger.warn(\"No response to scene poll\");\n+        }\n+\n+        // remove any previously created channels that no longer exist\n+        if (!idChannelMap.isEmpty()) {\n+            logger.debug(\"Removing {} orphan scene channels\", idChannelMap.size());\n+            List<Channel> allChannels = new ArrayList<>(getThing().getChannels());\n+            allChannels.removeAll(idChannelMap.values());\n+            updateThing(editThing().withChannels(allChannels).build());\n         }\n     }\n \n-    private Map<String, Thing> getThingsByShadeId() {\n-        Map<String, Thing> ret = new HashMap<>();\n+    private Map<Thing, String> getThingIdMap() {\n+        Map<Thing, String> ret = new HashMap<>();\n         for (Thing thing : getThing().getThings()) {\n-            if (thing.getThingTypeUID().equals(HDPowerViewBindingConstants.THING_TYPE_SHADE)) {\n-                String id = thing.getConfiguration().as(HDPowerViewShadeConfiguration.class).id;\n-                ret.put(id, thing);\n+            String id = thing.getConfiguration().as(HDPowerViewShadeConfiguration.class).id;\n+            if (id != null && !id.isEmpty()) {\n+                ret.put(thing, id);\n             }\n         }\n         return ret;\n     }\n \n-    private Map<Integer, Channel> getSceneChannelsById() {\n-        Map<Integer, Channel> ret = new HashMap<>();\n+    private Map<String, ShadeData> getIdShadeDataMap(List<ShadeData> shadeData) {\n+        Map<String, ShadeData> ret = new HashMap<>();\n+        for (ShadeData shade : shadeData) {\n+            if (shade.id != 0) {\n+                ret.put(Integer.toString(shade.id), shade);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    private Map<String, Channel> getIdChannelMap() {\n+        Map<String, Channel> ret = new HashMap<>();\n         for (Channel channel : getThing().getChannels()) {\n-            if (channel.getChannelTypeUID().equals(sceneChannelTypeUID)) {\n-                Integer id = Integer.parseInt(channel.getUID().getId());\n-                ret.put(id, channel);\n+            if (sceneChannelTypeUID.equals(channel.getChannelTypeUID())) {\n+                ret.put(channel.getUID().getId(), channel);\n             }\n         }\n         return ret;\n     }\n+\n+    private void requestRefreshShades() {\n+        Map<Thing, String> thingIdMap = getThingIdMap();\n+        for (Entry<Thing, String> item : thingIdMap.entrySet()) {\n+            @SuppressWarnings(\"null\")\n+            Thing thing = item.getKey();\n+            ThingHandler handler = thing.getHandler();\n+            if (handler instanceof HDPowerViewShadeHandler) {\n+                ((HDPowerViewShadeHandler) handler).requestRefreshShade();\n+            } else {\n+                @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NzkzNA=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDk4ODU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewShadeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQyMDowOToxMVrOG3O15A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzo1MTo1NlrOG3tNCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2ODAzNg==", "bodyText": "It's good practice to append the unit to the field name e.g. REFRESH_DELAY_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r460568036", "createdAt": "2020-07-26T20:09:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewShadeHandler.java", "diffHunk": "@@ -12,119 +12,253 @@\n  */\n package org.openhab.binding.hdpowerview.internal.handler;\n \n-import java.io.IOException;\n+import static org.openhab.binding.hdpowerview.internal.HDPowerViewBindingConstants.*;\n+import static org.openhab.binding.hdpowerview.internal.api.ActuatorClass.*;\n+import static org.openhab.binding.hdpowerview.internal.api.CoordinateSystem.*;\n \n-import javax.ws.rs.core.Response;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n \n+import javax.ws.rs.ProcessingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n import org.eclipse.smarthome.core.library.types.StopMoveType;\n import org.eclipse.smarthome.core.library.types.UpDownType;\n import org.eclipse.smarthome.core.thing.ChannelUID;\n import org.eclipse.smarthome.core.thing.Thing;\n import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n import org.eclipse.smarthome.core.types.UnDefType;\n-import org.openhab.binding.hdpowerview.internal.HDPowerViewBindingConstants;\n+import org.openhab.binding.hdpowerview.internal.HDPowerViewWebTargets;\n+import org.openhab.binding.hdpowerview.internal.HubMaintenanceException;\n+import org.openhab.binding.hdpowerview.internal.api.ActuatorClass;\n+import org.openhab.binding.hdpowerview.internal.api.CoordinateSystem;\n import org.openhab.binding.hdpowerview.internal.api.ShadePosition;\n-import org.openhab.binding.hdpowerview.internal.api.responses.Shades.Shade;\n+import org.openhab.binding.hdpowerview.internal.api.responses.Shade;\n+import org.openhab.binding.hdpowerview.internal.api.responses.Shades.ShadeData;\n import org.openhab.binding.hdpowerview.internal.config.HDPowerViewShadeConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * Handles commands for an HD Power View shade\n+ * Handles commands for an HD PowerView Shade\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewShadeHandler extends AbstractHubbedThingHandler {\n \n-    private static final int MAX_POSITION = 65535;\n-    private static final int MAX_VANE = 32767;\n-\n     private final Logger logger = LoggerFactory.getLogger(HDPowerViewShadeHandler.class);\n \n+    private static final int REFRESH_DELAY = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA2NTQ4MA==", "bodyText": "Ok. Will do.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461065480", "createdAt": "2020-07-27T17:51:56Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewShadeHandler.java", "diffHunk": "@@ -12,119 +12,253 @@\n  */\n package org.openhab.binding.hdpowerview.internal.handler;\n \n-import java.io.IOException;\n+import static org.openhab.binding.hdpowerview.internal.HDPowerViewBindingConstants.*;\n+import static org.openhab.binding.hdpowerview.internal.api.ActuatorClass.*;\n+import static org.openhab.binding.hdpowerview.internal.api.CoordinateSystem.*;\n \n-import javax.ws.rs.core.Response;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n \n+import javax.ws.rs.ProcessingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n import org.eclipse.smarthome.core.library.types.StopMoveType;\n import org.eclipse.smarthome.core.library.types.UpDownType;\n import org.eclipse.smarthome.core.thing.ChannelUID;\n import org.eclipse.smarthome.core.thing.Thing;\n import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n import org.eclipse.smarthome.core.types.UnDefType;\n-import org.openhab.binding.hdpowerview.internal.HDPowerViewBindingConstants;\n+import org.openhab.binding.hdpowerview.internal.HDPowerViewWebTargets;\n+import org.openhab.binding.hdpowerview.internal.HubMaintenanceException;\n+import org.openhab.binding.hdpowerview.internal.api.ActuatorClass;\n+import org.openhab.binding.hdpowerview.internal.api.CoordinateSystem;\n import org.openhab.binding.hdpowerview.internal.api.ShadePosition;\n-import org.openhab.binding.hdpowerview.internal.api.responses.Shades.Shade;\n+import org.openhab.binding.hdpowerview.internal.api.responses.Shade;\n+import org.openhab.binding.hdpowerview.internal.api.responses.Shades.ShadeData;\n import org.openhab.binding.hdpowerview.internal.config.HDPowerViewShadeConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * Handles commands for an HD Power View shade\n+ * Handles commands for an HD PowerView Shade\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Andrew Fiddian-Green - Added support for secondary rail positions\n  */\n+@NonNullByDefault\n public class HDPowerViewShadeHandler extends AbstractHubbedThingHandler {\n \n-    private static final int MAX_POSITION = 65535;\n-    private static final int MAX_VANE = 32767;\n-\n     private final Logger logger = LoggerFactory.getLogger(HDPowerViewShadeHandler.class);\n \n+    private static final int REFRESH_DELAY = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2ODAzNg=="}, "originalCommit": {"oid": "264b1da9e83455baa5dd45f1f2de1d159b9d4121"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzA2OTMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxOToxNTowNFrOG4ayJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjowMzo1OVrOG41S_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMjI2Mw==", "bodyText": "For further coding: No harm in canceling an already cancelled task. The isCancelled() can be removed safely.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461812263", "createdAt": "2020-07-28T19:15:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -110,25 +138,37 @@ public void dispose() {\n         stopPoll();\n     }\n \n-    void pollNow() {\n-        if (isInitialized()) {\n-            schedulePoll();\n+    private void schedulePoll() {\n+        ScheduledFuture<?> future = this.pollFuture;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(false);\n         }\n-    }\n+        logger.debug(\"Scheduling poll for 5000ms out, then every {}ms\", refreshInterval);\n+        this.pollFuture = scheduler.scheduleWithFixedDelay(this::poll, 5000, refreshInterval, TimeUnit.MILLISECONDS);\n \n-    private void schedulePoll() {\n-        if (pollFuture != null) {\n-            pollFuture.cancel(false);\n+        future = this.hardRefreshFuture;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(false);\n+        }\n+        if (hardRefreshInterval > 0) {\n+            logger.debug(\"Scheduling hard refresh every {}minutes\", hardRefreshInterval);\n+            this.hardRefreshFuture = scheduler.scheduleWithFixedDelay(this::requestRefreshShades, 1,\n+                    hardRefreshInterval, TimeUnit.MINUTES);\n         }\n-        logger.debug(\"Scheduling poll for 500ms out, then every {} ms\", refreshInterval);\n-        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, 500, refreshInterval, TimeUnit.MILLISECONDS);\n     }\n \n     private synchronized void stopPoll() {\n-        if (pollFuture != null && !pollFuture.isCancelled()) {\n-            pollFuture.cancel(true);\n-            pollFuture = null;\n+        ScheduledFuture<?> future = this.pollFuture;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7971b8b29ac5df6b6d41d4505e43de3e6ca98d"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0NjY1NQ==", "bodyText": "Removed.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r462246655", "createdAt": "2020-07-29T12:03:59Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/java/org/openhab/binding/hdpowerview/internal/handler/HDPowerViewHubHandler.java", "diffHunk": "@@ -110,25 +138,37 @@ public void dispose() {\n         stopPoll();\n     }\n \n-    void pollNow() {\n-        if (isInitialized()) {\n-            schedulePoll();\n+    private void schedulePoll() {\n+        ScheduledFuture<?> future = this.pollFuture;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(false);\n         }\n-    }\n+        logger.debug(\"Scheduling poll for 5000ms out, then every {}ms\", refreshInterval);\n+        this.pollFuture = scheduler.scheduleWithFixedDelay(this::poll, 5000, refreshInterval, TimeUnit.MILLISECONDS);\n \n-    private void schedulePoll() {\n-        if (pollFuture != null) {\n-            pollFuture.cancel(false);\n+        future = this.hardRefreshFuture;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(false);\n+        }\n+        if (hardRefreshInterval > 0) {\n+            logger.debug(\"Scheduling hard refresh every {}minutes\", hardRefreshInterval);\n+            this.hardRefreshFuture = scheduler.scheduleWithFixedDelay(this::requestRefreshShades, 1,\n+                    hardRefreshInterval, TimeUnit.MINUTES);\n         }\n-        logger.debug(\"Scheduling poll for 500ms out, then every {} ms\", refreshInterval);\n-        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, 500, refreshInterval, TimeUnit.MILLISECONDS);\n     }\n \n     private synchronized void stopPoll() {\n-        if (pollFuture != null && !pollFuture.isCancelled()) {\n-            pollFuture.cancel(true);\n-            pollFuture = null;\n+        ScheduledFuture<?> future = this.pollFuture;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMjI2Mw=="}, "originalCommit": {"oid": "0c7971b8b29ac5df6b6d41d4505e43de3e6ca98d"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzEwNjE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.hdpowerview/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxOToyNDoxMFrOG4bISw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjowMzo0MlrOG41Sgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNzkzMQ==", "bodyText": "Is this the Channel you wanted to remove?", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r461817931", "createdAt": "2020-07-28T19:24:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -58,4 +82,10 @@\n \t\t<description>Activates the scene</description>\n \t</channel-type>\n \n+\t<channel-type id=\"refresh\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refresh Cache</label>\n+\t\t<description>Instructs the Hub to refresh its Shade data cache</description>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c7971b8b29ac5df6b6d41d4505e43de3e6ca98d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0NjUzMA==", "bodyText": "Yes. Removed.", "url": "https://github.com/openhab/openhab-addons/pull/8061#discussion_r462246530", "createdAt": "2020-07-29T12:03:42Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.hdpowerview/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -58,4 +82,10 @@\n \t\t<description>Activates the scene</description>\n \t</channel-type>\n \n+\t<channel-type id=\"refresh\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refresh Cache</label>\n+\t\t<description>Instructs the Hub to refresh its Shade data cache</description>\n+\t</channel-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNzkzMQ=="}, "originalCommit": {"oid": "0c7971b8b29ac5df6b6d41d4505e43de3e6ca98d"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4696, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}