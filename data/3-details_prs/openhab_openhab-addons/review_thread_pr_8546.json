{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMDM4NDE4", "number": 8546, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowMzowNlrOEsUQQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjoxMjo1MFrOExeXEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA0NjQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/.classpath", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowMzowNlrOHfibwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowMzowNlrOHfibwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjA2NA==", "bodyText": "This file is generated automatically by maven and should not be part of the PR.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832064", "createdAt": "2020-10-10T21:03:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/.classpath", "diffHunk": "@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA0NjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/.project", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowMzoxMlrOHfibxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowMzoxMlrOHfibxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjA3MA==", "bodyText": "This file is generated automatically by maven and should not be part of the PR.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832070", "createdAt": "2020-10-10T21:03:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/.project", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA0Nzg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowNToyOFrOHficfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowNToyOFrOHficfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjI1NQ==", "bodyText": "In this chapter, the Thing Type ID should be mentioned.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832255", "createdAt": "2020-10-10T21:05:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA0ODU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowNjoyOFrOHfic2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowNjoyOFrOHfic2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjM0NA==", "bodyText": "This sentence could be removed and re-added, when it's implemented.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832344", "createdAt": "2020-10-10T21:06:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration\n+\n+The Unified Remote Server Thing requires the host to be correctly configured in order to work correctly.\n+Other properties like tcpPort and udpPort are not used in the initial implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA0OTUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowODowNFrOHfidRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowODowNFrOHfidRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjQ1NQ==", "bodyText": "This example should be moved to the end to the chapter \"Full Example\". You could also add an example of the .items file and the .sitemap file (which are more important that the .things file).", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832455", "createdAt": "2020-10-10T21:08:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration\n+\n+The Unified Remote Server Thing requires the host to be correctly configured in order to work correctly.\n+Other properties like tcpPort and udpPort are not used in the initial implementation.\n+\n+```\n+Thing unifiedremote:server:xx-xx-xx-xx-xx-xx [ host=\"192.168.1.10\" ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA0OTg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowODozN1rOHfidcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowODozN1rOHfidcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjQ5Nw==", "bodyText": "Can you mention the parameter name of the address?", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832497", "createdAt": "2020-10-10T21:08:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration\n+\n+The Unified Remote Server Thing requires the host to be correctly configured in order to work correctly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA1MDEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowODo1N1rOHfidiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowODo1N1rOHfidiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjUyMw==", "bodyText": "These are only placeholders.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832523", "createdAt": "2020-10-10T21:08:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration\n+\n+The Unified Remote Server Thing requires the host to be correctly configured in order to work correctly.\n+Other properties like tcpPort and udpPort are not used in the initial implementation.\n+\n+```\n+Thing unifiedremote:server:xx-xx-xx-xx-xx-xx [ host=\"192.168.1.10\" ]\n+```\n+\n+## Channels\n+\n+_Here you should provide information about available channel types, what their meaning is and how they can be used._\n+\n+_Note that it is planned to generate some part of this based on the XML files within ```src/main/resources/OH-INF/thing``` of your binding._", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA1MDYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowOTo0MVrOHfidwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTowOTo0MVrOHfidwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjU3Ng==", "bodyText": "Are these absolute or relative coordinates? Is this in pixels?", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832576", "createdAt": "2020-10-10T21:09:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration\n+\n+The Unified Remote Server Thing requires the host to be correctly configured in order to work correctly.\n+Other properties like tcpPort and udpPort are not used in the initial implementation.\n+\n+```\n+Thing unifiedremote:server:xx-xx-xx-xx-xx-xx [ host=\"192.168.1.10\" ]\n+```\n+\n+## Channels\n+\n+_Here you should provide information about available channel types, what their meaning is and how they can be used._\n+\n+_Note that it is planned to generate some part of this based on the XML files within ```src/main/resources/OH-INF/thing``` of your binding._\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| mouse-move  | String | Mouse Move. Expect number JSON array (\"[10,10]\").   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA1MzU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxMzo0NVrOHfifEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxMzo0NVrOHfifEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjkxMg==", "bodyText": "The HTTP can be retrieved from the framework via injection. Then, resources are re-used. See for example https://github.com/openhab/openhab-addons/blob/main/bundles/org.openhab.binding.automower/src/main/java/org/openhab/binding/automower/internal/AutomowerHandlerFactory.java#L60", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832912", "createdAt": "2020-10-10T21:13:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA1Mzc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxNDowNlrOHfifJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxNDowNlrOHfifJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMjkzMw==", "bodyText": "This could be static. Same for the upper case fields below. Static fields should be moved to the top of the class.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502832933", "createdAt": "2020-10-10T21:14:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA1NTI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxNTo0OVrOHfifyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxNTo0OVrOHfifyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzA5OQ==", "bodyText": "This could be removed if you use the framework's HttpClient.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833099", "createdAt": "2020-10-10T21:15:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;\n+    private final String CONNECTION_ID_HEADER = \"UR-Connection-ID\";\n+    private @Nullable String connectionID;\n+    private @Nullable String connectionGUID;\n+\n+    private final String MOUSE_REMOTE = \"Relmtech.Basic Input\";\n+    private final String NAVIGATION_REMOTE = \"Unified.Navigation\";\n+    private final String POWER_REMOTE = \"Unified.Power\";\n+    private final String MEDIA_REMOTE = \"Unified.Media\";\n+    private final String MONITOR_REMOTE = \"Unified.Monitor\";\n+\n+    public UnifiedRemoteConnection(String host) {\n+        url = \"http://\" + host + \":\" + WEB_CLIENT_PORT + \"/client/\";\n+    }\n+\n+    public void authenticate() throws Exception {\n+        ContentResponse response = null;\n+        connectionGUID = \"web-\" + UUID.randomUUID().toString();\n+        if (!http.isStarted()) {\n+            http.start();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA1NTU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxNjoxNFrOHfif8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToxNjoxNFrOHfif8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzEzOQ==", "bodyText": "Better specify a timeout. Many bindings use 10 sec.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833139", "createdAt": "2020-10-10T21:16:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;\n+    private final String CONNECTION_ID_HEADER = \"UR-Connection-ID\";\n+    private @Nullable String connectionID;\n+    private @Nullable String connectionGUID;\n+\n+    private final String MOUSE_REMOTE = \"Relmtech.Basic Input\";\n+    private final String NAVIGATION_REMOTE = \"Unified.Navigation\";\n+    private final String POWER_REMOTE = \"Unified.Power\";\n+    private final String MEDIA_REMOTE = \"Unified.Media\";\n+    private final String MONITOR_REMOTE = \"Unified.Monitor\";\n+\n+    public UnifiedRemoteConnection(String host) {\n+        url = \"http://\" + host + \":\" + WEB_CLIENT_PORT + \"/client/\";\n+    }\n+\n+    public void authenticate() throws Exception {\n+        ContentResponse response = null;\n+        connectionGUID = \"web-\" + UUID.randomUUID().toString();\n+        if (!http.isStarted()) {\n+            http.start();\n+        }\n+        response = http.GET(getPath(\"connect\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2MDA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyMzoxNVrOHfih_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyMzoxNVrOHfih_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzY2Mw==", "bodyText": "This can also be removed if using the framework's HttpClient.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833663", "createdAt": "2020-10-10T21:23:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteConnection.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import java.io.Closeable;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link UnifiedRemoteConnection} Handles Remote Server Communications\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteConnection implements Closeable {\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteConnection.class);\n+    private final String url;\n+    private final HttpClient http = new HttpClient();\n+    private final JsonParser jsonParser = new JsonParser();\n+    private final int WEB_CLIENT_PORT = 9510;\n+    private final String CONNECTION_ID_HEADER = \"UR-Connection-ID\";\n+    private @Nullable String connectionID;\n+    private @Nullable String connectionGUID;\n+\n+    private final String MOUSE_REMOTE = \"Relmtech.Basic Input\";\n+    private final String NAVIGATION_REMOTE = \"Unified.Navigation\";\n+    private final String POWER_REMOTE = \"Unified.Power\";\n+    private final String MEDIA_REMOTE = \"Unified.Media\";\n+    private final String MONITOR_REMOTE = \"Unified.Monitor\";\n+\n+    public UnifiedRemoteConnection(String host) {\n+        url = \"http://\" + host + \":\" + WEB_CLIENT_PORT + \"/client/\";\n+    }\n+\n+    public void authenticate() throws Exception {\n+        ContentResponse response = null;\n+        connectionGUID = \"web-\" + UUID.randomUUID().toString();\n+        if (!http.isStarted()) {\n+            http.start();\n+        }\n+        response = http.GET(getPath(\"connect\"));\n+        JsonObject responseBody = jsonParser.parse(response.getContentAsString()).getAsJsonObject();\n+        connectionID = responseBody.get(\"id\").getAsString();\n+\n+        String password = UUID.randomUUID().toString();\n+        JsonObject authPayload = new JsonObject();\n+        authPayload.addProperty(\"Action\", 0);\n+        authPayload.addProperty(\"Request\", 0);\n+        authPayload.addProperty(\"Version\", 10);\n+        authPayload.addProperty(\"Password\", password);\n+        authPayload.addProperty(\"Platform\", \"web\");\n+        authPayload.addProperty(\"Source\", connectionGUID);\n+        request(authPayload);\n+\n+        JsonObject capabilitiesPayload = new JsonObject();\n+        JsonObject capabilitiesInnerPayload = new JsonObject();\n+        capabilitiesInnerPayload.addProperty(\"Actions\", true);\n+        capabilitiesInnerPayload.addProperty(\"Sync\", true);\n+        capabilitiesInnerPayload.addProperty(\"Grid\", true);\n+        capabilitiesInnerPayload.addProperty(\"Fast\", false);\n+        capabilitiesInnerPayload.addProperty(\"Loading\", true);\n+        capabilitiesInnerPayload.addProperty(\"Encryption2\", true);\n+        capabilitiesPayload.add(\"Capabilities\", capabilitiesInnerPayload);\n+        capabilitiesPayload.addProperty(\"Action\", 1);\n+        capabilitiesPayload.addProperty(\"Request\", 1);\n+        capabilitiesPayload.addProperty(\"Source\", connectionGUID);\n+        request(capabilitiesPayload);\n+    }\n+\n+    public ContentResponse mouseMove(String jsonIntArray)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        JsonArray cordinates = jsonParser.parse(jsonIntArray).getAsJsonArray();\n+        int x = cordinates.get(0).getAsInt();\n+        int y = cordinates.get(1).getAsInt();\n+        return this.execRemoteAction(\"Relmtech.Basic Input\", \"delta\",\n+                wrapValues(new String[] { \"0\", Integer.toString(x), Integer.toString(y) }));\n+    }\n+\n+    public ContentResponse sendKey(String key) throws InterruptedException, ExecutionException, TimeoutException {\n+        String remoteID = \"\";\n+        String actionName = \"\";\n+        String value = null;\n+        switch (key) {\n+            case \"LEFT_CLICK\":\n+                remoteID = MOUSE_REMOTE;\n+                actionName = \"left\";\n+                break;\n+            case \"RIGHT_CLICK\":\n+                remoteID = MOUSE_REMOTE;\n+                actionName = \"right\";\n+                break;\n+            case \"LOCK\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"lock\";\n+                break;\n+            case \"UNLOCK\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"unlock\";\n+                break;\n+            case \"SLEEP\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"sleep\";\n+                break;\n+            case \"SHUTDOWN\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"shutdown\";\n+                break;\n+            case \"RESTART\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"restart\";\n+                break;\n+            case \"LOGOFF\":\n+                remoteID = POWER_REMOTE;\n+                actionName = \"logoff\";\n+                break;\n+            case \"PLAY/PAUSE\":\n+            case \"PLAY\":\n+            case \"PAUSE\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"play_pause\";\n+                break;\n+            case \"NEXT\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"next\";\n+                break;\n+            case \"PREVIOUS\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"previous\";\n+                break;\n+            case \"STOP\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"stop\";\n+                break;\n+            case \"VOLUME_MUTE\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"volume_mute\";\n+                break;\n+            case \"VOLUME_UP\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"volume_up\";\n+                break;\n+            case \"VOLUME_DOWN\":\n+                remoteID = MEDIA_REMOTE;\n+                actionName = \"volume_down\";\n+                break;\n+            case \"BRIGHTNESS_UP\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"brightness_up\";\n+                break;\n+            case \"BRIGHTNESS_DOWN\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"brightness_down\";\n+                break;\n+            case \"MONITOR_OFF\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"turn_off\";\n+                break;\n+            case \"MONITOR_ON\":\n+                remoteID = MONITOR_REMOTE;\n+                actionName = \"turn_on\";\n+                break;\n+            case \"ESCAPE\":\n+            case \"SPACE\":\n+            case \"BACK\":\n+            case \"LWIN\":\n+            case \"CONTROL\":\n+            case \"TAB\":\n+            case \"MENU\":\n+            case \"RETURN\":\n+            case \"UP\":\n+            case \"DOWN\":\n+            case \"LEFT\":\n+            case \"RIGHT\":\n+                remoteID = NAVIGATION_REMOTE;\n+                actionName = \"toggle\";\n+                value = key;\n+                break;\n+        }\n+        JsonArray wrappedValues = null;\n+        if (value != null) {\n+            wrappedValues = wrapValues(new String[] { value });\n+        }\n+        return this.execRemoteAction(remoteID, actionName, wrappedValues);\n+    }\n+\n+    public ContentResponse keepAlive() throws InterruptedException, ExecutionException, TimeoutException {\n+        JsonObject payload = new JsonObject();\n+        payload.addProperty(\"KeepAlive\", true);\n+        payload.addProperty(\"Source\", connectionGUID);\n+        return request(payload);\n+    }\n+\n+    private ContentResponse execRemoteAction(String remoteID, String name, @Nullable JsonElement values)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        JsonObject payload = new JsonObject();\n+        JsonObject runInnerPayload = new JsonObject();\n+        JsonObject extrasInnerPayload = new JsonObject();\n+        if (values != null) {\n+            extrasInnerPayload.add(\"Values\", values);\n+            runInnerPayload.add(\"Extras\", extrasInnerPayload);\n+        }\n+        runInnerPayload.addProperty(\"Name\", name);\n+        payload.addProperty(\"ID\", remoteID);\n+        payload.addProperty(\"Action\", 7);\n+        payload.addProperty(\"Request\", 7);\n+        payload.add(\"Run\", runInnerPayload);\n+        payload.addProperty(\"Source\", connectionGUID);\n+        return request(payload);\n+    }\n+\n+    private ContentResponse request(JsonObject content)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Request request = http.POST(getPath(\"request\"));\n+        request.header(HttpHeader.CONTENT_TYPE, \"application/json\");\n+        if (connectionID != null)\n+            request.header(CONNECTION_ID_HEADER, connectionID);\n+        String stringContent = content.toString();\n+        logger.debug(\"[Request Payload {} ]\", stringContent);\n+        request.content(new StringContentProvider(stringContent, \"utf-8\"));\n+        return request.send();\n+    }\n+\n+    private JsonArray wrapValues(String[] commandValues) {\n+        JsonArray values = new JsonArray();\n+        for (String value : commandValues) {\n+            JsonObject valueWrapper = new JsonObject();\n+            valueWrapper.addProperty(\"Value\", value);\n+            values.add(valueWrapper);\n+        }\n+        return values;\n+    }\n+\n+    private String getPath(String path) {\n+        return url + path;\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (http.isStarted()) {\n+            try {\n+                http.stop();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2MDM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyMzo0NVrOHfiiKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyMzo0NVrOHfiiKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzcwNg==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833706", "createdAt": "2020-10-10T21:23:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2MDYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNDowMFrOHfiiRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNDowMFrOHfiiRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzczMg==", "bodyText": "Loggers should not be final.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833732", "createdAt": "2020-10-10T21:24:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2MTMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNDo0N1rOHfiimg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNDo0N1rOHfiimg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzgxOA==", "bodyText": "Syntactical sugar\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    client.call(serverInfo -> addNewServer(serverInfo));\n          \n          \n            \n                    client.call(this::addNewServer);", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833818", "createdAt": "2020-10-10T21:24:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2MTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNToxOVrOHfii2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNToxOVrOHfii2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMzg4Mw==", "bodyText": "Can you add the representationProperty?", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502833883", "createdAt": "2020-10-10T21:25:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2MjkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNjo1NFrOHfijXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyNjo1NFrOHfijXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDAxMg==", "bodyText": "See above. Append unit.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834012", "createdAt": "2020-10-10T21:26:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2NDMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyOToyNFrOHfikCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMToyOToyNFrOHfikCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDE4NQ==", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834185", "createdAt": "2020-10-10T21:29:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2NjMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMTozM1rOHfik6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMTozM1rOHfik6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDQxMA==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834410", "createdAt": "2020-10-10T21:31:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2NjQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMTo0OVrOHfik_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMTo0OVrOHfik_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDQzMQ==", "bodyText": "See above. logging", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834431", "createdAt": "2020-10-10T21:31:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {\n+                        logger.error(\"Exception parsing server discovery response from {}: {}\", host, ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2Njk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMjozM1rOHfilOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMjozM1rOHfilOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDQ4OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834488", "createdAt": "2020-10-10T21:32:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {\n+                        logger.error(\"Exception parsing server discovery response from {}: {}\", host, ex.getMessage());\n+                    }\n+                }\n+            } catch (SocketTimeoutException ste) {\n+                logger.debug(\"SocketTimeoutException during socket operation: {}\", ste.getMessage());\n+            } catch (IOException ioe) {\n+                logger.error(\"IOException during socket operation: {}\", ioe.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2NzUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMzoxNFrOHfilfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozMzoxNFrOHfilfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDU1Nw==", "bodyText": "You could add this to the finally block, to close the socket also if an unchecked exception is thrown.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834557", "createdAt": "2020-10-10T21:33:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(serverInfo -> addNewServer(serverInfo));\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL).withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {\n+        /**\n+         * Port used for broadcast and listening.\n+         */\n+        public static final int DISCOVERY_PORT = 9511;\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_REQUEST = \"6N T|-Ar-A6N T|-Ar-A6N T|-Ar-A\";\n+        /**\n+         * String the client sends, to disambiguate packets on this port.\n+         */\n+        public static final String DISCOVERY_RESPONSE_PREFIX = \")-b@ h): :)i)-b@ h): :)i)-b@ h): :)\";\n+        /**\n+         * String used to replace non printable characters on service response\n+         */\n+        public static final String NON_PRINTABLE_CHARTS_REPLACEMENT = \": :\";\n+\n+        private static final int MAX_PACKET_SIZE = 2048;\n+        /**\n+         * maximum time to wait for a reply, in milliseconds.\n+         */\n+        private static final int TIMEOUT = 3000; // milliseonds\n+\n+        public class ServerInfo {\n+            String name;\n+            int tcpPort;\n+            int udpPort;\n+            String host;\n+            String macAddress;\n+            String publicIp;\n+\n+            ServerInfo(String host, int tcpPort, int udpPort, String name, String macAddress, String publicIp) {\n+                this.name = name;\n+                this.tcpPort = tcpPort;\n+                this.udpPort = udpPort;\n+                this.host = host;\n+                this.macAddress = macAddress;\n+                this.publicIp = publicIp;\n+            }\n+        }\n+\n+        /**\n+         * Create a UDP socket on the service discovery broadcast port.\n+         *\n+         * @return open DatagramSocket if successful\n+         * @throws RuntimeException if cannot create the socket\n+         */\n+        public DatagramSocket createSocket() throws SocketException {\n+            DatagramSocket socket;\n+            socket = new DatagramSocket();\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(TIMEOUT);\n+            return socket;\n+        }\n+\n+        private ServerInfo tryParseServerDiscovery(DatagramPacket receivePacket) throws ParseException {\n+            String host = receivePacket.getAddress().getHostAddress();\n+            String reply = new String(receivePacket.getData()).replaceAll(\"[\\\\p{C}]\", NON_PRINTABLE_CHARTS_REPLACEMENT)\n+                    .replaceAll(\"[^\\\\x00-\\\\x7F]\", NON_PRINTABLE_CHARTS_REPLACEMENT);\n+            if (!reply.startsWith(DISCOVERY_RESPONSE_PREFIX))\n+                throw new ParseException(\"Bad discovery response prefix\", 0);\n+            String[] parts = Arrays\n+                    .stream(reply.replace(DISCOVERY_RESPONSE_PREFIX, \"\").split(NON_PRINTABLE_CHARTS_REPLACEMENT))\n+                    .filter((String e) -> e.length() != 0).toArray(String[]::new);\n+            String name = parts[0];\n+            int tcpPort = Integer.parseInt(parts[1]);\n+            int udpPort = Integer.parseInt(parts[3]);\n+            String macAddress = parts[2];\n+            String publicIp = parts[4];\n+            return new ServerInfo(host, tcpPort, udpPort, name, macAddress, publicIp);\n+        }\n+\n+        /**\n+         * Send broadcast packets with service request string until a response\n+         * is received. Return the response as String (even though it should\n+         * contain an internet address).\n+         *\n+         * @return String received from server. Should be server IP address.\n+         *         Returns empty string if failed to get valid reply.\n+         */\n+        public void call(Consumer<ServerInfo> listener) {\n+            byte[] receiveBuffer = new byte[MAX_PACKET_SIZE];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+\n+            DatagramSocket socket = null;\n+            try {\n+                socket = createSocket();\n+            } catch (SocketException e) {\n+                logger.error(\"Error creating socket: {}\", e.getMessage());\n+                return;\n+            }\n+            byte[] packetData = DISCOVERY_REQUEST.getBytes();\n+            try {\n+                InetAddress broadcastAddress = InetAddress.getByName(\"255.255.255.255\");\n+                int servicePort = DISCOVERY_PORT;\n+                DatagramPacket packet = new DatagramPacket(packetData, packetData.length, broadcastAddress,\n+                        servicePort);\n+                socket.send(packet);\n+                logger.debug(\"Sent packet to {}:{}\", broadcastAddress.getHostAddress(), servicePort);\n+                for (int i = 0; i < 20; i++) {\n+                    socket.receive(receivePacket);\n+                    String host = receivePacket.getAddress().getHostAddress();\n+                    logger.debug(\"Received reply from {}\", host);\n+                    try {\n+                        ServerInfo serverInfo = tryParseServerDiscovery(receivePacket);\n+                        listener.accept(serverInfo);\n+                    } catch (Exception ex) {\n+                        logger.error(\"Exception parsing server discovery response from {}: {}\", host, ex.getMessage());\n+                    }\n+                }\n+            } catch (SocketTimeoutException ste) {\n+                logger.debug(\"SocketTimeoutException during socket operation: {}\", ste.getMessage());\n+            } catch (IOException ioe) {\n+                logger.error(\"IOException during socket operation: {}\", ioe.getMessage());\n+            }\n+            socket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2ODIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozNDoyMVrOHfilzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozNDoyMVrOHfilzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDYzOQ==", "bodyText": "As the Thing doesn't provide any data, this could be removed entirely.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834639", "createdAt": "2020-10-10T21:34:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public UnifiedRemoteHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO: nothing to do for now\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA2OTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozNjoxOFrOHfimkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozNjoxOFrOHfimkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNDgzNA==", "bodyText": "When using the framework's HttpClient, this could be the concrete Exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502834834", "createdAt": "2020-10-10T21:36:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public UnifiedRemoteHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO: nothing to do for now\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        if (!isLinked(channelId))\n+            return;\n+        String stringCommand = command.toFullString();\n+        try {\n+            if (connection != null) {\n+                ContentResponse response;\n+                switch (channelId) {\n+                    case MOUSE_CHANNEL:\n+                        response = connection.mouseMove(stringCommand);\n+                        break;\n+                    case SEND_KEY_CHANNEL:\n+                        response = connection.sendKey(stringCommand);\n+                        break;\n+                    default:\n+                        return;\n+                }\n+                if (isErrorResponse(response)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Session expired\");\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection not initialized\");\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA3MTMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozODozOFrOHfinSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozODozOFrOHfinSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNTAxNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502835017", "createdAt": "2020-10-10T21:38:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public UnifiedRemoteHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO: nothing to do for now\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        if (!isLinked(channelId))\n+            return;\n+        String stringCommand = command.toFullString();\n+        try {\n+            if (connection != null) {\n+                ContentResponse response;\n+                switch (channelId) {\n+                    case MOUSE_CHANNEL:\n+                        response = connection.mouseMove(stringCommand);\n+                        break;\n+                    case SEND_KEY_CHANNEL:\n+                        response = connection.sendKey(stringCommand);\n+                        break;\n+                    default:\n+                        return;\n+                }\n+                if (isErrorResponse(response)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Session expired\");\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection not initialized\");\n+            }\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Server request fail: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection = getNewConnection();\n+        initConnectionChecker();\n+    }\n+\n+    private UnifiedRemoteConnection getNewConnection() {\n+        config = getConfigAs(UnifiedRemoteConfiguration.class);\n+        return new UnifiedRemoteConnection(config.host);\n+    }\n+\n+    private void initConnectionChecker() {\n+        stopConnectionChecker();\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(() -> {\n+            try {\n+                ThingStatus status = thing.getStatus();\n+                if ((status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN) && connection != null) {\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                } else if (status == ThingStatus.ONLINE) {\n+                    if (isErrorResponse(connection.keepAlive())) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Keep alive failed\");\n+                    }\n+                }\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA3MjE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozOTo0M1rOHfinqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTozOTo0M1rOHfinqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNTExMw==", "bodyText": "Please remove the extra empty line.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502835113", "createdAt": "2020-10-10T21:39:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"unifiedremote\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA3MjcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTo0MDoxN1rOHfin7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTo0MDoxN1rOHfin7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNTE4Mg==", "bodyText": "You could specify <context>network-address</context> to get a free validation.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r502835182", "createdAt": "2020-10-10T21:40:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,82 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"unifiedremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"server\">\n+\t\t<label>Unified Remote Server</label>\n+\t\t<description>Unified Remote Server Thing for Unified Remote Binding</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"mouse-move\" typeId=\"mouse-move-channel\"/>\n+\t\t\t<channel id=\"send-key\" typeId=\"send-key-channel\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Hostname</label>\n+\t\t\t\t<description>Unified Remote Server Hostname</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "156fed2f7e7906edd05b042d10fb188b954fd852"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NzA1Njk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxODowMjo0NlrOHjsovQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxODowMjo0NlrOHjsovQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5MzUzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Only supported thing is 'Unified Remote Server Thing' witch requires the Hostname to be correctly configured in order to work.\n          \n          \n            \n            Only supported thing is 'Unified Remote Server Thing' which requires the Hostname to be correctly configured in order to work.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r507193533", "createdAt": "2020-10-18T18:02:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/README.md", "diffHunk": "@@ -0,0 +1,46 @@\n+# UnifiedRemote Binding\n+\n+This binding integrates the [Unified Remote Server](https://www.unifiedremote.com/).\n+\n+<b>Known Limitations: It needs the web interface to be enabled on the server settings to work.</b>\n+\n+## Discovery\n+\n+Discovery works on the default discovery UDP port 9511.\n+\n+## Thing Configuration\n+\n+Only supported thing is 'Unified Remote Server Thing' witch requires the Hostname to be correctly configured in order to work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243419e3850f4eb0ea6c65754992882eb4fbd3b7"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NzA2MTQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxODowNzoxNVrOHjsq1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxODowNzoxNVrOHjsq1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5NDA3MA==", "bodyText": "The representation property must be the name of the property, not the value.", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r507194070", "createdAt": "2020-10-18T18:07:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(this::addNewServer);\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(serverInfo.macAddress)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243419e3850f4eb0ea6c65754992882eb4fbd3b7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NzA2Mzk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxODowOTo1OFrOHjsr9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxODowOTo1OFrOHjsr9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5NDM1Ng==", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (connectionCheckerSchedule != null && !connectionCheckerSchedule.isCancelled()) {\n          \n          \n            \n                    if (connectionCheckerSchedule != null) {", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r507194356", "createdAt": "2020-10-18T18:09:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteHandler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.MOUSE_CHANNEL;\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.SEND_KEY_CHANNEL;\n+\n+import java.net.ConnectException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class UnifiedRemoteHandler extends BaseThingHandler {\n+\n+    private Logger logger = LoggerFactory.getLogger(UnifiedRemoteHandler.class);\n+\n+    private @Nullable UnifiedRemoteConfiguration config;\n+\n+    private @Nullable UnifiedRemoteConnection connection;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private HttpClient httpClient;\n+\n+    public UnifiedRemoteHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channelId = channelUID.getId();\n+        if (!isLinked(channelId))\n+            return;\n+        String stringCommand = command.toFullString();\n+        try {\n+            if (connection != null) {\n+                ContentResponse response;\n+                switch (channelId) {\n+                    case MOUSE_CHANNEL:\n+                        response = connection.mouseMove(stringCommand);\n+                        break;\n+                    case SEND_KEY_CHANNEL:\n+                        response = connection.sendKey(stringCommand);\n+                        break;\n+                    default:\n+                        return;\n+                }\n+                if (isErrorResponse(response)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Session expired\");\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection not initialized\");\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            if (e.getCause() instanceof ConnectException) {\n+                // we assume thing is offline\n+                updateStatus(ThingStatus.OFFLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Unexpected exception: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection = getNewConnection();\n+        initConnectionChecker();\n+    }\n+\n+    private UnifiedRemoteConnection getNewConnection() {\n+        config = getConfigAs(UnifiedRemoteConfiguration.class);\n+        return new UnifiedRemoteConnection(this.httpClient, config.host);\n+    }\n+\n+    private void initConnectionChecker() {\n+        stopConnectionChecker();\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(() -> {\n+            try {\n+                ThingStatus status = thing.getStatus();\n+                if ((status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN) && connection != null) {\n+                    connection.authenticate();\n+                    updateStatus(ThingStatus.ONLINE);\n+                } else if (status == ThingStatus.ONLINE) {\n+                    if (isErrorResponse(connection.keepAlive())) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Keep alive failed\");\n+                    }\n+                }\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                if (e.getCause() instanceof ConnectException) {\n+                    // we assume thing is offline\n+                    updateStatus(ThingStatus.OFFLINE);\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Unexpected exception: \" + e.getMessage());\n+                }\n+            }\n+        }, 0, 40, TimeUnit.SECONDS);\n+    }\n+\n+    private void stopConnectionChecker() {\n+        if (connectionCheckerSchedule != null && !connectionCheckerSchedule.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243419e3850f4eb0ea6c65754992882eb4fbd3b7"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzEzMDk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjoxMjozNlrOHno4eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjoxMjozNlrOHno4eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyNjMyOQ==", "bodyText": "Is this nested class even needed? It doesn't have any fields. Can you just move all this logic into the UnifiedRemoteDiscoveryService class instead?", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r511326329", "createdAt": "2020-10-24T06:12:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n+@NonNullByDefault\n+public class UnifiedRemoteDiscoveryService extends AbstractDiscoveryService {\n+\n+    private Logger logger = LoggerFactory.getLogger(UnifiedRemoteDiscoveryService.class);\n+    static final int TIMEOUT_MS = 20000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = TimeUnit.MINUTES.toSeconds(5);\n+\n+    public UnifiedRemoteDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        UnifiedRemoteUdpDiscovery client = new UnifiedRemoteUdpDiscovery();\n+        client.call(this::addNewServer);\n+    }\n+\n+    private void addNewServer(UnifiedRemoteUdpDiscovery.ServerInfo serverInfo) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_MAC_ADDRESS, serverInfo.macAddress);\n+        properties.put(PARAMETER_HOSTNAME, serverInfo.host);\n+        properties.put(PARAMETER_TCP_PORT, serverInfo.tcpPort);\n+        properties.put(PARAMETER_UDP_PORT, serverInfo.udpPort);\n+        thingDiscovered(\n+                DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_UNIFIED_REMOTE_SERVER, serverInfo.macAddress))\n+                        .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(PARAMETER_MAC_ADDRESS)\n+                        .withProperties(properties).withLabel(serverInfo.name).build());\n+    }\n+\n+    private class UnifiedRemoteUdpDiscovery {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4f98a6d277424bd773d2617e0539b9c1c9b5359"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzEzMTA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjoxMjo1MFrOHno4hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjoxMjo1MFrOHno4hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyNjM0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.unifiedremote\")", "url": "https://github.com/openhab/openhab-addons/pull/8546#discussion_r511326342", "createdAt": "2020-10-24T06:12:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.unifiedremote/src/main/java/org/openhab/binding/unifiedremote/internal/UnifiedRemoteDiscoveryService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.unifiedremote.internal;\n+\n+import static org.openhab.binding.unifiedremote.internal.UnifiedRemoteBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link UnifiedRemoteDiscoveryService} discover Unified Remote Server Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.unifiedremote\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4f98a6d277424bd773d2617e0539b9c1c9b5359"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4331, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}