{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Njc1MDgz", "number": 7828, "title": "[deconz] Add support for ZHAThermostat", "bodyText": "Adds support for Zigbee Thermostat based on Eurotronics Spirit\nCloses #6251\nSigned-off-by: Lukas Agethen lukas83@gmx.de", "createdAt": "2020-05-31T21:46:51Z", "url": "https://github.com/openhab/openhab-addons/pull/7828", "merged": true, "mergeCommit": {"oid": "f9e54549c6b1cf2b6e3cdbef9dd17627a27b673f"}, "closed": true, "closedAt": "2020-06-07T21:18:01Z", "author": {"login": "LukasA83"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmyjSWAH2gAyNDI1Njc1MDgzOjY0YzgzYzBkYTQ5ODA3YjM4NDc1MDNmYmM0YjBjZjdjZDg3MTU1YjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpCk9AgFqTQyNTg1NDA5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "64c83c0da49807b3847503fbc4b0cf7cd87155b6", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/64c83c0da49807b3847503fbc4b0cf7cd87155b6", "committedDate": "2020-05-31T21:29:00Z", "message": "[deconz] Add support for ZHAThermostat\n\nAdds support for Zigbee Thermostat based on Eurotronics Spirit\nCloses #6251\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32b52ed57a442ef707ce1d659ac123692c2cdc7f", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/32b52ed57a442ef707ce1d659ac123692c2cdc7f", "committedDate": "2020-05-31T21:41:31Z", "message": "[deconz] Add support for ZHAThermostat\n\nAdds support for Zigbee Thermostat based on Eurotronics Spirit\nCloses #6251\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/163360f1d1bccc8e1eb942c5d477151a5adfeffb", "committedDate": "2020-05-31T21:43:24Z", "message": "Merge branch 'deconz' of https://github.com/LukasA83/openhab-addons.git into HEAD"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTQ3ODg3", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-421947887", "createdAt": "2020-06-01T15:27:00Z", "commit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyNzowMFrOGdOtAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNjowNzoyMlrOGdQvnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMjc4Nw==", "bodyText": "Wouldn't it make sense to check if the command string is allowed? You could define a Set<String> with the allowed values as a constant and check if the command string is contained in that set. I know that the deconz software is a bit strange with sending wrong commands (at least for lights).", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433302787", "createdAt": "2020-06-01T15:27:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        SensorConfig newConfig = new SensorConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                BigDecimal newTemperature;\n+                if (command instanceof DecimalType) {\n+                    newTemperature = ((DecimalType) command).toBigDecimal();\n+                } else if (command instanceof QuantityType) {\n+                    newTemperature = ((QuantityType) command).toUnit(CELSIUS).toBigDecimal();\n+                } else {\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newTemperature.scaleByPowerOfTen(2).intValue();\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    newConfig.mode = ((StringType) command).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzMTQzMg==", "bodyText": "Are there Xiaomi Theromstats which have an optional temperature channel?", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433331432", "createdAt": "2020-06-01T15:58:44Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        SensorConfig newConfig = new SensorConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                BigDecimal newTemperature;\n+                if (command instanceof DecimalType) {\n+                    newTemperature = ((DecimalType) command).toBigDecimal();\n+                } else if (command instanceof QuantityType) {\n+                    newTemperature = ((QuantityType) command).toUnit(CELSIUS).toBigDecimal();\n+                } else {\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newTemperature.scaleByPowerOfTen(2).intValue();\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    newConfig.mode = ((StringType) command).toString();\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"sensors\", config.id,\n+                \"config\");\n+\n+        String json = gson.toJson(newConfig);\n+        logger.trace(\"Sending {} to sensor {} via {}\", json, config.id, url);\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        super.valueUpdated(channelUID, newConfig);\n+        String mode = newConfig.mode;\n+        String channelID = channelUID.getId();\n+        switch (channelID) {\n+            case CHANNEL_HEATSETPOINT:\n+                updateQuantityTypeChannel(channelID, newConfig.heatsetpoint, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                updateDecimalTypeChannel(channelID, newConfig.offset);\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (mode != null) {\n+                    updateState(channelUID, new StringType(mode));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        super.valueUpdated(channelID, newState, initializing);\n+        switch (channelID) {\n+            case CHANNEL_TEMPERATURE:\n+                updateQuantityTypeChannel(channelID, newState.temperature, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_VALVE_POSITION:\n+                updateQuantityTypeChannel(channelID, newState.valve, PERCENT, 100.0 / 255);\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {\n+        // some Xiaomi sensors\n+        if (sensorConfig.temperature != null || sensorState.temperature != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzMTY5Mw==", "bodyText": "Isn't that a mandatory channel on a theromstat? Also below", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433331693", "createdAt": "2020-06-01T15:59:12Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        SensorConfig newConfig = new SensorConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                BigDecimal newTemperature;\n+                if (command instanceof DecimalType) {\n+                    newTemperature = ((DecimalType) command).toBigDecimal();\n+                } else if (command instanceof QuantityType) {\n+                    newTemperature = ((QuantityType) command).toUnit(CELSIUS).toBigDecimal();\n+                } else {\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newTemperature.scaleByPowerOfTen(2).intValue();\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    newConfig.mode = ((StringType) command).toString();\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"sensors\", config.id,\n+                \"config\");\n+\n+        String json = gson.toJson(newConfig);\n+        logger.trace(\"Sending {} to sensor {} via {}\", json, config.id, url);\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        super.valueUpdated(channelUID, newConfig);\n+        String mode = newConfig.mode;\n+        String channelID = channelUID.getId();\n+        switch (channelID) {\n+            case CHANNEL_HEATSETPOINT:\n+                updateQuantityTypeChannel(channelID, newConfig.heatsetpoint, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                updateDecimalTypeChannel(channelID, newConfig.offset);\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (mode != null) {\n+                    updateState(channelUID, new StringType(mode));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        super.valueUpdated(channelID, newState, initializing);\n+        switch (channelID) {\n+            case CHANNEL_TEMPERATURE:\n+                updateQuantityTypeChannel(channelID, newState.temperature, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_VALVE_POSITION:\n+                updateQuantityTypeChannel(channelID, newState.valve, PERCENT, 100.0 / 255);\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {\n+        // some Xiaomi sensors\n+        if (sensorConfig.temperature != null || sensorState.temperature != null) {\n+            createChannel(CHANNEL_TEMPERATURE, ChannelKind.STATE);\n+        }\n+\n+        // (Eurotronics) Thermostat\n+        if (sensorState.valve != null) {\n+            createChannel(CHANNEL_VALVE_POSITION, ChannelKind.STATE);\n+        }\n+\n+        if (sensorConfig.heatsetpoint != null) {\n+            createChannel(CHANNEL_HEATSETPOINT, ChannelKind.STATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNDAzNQ==", "bodyText": "Is this really meant to be called from outside? I don't think so.protected would be better. Also JavaDoc is missing", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433334035", "createdAt": "2020-06-01T16:03:14Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorBaseThingHandler.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Every sensor and switch is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author David Graeff - Initial contribution\n+ * @author Lukas Agethen - Refactored to provide better extensibility\n+ */\n+@NonNullByDefault\n+public abstract class SensorBaseThingHandler extends DeconzBaseThingHandler<SensorMessage> {\n+    private final Logger logger = LoggerFactory.getLogger(SensorBaseThingHandler.class);\n+    /**\n+     * The sensor state. Contains all possible fields for all supported sensors and switches\n+     */\n+    protected SensorConfig sensorConfig = new SensorConfig();\n+    protected SensorState sensorState = new SensorState();\n+    /**\n+     * Prevent a dispose/init cycle while this flag is set. Use for property updates\n+     */\n+    private boolean ignoreConfigurationUpdate;\n+\n+    public SensorBaseThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"sensors\");\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerSensorListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterSensorListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    public abstract void handleCommand(ChannelUID channelUID, Command command);\n+\n+    protected abstract void createTypeSpecificChannels(SensorConfig sensorState, SensorState sensorConfig);\n+\n+    protected abstract List<String> getConfigChannels();\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!ignoreConfigurationUpdate) {\n+            super.handleConfigurationUpdate(configurationParameters);\n+        }\n+    }\n+\n+    @Override\n+    protected @Nullable SensorMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), SensorMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable SensorMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        SensorConfig newSensorConfig = stateResponse.config;\n+        sensorConfig = newSensorConfig != null ? newSensorConfig : new SensorConfig();\n+        SensorState newSensorState = stateResponse.state;\n+        sensorState = newSensorState != null ? newSensorState : new SensorState();\n+\n+        // Add some information about the sensor\n+        if (!sensorConfig.reachable) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE, \"Not reachable\");\n+            return;\n+        }\n+\n+        if (!sensorConfig.on) {\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        Map<String, String> editProperties = editProperties();\n+        editProperties.put(Thing.PROPERTY_FIRMWARE_VERSION, stateResponse.swversion);\n+        editProperties.put(Thing.PROPERTY_MODEL_ID, stateResponse.modelid);\n+        editProperties.put(UNIQUE_ID, stateResponse.uniqueid);\n+        ignoreConfigurationUpdate = true;\n+        updateProperties(editProperties);\n+\n+        // Some sensors support optional channels\n+        // (see https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices#sensors)\n+        // any battery-powered sensor\n+        if (sensorConfig.battery != null) {\n+            createChannel(CHANNEL_BATTERY_LEVEL, ChannelKind.STATE);\n+            createChannel(CHANNEL_BATTERY_LOW, ChannelKind.STATE);\n+        }\n+\n+        createTypeSpecificChannels(sensorConfig, sensorState);\n+\n+        ignoreConfigurationUpdate = false;\n+\n+        // Initial data\n+        updateChannels(sensorConfig);\n+        updateChannels(sensorState, true);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    protected void createChannel(String channelId, ChannelKind kind) {\n+        ThingHandlerCallback callback = getCallback();\n+        if (callback != null) {\n+            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            ChannelTypeUID channelTypeUID;\n+            switch (channelId) {\n+                case CHANNEL_BATTERY_LEVEL:\n+                    channelTypeUID = new ChannelTypeUID(\"system:battery-level\");\n+                    break;\n+                case CHANNEL_BATTERY_LOW:\n+                    channelTypeUID = new ChannelTypeUID(\"system:low-battery\");\n+                    break;\n+                default:\n+                    channelTypeUID = new ChannelTypeUID(BINDING_ID, channelId);\n+                    break;\n+            }\n+            Channel channel = callback.createChannelBuilder(channelUID, channelTypeUID).withKind(kind).build();\n+            updateThing(editThing().withoutChannel(channelUID).withChannel(channel).build());\n+        }\n+    }\n+\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNTUxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                        default:\n          \n          \n            \n                            // other cases covered by sub-class\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nFor code readability", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433335512", "createdAt": "2020-06-01T16:06:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorBaseThingHandler.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.type.ChannelKind;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorMessage;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Every sensor and switch is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author David Graeff - Initial contribution\n+ * @author Lukas Agethen - Refactored to provide better extensibility\n+ */\n+@NonNullByDefault\n+public abstract class SensorBaseThingHandler extends DeconzBaseThingHandler<SensorMessage> {\n+    private final Logger logger = LoggerFactory.getLogger(SensorBaseThingHandler.class);\n+    /**\n+     * The sensor state. Contains all possible fields for all supported sensors and switches\n+     */\n+    protected SensorConfig sensorConfig = new SensorConfig();\n+    protected SensorState sensorState = new SensorState();\n+    /**\n+     * Prevent a dispose/init cycle while this flag is set. Use for property updates\n+     */\n+    private boolean ignoreConfigurationUpdate;\n+\n+    public SensorBaseThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"sensors\");\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerSensorListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterSensorListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    public abstract void handleCommand(ChannelUID channelUID, Command command);\n+\n+    protected abstract void createTypeSpecificChannels(SensorConfig sensorState, SensorState sensorConfig);\n+\n+    protected abstract List<String> getConfigChannels();\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!ignoreConfigurationUpdate) {\n+            super.handleConfigurationUpdate(configurationParameters);\n+        }\n+    }\n+\n+    @Override\n+    protected @Nullable SensorMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), SensorMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable SensorMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        SensorConfig newSensorConfig = stateResponse.config;\n+        sensorConfig = newSensorConfig != null ? newSensorConfig : new SensorConfig();\n+        SensorState newSensorState = stateResponse.state;\n+        sensorState = newSensorState != null ? newSensorState : new SensorState();\n+\n+        // Add some information about the sensor\n+        if (!sensorConfig.reachable) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE, \"Not reachable\");\n+            return;\n+        }\n+\n+        if (!sensorConfig.on) {\n+            updateStatus(ThingStatus.OFFLINE);\n+            return;\n+        }\n+\n+        Map<String, String> editProperties = editProperties();\n+        editProperties.put(Thing.PROPERTY_FIRMWARE_VERSION, stateResponse.swversion);\n+        editProperties.put(Thing.PROPERTY_MODEL_ID, stateResponse.modelid);\n+        editProperties.put(UNIQUE_ID, stateResponse.uniqueid);\n+        ignoreConfigurationUpdate = true;\n+        updateProperties(editProperties);\n+\n+        // Some sensors support optional channels\n+        // (see https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices#sensors)\n+        // any battery-powered sensor\n+        if (sensorConfig.battery != null) {\n+            createChannel(CHANNEL_BATTERY_LEVEL, ChannelKind.STATE);\n+            createChannel(CHANNEL_BATTERY_LOW, ChannelKind.STATE);\n+        }\n+\n+        createTypeSpecificChannels(sensorConfig, sensorState);\n+\n+        ignoreConfigurationUpdate = false;\n+\n+        // Initial data\n+        updateChannels(sensorConfig);\n+        updateChannels(sensorState, true);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    protected void createChannel(String channelId, ChannelKind kind) {\n+        ThingHandlerCallback callback = getCallback();\n+        if (callback != null) {\n+            ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            ChannelTypeUID channelTypeUID;\n+            switch (channelId) {\n+                case CHANNEL_BATTERY_LEVEL:\n+                    channelTypeUID = new ChannelTypeUID(\"system:battery-level\");\n+                    break;\n+                case CHANNEL_BATTERY_LOW:\n+                    channelTypeUID = new ChannelTypeUID(\"system:low-battery\");\n+                    break;\n+                default:\n+                    channelTypeUID = new ChannelTypeUID(BINDING_ID, channelId);\n+                    break;\n+            }\n+            Channel channel = callback.createChannelBuilder(channelUID, channelTypeUID).withKind(kind).build();\n+            updateThing(editThing().withoutChannel(channelUID).withChannel(channel).build());\n+        }\n+    }\n+\n+    public void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        Integer batteryLevel = newConfig.battery;\n+        switch (channelUID.getId()) {\n+            case CHANNEL_BATTERY_LEVEL:\n+                if (batteryLevel != null) {\n+                    updateState(channelUID, new DecimalType(batteryLevel.longValue()));\n+                }\n+                break;\n+            case CHANNEL_BATTERY_LOW:\n+                if (batteryLevel != null) {\n+                    updateState(channelUID, OnOffType.from(batteryLevel <= 10));\n+                }\n+                break;\n+        }\n+    }\n+\n+    public void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        switch (channelID) {\n+            case CHANNEL_LAST_UPDATED:\n+                String lastUpdated = newState.lastupdated;\n+                if (lastUpdated != null && !\"none\".equals(lastUpdated)) {\n+                    updateState(channelID,\n+                            new DateTimeType(ZonedDateTime.ofInstant(\n+                                    LocalDateTime.parse(lastUpdated, DateTimeFormatter.ISO_LOCAL_DATE_TIME),\n+                                    ZoneOffset.UTC, ZoneId.systemDefault())));\n+                }\n+                break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNjIyMQ==", "bodyText": "If the channel is added from the thing-type, you don't need to add it dynamically, also below. If the channels are mandatory, adding them here is the better choice (simplifies code).", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433336221", "createdAt": "2020-06-01T16:07:22Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/resources/ESH-INF/thing/sensor-thing-types.xml", "diffHunk": "@@ -475,5 +475,53 @@\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n \n+\t<thing-type id=\"thermostat\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"deconz\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Thermostat</label>\n+\t\t<description>A Thermostat sensor/actor</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"temperature\" id=\"temperature\"/>\n+\t\t\t<channel typeId=\"heatsetpoint\" id=\"heatsetpoint\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "163360f1d1bccc8e1eb942c5d477151a5adfeffb"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ca41cbe246a332af7a2061c33576b9b38039793", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0ca41cbe246a332af7a2061c33576b9b38039793", "committedDate": "2020-06-02T14:33:32Z", "message": "Refactored based on suggestions\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50", "committedDate": "2020-06-02T14:59:39Z", "message": "Fixed logging if update is not confirmed by \"success\" object\n\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODI2MzY0", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-422826364", "createdAt": "2020-06-02T15:56:47Z", "commit": {"oid": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1Njo0N1rOGd4nCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1ODozMFrOGd4tzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4OTM4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n          \n          \n            \n                public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_THERMOSTAT);", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433989386", "createdAt": "2020-06-02T15:56:47Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.dto.ThermostatConfig;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.types.ThermostatMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MTExOA==", "bodyText": "remove if not needed", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r433991118", "createdAt": "2020-06-02T15:58:30Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.eclipse.smarthome.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+import static org.openhab.binding.deconz.internal.Util.buildUrl;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.SensorConfig;\n+import org.openhab.binding.deconz.internal.dto.SensorState;\n+import org.openhab.binding.deconz.internal.dto.ThermostatConfig;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.types.ThermostatMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This sensor Thermostat Thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial sensor state.\n+ *\n+ * Only the Thermostat is supported by this Thing, because a unified state is kept\n+ * in {@link #sensorState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SensorThermostatThingHandler extends SensorBaseThingHandler {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n+\n+    private static final List<String> CONFIG_CHANNELS = Arrays.asList(CHANNEL_BATTERY_LEVEL, CHANNEL_BATTERY_LOW,\n+            CHANNEL_HEATSETPOINT, CHANNEL_TEMPERATURE_OFFSET, CHANNEL_THERMOSTAT_MODE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SensorThermostatThingHandler.class);\n+\n+    public SensorThermostatThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            sensorState.buttonevent = null;\n+            valueUpdated(channelUID.getId(), sensorState, false);\n+            return;\n+        }\n+        ThermostatConfig newConfig = new ThermostatConfig();\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case CHANNEL_HEATSETPOINT:\n+                Integer newHeatsetpoint = getTemperatureFromCommand(command);\n+                if (newHeatsetpoint == null) {\n+                    logger.warn(\"Heatsetpoint must not be null.\");\n+                    return;\n+                }\n+                newConfig.heatsetpoint = newHeatsetpoint;\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                Integer newOffset = getTemperatureFromCommand(command);\n+                if (newOffset == null) {\n+                    logger.warn(\"Offset must not be null.\");\n+                    return;\n+                }\n+                newConfig.offset = newOffset;\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (command instanceof StringType) {\n+                    String thermostatMode = ((StringType) command).toString();\n+                    try {\n+                        newConfig.mode = ThermostatMode.valueOf(thermostatMode);\n+                    } catch (IllegalArgumentException ex) {\n+                        logger.warn(\"Invalid thermostat mode: {}. Valid values: {}\", thermostatMode,\n+                                ThermostatMode.values());\n+                        return;\n+                    }\n+                    if (newConfig.mode == ThermostatMode.UNKNOWN) {\n+                        logger.warn(\"Invalid thermostat mode: {}. Valid values: {}\", thermostatMode,\n+                                ThermostatMode.values());\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"sensors\", config.id,\n+                \"config\");\n+\n+        String json = gson.toJson(newConfig);\n+        logger.trace(\"Sending {} to sensor {} via {}\", json, config.id, url);\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            String bodyContent = v.getBody();\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), bodyContent);\n+            if (!bodyContent.contains(\"success\")) {\n+                logger.debug(\"Sending command {} to channel {} failed: {}\", command, channelUID, bodyContent);\n+            }\n+\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void valueUpdated(ChannelUID channelUID, SensorConfig newConfig) {\n+        super.valueUpdated(channelUID, newConfig);\n+        String mode = newConfig.mode != null ? newConfig.mode.name() : ThermostatMode.UNKNOWN.name();\n+        String channelID = channelUID.getId();\n+        switch (channelID) {\n+            case CHANNEL_HEATSETPOINT:\n+                updateQuantityTypeChannel(channelID, newConfig.heatsetpoint, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_TEMPERATURE_OFFSET:\n+                updateQuantityTypeChannel(channelID, newConfig.offset, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_THERMOSTAT_MODE:\n+                if (mode != null) {\n+                    updateState(channelUID, new StringType(mode));\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void valueUpdated(String channelID, SensorState newState, boolean initializing) {\n+        super.valueUpdated(channelID, newState, initializing);\n+        switch (channelID) {\n+            case CHANNEL_TEMPERATURE:\n+                updateQuantityTypeChannel(channelID, newState.temperature, CELSIUS, 1.0 / 100);\n+                break;\n+            case CHANNEL_VALVE_POSITION:\n+                updateQuantityTypeChannel(channelID, newState.valve, PERCENT, 100.0 / 255);\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {\n+        /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44ebd24cd1eb516a506e76c6ac3f3eaad59a7e50"}, "originalPosition": 184}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c852d95311e3ddb133070e5b8c37b378975d7a81", "committedDate": "2020-06-02T17:58:06Z", "message": "Clean-up\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTUzMTU3", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-422953157", "createdAt": "2020-06-02T18:32:53Z", "commit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxODozMjo1M1rOGd_DOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxODozMjo1M1rOGd_DOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5NDkwNg==", "bodyText": "Do you need to override this method at all?", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r434094906", "createdAt": "2020-06-02T18:32:53Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/SensorThermostatThingHandler.java", "diffHunk": "@@ -181,29 +178,6 @@ protected void valueUpdated(String channelID, SensorState newState, boolean init\n \n     @Override\n     protected void createTypeSpecificChannels(SensorConfig sensorConfig, SensorState sensorState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDAzMzgy", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-425003382", "createdAt": "2020-06-05T05:23:10Z", "commit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyMzoxMFrOGfgx2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyNDoyNlrOGfgzAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjA4OQ==", "bodyText": "improper indentation", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435696089", "createdAt": "2020-06-05T05:23:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/resources/ESH-INF/thing/sensor-thing-types.xml", "diffHunk": "@@ -475,5 +475,53 @@\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n \n+\t<thing-type id=\"thermostat\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"deconz\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Thermostat</label>\n+\t\t<description>A Thermostat sensor/actor</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"temperature\" id=\"temperature\"/>\n+\t\t\t<channel typeId=\"heatsetpoint\" id=\"heatsetpoint\"/>\n+\t\t\t<channel typeId=\"mode\" id=\"mode\"/>\n+\t\t\t<channel typeId=\"offset\" id=\"offset\"/>\n+\t\t\t<channel typeId=\"valve\" id=\"valve\"/>\n+\t\t\t<channel typeId=\"last_updated\" id=\"last_updated\"/>\n+\t\t</channels>\n+\t\t<representation-property>uid</representation-property>\n+\t\t<config-description-ref uri=\"thing-type:deconz:sensor\"/>\n+\t</thing-type>\n+\n+\t<channel-type id=\"heatsetpoint\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Target temperature</label>\n+\t\t<description>Target temperature</description>\n+\t\t<state pattern=\"%.1f %unit%\" step=\"0.5\" max=\"28\" min=\"6\"></state>\n+\t</channel-type>\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Current mode</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"AUTO\">auto</option>\n+\t\t\t\t<option value=\"HEAT\">heat</option>\n+\t\t\t\t<option value=\"OFF\">off</option>\n+\t\t</options>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM4Ng==", "bodyText": "Maybe add @NonNullByDefault?", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435696386", "createdAt": "2020-06-05T05:24:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/types/ThermostatModeGsonTypeAdapter.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.types;\n+\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ * Custom (de)serializer for {@link ThermostatMode}\n+ *\n+ * @author Lukas Agethen - Initial contribution\n+ */\n+public class ThermostatModeGsonTypeAdapter implements JsonDeserializer<ThermostatMode>, JsonSerializer<ThermostatMode> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDk2MDI3", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-425096027", "createdAt": "2020-06-05T08:24:42Z", "commit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODoyNDo0MlrOGflE4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODoyNDo0MlrOGflE4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjQ5Ng==", "bodyText": "Why SensorConfig extends ThermostatConfig. Shouldn't this be the other way around because ThermostatConfig is the more specific class?", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r435766496", "createdAt": "2020-06-05T08:24:42Z", "author": {"login": "DerOetzi"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/dto/SensorConfig.java", "diffHunk": "@@ -23,9 +23,10 @@\n  * https://dresden-elektronik.github.io/deconz-rest-doc/sensors/.\n  *\n  * @author David Graeff - Initial contribution\n+ * @author Lukas Agethen - Add Thermostat parameters\n  */\n @NonNullByDefault\n-public class SensorConfig {\n+public class SensorConfig extends ThermostatConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c852d95311e3ddb133070e5b8c37b378975d7a81"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88dd1579896aadd58c64ef9f5557116b4361a2b6", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/88dd1579896aadd58c64ef9f5557116b4361a2b6", "committedDate": "2020-06-05T16:08:09Z", "message": "Minor refactoring\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjE4NTMw", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-425618530", "createdAt": "2020-06-05T20:52:25Z", "commit": {"oid": "88dd1579896aadd58c64ef9f5557116b4361a2b6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDo1MjoyNVrOGf9BnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDo1MjoyNVrOGf9BnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1ODg3Nw==", "bodyText": "Are you sure that passing null to JsonPrimitive is valid? Looking at https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/JsonPrimitive.java#L60 it checks null and throws an NPE if the value is null.", "url": "https://github.com/openhab/openhab-addons/pull/7828#discussion_r436158877", "createdAt": "2020-06-05T20:52:25Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/types/ThermostatModeGsonTypeAdapter.java", "diffHunk": "@@ -27,17 +30,22 @@\n  *\n  * @author Lukas Agethen - Initial contribution\n  */\n+@NonNullByDefault\n public class ThermostatModeGsonTypeAdapter implements JsonDeserializer<ThermostatMode>, JsonSerializer<ThermostatMode> {\n     @Override\n-    public ThermostatMode deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n-            throws JsonParseException {\n-        String s = json.getAsString();\n-        return s == null ? ThermostatMode.UNKNOWN : ThermostatMode.fromString(s);\n+    public ThermostatMode deserialize(@Nullable JsonElement json, @Nullable Type typeOfT,\n+            @Nullable JsonDeserializationContext context) throws JsonParseException {\n+        JsonElement jsonLocal = json;\n+        if (jsonLocal != null) {\n+            String s = jsonLocal.getAsString();\n+            return s == null ? ThermostatMode.UNKNOWN : ThermostatMode.fromString(s);\n+        }\n+        return ThermostatMode.UNKNOWN;\n     }\n \n     @Override\n-    public JsonElement serialize(ThermostatMode src, Type typeOfSrc, JsonSerializationContext context)\n-            throws JsonParseException {\n+    public JsonElement serialize(ThermostatMode src, @Nullable Type typeOfSrc,\n+            @Nullable JsonSerializationContext context) throws JsonParseException {\n         return new JsonPrimitive(src != ThermostatMode.UNKNOWN ? src.getDeconzValue() : null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88dd1579896aadd58c64ef9f5557116b4361a2b6"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3082f0a09fd639a63b051306eecc787f4bc2cc88", "author": {"user": {"login": "LukasA83", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3082f0a09fd639a63b051306eecc787f4bc2cc88", "committedDate": "2020-06-06T11:30:24Z", "message": "Fix Thermostat mode JSON serialization\n\nSigned-off-by: Lukas Agethen <lukas83@gmx.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzQ4ODI4", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-425748828", "createdAt": "2020-06-06T15:40:00Z", "commit": {"oid": "3082f0a09fd639a63b051306eecc787f4bc2cc88"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODU0MDk1", "url": "https://github.com/openhab/openhab-addons/pull/7828#pullrequestreview-425854095", "createdAt": "2020-06-07T21:17:09Z", "commit": {"oid": "3082f0a09fd639a63b051306eecc787f4bc2cc88"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 507, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}