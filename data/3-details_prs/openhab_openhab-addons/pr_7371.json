{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMjU0NDgy", "number": 7371, "title": "[monopriceaudio] Monoprice Whole House Amplifier Binding - initial contribution", "bodyText": "[monopriceaudio] Initial contribution\nThis is the initial implementation of a Binding to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 multi-zone whole house amplifier. The binding is configurable to control up to 18 zones when 3 amplifiers are connected together. The preferred connection to the amplifier controller is via a direct serial port connection but serial over IP connections are also supported.", "createdAt": "2020-04-14T15:26:48Z", "url": "https://github.com/openhab/openhab-addons/pull/7371", "merged": true, "mergeCommit": {"oid": "d574e37c6ab8ab14bfe6371ec7afa0a74e24b24d"}, "closed": true, "closedAt": "2020-09-03T06:31:36Z", "author": {"login": "mlobstein"}, "timelineItems": {"totalCount": 69, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXUds4gH2gAyNDAzMjU0NDgyOjI5NDAwYjUxNmEzMGMyZWYyYzJjZmFiMzg2Y2Q1ODYzYjkzNWNkYTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFFlK_gH2gAyNDAzMjU0NDgyOmFkMjczMWMyMzBiMmM4NzYyOGRlNDU5Yjc3ZjAzMDgyZGEwNmI2NTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "committedDate": "2020-04-13T19:56:53Z", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcb0a5701d08151c606b3a6bca2bd68741183040", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/bcb0a5701d08151c606b3a6bca2bd68741183040", "committedDate": "2020-04-14T02:29:25Z", "message": "MonopriceAudio Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2254bbe8e988dd6b130b00aef8225e3b79c7a94c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2254bbe8e988dd6b130b00aef8225e3b79c7a94c", "committedDate": "2020-04-14T15:10:55Z", "message": "fix documentation issues\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b13b1f303241948a7647014b7adc5a14ee35dc48", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b13b1f303241948a7647014b7adc5a14ee35dc48", "committedDate": "2020-04-19T18:37:15Z", "message": "Add logic set offline status if the controller is not responding\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "committedDate": "2020-04-19T18:41:08Z", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cc33e62f6c1dab46457526dda876750ff613a1d", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7cc33e62f6c1dab46457526dda876750ff613a1d", "committedDate": "2020-04-19T18:44:19Z", "message": "fix merge conflict in pom.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f077b3e504cbe95b4b0b0676ed034b87476f25c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3f077b3e504cbe95b4b0b0676ed034b87476f25c", "committedDate": "2020-04-19T20:08:28Z", "message": "update pom version to 2.5.5\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "546783b7ac100c45270e008dd7b55e0d5c781e37", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/546783b7ac100c45270e008dd7b55e0d5c781e37", "committedDate": "2020-05-01T22:24:37Z", "message": "Removed advanced from treble, bass and balance in channels.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8485fa9668467a03627b328488f892594e0ca8d3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/8485fa9668467a03627b328488f892594e0ca8d3", "committedDate": "2020-05-22T16:09:05Z", "message": "Cleanup before review\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99430f8919968fda476e81cb27e1bd44b1a19752", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/99430f8919968fda476e81cb27e1bd44b1a19752", "committedDate": "2020-05-23T04:53:31Z", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "399741ecdd8a650362929167b0227e70a9885b4c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/399741ecdd8a650362929167b0227e70a9885b4c", "committedDate": "2020-05-25T22:05:28Z", "message": "refactored to minimize unnecessary channel updates\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "committedDate": "2020-05-27T03:57:29Z", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7643886a75fe02b8479e92b71bc7f63a799739ae", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7643886a75fe02b8479e92b71bc7f63a799739ae", "committedDate": "2020-05-27T04:27:37Z", "message": "Merge branch '2.5.x' into MonopriceAudio"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/70cd561d206e45925692019f6199bcaa2a5d8515", "committedDate": "2020-05-27T05:03:46Z", "message": "more cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzkyNDMz", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-421392433", "createdAt": "2020-05-30T09:31:44Z", "commit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwOTozMTo0NFrOGcxoxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMjowMDo0OVrOGcyNWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNjU2NQ==", "bodyText": "If these have only two states, can you make them switches?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432826565", "createdAt": "2020-05-30T09:31:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/README.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# MonopriceAudio Binding\n+\n+This binding can be used to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 whole house multi-zone amplifier.\n+All controller functions available through the serial port interface can be controlled by the binding.\n+Up to 18 zones can be controlled when 3 amplifiers are connected together (if not all zones on the amp are used they can be excluded via configuration).\n+Activating the 'Page All Zones' feature can only be done through the +12v trigger input on the back of the amplifier.\n+\n+The binding supports two different kinds of connections:\n+\n+* serial connection,\n+* serial over IP connection\n+\n+For users without serial connector on server side, you can add a serial to USB adapter.\n+\n+You don't need to have your Monoprice whole house amplifier device directly connected to your openHAB server.\n+You can connect it for example to a Raspberry Pi and use [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) to make the serial connection available on LAN (serial over IP).\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the amplifier controller.\n+It has the `amplifier` id.\n+\n+## Discovery\n+\n+Discovery is not supported.\n+You have to add all things manually.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label      | Parameter ID     | Description                                                                                                                    | Accepted values    |\n+|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------|--------------------|\n+| Serial Port          | serialPort       | Serial port to use for connecting to the Monoprice whole house amplifier device                                                | Serial port name | |\n+| Address              | host             | Host name or IP address of the machine connected to the Monoprice whole house amplifier device (serial over IP)                | Host name or IP  | |\n+| Port                 | port             | Communication port (serial over IP).                                                                                           | TCP port number  | |\n+| Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |\n+| Polling Interval     | pollingInterval  | (Optional) Configures how often (in seconds) to poll the controller to check for zone updates                                  | 5-60; default 15 | |\n+| Ignore Zones         | ignoreZones      | (Optional) A comma seperated list of Zone numbers that will ignore the 'All Zone' (except All Off) commands                    | ie: \"1,6,10\"     | |\n+| Initial All Volume   | initialAllVolume | (Optional) When 'All' zones are activated, the volume will reset to this value to prevent excessive blaring of sound ;)        | 1-30; default 10 | |\n+| Source 1 Input Label | inputLabel1      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 1\") | A free text name | |\n+| Source 2 Input Label | inputLabel2      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 2\") | A free text name | |\n+| Source 3 Input Label | inputLabel3      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 3\") | A free text name | |\n+| Source 4 Input Label | inputLabel4      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 4\") | A free text name | |\n+| Source 5 Input Label | inputLabel5      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 5\") | A free text name | |\n+| Source 6 Input Label | inputLabel6      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 6\") | A free text name | |\n+\n+Some notes:\n+\n+* On Linux, you may get an error stating the serial port cannot be opened when the MonopriceAudio binding tries to load.  You can get around this by adding the `openhab` user to the `dialout` group like this: `usermod -a -G dialout openhab`.\n+* Also on Linux you may have issues with the USB if using two serial USB devices e.g. MonopriceAudio and RFXcom. See the [general documentation about serial port configuration](/docs/administration/serial.html) for more on symlinking the USB ports.\n+* Here is an example of ser2net.conf you can use to share your serial port /dev/ttyUSB0 on IP port 4444 using [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) (take care, the baud rate is specific to the Monoprice amplifier):\n+\n+```\n+4444:raw:0:/dev/ttyUSB0:9600 8DATABITS NONE 1STOPBIT LOCAL\n+```\n+\n+## Channels\n+\n+The following channels are available:\n+\n+| Channel ID                    | Item Type            | Description                                                                                                   |\n+|-------------------------------|----------------------|---------------------------------------------------------------------------------------------------------------|\n+| all:allon                     | Switch               | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |\n+| all:alloff                    | Switch               | Turn all zones off simultaneously (except those specified by the ignoreZones config option)                   |\n+| all:allsource                 | Number               | Select the source input for all zones simultaneously (1-6) (except ignoreZones)                               |\n+| all:allvolume                 | Dimmer               | Control the volume for all zones simultaneously (0-100%) [translates to 0-38] (except ignoreZones)            |\n+| all:allmute                   | Switch               | Mute or unmute all zones simultaneously (except ignoreZones)                                                  |\n+| zoneN#power (where N= 1-18)   | Switch               | Turn the power for a zone on or off                                                                           |\n+| zoneN#source (where N= 1-18)  | Number               | Select the source input for a zone (1-6)                                                                      |\n+| zoneN#volume (where N= 1-18)  | Dimmer               | Control the volume for a zone (0-100%) [translates to 0-38]                                                   |\n+| zoneN#mute (where N= 1-18)    | Switch               | Mute or unmute a zone                                                                                         |\n+| zoneN#treble (where N= 1-18)  | Number               | Adjust the treble control for a zone (-7 to 7) -7=none, 0=flat, 7=full                                        |\n+| zoneN#bass (where N= 1-18)    | Number               | Adjust the bass control for a zone (-7 to 7) -7=none, 0=flat, 7=full                                          |\n+| zoneN#balance (where N= 1-18) | Number               | Adjust the balance control for a zone (-10 to 10) -10=left, 0=center, 10=right                                |\n+| zoneN#dnd (where N= 1-18)     | Switch               | Turn on or off the Do Not Disturb for the zone (for when the controller's external page trigger is activated) |\n+| zoneN#page (where N= 1-18)    | Number               | Indicates if the page input is activated for the zone (ReadOnly 0-1)                                          |\n+| zoneN#keypad (where N= 1-18)  | Number               | Indicates if the physical keypad is attached to a zone (ReadOnly 0-1)                                         |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNjY5NQ==", "bodyText": "I understand these as actions rather than states, that can be switched. Did you take look into ThingActions?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432826695", "createdAt": "2020-05-30T09:33:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/README.md", "diffHunk": "@@ -0,0 +1,149 @@\n+# MonopriceAudio Binding\n+\n+This binding can be used to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 whole house multi-zone amplifier.\n+All controller functions available through the serial port interface can be controlled by the binding.\n+Up to 18 zones can be controlled when 3 amplifiers are connected together (if not all zones on the amp are used they can be excluded via configuration).\n+Activating the 'Page All Zones' feature can only be done through the +12v trigger input on the back of the amplifier.\n+\n+The binding supports two different kinds of connections:\n+\n+* serial connection,\n+* serial over IP connection\n+\n+For users without serial connector on server side, you can add a serial to USB adapter.\n+\n+You don't need to have your Monoprice whole house amplifier device directly connected to your openHAB server.\n+You can connect it for example to a Raspberry Pi and use [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) to make the serial connection available on LAN (serial over IP).\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the amplifier controller.\n+It has the `amplifier` id.\n+\n+## Discovery\n+\n+Discovery is not supported.\n+You have to add all things manually.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label      | Parameter ID     | Description                                                                                                                    | Accepted values    |\n+|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------|--------------------|\n+| Serial Port          | serialPort       | Serial port to use for connecting to the Monoprice whole house amplifier device                                                | Serial port name | |\n+| Address              | host             | Host name or IP address of the machine connected to the Monoprice whole house amplifier device (serial over IP)                | Host name or IP  | |\n+| Port                 | port             | Communication port (serial over IP).                                                                                           | TCP port number  | |\n+| Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |\n+| Polling Interval     | pollingInterval  | (Optional) Configures how often (in seconds) to poll the controller to check for zone updates                                  | 5-60; default 15 | |\n+| Ignore Zones         | ignoreZones      | (Optional) A comma seperated list of Zone numbers that will ignore the 'All Zone' (except All Off) commands                    | ie: \"1,6,10\"     | |\n+| Initial All Volume   | initialAllVolume | (Optional) When 'All' zones are activated, the volume will reset to this value to prevent excessive blaring of sound ;)        | 1-30; default 10 | |\n+| Source 1 Input Label | inputLabel1      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 1\") | A free text name | |\n+| Source 2 Input Label | inputLabel2      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 2\") | A free text name | |\n+| Source 3 Input Label | inputLabel3      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 3\") | A free text name | |\n+| Source 4 Input Label | inputLabel4      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 4\") | A free text name | |\n+| Source 5 Input Label | inputLabel5      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 5\") | A free text name | |\n+| Source 6 Input Label | inputLabel6      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 6\") | A free text name | |\n+\n+Some notes:\n+\n+* On Linux, you may get an error stating the serial port cannot be opened when the MonopriceAudio binding tries to load.  You can get around this by adding the `openhab` user to the `dialout` group like this: `usermod -a -G dialout openhab`.\n+* Also on Linux you may have issues with the USB if using two serial USB devices e.g. MonopriceAudio and RFXcom. See the [general documentation about serial port configuration](/docs/administration/serial.html) for more on symlinking the USB ports.\n+* Here is an example of ser2net.conf you can use to share your serial port /dev/ttyUSB0 on IP port 4444 using [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) (take care, the baud rate is specific to the Monoprice amplifier):\n+\n+```\n+4444:raw:0:/dev/ttyUSB0:9600 8DATABITS NONE 1STOPBIT LOCAL\n+```\n+\n+## Channels\n+\n+The following channels are available:\n+\n+| Channel ID                    | Item Type            | Description                                                                                                   |\n+|-------------------------------|----------------------|---------------------------------------------------------------------------------------------------------------|\n+| all:allon                     | Switch               | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |\n+| all:alloff                    | Switch               | Turn all zones off simultaneously (except those specified by the ignoreZones config option)                   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzI4Nw==", "bodyText": "Is there a reason for Nullable?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827287", "createdAt": "2020-05-30T09:43:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+\n+    QUERY(\"?\"),\n+    BEGIN_CMD(\"<\"),\n+    END_CMD(\"\\r\"),\n+\n+    POWER_ON(\"PR01\"),\n+    POWER_OFF(\"PR00\"),\n+    SOURCE(\"CH\"),\n+    VOLUME(\"VO\"),\n+    MUTE_ON(\"MU01\"),\n+    MUTE_OFF(\"MU00\"),\n+    TREBLE(\"TR\"),\n+    BASS(\"BS\"),\n+    BALANCE(\"BL\"),\n+    DND_ON(\"DT01\"),\n+    DND_OFF(\"DT00\");\n+\n+    private @Nullable String value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw==", "bodyText": "What is expected to throw a InterruptedIOException?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827513", "createdAt": "2020-05-30T09:47:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzU4Mg==", "bodyText": "This exception is logged here and in MonopriceAudioReaderThread.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827582", "createdAt": "2020-05-30T09:48:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzc4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    byte[] message = new byte[0];\n          \n          \n            \n                    byte[] message;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827785", "createdAt": "2020-05-30T09:51:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzk3NA==", "bodyText": "Is this message necessary? The content is logged again below.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827974", "createdAt": "2020-05-30T09:54:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODE2Nw==", "bodyText": "If you log exceptions where they are eventually catched, you don't have to take care if the same error is logged multiple times. This exception is logged here and at least at MonopriceAudioHandler:400.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828167", "createdAt": "2020-05-30T09:57:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODI4MA==", "bodyText": "Better specify the encoding you expect.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828280", "createdAt": "2020-05-30T09:59:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODU3OA==", "bodyText": "It's bad practice to catch unchecked exceptions. Can you evaluate the return value of find()?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828578", "createdAt": "2020-05-30T10:03:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (READ_ERROR.equals(message)) {\n+            dispatchKeyValue(KEY_ERROR, MSG_VALUE_ON);\n+            return;\n+        }\n+\n+        // Amp controller sends status string: #>1200010000130809100601\n+        Pattern p = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+        try {\n+            Matcher matcher = p.matcher(message);\n+            matcher.find();\n+            // pull out just the digits and send them as an event\n+            dispatchKeyValue(KEY_ZONE_UPDATE, matcher.group(1));\n+        } catch (IllegalStateException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODY5NA==", "bodyText": "Syntactical sugar:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        listeners.get(i).onNewMessageEvent(event);\n          \n          \n            \n                    }\n          \n          \n            \n                    listeners.forEach(l -> l.onNewMessageEvent(event));", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828694", "createdAt": "2020-05-30T10:05:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (READ_ERROR.equals(message)) {\n+            dispatchKeyValue(KEY_ERROR, MSG_VALUE_ON);\n+            return;\n+        }\n+\n+        // Amp controller sends status string: #>1200010000130809100601\n+        Pattern p = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+        try {\n+            Matcher matcher = p.matcher(message);\n+            matcher.find();\n+            // pull out just the digits and send them as an event\n+            dispatchKeyValue(KEY_ZONE_UPDATE, matcher.group(1));\n+        } catch (IllegalStateException e) {\n+            logger.debug(\"no match on message: {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Dispatch an event (key, value) to the event listeners\n+     *\n+     * @param key the key\n+     * @param value the value\n+     */\n+    private void dispatchKeyValue(String key, String value) {\n+        MonopriceAudioMessageEvent event = new MonopriceAudioMessageEvent(this, key, value);\n+        for (int i = 0; i < listeners.size(); i++) {\n+            listeners.get(i).onNewMessageEvent(event);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTA4Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829087", "createdAt": "2020-05-30T10:11:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(String address, Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.clientSocket = clientSocket;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"IP connection opened\");\n+        } catch (IOException | SecurityException | IllegalArgumentException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening IP connection failed: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTI1OQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829259", "createdAt": "2020-05-30T10:14:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(String address, Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.clientSocket = clientSocket;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"IP connection opened\");\n+        } catch (IOException | SecurityException | IllegalArgumentException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening IP connection failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"Opening IP connection failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+        logger.debug(\"Closing IP connection\");\n+        super.cleanup();\n+        Socket clientSocket = this.clientSocket;\n+        if (clientSocket != null) {\n+            try {\n+                clientSocket.close();\n+            } catch (IOException e) {\n+            }\n+            this.clientSocket = null;\n+        }\n+        setConnected(false);\n+        logger.debug(\"IP connection closed\");\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     * In case of socket timeout, the returned value is 0.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    @Override\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (SocketTimeoutException e) {\n+            return 0;\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTkzNw==", "bodyText": "This could be made a static field.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829937", "createdAt": "2020-05-30T10:24:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.InterruptedIOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Data listener started\");\n+\n+        final int size = 64;\n+        byte[] readDataBuffer = new byte[READ_BUFFER_SIZE];\n+        byte[] dataBuffer = new byte[size];\n+        int index = 0;\n+        final char terminatingChar = '\\r';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDAyNw==", "bodyText": "This could be made a static field.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830027", "createdAt": "2020-05-30T10:25:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.InterruptedIOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Data listener started\");\n+\n+        final int size = 64;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDI5Ng==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830296", "createdAt": "2020-05-30T10:30:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDM5NA==", "bodyText": "See above (each catch)", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830394", "createdAt": "2020-05-30T10:31:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);\n+                throw new MonopriceAudioException(\"Opening serial connection failed: No Such Port\");\n+            }\n+\n+            SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000);\n+\n+            commPort.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(100);\n+            commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\n+\n+            InputStream dataIn = commPort.getInputStream();\n+            OutputStream dataOut = commPort.getOutputStream();\n+\n+            if (dataOut != null) {\n+                dataOut.flush();\n+            }\n+            if (dataIn != null && dataIn.markSupported()) {\n+                try {\n+                    dataIn.reset();\n+                } catch (IOException e) {\n+                }\n+            }\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.serialPort = commPort;\n+            this.dataIn = dataIn;\n+            this.dataOut = dataOut;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"Serial connection opened\");\n+        } catch (PortInUseException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening serial connection failed: Port in Use Exception: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDk4NA==", "bodyText": "You could use valueOf() to get rid of the Maps in the MonopriceAudioZone Enum.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n          \n          \n            \n                                                        connector.sendCommand(MonopriceAudioZone.valueOf(\"ZONE\" + zoneId),", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830984", "createdAt": "2020-05-30T10:40:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjAyNQ==", "bodyText": "Can you make these Nullable? You could combine the config validation in the handler with the != null checks to not blowing up your code.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832025", "createdAt": "2020-05-30T10:58:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+\n+    public @NonNullByDefault({}) Integer numZones;\n+    public @NonNullByDefault({}) Integer pollingInterval;\n+    public @NonNullByDefault({}) String serialPort;\n+    public @NonNullByDefault({}) String host;\n+    public @NonNullByDefault({}) Integer port;\n+    public @NonNullByDefault({}) String ignoreZones;\n+    public @NonNullByDefault({}) Integer initialAllVolume;\n+    public @NonNullByDefault({}) String inputLabel1;\n+    public @NonNullByDefault({}) String inputLabel2;\n+    public @NonNullByDefault({}) String inputLabel3;\n+    public @NonNullByDefault({}) String inputLabel4;\n+    public @NonNullByDefault({}) String inputLabel5;\n+    public @NonNullByDefault({}) String inputLabel6;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjEwNA==", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<String>();\n          \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<>();", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832104", "createdAt": "2020-05-30T10:59:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjE4Ng==", "bodyText": "Better use primitive types where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Long lastPollingUpdate = System.currentTimeMillis();\n          \n          \n            \n                private long lastPollingUpdate = System.currentTimeMillis();", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832186", "createdAt": "2020-05-30T11:00:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjIzMQ==", "bodyText": "Can this message be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832231", "createdAt": "2020-05-30T11:02:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjYzMA==", "bodyText": "You could have had some fun with streams here. Next time...", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832630", "createdAt": "2020-05-30T11:09:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjkxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n          \n          \n            \n                                    ZONE + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832911", "createdAt": "2020-05-30T11:13:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzA5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n          \n          \n            \n                                if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)))) {", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833093", "createdAt": "2020-05-30T11:16:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzE4OA==", "bodyText": "Can these log messages be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833188", "createdAt": "2020-05-30T11:18:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzIzOQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833239", "createdAt": "2020-05-30T11:19:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA==", "bodyText": "There are lots of NonNull warnings for connector. You can reference connector with a local variable and check it for nullness. Then, these warnings will disappear.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833504", "createdAt": "2020-05-30T11:22:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzU4OA==", "bodyText": "Better use primitives int.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833588", "createdAt": "2020-05-30T11:24:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzY5OQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833699", "createdAt": "2020-05-30T11:25:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzcyMQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833721", "createdAt": "2020-05-30T11:25:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzc2Mw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833763", "createdAt": "2020-05-30T11:26:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzk1MQ==", "bodyText": "30ms are not enough to guarentee that the JVM will execute the following code in a different time slice, hence the sleep could be ignored. You should be safe with 100ms.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833951", "createdAt": "2020-05-30T11:29:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDEyMg==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834122", "createdAt": "2020-05-30T11:32:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE1NA==", "bodyText": "See above. Please check the other occurrences down below.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834154", "createdAt": "2020-05-30T11:32:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 382}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE3MA==", "bodyText": "See above. Please check the other occurrences down below.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834170", "createdAt": "2020-05-30T11:33:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 384}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDQxOQ==", "bodyText": "Can this be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834419", "createdAt": "2020-05-30T11:37:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDQ5MA==", "bodyText": "Should this be warn or can be completly removed?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834490", "createdAt": "2020-05-30T11:39:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 523}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUwMQ==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834501", "createdAt": "2020-05-30T11:39:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 527}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUyNQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834525", "createdAt": "2020-05-30T11:39:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 545}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDY1MA==", "bodyText": "You can use == when using primitive types. Would < or > be more adequate here?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834650", "createdAt": "2020-05-30T11:41:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 550}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc0OA==", "bodyText": "No harm in cancelling an already canceled job.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834748", "createdAt": "2020-05-30T11:43:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 578}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc5MA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834790", "createdAt": "2020-05-30T11:43:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 602}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc5Mw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834793", "createdAt": "2020-05-30T11:43:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDgxNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834817", "createdAt": "2020-05-30T11:44:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 627}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTE0OA==", "bodyText": "You could make that a static field to save resources.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835148", "createdAt": "2020-05-30T11:48:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneData zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = new DecimalType(zoneData.isPageActive() ? 1 : 0);\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = new DecimalType(zoneData.isKeypadActive() ? 1 : 0);\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneData zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601\n+            Pattern p = Pattern.compile(\n+                    \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 690}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTE3Mw==", "bodyText": "Better evaluate the return value of find(), instead of catching the unchecked exception.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835173", "createdAt": "2020-05-30T11:49:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneData zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = new DecimalType(zoneData.isPageActive() ? 1 : 0);\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = new DecimalType(zoneData.isKeypadActive() ? 1 : 0);\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneData zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601\n+            Pattern p = Pattern.compile(\n+                    \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+            try {\n+                Matcher matcher = p.matcher(newZoneData);\n+                matcher.find();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 693}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTM1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"5\" max=\"60\" required=\"false\">\n          \n          \n            \n            \t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"5\" max=\"60\" unit=\"s\"  required=\"false\">", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835356", "createdAt": "2020-05-30T11:52:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,541 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"monopriceaudio\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Monoprice Whole House Amplifier Thing -->\n+\t<thing-type id=\"amplifier\">\n+\t\t<label>Whole House Amplifier</label>\n+\t\t<description>\n+\t\t\tA multi-zone whole house amplifier system\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"all\" typeId=\"all\">\n+\t\t\t\t<label>All Zones</label>\n+\t\t\t\t<description>Control All Zones Simultaneously</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone1\" typeId=\"zone1\">\n+\t\t\t\t<label>Zone 1</label>\n+\t\t\t\t<description>The Controls for Zone 1</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone2\" typeId=\"zone2\">\n+\t\t\t\t<label>Zone 2</label>\n+\t\t\t\t<description>The Controls for Zone 2</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone3\" typeId=\"zone3\">\n+\t\t\t\t<label>Zone 3</label>\n+\t\t\t\t<description>The Controls for Zone 3</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone4\" typeId=\"zone4\">\n+\t\t\t\t<label>Zone 4</label>\n+\t\t\t\t<description>The Controls for Zone 4</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone5\" typeId=\"zone5\">\n+\t\t\t\t<label>Zone 5</label>\n+\t\t\t\t<description>The Controls for Zone 5</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone6\" typeId=\"zone6\">\n+\t\t\t\t<label>Zone 6</label>\n+\t\t\t\t<description>The Controls for Zone 6</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone7\" typeId=\"zone7\">\n+\t\t\t\t<label>Zone 7</label>\n+\t\t\t\t<description>The Controls for Zone 7</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone8\" typeId=\"zone8\">\n+\t\t\t\t<label>Zone 8</label>\n+\t\t\t\t<description>The Controls for Zone 8</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone9\" typeId=\"zone9\">\n+\t\t\t\t<label>Zone 9</label>\n+\t\t\t\t<description>The Controls for Zone 9</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone10\" typeId=\"zone10\">\n+\t\t\t\t<label>Zone 10</label>\n+\t\t\t\t<description>The Controls for Zone 10</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone11\" typeId=\"zone11\">\n+\t\t\t\t<label>Zone 11</label>\n+\t\t\t\t<description>The Controls for Zone 11</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone12\" typeId=\"zone12\">\n+\t\t\t\t<label>Zone 12</label>\n+\t\t\t\t<description>The Controls for Zone 12</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone13\" typeId=\"zone13\">\n+\t\t\t\t<label>Zone 13</label>\n+\t\t\t\t<description>The Controls for Zone 13</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone14\" typeId=\"zone14\">\n+\t\t\t\t<label>Zone 14</label>\n+\t\t\t\t<description>The Controls for Zone 14</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone15\" typeId=\"zone15\">\n+\t\t\t\t<label>Zone 15</label>\n+\t\t\t\t<description>The Controls for Zone 15</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone16\" typeId=\"zone16\">\n+\t\t\t\t<label>Zone 16</label>\n+\t\t\t\t<description>The Controls for Zone 16</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone17\" typeId=\"zone17\">\n+\t\t\t\t<label>Zone 17</label>\n+\t\t\t\t<description>The Controls for Zone 17</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone18\" typeId=\"zone18\">\n+\t\t\t\t<label>Zone 18</label>\n+\t\t\t\t<description>The Controls for Zone 18</description>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>Serial Port to Use for Connecting to the Monoprice Amplifier</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Machine Connected to the Monoprice Amplifier (Serial over IP)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Communication Port (IP or Serial over IP). For IP connection to the Monoprice Amplifier</description>\n+\t\t\t\t<default>4444</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"numZones\" type=\"integer\" min=\"1\" max=\"18\" required=\"true\">\n+\t\t\t\t<label>Number of Zones</label>\n+\t\t\t\t<description>Number of Zones on the Amplifier to Utilize in the Binding (Up to 18 Zones With 3 Amplifiers Connected\n+\t\t\t\t\tTogether)</description>\n+\t\t\t\t<default>6</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"5\" max=\"60\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTYyNQ==", "bodyText": "You should handle the case, the user enters an invalid zone number. E.g. check for get() returning null or make the generic type of ignoreZones Nullable.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835625", "createdAt": "2020-05-30T11:56:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTkzMA==", "bodyText": "Is there a reason why you don't specify min/max?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835930", "createdAt": "2020-05-30T12:00:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,541 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"monopriceaudio\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Monoprice Whole House Amplifier Thing -->\n+\t<thing-type id=\"amplifier\">\n+\t\t<label>Whole House Amplifier</label>\n+\t\t<description>\n+\t\t\tA multi-zone whole house amplifier system\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"all\" typeId=\"all\">\n+\t\t\t\t<label>All Zones</label>\n+\t\t\t\t<description>Control All Zones Simultaneously</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone1\" typeId=\"zone1\">\n+\t\t\t\t<label>Zone 1</label>\n+\t\t\t\t<description>The Controls for Zone 1</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone2\" typeId=\"zone2\">\n+\t\t\t\t<label>Zone 2</label>\n+\t\t\t\t<description>The Controls for Zone 2</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone3\" typeId=\"zone3\">\n+\t\t\t\t<label>Zone 3</label>\n+\t\t\t\t<description>The Controls for Zone 3</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone4\" typeId=\"zone4\">\n+\t\t\t\t<label>Zone 4</label>\n+\t\t\t\t<description>The Controls for Zone 4</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone5\" typeId=\"zone5\">\n+\t\t\t\t<label>Zone 5</label>\n+\t\t\t\t<description>The Controls for Zone 5</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone6\" typeId=\"zone6\">\n+\t\t\t\t<label>Zone 6</label>\n+\t\t\t\t<description>The Controls for Zone 6</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone7\" typeId=\"zone7\">\n+\t\t\t\t<label>Zone 7</label>\n+\t\t\t\t<description>The Controls for Zone 7</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone8\" typeId=\"zone8\">\n+\t\t\t\t<label>Zone 8</label>\n+\t\t\t\t<description>The Controls for Zone 8</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone9\" typeId=\"zone9\">\n+\t\t\t\t<label>Zone 9</label>\n+\t\t\t\t<description>The Controls for Zone 9</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone10\" typeId=\"zone10\">\n+\t\t\t\t<label>Zone 10</label>\n+\t\t\t\t<description>The Controls for Zone 10</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone11\" typeId=\"zone11\">\n+\t\t\t\t<label>Zone 11</label>\n+\t\t\t\t<description>The Controls for Zone 11</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone12\" typeId=\"zone12\">\n+\t\t\t\t<label>Zone 12</label>\n+\t\t\t\t<description>The Controls for Zone 12</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone13\" typeId=\"zone13\">\n+\t\t\t\t<label>Zone 13</label>\n+\t\t\t\t<description>The Controls for Zone 13</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone14\" typeId=\"zone14\">\n+\t\t\t\t<label>Zone 14</label>\n+\t\t\t\t<description>The Controls for Zone 14</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone15\" typeId=\"zone15\">\n+\t\t\t\t<label>Zone 15</label>\n+\t\t\t\t<description>The Controls for Zone 15</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone16\" typeId=\"zone16\">\n+\t\t\t\t<label>Zone 16</label>\n+\t\t\t\t<description>The Controls for Zone 16</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone17\" typeId=\"zone17\">\n+\t\t\t\t<label>Zone 17</label>\n+\t\t\t\t<description>The Controls for Zone 17</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone18\" typeId=\"zone18\">\n+\t\t\t\t<label>Zone 18</label>\n+\t\t\t\t<description>The Controls for Zone 18</description>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>Serial Port to Use for Connecting to the Monoprice Amplifier</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Machine Connected to the Monoprice Amplifier (Serial over IP)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Communication Port (IP or Serial over IP). For IP connection to the Monoprice Amplifier</description>\n+\t\t\t\t<default>4444</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"numZones\" type=\"integer\" min=\"1\" max=\"18\" required=\"true\">\n+\t\t\t\t<label>Number of Zones</label>\n+\t\t\t\t<description>Number of Zones on the Amplifier to Utilize in the Binding (Up to 18 Zones With 3 Amplifiers Connected\n+\t\t\t\t\tTogether)</description>\n+\t\t\t\t<default>6</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"5\" max=\"60\" required=\"false\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Configures How Often to Poll the Controller to Check for Zone Updates (5-60; Default 15)</description>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ignoreZones\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Ignore Zones</label>\n+\t\t\t\t<description>(Optional) A Comma Seperated List of Zone Numbers That Will Ignore the 'All Zone' (Except All Off)\n+\t\t\t\t\tCommands (ie: 1,6,10)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"initialAllVolume\" type=\"integer\" min=\"1\" max=\"30\" required=\"false\">\n+\t\t\t\t<label>Initial All Volume</label>\n+\t\t\t\t<description>When 'All' Zones Are Activated, the Volume Will Reset to This Value (1-30; default 10) to Prevent\n+\t\t\t\t\tExcessive Blaring of Sound ;)</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel1\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 1 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 1</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel2\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 2 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel3\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 3 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 3</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel4\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 4 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 4</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel5\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 5 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 5</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel6\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 6 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 6</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-group-type id=\"all\">\n+\t\t<label>All Zones</label>\n+\t\t<description>Control All Zones Simultaneously</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"allon\" typeId=\"allon\"/>\n+\t\t\t<channel id=\"alloff\" typeId=\"alloff\"/>\n+\t\t\t<channel id=\"allsource\" typeId=\"source\"/>\n+\t\t\t<channel id=\"allvolume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"allmute\" typeId=\"system.mute\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone1\">\n+\t\t<label>Zone 1</label>\n+\t\t<description>The Controls for Zone 1</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone2\">\n+\t\t<label>Zone 2</label>\n+\t\t<description>The Controls for Zone 2</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone3\">\n+\t\t<label>Zone 3</label>\n+\t\t<description>The Controls for Zone 3</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone4\">\n+\t\t<label>Zone 4</label>\n+\t\t<description>The Controls for Zone 4</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone5\">\n+\t\t<label>Zone 5</label>\n+\t\t<description>The Controls for Zone 5</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone6\">\n+\t\t<label>Zone 6</label>\n+\t\t<description>The Controls for Zone 6</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone7\">\n+\t\t<label>Zone 7</label>\n+\t\t<description>The Controls for Zone 7</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone8\">\n+\t\t<label>Zone 8</label>\n+\t\t<description>The Controls for Zone 8</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone9\">\n+\t\t<label>Zone 9</label>\n+\t\t<description>The Controls for Zone 9</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone10\">\n+\t\t<label>Zone 10</label>\n+\t\t<description>The Controls for Zone 10</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone11\">\n+\t\t<label>Zone 11</label>\n+\t\t<description>The Controls for Zone 11</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone12\">\n+\t\t<label>Zone 12</label>\n+\t\t<description>The Controls for Zone 12</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone13\">\n+\t\t<label>Zone 13</label>\n+\t\t<description>The Controls for Zone 13</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone14\">\n+\t\t<label>Zone 14</label>\n+\t\t<description>The Controls for Zone 14</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone15\">\n+\t\t<label>Zone 15</label>\n+\t\t<description>The Controls for Zone 15</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone16\">\n+\t\t<label>Zone 16</label>\n+\t\t<description>The Controls for Zone 16</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone17\">\n+\t\t<label>Zone 17</label>\n+\t\t<description>The Controls for Zone 17</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone18\">\n+\t\t<label>Zone 18</label>\n+\t\t<description>The Controls for Zone 18</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"allon\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>All On</label>\n+\t\t<description>Turn All Zones On</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alloff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>All Off</label>\n+\t\t<description>Turn All Zones Off</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"source\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515"}, "originalPosition": 494}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f59993883de521456437c5b3471a0bb4844169e", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2f59993883de521456437c5b3471a0bb4844169e", "committedDate": "2020-06-01T04:31:32Z", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "646c6f39247be8ce22cf96ae97b863f3a1f72bc8", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/646c6f39247be8ce22cf96ae97b863f3a1f72bc8", "committedDate": "2020-06-01T05:20:31Z", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9d29a8ea5ab145757680c602e69f784d66e52e3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a9d29a8ea5ab145757680c602e69f784d66e52e3", "committedDate": "2020-06-01T05:28:52Z", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16a523a0de2ce99db1a460a000bfdb0b1af2259c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/16a523a0de2ce99db1a460a000bfdb0b1af2259c", "committedDate": "2020-06-01T18:05:10Z", "message": "implement code review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7c5ee5eb1e4a3bf8f23533fc5b372268697b8bf", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d7c5ee5eb1e4a3bf8f23533fc5b372268697b8bf", "committedDate": "2020-06-01T20:00:47Z", "message": "Removed InterruptedIOException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db01c93a26ef33d48f2827a7f313f87c35d55017", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/db01c93a26ef33d48f2827a7f313f87c35d55017", "committedDate": "2020-06-01T21:31:09Z", "message": "Use Contact instead of Number\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "committedDate": "2020-06-04T21:19:29Z", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c677c0596be4b15330ed2f20c98e1a98a90a906a", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c677c0596be4b15330ed2f20c98e1a98a90a906a", "committedDate": "2020-06-04T21:20:39Z", "message": "changes to fix null pointer warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "committedDate": "2020-06-04T21:23:28Z", "message": "fix CODEOWNERS conflicts\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NDA0NjA1", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-425404605", "createdAt": "2020-06-05T15:31:09Z", "commit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTozMTowOVrOGfzQVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjoyMDoyNlrOGf0_Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5ODgwNQ==", "bodyText": "Use named threads.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435998805", "createdAt": "2020-06-05T15:31:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMzIyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final ArrayList<String> VALID_ZONES = new ArrayList<String>(\n          \n          \n            \n                        Arrays.asList(ZONE1.getZoneId(), ZONE2.getZoneId(), ZONE3.getZoneId(), ZONE4.getZoneId(), ZONE5.getZoneId(),\n          \n          \n            \n                                ZONE6.getZoneId(), ZONE7.getZoneId(), ZONE8.getZoneId(), ZONE9.getZoneId(), ZONE10.getZoneId(),\n          \n          \n            \n                                ZONE11.getZoneId(), ZONE12.getZoneId(), ZONE13.getZoneId(), ZONE14.getZoneId(), ZONE15.getZoneId(),\n          \n          \n            \n                                ZONE16.getZoneId(), ZONE17.getZoneId(), ZONE18.getZoneId()));\n          \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.getZoneId())\n          \n          \n            \n                        .collect(Collectors.toList());", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436003223", "createdAt": "2020-06-05T15:37:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone ids\n+    public static final ArrayList<String> VALID_ZONES = new ArrayList<String>(\n+            Arrays.asList(ZONE1.getZoneId(), ZONE2.getZoneId(), ZONE3.getZoneId(), ZONE4.getZoneId(), ZONE5.getZoneId(),\n+                    ZONE6.getZoneId(), ZONE7.getZoneId(), ZONE8.getZoneId(), ZONE9.getZoneId(), ZONE10.getZoneId(),\n+                    ZONE11.getZoneId(), ZONE12.getZoneId(), ZONE13.getZoneId(), ZONE14.getZoneId(), ZONE15.getZoneId(),\n+                    ZONE16.getZoneId(), ZONE17.getZoneId(), ZONE18.getZoneId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw==", "bodyText": "Why is the null annotation disabled?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436006183", "createdAt": "2020-06-05T15:42:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+    public Integer numZones = 1;\n+    public Integer pollingInterval = 15;\n+    public @NonNullByDefault({}) String serialPort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjU0Mw==", "bodyText": "Can be removed", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436006543", "createdAt": "2020-06-05T15:43:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.dto;\n+\n+/**\n+ * Represents the data elements of a single zone of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class MonopriceAudioZoneDTO {\n+\n+    private String zone;\n+    private String page;\n+    private String power;\n+    private String mute;\n+    private String dnd;\n+    private String volume;\n+    private String treble;\n+    private String bass;\n+    private String balance;\n+    private String source;\n+    private String keypad;\n+\n+    public MonopriceAudioZoneDTO() {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNzY4NA==", "bodyText": "You could replace this by a stream operation, too. See above.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436007684", "createdAt": "2020-06-05T15:45:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwODk1Mg==", "bodyText": "Since there shouldn't be any concurrency issues with the configuration, you could annotate this method with @SuppressWarnings(\"null\"), to prevent the compiler warnings.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436008952", "createdAt": "2020-06-05T15:47:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwOTUwMg==", "bodyText": "These comments have no benefit and can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436009502", "createdAt": "2020-06-05T15:48:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMTgzMA==", "bodyText": "You might want to log a warning or throw an exception if the zone is out of range.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436011830", "createdAt": "2020-06-05T15:52:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMzEwMQ==", "bodyText": "The method of the base class has no implementation, therefore this could be remoeved.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436013101", "createdAt": "2020-06-05T15:54:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk5MA==", "bodyText": "A timeout of 150ms seem a bit short. Are you sure is is enough under all circumstances?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436018990", "createdAt": "2020-06-05T16:05:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.valueOf(ZONE + zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 546}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDQyOQ==", "bodyText": "Are you sure this synchronization is sufficent? If I see correctly scheduleReconnectJob() can be called from different threads. openConnection() itself is synchronized but what if multiple threads call it one after another at this location? Should the sequenceLock monitor start at the beginning of this scheduler job? Same for the polling job.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436024429", "createdAt": "2020-06-05T16:15:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.valueOf(ZONE + zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNzE0Ng==", "bodyText": "You could specify min/max.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436027146", "createdAt": "2020-06-05T16:20:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,552 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"monopriceaudio\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Monoprice Whole House Amplifier Thing -->\n+\t<thing-type id=\"amplifier\">\n+\t\t<label>Whole House Amplifier</label>\n+\t\t<description>\n+\t\t\tA Multi-zone Whole House Amplifier System\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"all\" typeId=\"all\">\n+\t\t\t\t<label>All Zones</label>\n+\t\t\t\t<description>Control All Zones Simultaneously</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone1\" typeId=\"zone1\">\n+\t\t\t\t<label>Zone 1</label>\n+\t\t\t\t<description>The Controls for Zone 1</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone2\" typeId=\"zone2\">\n+\t\t\t\t<label>Zone 2</label>\n+\t\t\t\t<description>The Controls for Zone 2</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone3\" typeId=\"zone3\">\n+\t\t\t\t<label>Zone 3</label>\n+\t\t\t\t<description>The Controls for Zone 3</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone4\" typeId=\"zone4\">\n+\t\t\t\t<label>Zone 4</label>\n+\t\t\t\t<description>The Controls for Zone 4</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone5\" typeId=\"zone5\">\n+\t\t\t\t<label>Zone 5</label>\n+\t\t\t\t<description>The Controls for Zone 5</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone6\" typeId=\"zone6\">\n+\t\t\t\t<label>Zone 6</label>\n+\t\t\t\t<description>The Controls for Zone 6</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone7\" typeId=\"zone7\">\n+\t\t\t\t<label>Zone 7</label>\n+\t\t\t\t<description>The Controls for Zone 7</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone8\" typeId=\"zone8\">\n+\t\t\t\t<label>Zone 8</label>\n+\t\t\t\t<description>The Controls for Zone 8</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone9\" typeId=\"zone9\">\n+\t\t\t\t<label>Zone 9</label>\n+\t\t\t\t<description>The Controls for Zone 9</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone10\" typeId=\"zone10\">\n+\t\t\t\t<label>Zone 10</label>\n+\t\t\t\t<description>The Controls for Zone 10</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone11\" typeId=\"zone11\">\n+\t\t\t\t<label>Zone 11</label>\n+\t\t\t\t<description>The Controls for Zone 11</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone12\" typeId=\"zone12\">\n+\t\t\t\t<label>Zone 12</label>\n+\t\t\t\t<description>The Controls for Zone 12</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone13\" typeId=\"zone13\">\n+\t\t\t\t<label>Zone 13</label>\n+\t\t\t\t<description>The Controls for Zone 13</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone14\" typeId=\"zone14\">\n+\t\t\t\t<label>Zone 14</label>\n+\t\t\t\t<description>The Controls for Zone 14</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone15\" typeId=\"zone15\">\n+\t\t\t\t<label>Zone 15</label>\n+\t\t\t\t<description>The Controls for Zone 15</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone16\" typeId=\"zone16\">\n+\t\t\t\t<label>Zone 16</label>\n+\t\t\t\t<description>The Controls for Zone 16</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone17\" typeId=\"zone17\">\n+\t\t\t\t<label>Zone 17</label>\n+\t\t\t\t<description>The Controls for Zone 17</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone18\" typeId=\"zone18\">\n+\t\t\t\t<label>Zone 18</label>\n+\t\t\t\t<description>The Controls for Zone 18</description>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>Serial Port to Use for Connecting to the Monoprice Amplifier</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Machine Connected to the Monoprice Amplifier (Serial over IP)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "committedDate": "2020-06-05T21:38:28Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzI3MjE4", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-425727218", "createdAt": "2020-06-06T09:23:44Z", "commit": {"oid": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwOToyMzo0NFrOGgC0Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwOToyMzo0NFrOGgC0Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MzczNQ==", "bodyText": "One compiler warning left.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436253735", "createdAt": "2020-06-06T09:23:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private @Nullable String address;\n+    private @Nullable Integer port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(@Nullable String address, @Nullable Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62e417b47937cdba6807f3e58194132edc4b3a92", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/62e417b47937cdba6807f3e58194132edc4b3a92", "committedDate": "2020-06-09T02:50:52Z", "message": "fix compilier warning\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f763e8586c14bb653986e8468b816a61a3f3a1a6", "committedDate": "2020-06-10T20:46:46Z", "message": "fix sychronized placement around openConnection()\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjQxMTY0", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-430241164", "createdAt": "2020-06-14T18:28:09Z", "commit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyODoxMFrOGjeq5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxOToxMDowNlrOGje3Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTg0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));\n          \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439855846", "createdAt": "2020-06-14T18:28:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NjA5NQ==", "bodyText": "You could put the SerialPortManager as an argument here, too. Then, you can remove the @NonNullByDefault({}) from both fields.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439856095", "createdAt": "2020-06-14T18:31:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    @Activate\n+    public MonopriceAudioHandlerFactory(final @Reference MonopriceAudioStateDescriptionOptionProvider provider) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NjQ1MA==", "bodyText": "Isn't 00 appended if valueis 0?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439856450", "createdAt": "2020-06-14T18:35:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message;\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzMwMQ==", "bodyText": "You already do all null checks to be able to make this Nullable. Why not go for it?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857301", "createdAt": "2020-06-14T18:46:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+    public Integer numZones = 1;\n+    public Integer pollingInterval = 15;\n+    public @NonNullByDefault({}) String serialPort;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw=="}, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzYyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n          \n          \n            \n                            ignore.forEach(zone -> {\n          \n          \n            \n                            Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857627", "createdAt": "2020-06-14T18:51:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzg5MA==", "bodyText": "When I read this again, I think other reviewers won't be happy about this. You could initialize the config parameters with default values in your configuration class, to be able to remove the Nullables from the fields. Then, this suppression isn't necessary at all.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857890", "createdAt": "2020-06-14T18:55:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwODk1Mg=="}, "originalCommit": {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzk0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n          \n          \n            \n                        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857940", "createdAt": "2020-06-14T18:55:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ==", "bodyText": "Are you aware that multiple handleCommand()s can be invoked at the same time from different threads? This rate limit might not work, then.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439858565", "createdAt": "2020-06-14T19:03:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1OTAxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>A Switch That Controls if the Zone Should Ignore an Incoming Audio Page</description>\n          \n          \n            \n            \t\t<description>Controls if the Zone Should Ignore an Incoming Audio Page</description>", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439859015", "createdAt": "2020-06-14T19:10:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,552 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"monopriceaudio\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Monoprice Whole House Amplifier Thing -->\n+\t<thing-type id=\"amplifier\">\n+\t\t<label>Whole House Amplifier</label>\n+\t\t<description>\n+\t\t\tA Multi-zone Whole House Amplifier System\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"all\" typeId=\"all\">\n+\t\t\t\t<label>All Zones</label>\n+\t\t\t\t<description>Control All Zones Simultaneously</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone1\" typeId=\"zone1\">\n+\t\t\t\t<label>Zone 1</label>\n+\t\t\t\t<description>The Controls for Zone 1</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone2\" typeId=\"zone2\">\n+\t\t\t\t<label>Zone 2</label>\n+\t\t\t\t<description>The Controls for Zone 2</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone3\" typeId=\"zone3\">\n+\t\t\t\t<label>Zone 3</label>\n+\t\t\t\t<description>The Controls for Zone 3</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone4\" typeId=\"zone4\">\n+\t\t\t\t<label>Zone 4</label>\n+\t\t\t\t<description>The Controls for Zone 4</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone5\" typeId=\"zone5\">\n+\t\t\t\t<label>Zone 5</label>\n+\t\t\t\t<description>The Controls for Zone 5</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone6\" typeId=\"zone6\">\n+\t\t\t\t<label>Zone 6</label>\n+\t\t\t\t<description>The Controls for Zone 6</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone7\" typeId=\"zone7\">\n+\t\t\t\t<label>Zone 7</label>\n+\t\t\t\t<description>The Controls for Zone 7</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone8\" typeId=\"zone8\">\n+\t\t\t\t<label>Zone 8</label>\n+\t\t\t\t<description>The Controls for Zone 8</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone9\" typeId=\"zone9\">\n+\t\t\t\t<label>Zone 9</label>\n+\t\t\t\t<description>The Controls for Zone 9</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone10\" typeId=\"zone10\">\n+\t\t\t\t<label>Zone 10</label>\n+\t\t\t\t<description>The Controls for Zone 10</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone11\" typeId=\"zone11\">\n+\t\t\t\t<label>Zone 11</label>\n+\t\t\t\t<description>The Controls for Zone 11</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone12\" typeId=\"zone12\">\n+\t\t\t\t<label>Zone 12</label>\n+\t\t\t\t<description>The Controls for Zone 12</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone13\" typeId=\"zone13\">\n+\t\t\t\t<label>Zone 13</label>\n+\t\t\t\t<description>The Controls for Zone 13</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone14\" typeId=\"zone14\">\n+\t\t\t\t<label>Zone 14</label>\n+\t\t\t\t<description>The Controls for Zone 14</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone15\" typeId=\"zone15\">\n+\t\t\t\t<label>Zone 15</label>\n+\t\t\t\t<description>The Controls for Zone 15</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone16\" typeId=\"zone16\">\n+\t\t\t\t<label>Zone 16</label>\n+\t\t\t\t<description>The Controls for Zone 16</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone17\" typeId=\"zone17\">\n+\t\t\t\t<label>Zone 17</label>\n+\t\t\t\t<description>The Controls for Zone 17</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone18\" typeId=\"zone18\">\n+\t\t\t\t<label>Zone 18</label>\n+\t\t\t\t<description>The Controls for Zone 18</description>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>Serial Port to Use for Connecting to the Monoprice Amplifier</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Machine Connected to the Monoprice Amplifier (Serial over IP)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"false\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Communication Port (IP or Serial over IP). For IP connection to the Monoprice Amplifier</description>\n+\t\t\t\t<default>4444</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"numZones\" type=\"integer\" min=\"1\" max=\"18\" required=\"true\">\n+\t\t\t\t<label>Number of Zones</label>\n+\t\t\t\t<description>Number of Zones on the Amplifier to Utilize in the Binding (Up to 18 Zones With 3 Amplifiers Connected\n+\t\t\t\t\tTogether)</description>\n+\t\t\t\t<default>6</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"5\" max=\"60\" unit=\"s\" required=\"false\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Configures How Often to Poll the Controller to Check for Zone Updates (5-60; Default 15)</description>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ignoreZones\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Ignore Zones</label>\n+\t\t\t\t<description>(Optional) A Comma Seperated List of Zone Numbers That Will Ignore the 'All Zone' (Except All Off)\n+\t\t\t\t\tCommands (ie: 1,6,10)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"initialAllVolume\" type=\"integer\" min=\"1\" max=\"30\" required=\"false\">\n+\t\t\t\t<label>Initial All Volume</label>\n+\t\t\t\t<description>When 'All' Zones Are Activated, the Volume Will Reset to This Value (1-30; default 10) to Prevent\n+\t\t\t\t\tExcessive Blaring of Sound ;)</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel1\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 1 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 1</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel2\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 2 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel3\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 3 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 3</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel4\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 4 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 4</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel5\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 5 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 5</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel6\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Source 6 Input Label</label>\n+\t\t\t\t<description>Friendly Name for the Input Source to Be Displayed in the UI (ie: Chromecast, Radio, CD, etc.)</description>\n+\t\t\t\t<default>Source 6</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-group-type id=\"all\">\n+\t\t<label>All Zones</label>\n+\t\t<description>Control All Zones Simultaneously</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"allon\" typeId=\"allon\"/>\n+\t\t\t<channel id=\"alloff\" typeId=\"alloff\"/>\n+\t\t\t<channel id=\"allsource\" typeId=\"source\"/>\n+\t\t\t<channel id=\"allvolume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"allmute\" typeId=\"system.mute\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone1\">\n+\t\t<label>Zone 1</label>\n+\t\t<description>The Controls for Zone 1</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone2\">\n+\t\t<label>Zone 2</label>\n+\t\t<description>The Controls for Zone 2</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone3\">\n+\t\t<label>Zone 3</label>\n+\t\t<description>The Controls for Zone 3</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone4\">\n+\t\t<label>Zone 4</label>\n+\t\t<description>The Controls for Zone 4</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone5\">\n+\t\t<label>Zone 5</label>\n+\t\t<description>The Controls for Zone 5</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone6\">\n+\t\t<label>Zone 6</label>\n+\t\t<description>The Controls for Zone 6</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone7\">\n+\t\t<label>Zone 7</label>\n+\t\t<description>The Controls for Zone 7</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone8\">\n+\t\t<label>Zone 8</label>\n+\t\t<description>The Controls for Zone 8</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone9\">\n+\t\t<label>Zone 9</label>\n+\t\t<description>The Controls for Zone 9</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone10\">\n+\t\t<label>Zone 10</label>\n+\t\t<description>The Controls for Zone 10</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone11\">\n+\t\t<label>Zone 11</label>\n+\t\t<description>The Controls for Zone 11</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone12\">\n+\t\t<label>Zone 12</label>\n+\t\t<description>The Controls for Zone 12</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone13\">\n+\t\t<label>Zone 13</label>\n+\t\t<description>The Controls for Zone 13</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone14\">\n+\t\t<label>Zone 14</label>\n+\t\t<description>The Controls for Zone 14</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone15\">\n+\t\t<label>Zone 15</label>\n+\t\t<description>The Controls for Zone 15</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone16\">\n+\t\t<label>Zone 16</label>\n+\t\t<description>The Controls for Zone 16</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone17\">\n+\t\t<label>Zone 17</label>\n+\t\t<description>The Controls for Zone 17</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"zone18\">\n+\t\t<label>Zone 18</label>\n+\t\t<description>The Controls for Zone 18</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\"/>\n+\t\t\t<channel id=\"source\" typeId=\"source\"/>\n+\t\t\t<channel id=\"volume\" typeId=\"system.volume\"/>\n+\t\t\t<channel id=\"mute\" typeId=\"system.mute\"/>\n+\t\t\t<channel id=\"treble\" typeId=\"treble\"/>\n+\t\t\t<channel id=\"bass\" typeId=\"bass\"/>\n+\t\t\t<channel id=\"balance\" typeId=\"balance\"/>\n+\t\t\t<channel id=\"dnd\" typeId=\"dnd\"/>\n+\t\t\t<channel id=\"page\" typeId=\"page\"/>\n+\t\t\t<channel id=\"keypad\" typeId=\"keypad\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"allon\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>All On</label>\n+\t\t<description>Turn All Zones On</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alloff\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>All Off</label>\n+\t\t<description>Turn All Zones Off</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"source\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Source Input</label>\n+\t\t<description>Select the Source Input</description>\n+\t\t<state min=\"1\" max=\"6\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"treble\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Treble Adjustment</label>\n+\t\t<description>Adjust the Treble</description>\n+\t\t<state min=\"-7\" max=\"7\" step=\"1\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"bass\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Bass Adjustment</label>\n+\t\t<description>Adjust the Bass</description>\n+\t\t<state min=\"-7\" max=\"7\" step=\"1\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"balance\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Balance Adjustment</label>\n+\t\t<description>Adjust the Balance</description>\n+\t\t<state min=\"-10\" max=\"10\" step=\"1\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"dnd\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Do Not Disturb</label>\n+\t\t<description>A Switch That Controls if the Zone Should Ignore an Incoming Audio Page</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6"}, "originalPosition": 525}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e09ceb96d7b73cffdaf3a77707711cd741719f88", "committedDate": "2020-06-15T05:40:02Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "committedDate": "2020-06-16T23:44:48Z", "message": "remove sleep and fix a few bugs\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTgwNTQ4", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-432580548", "createdAt": "2020-06-17T16:39:25Z", "commit": {"oid": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozOToyNVrOGlOA9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjo0MDozMVrOGlOD5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDExNg==", "bodyText": "The code begs for streams :) If you like, try findAny().orElseThrow(...", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441680116", "createdAt": "2020-06-17T16:39:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -48,10 +49,23 @@\n \n     private String zoneId;\n \n-    // make a list of all valid zone ids\n-    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.getZoneId())\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n             .collect(Collectors.toList());\n \n+    // make a list of all valid zone ids\n+    public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(z -> z.getZoneId()).collect(Collectors.toList());\n+\n+    public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n+        for (MonopriceAudioZone z : MonopriceAudioZone.values()) {\n+            if (z.zoneId.equalsIgnoreCase(zoneId)) {\n+                return z;\n+            }\n+        }\n+        throw new MonopriceAudioException(\"Invalid zoneId specified: \" + zoneId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDg3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        ignoreZones.add(ZONE + String.valueOf(zoneInt));\n          \n          \n            \n                                        ignoreZones.add(ZONE + zoneInt);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441680870", "createdAt": "2020-06-17T16:40:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -164,7 +163,7 @@ public void initialize() {\n                     try {\n                         int zoneInt = Integer.parseInt(zone);\n                         if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n-                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                            ignoreZones.add(ZONE + String.valueOf(zoneInt));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e0e166958454b6492345b317ee9ec96ef70a7a40", "committedDate": "2020-06-17T19:51:22Z", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzQyMjUy", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-432742252", "createdAt": "2020-06-17T20:17:36Z", "commit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODIxNjU1", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-432821655", "createdAt": "2020-06-17T22:31:33Z", "commit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjozMTozM1rOGlZk_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMzo1NDo1NFrOGlbH8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2OTU2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n            \n          \n          \n            \n                private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n          \n          \n            \n                private final SerialPortManager serialPortManager;\n          \n          \n            \n            \n          \n          \n            \n                private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441869565", "createdAt": "2020-06-17T22:31:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MTMxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Opening serial connection on port {}\", serialPortName);\n          \n          \n            \n                    logger.debug(\"Opening serial connection on port {}\", serialPortName);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441871310", "createdAt": "2020-06-17T22:36:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw==", "bodyText": "What if the user has multiple amplifiers?\nThis map shouldn't be static. Please make the name lowercase accordingly as well.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441874713", "createdAt": "2020-06-17T22:47:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTc5NQ==", "bodyText": "Just return early here so you can get rid of the \"else\" statement and indentations.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441875795", "createdAt": "2020-06-17T22:51:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NjAyNg==", "bodyText": "Please remove this.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441876026", "createdAt": "2020-06-17T22:51:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3ODQzOA==", "bodyText": "The main benefit of streams and lambdas is how concise they can make code. But sometimes they aren't as concise as a regular loop...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n          \n          \n            \n                            for (String zone : config.ignoreZones.split(\",\")) {", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441878438", "createdAt": "2020-06-17T22:59:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4MDc3MA==", "bodyText": "Might as well save later code from having to call it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n          \n          \n            \n                        Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441880770", "createdAt": "2020-06-17T23:07:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NDU5Ng==", "bodyText": "I feel like all these on/off command handlers could be simplified to a single function.\nprivate void handleOnOff(Command command, MonopriceAudioZone zone, MonopriceAudioCommand onCommand, MonopriceAudioCommand offCommand, BiConsumer<MonopriceAudioZoneDTO, String> adjuster){\n    if( command == OnOffType.ON){\n        connector.sendCommand(zone, onCommand);\n        adjuster.accept(ZONE_DATA_MAP.get(zone.getZoneId()), ON);\n    } else if (command == OnOffType.OFF){\n        connector.sendCommand(zone, offCommand);\n        adjuster.accept(ZONE_DATA_MAP.get(zone.getZoneId()), OFF);\n    }\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (command instanceof OnOffType && command == OnOffType.ON) {\n          \n          \n            \n                                        connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n          \n          \n            \n                                        ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n          \n          \n            \n                                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n          \n          \n            \n                                        connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n          \n          \n            \n                                        ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    handleOnOff(command, zone, MonopriceAudioCommand.MUTE_ON, MonopriceAudioCommand.MUTE_OFF, MonopriceAudioZone::setMute);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441884596", "createdAt": "2020-06-17T23:19:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzQ5Ng==", "bodyText": "might as well break early instead of having to perform another null check.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cmd = null;\n          \n          \n            \n                                    }\n          \n          \n            \n            \n          \n          \n            \n                                    if (cmd != null) {\n          \n          \n            \n                                        break;\n          \n          \n            \n                                    }", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441887496", "createdAt": "2020-06-17T23:29:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzU3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (command instanceof OnOffType && command == OnOffType.ON) {\n          \n          \n            \n                                        cmd = MonopriceAudioCommand.MUTE_ON;\n          \n          \n            \n                                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n          \n          \n            \n                                    if (command == OnOffType.ON) {\n          \n          \n            \n                                        cmd = MonopriceAudioCommand.MUTE_ON;\n          \n          \n            \n                                    } else if (command == OnOffType.OFF) {", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441887574", "createdAt": "2020-06-17T23:29:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MDAxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event);\n          \n          \n            \n                public void onNewMessageEvent(MonopriceAudioMessageEvent event);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441890013", "createdAt": "2020-06-17T23:37:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * MonopriceAudio Event Listener interface. Handles incoming MonopriceAudio message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface MonopriceAudioMessageEventListener extends EventListener {\n+\n+    /**\n+     * Event handler method for incoming MonopriceAudio message events\n+     *\n+     * @param event the event object\n+     */\n+    public void onNewMessageEvent(EventObject event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MTExMg==", "bodyText": "This is more of an external issue rather than one that a user can address, so just make this log debug instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Invalid zone update message: {}\", newZoneData);\n          \n          \n            \n                            logger.debug(\"Invalid zone update message: {}\", newZoneData);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441891112", "createdAt": "2020-06-17T23:41:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n+                        } catch (MonopriceAudioException e) {\n+                            logger.warn(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = zoneData.isPageActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = zoneData.isKeypadActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneDTO zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601, matcher pattern from above:\n+            // \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\"\n+            Matcher matcher = PATTERN.matcher(newZoneData);\n+            if (matcher.find()) {\n+                zoneData.setZone(matcher.group(1));\n+\n+                if (!matcher.group(2).equals(zoneData.getPage())) {\n+                    zoneData.setPage(matcher.group(2));\n+                    updateChannelState(zone, CHANNEL_TYPE_PAGE, zoneData);\n+                }\n+\n+                if (!matcher.group(3).equals(zoneData.getPower())) {\n+                    zoneData.setPower(matcher.group(3));\n+                    updateChannelState(zone, CHANNEL_TYPE_POWER, zoneData);\n+                }\n+\n+                if (!matcher.group(4).equals(zoneData.getMute())) {\n+                    zoneData.setMute(matcher.group(4));\n+                    updateChannelState(zone, CHANNEL_TYPE_MUTE, zoneData);\n+                }\n+\n+                if (!matcher.group(5).equals(zoneData.getDnd())) {\n+                    zoneData.setDnd(matcher.group(5));\n+                    updateChannelState(zone, CHANNEL_TYPE_DND, zoneData);\n+                }\n+\n+                if (!matcher.group(6).equals(zoneData.getVolume())) {\n+                    zoneData.setVolume(matcher.group(6));\n+                    updateChannelState(zone, CHANNEL_TYPE_VOLUME, zoneData);\n+                }\n+\n+                if (!matcher.group(7).equals(zoneData.getTreble())) {\n+                    zoneData.setTreble(matcher.group(7));\n+                    updateChannelState(zone, CHANNEL_TYPE_TREBLE, zoneData);\n+                }\n+\n+                if (!matcher.group(8).equals(zoneData.getBass())) {\n+                    zoneData.setBass(matcher.group(8));\n+                    updateChannelState(zone, CHANNEL_TYPE_BASS, zoneData);\n+                }\n+\n+                if (!matcher.group(9).equals(zoneData.getBalance())) {\n+                    zoneData.setBalance(matcher.group(9));\n+                    updateChannelState(zone, CHANNEL_TYPE_BALANCE, zoneData);\n+                }\n+\n+                if (!matcher.group(10).equals(zoneData.getSource())) {\n+                    zoneData.setSource(matcher.group(10));\n+                    updateChannelState(zone, CHANNEL_TYPE_SOURCE, zoneData);\n+                }\n+\n+                if (!matcher.group(11).equals(zoneData.getKeypad())) {\n+                    zoneData.setKeypad(matcher.group(11));\n+                    updateChannelState(zone, CHANNEL_TYPE_KEYPAD, zoneData);\n+                }\n+            } else {\n+                logger.warn(\"Invalid zone update message: {}\", newZoneData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 717}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MTk2Nw==", "bodyText": "The TimeUnit.SECONDS.toSeconds doesn't do anything here so you can omit it. If you are trying to make your assignment more declarative then I suggest you add a _SEC suffix to your constant name instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n          \n          \n            \n                private static final long RECON_POLLING_INTERVAL_SEC = 60;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441891967", "createdAt": "2020-06-17T23:44:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjAwMA==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892000", "createdAt": "2020-06-17T23:44:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjIwMQ==", "bodyText": "Since order doesn't matter and you are only performing lookups on it, use a Set instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<>();\n          \n          \n            \n                private final Set<String> ignoreZones = new HasSet<>();", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892201", "createdAt": "2020-06-17T23:45:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjI0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892245", "createdAt": "2020-06-17T23:45:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5Mjk1Nw==", "bodyText": "You should also clear your ignoreZones here.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892957", "createdAt": "2020-06-17T23:47:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MzA0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n          \n          \n            \n                        pollingInterval = config.pollingInterval;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441893040", "createdAt": "2020-06-17T23:48:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5Mzc3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n          \n          \n            \n            \n          \n          \n            \n                                // poll each zone up to the number of zones specified in the configuration\n          \n          \n            \n                                zoneStream.limit(numZones).forEach((zoneName) -> {\n          \n          \n            \n                                // poll each zone up to the number of zones specified in the configuration\n          \n          \n            \n                                MonopriceAudioZone.VALID_ZONES.stream().limit(numZones).forEach((zoneName) -> {", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441893773", "createdAt": "2020-06-17T23:50:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 573}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng==", "bodyText": "Is there any change that zoneData.getTreble() wouldn't return a parsable number? If so then you should catch the exception, if not then I suggest changing the datatype from a String to an int.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n          \n          \n            \n                            state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441894896", "createdAt": "2020-06-17T23:54:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n+                        } catch (MonopriceAudioException e) {\n+                            logger.warn(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40"}, "originalPosition": 635}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "committedDate": "2020-06-18T04:12:41Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0d3e3569c0dd490c3db64e018e702235b09969c7", "committedDate": "2020-06-19T02:59:55Z", "message": "make ZONE_DATA_MAP not static\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MjYyOTkx", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-434262991", "createdAt": "2020-06-19T18:14:04Z", "commit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODoxNDowNFrOGmdfug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODozMzoyN1rOGmd-HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MjMzMA==", "bodyText": "Why are BEGIN_CMD AND END_CMD in this list of enums? They are never used as discrete commands and are just used as part of command construction. I don't think they belong here.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442982330", "createdAt": "2020-06-19T18:14:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+    QUERY(\"?\"),\n+    BEGIN_CMD(\"<\"),\n+    END_CMD(\"\\r\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzEyNg==", "bodyText": "Make sure that any created threads are daemon.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                }\n          \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                    setDaemon(true);\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442983126", "createdAt": "2020-06-19T18:15:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID);\n+        this.connector = connector;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NDY5Mw==", "bodyText": "Since more than one of these threads can exist, you want to make sure they don't have the same name. Add additional information to the name such as either the thingUID or the address this thread is reading from.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442984693", "createdAt": "2020-06-19T18:19:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjE3NQ==", "bodyText": "If the thread is in the middle of blocking for IO it may not respond to interrupt requests. To make sure that it is kicked awake you should make sure to close the input and output streams before you try joining the thread.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442986175", "createdAt": "2020-06-19T18:23:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzA4Ng==", "bodyText": "you should still log this exception", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987086", "createdAt": "2020-06-19T18:25:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzE0NQ==", "bodyText": "this one too", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987145", "createdAt": "2020-06-19T18:25:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzQ5Ng==", "bodyText": "It is dangerous to wait indefinitely for the join, so add a reasonable timeout and log a warning if that timeout is exceeded.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987496", "createdAt": "2020-06-19T18:26:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODY3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n          \n          \n            \n                private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n          \n      \n    \n    \n  \n\nAlso move this field above the non-final fields.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442988678", "createdAt": "2020-06-19T18:29:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODkyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashSet<String> ignoreZones = new HashSet<>();\n          \n          \n            \n                private Set<String> ignoreZones = new HashSet<>();", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442988921", "createdAt": "2020-06-19T18:30:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ==", "bodyText": "You should try to handle the RefreshType command for all of these channels.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442989671", "createdAt": "2020-06-19T18:32:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new MonopriceAudioIpConnector(config.host, config.port);\n+        }\n+\n+        pollingInterval = config.pollingInterval;\n+        numZones = config.numZones;\n+        initialAllVolume = config.initialAllVolume;\n+\n+        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+        // zone ids to get the controller's internal zone ids and save those to a list\n+        if (config.ignoreZones != null) {\n+            for (String zone : config.ignoreZones.split(\",\")) {\n+                try {\n+                    int zoneInt = Integer.parseInt(zone);\n+                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                        ignoreZones.add(ZONE + zoneInt);\n+                    } else {\n+                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                MAX_ZONES);\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                }\n+            }\n+        }\n+\n+        // Build a state option list for the source labels\n+        List<StateOption> sourcesLabels = new ArrayList<>();\n+        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+        // Put the source labels on all active zones\n+        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+        stateDescriptionProvider.setStateOptions(\n+                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+        activeZones.forEach(zoneNum -> {\n+            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+        });\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        // initialize the all volume state\n+        allVolume = initialAllVolume;\n+        long allVolumePct = Math\n+                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        ignoreZones.clear();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MDEwOQ==", "bodyText": "Success is expected, so I think you can change the logging level to trace.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n          \n          \n            \n                                logger.trace(\"Command {} from channel {} succeeded\", command, channel);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442990109", "createdAt": "2020-06-19T18:33:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new MonopriceAudioIpConnector(config.host, config.port);\n+        }\n+\n+        pollingInterval = config.pollingInterval;\n+        numZones = config.numZones;\n+        initialAllVolume = config.initialAllVolume;\n+\n+        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+        // zone ids to get the controller's internal zone ids and save those to a list\n+        if (config.ignoreZones != null) {\n+            for (String zone : config.ignoreZones.split(\",\")) {\n+                try {\n+                    int zoneInt = Integer.parseInt(zone);\n+                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                        ignoreZones.add(ZONE + zoneInt);\n+                    } else {\n+                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                MAX_ZONES);\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                }\n+            }\n+        }\n+\n+        // Build a state option list for the source labels\n+        List<StateOption> sourcesLabels = new ArrayList<>();\n+        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+        // Put the source labels on all active zones\n+        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+        stateDescriptionProvider.setStateOptions(\n+                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+        activeZones.forEach(zoneNum -> {\n+            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+        });\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        // initialize the all volume state\n+        allVolume = initialAllVolume;\n+        long allVolumePct = Math\n+                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        ignoreZones.clear();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        if (command instanceof OnOffType) {\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.POWER, 1);\n+                                        // reset the volume of each zone to allVolume\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, allVolume);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                    }\n+                                }\n+\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        if (command instanceof OnOffType) {\n+                            // set allVolume back to initial volume\n+                            allVolume = initialAllVolume;\n+                            long allVolumePct = Math.round(\n+                                    (double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                            zoneStream.forEach((zoneName) -> {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER, 0);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                                }\n+\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        if (command instanceof OnOffType) {\n+                            int cmd = command == OnOffType.ON ? 1 : 0;\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.MUTE, cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7"}, "originalPosition": 416}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/592e16adf7d9cb184385738bae937c6ad6ecdaf0", "committedDate": "2020-06-20T02:36:29Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "committedDate": "2020-06-24T13:47:17Z", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aa4b61b3250c1c64d6f3eac110c3e1ccbe8fb2d", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3aa4b61b3250c1c64d6f3eac110c3e1ccbe8fb2d", "committedDate": "2020-06-24T14:12:08Z", "message": "Merge branch '2.5.x' into MonopriceAudio"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/fd64d16a198b55e5c4792b8c88394ded00eeb042", "committedDate": "2020-06-24T14:23:30Z", "message": "Update pom version and format README\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDIyMzMx", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-437022331", "createdAt": "2020-06-24T21:32:51Z", "commit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTozMjo1MVrOGoj4aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTo0MjozMVrOGokJVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NDEwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |\n          \n          \n            \n            | Number of Zones      | numZones         | (Optional) Number of amplifier zones to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445184105", "createdAt": "2020-06-24T21:32:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/README.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# MonopriceAudio Binding\n+\n+This binding can be used to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 whole house multi-zone amplifier.\n+All controller functions available through the serial port interface can be controlled by the binding.\n+Up to 18 zones can be controlled when 3 amplifiers are connected together (if not all zones on the amp are used they can be excluded via configuration).\n+Activating the 'Page All Zones' feature can only be done through the +12v trigger input on the back of the amplifier.\n+\n+The binding supports two different kinds of connections:\n+\n+* serial connection,\n+* serial over IP connection\n+\n+For users without serial connector on server side, you can add a serial to USB adapter.\n+\n+You don't need to have your Monoprice whole house amplifier device directly connected to your openHAB server.\n+You can connect it for example to a Raspberry Pi and use [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) to make the serial connection available on LAN (serial over IP).\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the amplifier controller.\n+It has the `amplifier` id.\n+\n+## Discovery\n+\n+Discovery is not supported.\n+You have to add all things manually.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label      | Parameter ID     | Description                                                                                                                    | Accepted values    |\n+|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------|--------------------|\n+| Serial Port          | serialPort       | Serial port to use for connecting to the Monoprice whole house amplifier device                                                | Serial port name | |\n+| Address              | host             | Host name or IP address of the machine connected to the Monoprice whole house amplifier device (serial over IP)                | Host name or IP  | |\n+| Port                 | port             | Communication port (serial over IP).                                                                                           | TCP port number  | |\n+| Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NDgwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | all:allsource                 | Number    | Select the source input for all zones simultaneously (1-6) (except ignoreZones)                               |\n          \n          \n            \n            | all:allsource                 | Number    | Select the input source for all zones simultaneously (1-6) (except ignoreZones)                               |", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445184804", "createdAt": "2020-06-24T21:34:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/README.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# MonopriceAudio Binding\n+\n+This binding can be used to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 whole house multi-zone amplifier.\n+All controller functions available through the serial port interface can be controlled by the binding.\n+Up to 18 zones can be controlled when 3 amplifiers are connected together (if not all zones on the amp are used they can be excluded via configuration).\n+Activating the 'Page All Zones' feature can only be done through the +12v trigger input on the back of the amplifier.\n+\n+The binding supports two different kinds of connections:\n+\n+* serial connection,\n+* serial over IP connection\n+\n+For users without serial connector on server side, you can add a serial to USB adapter.\n+\n+You don't need to have your Monoprice whole house amplifier device directly connected to your openHAB server.\n+You can connect it for example to a Raspberry Pi and use [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) to make the serial connection available on LAN (serial over IP).\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the amplifier controller.\n+It has the `amplifier` id.\n+\n+## Discovery\n+\n+Discovery is not supported.\n+You have to add all things manually.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label      | Parameter ID     | Description                                                                                                                    | Accepted values    |\n+|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------|--------------------|\n+| Serial Port          | serialPort       | Serial port to use for connecting to the Monoprice whole house amplifier device                                                | Serial port name | |\n+| Address              | host             | Host name or IP address of the machine connected to the Monoprice whole house amplifier device (serial over IP)                | Host name or IP  | |\n+| Port                 | port             | Communication port (serial over IP).                                                                                           | TCP port number  | |\n+| Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |\n+| Polling Interval     | pollingInterval  | (Optional) Configures how often (in seconds) to poll the controller to check for zone updates                                  | 5-60; default 15 | |\n+| Ignore Zones         | ignoreZones      | (Optional) A comma seperated list of Zone numbers that will ignore the 'All Zone' (except All Off) commands                    | ie: \"1,6,10\"     | |\n+| Initial All Volume   | initialAllVolume | (Optional) When 'All' zones are activated, the volume will reset to this value to prevent excessive blaring of sound ;)        | 1-30; default 10 | |\n+| Source 1 Input Label | inputLabel1      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 1\") | A free text name | |\n+| Source 2 Input Label | inputLabel2      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 2\") | A free text name | |\n+| Source 3 Input Label | inputLabel3      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 3\") | A free text name | |\n+| Source 4 Input Label | inputLabel4      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 4\") | A free text name | |\n+| Source 5 Input Label | inputLabel5      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 5\") | A free text name | |\n+| Source 6 Input Label | inputLabel6      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 6\") | A free text name | |\n+\n+Some notes:\n+\n+* On Linux, you may get an error stating the serial port cannot be opened when the MonopriceAudio binding tries to load. \n+  You can get around this by adding the `openhab` user to the `dialout` group like this: `usermod -a -G dialout openhab`.\n+* Also on Linux you may have issues with the USB if using two serial USB devices e.g. MonopriceAudio and RFXcom.\n+  See the [general documentation about serial port configuration](/docs/administration/serial.html) for more on symlinking the USB ports.\n+* Here is an example of ser2net.conf you can use to share your serial port /dev/ttyUSB0 on IP port 4444 using [ser2net Linux tool](https://sourceforge.net/projects/ser2net/)\n+  (take care, the baud rate is specific to the Monoprice amplifier):\n+\n+```\n+4444:raw:0:/dev/ttyUSB0:9600 8DATABITS NONE 1STOPBIT LOCAL\n+```\n+\n+## Channels\n+\n+The following channels are available:\n+\n+| Channel ID                    | Item Type | Description                                                                                                   |\n+|-------------------------------|-----------|---------------------------------------------------------------------------------------------------------------|\n+| all:allon                     | Switch    | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |\n+| all:alloff                    | Switch    | Turn all zones off simultaneously (except those specified by the ignoreZones config option)                   |\n+| all:allsource                 | Number    | Select the source input for all zones simultaneously (1-6) (except ignoreZones)                               |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NTg1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | all:allon                     | Switch    | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |\n          \n          \n            \n            | all#allon                     | Switch    | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |\n          \n      \n    \n    \n  \n\nYou will need to apply the same fix to the other channels in this table as well.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445185855", "createdAt": "2020-06-24T21:36:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/README.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# MonopriceAudio Binding\n+\n+This binding can be used to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 whole house multi-zone amplifier.\n+All controller functions available through the serial port interface can be controlled by the binding.\n+Up to 18 zones can be controlled when 3 amplifiers are connected together (if not all zones on the amp are used they can be excluded via configuration).\n+Activating the 'Page All Zones' feature can only be done through the +12v trigger input on the back of the amplifier.\n+\n+The binding supports two different kinds of connections:\n+\n+* serial connection,\n+* serial over IP connection\n+\n+For users without serial connector on server side, you can add a serial to USB adapter.\n+\n+You don't need to have your Monoprice whole house amplifier device directly connected to your openHAB server.\n+You can connect it for example to a Raspberry Pi and use [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) to make the serial connection available on LAN (serial over IP).\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the amplifier controller.\n+It has the `amplifier` id.\n+\n+## Discovery\n+\n+Discovery is not supported.\n+You have to add all things manually.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label      | Parameter ID     | Description                                                                                                                    | Accepted values    |\n+|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------|--------------------|\n+| Serial Port          | serialPort       | Serial port to use for connecting to the Monoprice whole house amplifier device                                                | Serial port name | |\n+| Address              | host             | Host name or IP address of the machine connected to the Monoprice whole house amplifier device (serial over IP)                | Host name or IP  | |\n+| Port                 | port             | Communication port (serial over IP).                                                                                           | TCP port number  | |\n+| Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |\n+| Polling Interval     | pollingInterval  | (Optional) Configures how often (in seconds) to poll the controller to check for zone updates                                  | 5-60; default 15 | |\n+| Ignore Zones         | ignoreZones      | (Optional) A comma seperated list of Zone numbers that will ignore the 'All Zone' (except All Off) commands                    | ie: \"1,6,10\"     | |\n+| Initial All Volume   | initialAllVolume | (Optional) When 'All' zones are activated, the volume will reset to this value to prevent excessive blaring of sound ;)        | 1-30; default 10 | |\n+| Source 1 Input Label | inputLabel1      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 1\") | A free text name | |\n+| Source 2 Input Label | inputLabel2      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 2\") | A free text name | |\n+| Source 3 Input Label | inputLabel3      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 3\") | A free text name | |\n+| Source 4 Input Label | inputLabel4      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 4\") | A free text name | |\n+| Source 5 Input Label | inputLabel5      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 5\") | A free text name | |\n+| Source 6 Input Label | inputLabel6      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 6\") | A free text name | |\n+\n+Some notes:\n+\n+* On Linux, you may get an error stating the serial port cannot be opened when the MonopriceAudio binding tries to load. \n+  You can get around this by adding the `openhab` user to the `dialout` group like this: `usermod -a -G dialout openhab`.\n+* Also on Linux you may have issues with the USB if using two serial USB devices e.g. MonopriceAudio and RFXcom.\n+  See the [general documentation about serial port configuration](/docs/administration/serial.html) for more on symlinking the USB ports.\n+* Here is an example of ser2net.conf you can use to share your serial port /dev/ttyUSB0 on IP port 4444 using [ser2net Linux tool](https://sourceforge.net/projects/ser2net/)\n+  (take care, the baud rate is specific to the Monoprice amplifier):\n+\n+```\n+4444:raw:0:/dev/ttyUSB0:9600 8DATABITS NONE 1STOPBIT LOCAL\n+```\n+\n+## Channels\n+\n+The following channels are available:\n+\n+| Channel ID                    | Item Type | Description                                                                                                   |\n+|-------------------------------|-----------|---------------------------------------------------------------------------------------------------------------|\n+| all:allon                     | Switch    | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4Njk5MA==", "bodyText": "These should be combined into a single switch channel.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445186990", "createdAt": "2020-06-24T21:39:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/README.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# MonopriceAudio Binding\n+\n+This binding can be used to control the Monoprice MPR-SG6Z or Dayton Audio DAX66 whole house multi-zone amplifier.\n+All controller functions available through the serial port interface can be controlled by the binding.\n+Up to 18 zones can be controlled when 3 amplifiers are connected together (if not all zones on the amp are used they can be excluded via configuration).\n+Activating the 'Page All Zones' feature can only be done through the +12v trigger input on the back of the amplifier.\n+\n+The binding supports two different kinds of connections:\n+\n+* serial connection,\n+* serial over IP connection\n+\n+For users without serial connector on server side, you can add a serial to USB adapter.\n+\n+You don't need to have your Monoprice whole house amplifier device directly connected to your openHAB server.\n+You can connect it for example to a Raspberry Pi and use [ser2net Linux tool](https://sourceforge.net/projects/ser2net/) to make the serial connection available on LAN (serial over IP).\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the amplifier controller.\n+It has the `amplifier` id.\n+\n+## Discovery\n+\n+Discovery is not supported.\n+You have to add all things manually.\n+\n+## Binding Configuration\n+\n+There are no overall binding configuration settings that need to be set.\n+All settings are through thing configuration parameters.\n+\n+## Thing Configuration\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label      | Parameter ID     | Description                                                                                                                    | Accepted values    |\n+|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------|--------------------|\n+| Serial Port          | serialPort       | Serial port to use for connecting to the Monoprice whole house amplifier device                                                | Serial port name | |\n+| Address              | host             | Host name or IP address of the machine connected to the Monoprice whole house amplifier device (serial over IP)                | Host name or IP  | |\n+| Port                 | port             | Communication port (serial over IP).                                                                                           | TCP port number  | |\n+| Number of Zones      | numZones         | (Optional) Number of zones on the amplifier to utilize in the binding (up to 18 zones with 3 amplifiers connected together)    | 1-18; default 6  | |\n+| Polling Interval     | pollingInterval  | (Optional) Configures how often (in seconds) to poll the controller to check for zone updates                                  | 5-60; default 15 | |\n+| Ignore Zones         | ignoreZones      | (Optional) A comma seperated list of Zone numbers that will ignore the 'All Zone' (except All Off) commands                    | ie: \"1,6,10\"     | |\n+| Initial All Volume   | initialAllVolume | (Optional) When 'All' zones are activated, the volume will reset to this value to prevent excessive blaring of sound ;)        | 1-30; default 10 | |\n+| Source 1 Input Label | inputLabel1      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 1\") | A free text name | |\n+| Source 2 Input Label | inputLabel2      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 2\") | A free text name | |\n+| Source 3 Input Label | inputLabel3      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 3\") | A free text name | |\n+| Source 4 Input Label | inputLabel4      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 4\") | A free text name | |\n+| Source 5 Input Label | inputLabel5      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 5\") | A free text name | |\n+| Source 6 Input Label | inputLabel6      | (Optional) Friendly name for the input source to be displayed in the UI (ie: Chromecast, Radio, CD, etc.) (default \"Source 6\") | A free text name | |\n+\n+Some notes:\n+\n+* On Linux, you may get an error stating the serial port cannot be opened when the MonopriceAudio binding tries to load. \n+  You can get around this by adding the `openhab` user to the `dialout` group like this: `usermod -a -G dialout openhab`.\n+* Also on Linux you may have issues with the USB if using two serial USB devices e.g. MonopriceAudio and RFXcom.\n+  See the [general documentation about serial port configuration](/docs/administration/serial.html) for more on symlinking the USB ports.\n+* Here is an example of ser2net.conf you can use to share your serial port /dev/ttyUSB0 on IP port 4444 using [ser2net Linux tool](https://sourceforge.net/projects/ser2net/)\n+  (take care, the baud rate is specific to the Monoprice amplifier):\n+\n+```\n+4444:raw:0:/dev/ttyUSB0:9600 8DATABITS NONE 1STOPBIT LOCAL\n+```\n+\n+## Channels\n+\n+The following channels are available:\n+\n+| Channel ID                    | Item Type | Description                                                                                                   |\n+|-------------------------------|-----------|---------------------------------------------------------------------------------------------------------------|\n+| all:allon                     | Switch    | Turn all zones on simultaneously (except those specified by the ignoreZones config option)                    |\n+| all:alloff                    | Switch    | Turn all zones off simultaneously (except those specified by the ignoreZones config option)                   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODAyNA==", "bodyText": "You should include the cause exception in your MonopriceAudioException.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n          \n          \n            \n                        throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188024", "createdAt": "2020-06-24T21:41:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODE2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n          \n          \n            \n                        throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188164", "createdAt": "2020-06-24T21:42:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = \"\";\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            messageStr = BEGIN_CMD + zone.getZoneId() + cmd.getValue() + String.format(\"%02d\", value);\n+        } else {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: passed in value is null\");\n+        }\n+        messageStr += END_CMD;\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(messageStr.getBytes(StandardCharsets.US_ASCII));\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODQzNw==", "bodyText": "You should make another constructor that takes a String and a Throwable as an argument. To allow the passing of cause exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188437", "createdAt": "2020-06-24T21:42:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link MonopriceAudioException} class is used for any exception thrown by the binding\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "committedDate": "2020-06-25T02:26:43Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c34c6d62ac3b72976a0dd5bca563325e8208adb7", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c34c6d62ac3b72976a0dd5bca563325e8208adb7", "committedDate": "2020-06-25T03:56:52Z", "message": "commit change that was missed\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4fd3ae79696e47991c8543f02061493c80e2a32", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f4fd3ae79696e47991c8543f02061493c80e2a32", "committedDate": "2020-07-06T02:33:08Z", "message": "fix variable name for pmd report\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2c03db0cb30ac223ec1a99a5958701afbd36ddd", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d2c03db0cb30ac223ec1a99a5958701afbd36ddd", "committedDate": "2020-07-08T22:22:45Z", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cbdb3ad598334b0c5d111a3091f064a8add1601", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5cbdb3ad598334b0c5d111a3091f064a8add1601", "committedDate": "2020-07-08T22:24:51Z", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cac938edc2d3677c63ba1d34cf36b0f5844e5353", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/cac938edc2d3677c63ba1d34cf36b0f5844e5353", "committedDate": "2020-07-09T01:13:36Z", "message": "fix order of updateStatus() call\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "committedDate": "2020-07-16T21:38:23Z", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b579193ad576302dc462c6574b4890746be2025", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "committedDate": "2020-07-25T03:38:33Z", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78f69778930aba426a203feec98c17aee188a536", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/78f69778930aba426a203feec98c17aee188a536", "committedDate": "2020-07-28T15:24:48Z", "message": "Merge pull request #8 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0cd7f937d1a5508ec45839ed56eae456a63791d", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d0cd7f937d1a5508ec45839ed56eae456a63791d", "committedDate": "2020-07-28T15:26:15Z", "message": "Merge branch '2.5.x' into MonopriceAudio"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b244b79e0d2a08ac3072306017f3c5576824f6c7", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b244b79e0d2a08ac3072306017f3c5576824f6c7", "committedDate": "2020-07-28T15:55:47Z", "message": "update version and fix remaining warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7f0a56bf418fed52b7ad2773f493a849942f4857", "committedDate": "2020-08-14T18:46:07Z", "message": "documentation fixes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNDU5MjA1", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-472459205", "createdAt": "2020-08-21T12:48:47Z", "commit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMjo0ODo0N1rOHEr3rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzo0MToxM1rOHEtr0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NTExNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String value;\n          \n          \n            \n                private final String value;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474675117", "createdAt": "2020-08-21T12:48:47Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+    QUERY(\"?\"),\n+    POWER(\"PR\"),\n+    SOURCE(\"CH\"),\n+    VOLUME(\"VO\"),\n+    MUTE(\"MU\"),\n+    TREBLE(\"TR\"),\n+    BASS(\"BS\"),\n+    BALANCE(\"BL\"),\n+    DND(\"DT\");\n+\n+    private String value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NTQ2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n          \n          \n            \n                private final List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474675463", "createdAt": "2020-08-21T12:49:24Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NjEyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n          \n          \n            \n                    super(\"OH-binding-\" + MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676121", "createdAt": "2020-08-21T12:50:40Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     * @param uid unique identifier from the connector\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector, String uid) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NjQ1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String serialPortName;\n          \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final String serialPortName;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676450", "createdAt": "2020-08-21T12:51:20Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3Njk0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n          \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(MonopriceAudioZone::name)", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676943", "createdAt": "2020-08-21T12:52:20Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NzA2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .map(z -> z.getZoneId()).collect(Collectors.toList());\n          \n          \n            \n                        .map(MonopriceAudioZone::getZoneId).collect(Collectors.toList());", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474677063", "createdAt": "2020-08-21T12:52:39Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n+            .collect(Collectors.toList());\n+\n+    // make a list of all valid zone ids\n+    public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(z -> z.getZoneId()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3ODU4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String zoneId;\n          \n          \n            \n                private final String zoneId;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474678589", "createdAt": "2020-08-21T12:55:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY4MDEyNA==", "bodyText": "If these zone groups are all the same you should define just a typeId zone. You already set the label and description here (what differentiates the zones).", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474680124", "createdAt": "2020-08-21T12:58:38Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,545 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"monopriceaudio\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Monoprice Whole House Amplifier Thing -->\n+\t<thing-type id=\"amplifier\">\n+\t\t<label>Whole House Amplifier</label>\n+\t\t<description>\n+\t\t\tA Multi-zone Whole House Amplifier System\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"all\" typeId=\"all\">\n+\t\t\t\t<label>All Zones</label>\n+\t\t\t\t<description>Control All Zones Simultaneously</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone1\" typeId=\"zone1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwMTU2Mw==", "bodyText": "Adding inputlabels here is probably not the right approach. A user can use mappings to set a specific name on the options list. See https://www.openhab.org/docs/configuration/sitemaps.html#mappings", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474701563", "createdAt": "2020-08-21T13:35:34Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,545 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"monopriceaudio\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Monoprice Whole House Amplifier Thing -->\n+\t<thing-type id=\"amplifier\">\n+\t\t<label>Whole House Amplifier</label>\n+\t\t<description>\n+\t\t\tA Multi-zone Whole House Amplifier System\n+\t\t</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"all\" typeId=\"all\">\n+\t\t\t\t<label>All Zones</label>\n+\t\t\t\t<description>Control All Zones Simultaneously</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone1\" typeId=\"zone1\">\n+\t\t\t\t<label>Zone 1</label>\n+\t\t\t\t<description>The Controls for Zone 1</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone2\" typeId=\"zone2\">\n+\t\t\t\t<label>Zone 2</label>\n+\t\t\t\t<description>The Controls for Zone 2</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone3\" typeId=\"zone3\">\n+\t\t\t\t<label>Zone 3</label>\n+\t\t\t\t<description>The Controls for Zone 3</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone4\" typeId=\"zone4\">\n+\t\t\t\t<label>Zone 4</label>\n+\t\t\t\t<description>The Controls for Zone 4</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone5\" typeId=\"zone5\">\n+\t\t\t\t<label>Zone 5</label>\n+\t\t\t\t<description>The Controls for Zone 5</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone6\" typeId=\"zone6\">\n+\t\t\t\t<label>Zone 6</label>\n+\t\t\t\t<description>The Controls for Zone 6</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone7\" typeId=\"zone7\">\n+\t\t\t\t<label>Zone 7</label>\n+\t\t\t\t<description>The Controls for Zone 7</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone8\" typeId=\"zone8\">\n+\t\t\t\t<label>Zone 8</label>\n+\t\t\t\t<description>The Controls for Zone 8</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone9\" typeId=\"zone9\">\n+\t\t\t\t<label>Zone 9</label>\n+\t\t\t\t<description>The Controls for Zone 9</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone10\" typeId=\"zone10\">\n+\t\t\t\t<label>Zone 10</label>\n+\t\t\t\t<description>The Controls for Zone 10</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone11\" typeId=\"zone11\">\n+\t\t\t\t<label>Zone 11</label>\n+\t\t\t\t<description>The Controls for Zone 11</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone12\" typeId=\"zone12\">\n+\t\t\t\t<label>Zone 12</label>\n+\t\t\t\t<description>The Controls for Zone 12</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone13\" typeId=\"zone13\">\n+\t\t\t\t<label>Zone 13</label>\n+\t\t\t\t<description>The Controls for Zone 13</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone14\" typeId=\"zone14\">\n+\t\t\t\t<label>Zone 14</label>\n+\t\t\t\t<description>The Controls for Zone 14</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone15\" typeId=\"zone15\">\n+\t\t\t\t<label>Zone 15</label>\n+\t\t\t\t<description>The Controls for Zone 15</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone16\" typeId=\"zone16\">\n+\t\t\t\t<label>Zone 16</label>\n+\t\t\t\t<description>The Controls for Zone 16</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone17\" typeId=\"zone17\">\n+\t\t\t\t<label>Zone 17</label>\n+\t\t\t\t<description>The Controls for Zone 17</description>\n+\t\t\t</channel-group>\n+\t\t\t<channel-group id=\"zone18\" typeId=\"zone18\">\n+\t\t\t\t<label>Zone 18</label>\n+\t\t\t\t<description>The Controls for Zone 18</description>\n+\t\t\t</channel-group>\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>Serial Port to Use for Connecting to the Monoprice Amplifier</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Machine Connected to the Monoprice Amplifier (Serial over IP)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"false\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Communication Port (IP or Serial over IP). For IP connection to the Monoprice Amplifier</description>\n+\t\t\t\t<default>4444</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"numZones\" type=\"integer\" min=\"1\" max=\"18\" required=\"true\">\n+\t\t\t\t<label>Number of Zones</label>\n+\t\t\t\t<description>Number of Zones on the Amplifier to Utilize in the Binding (Up to 18 Zones With 3 Amplifiers Connected\n+\t\t\t\t\tTogether)</description>\n+\t\t\t\t<default>6</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"5\" max=\"60\" unit=\"s\" required=\"false\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Configures How Often to Poll the Controller to Check for Zone Updates (5-60; Default 15)</description>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"ignoreZones\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Ignore Zones</label>\n+\t\t\t\t<description>(Optional) A Comma Seperated List of Zone Numbers That Will Ignore the 'All Zone' (Except All Off)\n+\t\t\t\t\tCommands (ie: 1,6,10)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"initialAllVolume\" type=\"integer\" min=\"1\" max=\"30\" required=\"false\">\n+\t\t\t\t<label>Initial All Volume</label>\n+\t\t\t\t<description>When 'All' Zones Are Activated, the Volume Will Reset to This Value (1-30; default 10) to Prevent\n+\t\t\t\t\tExcessive Blaring of Sound ;)</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"inputLabel1\" type=\"text\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDUxNg==", "bodyText": "The openHAB serial port handler supports rfc2217? Is there a reason not to use it and instead of having implemented a separate ip connector and configuration options?", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474704516", "createdAt": "2020-08-21T13:40:40Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,703 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private Set<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+        String ignoreZonesConfig = config.ignoreZones;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDg0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String key;\n          \n          \n            \n                private String value;\n          \n          \n            \n                private final String key;\n          \n          \n            \n                private final String value;", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474704848", "createdAt": "2020-08-21T13:41:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * MonopriceAudio event used to notify changes coming from messages received from the MonopriceAudio device\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioMessageEvent extends EventObject {\n+\n+    private static final long serialVersionUID = 1L;\n+    private String key;\n+    private String value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/4c109203efcc0bcb3112baf832ad75ecd2481a0a", "committedDate": "2020-08-22T01:04:44Z", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f49106bbf897956459a88243323fc5d64a4b3223", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f49106bbf897956459a88243323fc5d64a4b3223", "committedDate": "2020-08-22T01:32:17Z", "message": "Merge pull request #9 from openhab/2.5.x\n\nUpdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "746cf624b417b4b9df1e3ca4a8066f931485ef87", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/746cf624b417b4b9df1e3ca4a8066f931485ef87", "committedDate": "2020-08-22T01:35:22Z", "message": "merge pom.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b3468619f66ee3714b476681f761a0c92dff658", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1b3468619f66ee3714b476681f761a0c92dff658", "committedDate": "2020-08-26T13:25:14Z", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce6b1b83511266993e7e74b54122b54654265a79", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ce6b1b83511266993e7e74b54122b54654265a79", "committedDate": "2020-08-26T15:39:12Z", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca3481541399089a8850bdc845723806ad92a28d", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ca3481541399089a8850bdc845723806ad92a28d", "committedDate": "2020-08-26T16:57:47Z", "message": "Merge branch '2.5.x' into MonopriceAudio"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d1ac35725796cf41e0cd1cdd497c899ab06930c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9d1ac35725796cf41e0cd1cdd497c899ab06930c", "committedDate": "2020-08-26T17:09:42Z", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31227c502d4697366429850b34557b7cebf44831", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/31227c502d4697366429850b34557b7cebf44831", "committedDate": "2020-08-26T20:01:12Z", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67bb699dd5d433cc3428720005b61e6726193933", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/67bb699dd5d433cc3428720005b61e6726193933", "committedDate": "2020-08-26T20:03:28Z", "message": "Merge branch '2.5.x' into MonopriceAudio"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMzE0MjE2", "url": "https://github.com/openhab/openhab-addons/pull/7371#pullrequestreview-481314216", "createdAt": "2020-09-02T21:29:11Z", "commit": {"oid": "9d1ac35725796cf41e0cd1cdd497c899ab06930c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a5327cb44c5f0ed3f4640a439df62954d8ab33", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/86a5327cb44c5f0ed3f4640a439df62954d8ab33", "committedDate": "2020-09-03T00:24:02Z", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad2731c230b2c87628de459b77f03082da06b656", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ad2731c230b2c87628de459b77f03082da06b656", "committedDate": "2020-09-03T00:36:59Z", "message": "fix merge conflicts\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 809, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}