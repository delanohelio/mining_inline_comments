{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNTQ2Nzg1", "number": 8583, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQxMzoyOTo1M1rOEnvuBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyNzoyMVrOExf07A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTExNzQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQxMzoyOTo1M1rOHYgTIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoxMTowOFrOHYiYPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzA1OQ==", "bodyText": "I suggest to have a sub title ###Thing Configuration for \"calendar\" here", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495457059", "createdAt": "2020-09-26T13:29:53Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -6,10 +6,12 @@ Furthermore it is possible to embed `command tags` in the calendar event descrip\n \n ## Supported Things\n \n-The only thing type is the calendar.\n-It is based on a single iCalendar file.\n+The primary thing type is the calendar.\n+It is based on a single iCalendar file and implemented as bridge.\n There can be multiple things having different properties representing different calendars.\n \n+Each calendar can have event filters which allow to get multiple events, maybe filtered by additional criteria. Time based filtering is done by each event's start.\n+\n ## Thing Configuration\n \n Each `calendar` thing requires the following configuration parameters:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTEzNQ==", "bodyText": "OK.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495491135", "createdAt": "2020-09-26T20:11:08Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -6,10 +6,12 @@ Furthermore it is possible to embed `command tags` in the calendar event descrip\n \n ## Supported Things\n \n-The only thing type is the calendar.\n-It is based on a single iCalendar file.\n+The primary thing type is the calendar.\n+It is based on a single iCalendar file and implemented as bridge.\n There can be multiple things having different properties representing different calendars.\n \n+Each calendar can have event filters which allow to get multiple events, maybe filtered by additional criteria. Time based filtering is done by each event's start.\n+\n ## Thing Configuration\n \n Each `calendar` thing requires the following configuration parameters:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzA1OQ=="}, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTExNzkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQxMzozMDoyMVrOHYgTVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoxMzoxNlrOHYiY1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzExMA==", "bodyText": "And a a sub title ###Thing Configuration for \"eventFilter\" here", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495457110", "createdAt": "2020-09-26T13:30:21Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +25,54 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTI4NA==", "bodyText": "OK.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495491284", "createdAt": "2020-09-26T20:13:16Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +25,54 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzExMA=="}, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTExODQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQxMzozMTowNVrOHYgTlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoxMzowNVrOHYiYyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzE3Mg==", "bodyText": "Ditto sub title ###Channels for \"calendar\"", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495457172", "createdAt": "2020-09-26T13:31:05Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +25,54 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |\n+| `datetimeStart`  | The start of the time frame where to search for events relative to current time. Combined with `datetimeUnit`.                                                                               | optional                                   |\n+| `datetimeEnd`    | The end of the time frame where to search for events relative to current time. Combined with `datetimeUnit`. The value must be greater than `datetimeStart` to get results.                  | optional                                   |\n+| `datetimeRound`  | Whether to round the datetimes of start and end down to the earlier time unit. Example if set: current time is 13:00, timeunit is set to `DAY`. Resulting search will start and end at 0:00. | optional                                   |\n+| `textEventField` | A field to filter the events text-based. Valid values: `SUMMARY`, `DESCRIPTION`, `COMMENT`, `CONTACT` and `LOCATION` (as described in RFC 5545).                                             | optional/required for text-based filtering |\n+| `textEventValue` | The text to filter events with.                                                                                                                                                              | optional                                   |\n+| `textValueType`  | The type of the text to filter with. Valid values: `TEXT` (field must contain value), `REGEX` (field must match value, completely, dot matches all, case insensetive).                       | optional/required for text-based filtering |\n+\n ## Channels\n \n-The channels describe the current and the next forthcoming event.\n+The channels of `calendar` describe the current and the next forthcoming event.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTI3NA==", "bodyText": "OK.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495491274", "createdAt": "2020-09-26T20:13:05Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +25,54 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |\n+| `datetimeStart`  | The start of the time frame where to search for events relative to current time. Combined with `datetimeUnit`.                                                                               | optional                                   |\n+| `datetimeEnd`    | The end of the time frame where to search for events relative to current time. Combined with `datetimeUnit`. The value must be greater than `datetimeStart` to get results.                  | optional                                   |\n+| `datetimeRound`  | Whether to round the datetimes of start and end down to the earlier time unit. Example if set: current time is 13:00, timeunit is set to `DAY`. Resulting search will start and end at 0:00. | optional                                   |\n+| `textEventField` | A field to filter the events text-based. Valid values: `SUMMARY`, `DESCRIPTION`, `COMMENT`, `CONTACT` and `LOCATION` (as described in RFC 5545).                                             | optional/required for text-based filtering |\n+| `textEventValue` | The text to filter events with.                                                                                                                                                              | optional                                   |\n+| `textValueType`  | The type of the text to filter with. Valid values: `TEXT` (field must contain value), `REGEX` (field must match value, completely, dot matches all, case insensetive).                       | optional/required for text-based filtering |\n+\n ## Channels\n \n-The channels describe the current and the next forthcoming event.\n+The channels of `calendar` describe the current and the next forthcoming event.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzE3Mg=="}, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTExODcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQxMzozMTozNVrOHYgTvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQyMDoxMjo1MFrOHYiYvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzIxMg==", "bodyText": "Ditto sub title ###Channels for \"eventfilter\"", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495457212", "createdAt": "2020-09-26T13:31:35Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +25,54 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |\n+| `datetimeStart`  | The start of the time frame where to search for events relative to current time. Combined with `datetimeUnit`.                                                                               | optional                                   |\n+| `datetimeEnd`    | The end of the time frame where to search for events relative to current time. Combined with `datetimeUnit`. The value must be greater than `datetimeStart` to get results.                  | optional                                   |\n+| `datetimeRound`  | Whether to round the datetimes of start and end down to the earlier time unit. Example if set: current time is 13:00, timeunit is set to `DAY`. Resulting search will start and end at 0:00. | optional                                   |\n+| `textEventField` | A field to filter the events text-based. Valid values: `SUMMARY`, `DESCRIPTION`, `COMMENT`, `CONTACT` and `LOCATION` (as described in RFC 5545).                                             | optional/required for text-based filtering |\n+| `textEventValue` | The text to filter events with.                                                                                                                                                              | optional                                   |\n+| `textValueType`  | The type of the text to filter with. Valid values: `TEXT` (field must contain value), `REGEX` (field must match value, completely, dot matches all, case insensetive).                       | optional/required for text-based filtering |\n+\n ## Channels\n \n-The channels describe the current and the next forthcoming event.\n+The channels of `calendar` describe the current and the next forthcoming event.\n They are all read-only.\n \n-| Channel           | Type      | Description                                                                    |\n-|-------------------|-----------|--------------------------------------------------------------------------------|\n-| current_presence  | Switch    | Current presence of an event, `ON` if there is currently an event, `OFF` otherwise |\n-| current_title     | String    | Title of a currently present event                                             |\n-| current_start     | DateTime  | Start of a currently present event                                             |\n-| current_end       | DateTime  | End of a currently present event                                               |\n-| next_title        | String    | Title of the next event                                                        |\n-| next_start        | DateTime  | Start of the next event                                                        |\n-| next_end          | DateTime  | End of the next event                                                          |\n+| Channel           | Type      | Description                                                                         |\n+|-------------------|-----------|-------------------------------------------------------------------------------------|\n+| current_presence  | Switch    | Current presence of an event, `ON` if there is currently an event, `OFF` otherwise  |\n+| current_title     | String    | Title of a currently present event                                                  |\n+| current_start     | DateTime  | Start of a currently present event                                                  |\n+| current_end       | DateTime  | End of a currently present event                                                    |\n+| next_title        | String    | Title of the next event                                                             |\n+| next_start        | DateTime  | Start of the next event                                                             |\n+| next_end          | DateTime  | End of the next event                                                               |\n+\n+The channels of `eventfilter` are generated using following scheme, all are read-only.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5MTI2MA==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r495491260", "createdAt": "2020-09-26T20:12:50Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +25,54 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |\n+| `datetimeStart`  | The start of the time frame where to search for events relative to current time. Combined with `datetimeUnit`.                                                                               | optional                                   |\n+| `datetimeEnd`    | The end of the time frame where to search for events relative to current time. Combined with `datetimeUnit`. The value must be greater than `datetimeStart` to get results.                  | optional                                   |\n+| `datetimeRound`  | Whether to round the datetimes of start and end down to the earlier time unit. Example if set: current time is 13:00, timeunit is set to `DAY`. Resulting search will start and end at 0:00. | optional                                   |\n+| `textEventField` | A field to filter the events text-based. Valid values: `SUMMARY`, `DESCRIPTION`, `COMMENT`, `CONTACT` and `LOCATION` (as described in RFC 5545).                                             | optional/required for text-based filtering |\n+| `textEventValue` | The text to filter events with.                                                                                                                                                              | optional                                   |\n+| `textValueType`  | The type of the text to filter with. Valid values: `TEXT` (field must contain value), `REGEX` (field must match value, completely, dot matches all, case insensetive).                       | optional/required for text-based filtering |\n+\n ## Channels\n \n-The channels describe the current and the next forthcoming event.\n+The channels of `calendar` describe the current and the next forthcoming event.\n They are all read-only.\n \n-| Channel           | Type      | Description                                                                    |\n-|-------------------|-----------|--------------------------------------------------------------------------------|\n-| current_presence  | Switch    | Current presence of an event, `ON` if there is currently an event, `OFF` otherwise |\n-| current_title     | String    | Title of a currently present event                                             |\n-| current_start     | DateTime  | Start of a currently present event                                             |\n-| current_end       | DateTime  | End of a currently present event                                               |\n-| next_title        | String    | Title of the next event                                                        |\n-| next_start        | DateTime  | Start of the next event                                                        |\n-| next_end          | DateTime  | End of the next event                                                          |\n+| Channel           | Type      | Description                                                                         |\n+|-------------------|-----------|-------------------------------------------------------------------------------------|\n+| current_presence  | Switch    | Current presence of an event, `ON` if there is currently an event, `OFF` otherwise  |\n+| current_title     | String    | Title of a currently present event                                                  |\n+| current_start     | DateTime  | Start of a currently present event                                                  |\n+| current_end       | DateTime  | End of a currently present event                                                    |\n+| next_title        | String    | Title of the next event                                                             |\n+| next_start        | DateTime  | Start of the next event                                                             |\n+| next_end          | DateTime  | End of the next event                                                               |\n+\n+The channels of `eventfilter` are generated using following scheme, all are read-only.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ1NzIxMg=="}, "originalCommit": {"oid": "7f83451318d5e92a7e0361efbec5605e17f3ea5a"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA4MjM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTo1NDoyMVrOHfisPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTo1NDoyMVrOHfisPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNjI4Ng==", "bodyText": "I think that makes it clearer.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |\n          \n          \n            \n            | `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional (required for time-based filtering) |", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502836286", "createdAt": "2020-10-10T21:54:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +26,56 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n-## Channels\n+### Configuration for `eventfilter`\n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA4NTA3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMTo1ODo1OFrOHfitew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNDo0NTozNVrOHfkcHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNjYwMw==", "bodyText": "What does WEEK mean? Is it the calendar week?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502836603", "createdAt": "2020-10-10T21:58:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +26,56 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n-## Channels\n+### Configuration for `eventfilter`\n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2NDkyNw==", "bodyText": "Yes - a week are 604800 seconds (if datetimeRound is set, day will be to Monday as this is the first day in java.time).", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502864927", "createdAt": "2020-10-11T04:45:35Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -23,20 +26,56 @@ Each `calendar` thing requires the following configuration parameters:\n | `maxSize`           | The maximum size of the iCal-file in Mebibytes.                                                                                                                                           | mandatory (default available) |\n | `authorizationCode` | The authorization code to permit the execution of embedded command tags. If set, the binding checks that the authorization code in the command tag matches before executing any commands. | optional                      |\n \n-## Channels\n+### Configuration for `eventfilter`\n+Each `eventfilter` thing requires a bridge of type `calendar` and has following configuration options:\n+\n+| parameter name   | description                                                                                                                                                                                  | optional                                   |\n+|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n+| `maxEvents`      | The count of expected results.                                                                                                                                                               | mandatory                                  |\n+| `refreshTime`    | The frequency in minutes the channels get refreshed.                                                                                                                                         | mandatory (default available)              |\n+| `datetimeUnit`   | A unit for time settings in this filter. Valid values: `MINUTE`, `HOUR`, `DAY` and `WEEK`.                                                                                                   | optional/required for time-based filtering |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNjYwMw=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA5MDk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjowNjozMFrOHfiwCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNTo0NzoyM1rOHfkslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI1OA==", "bodyText": "The author tag should not be used on inner classes.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837258", "createdAt": "2020-10-10T22:06:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2OTE0Mg==", "bodyText": "Hm. Yes this was strange, i've added it as a maven plugin complained about the missing @author. However it now does not anymore. I'll remove.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502869142", "createdAt": "2020-10-11T05:47:23Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI1OA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA5MTA5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjowNjo0N1rOHfiwHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNTo1MTo1OFrOHfkuAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI3Ng==", "bodyText": "Logging to info should be used rarely. This could be debug. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837276", "createdAt": "2020-10-10T22:06:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2OTUwNg==", "bodyText": "This is intentionally info as it changes the users configuration. This should happen exactly once, because the handler only converted once. In that time the item is shortly unusable. Should we really hide the change to users configuration? It could lead to confusion because something changes without any notification - this way a user may find out, why something in his configuration changed.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502869506", "createdAt": "2020-10-11T05:51:58Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzI3Ng=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA5MTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjowNzoyNlrOHfiwTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QyMDozNzoyMFrOHjfsxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ==", "bodyText": "Why is this delay necessary?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837325", "createdAt": "2020-10-10T22:07:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3MDMyOA==", "bodyText": "OpenHAB does not provide hooks for upgrades AFAIK. It is as i need to be sure that the replacement is done asynchronous after the failed initialization. So createHandler(Thing) must return before i'm able to do the needed migration - which does not allow to use usual synchronization mechanisms. I'm pretty sure a 20 sec delay is enough to let the method return (it is just the next instruction after starting the thread containing the sleep).", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502870328", "createdAt": "2020-10-11T06:02:33Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NTM5Nw==", "bodyText": "What happens if you do it synchronously? Genuinely asking.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502965397", "createdAt": "2020-10-11T21:01:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2OTM2MQ==", "bodyText": "I've tried that first a long time ago. I couldn't add an item with same id as it collides with the existing one (that happens while migration). I think the removal has been not possible in the state \"initializing\" and the framework does not seem to remove the item in that time (all AFIAR!).", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502969361", "createdAt": "2020-10-11T21:41:27Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3MTExNg==", "bodyText": "@openhab/add-ons-maintainers is there a pattern to migrate Things from one version to another? In this case a Thread is spawn in the ThingHandlerFactory and after some delay the Thing is removed and re-added. Is this a valid approach?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502971116", "createdAt": "2020-10-11T21:59:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2MjIyMA==", "bodyText": "No, there is not. But this should definitely be done by the framework. We are looking for a solution for a long time (see eclipse-archived/smarthome#2555). There are already drafts for an implementation like openhab/openhab-core#1027 but unfortunately not THE result we are looking for.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r504162220", "createdAt": "2020-10-13T18:15:18Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk0NTYxNQ==", "bodyText": "@cweitkamp The question is now: how to continue here?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506945615", "createdAt": "2020-10-17T13:53:01Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NzY4Ng==", "bodyText": "I'd clearly say: Remove any migration logic from the binding (I never accepted that in other bindings either).\nAs long as there is no solution in the core framework, add a note to the distro that there is a breaking change in the binding configuration and that Things have to be re-created by the user.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506957686", "createdAt": "2020-10-17T16:08:09Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4MDM4Mg==", "bodyText": "hmm... ok.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506980382", "createdAt": "2020-10-17T20:22:15Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4MTU3Mw==", "bodyText": "I understand that this is not what you wanted to hear, sorry for that - but I always prefer general solutions to problems (even if they are in the future) instead of having 200 bindings trying to solve it on their own in different ways. So thanks for your understanding!", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506981573", "createdAt": "2020-10-17T20:37:20Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +84,61 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher);\n+            } else {\n+                // Migration needs to be done asynchronously. Using thread pool for common things.\n+                ThingUID uidToCopy = thing.getUID();\n+                ExecutorService threadPool = ThreadPoolManager.getPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+                threadPool.execute(new ReregisterThingRunnable(uidToCopy));\n+                return null;\n+            }\n+        } else if (thingTypeUID.equals(THING_TYPE_FILTERED_EVENTS)) {\n+            return new EventFilterHandler(thing);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This Runnable \"upgrades\" the thing \"calendar\" to the bridge of same type. To make sure the thing isn't in use, a\n+     * sleep blocks before doing actual work.\n+     *\n+     * @author Michael Wodniok - Initial contribution\n+     */\n+    private class ReregisterThingRunnable implements Runnable {\n+        private final ThingUID thingUID;\n+\n+        public ReregisterThingRunnable(ThingUID uid) {\n+            thingUID = uid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            logger.info(\"Converting Thing {} to Bridge. This will remove the item and readd it. Please stand by.\",\n+                    thingUID);\n+            try {\n+                Thread.sleep(20000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzMyNQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA5NjE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoxMzo1MFrOHfiyZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNToxMTozMVrOHlCGog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA==", "bodyText": "Please add the NonNullByDefault annotation.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502837860", "createdAt": "2020-10-10T22:13:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3MjkzMQ==", "bodyText": "Is there a guarantee that required parameters are non-null?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502872931", "createdAt": "2020-10-11T06:34:01Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NTU1NQ==", "bodyText": "No, not at all. If the user uses textual configuration, a field can be null if the user forgets to specify the parameter. You could declare the fields as Nullable or initialize them with a default value.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502965555", "createdAt": "2020-10-11T21:03:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4MDg1OA==", "bodyText": "Do you think it's really better to annotate as @NonNullByDefault and after that marking all members as @Nullable? The configuration classes are classical DTO's.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r506980858", "createdAt": "2020-10-17T20:28:31Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5Mjk2MQ==", "bodyText": "I must admit it's a bit inconsistent to annotate the configuration and the other DTOs not. But to stay consistent with the other bindings it'd be better to annotate the configuration. Many bindings initialize the fields with default values, to avoid the Nullable declaration.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507192961", "createdAt": "2020-10-18T17:57:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5MzgyNg==", "bodyText": "OK.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r508593826", "createdAt": "2020-10-20T15:11:31Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzNzg2MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA5NzYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoxNTozOVrOHfizBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMTowODo0MlrOHfqnYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODAyMg==", "bodyText": "Is there a reason why you chose BigDecimal instead of int?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838022", "createdAt": "2020-10-10T22:15:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {\n+    public BigDecimal maxEvents;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3MDQ2Nw==", "bodyText": "The docs:\n\nAll configuration values will be mapped to properties of the class. The type of the property must match the type of the configuration. Only the following types are supported for configuration values: Boolean, String and BigDecimal.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502870467", "createdAt": "2020-10-11T06:04:49Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {\n+    public BigDecimal maxEvents;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODAyMg=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NjExMw==", "bodyText": "That's interesting, as many bindings use int. You can leave it as-is.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502966113", "createdAt": "2020-10-11T21:08:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/config/EventFilterConfiguration.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.config;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * The EventFilterConfiguration holds configuration for the Event Filter Item Type.\n+ *\n+ * @author Michael Wodniok - Initial contribution\n+ */\n+public class EventFilterConfiguration {\n+    public BigDecimal maxEvents;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODAyMg=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTA5ODY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoxNzo0MVrOHfizfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNjo1ODozMFrOHflEFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODE0Mw==", "bodyText": "The compiler is more intelligent on local variables. This annotation could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838143", "createdAt": "2020-10-10T22:17:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTE1OA==", "bodyText": "OK, doing locally", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875158", "createdAt": "2020-10-11T06:58:30Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODE0Mw=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwMTI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoyMDo1OFrOHfi0rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwOTo0ODowOFrOHjk4RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODQ0Ng==", "bodyText": "I would set the ThingStatusDetail rather to CONFIGURATION_ERROR, as this error raises when the user forgot to configure the bridge. Also, the log message could be set as third argument to updateStatus(), so that it is displayed in the UI. The log message can be removed then, as it is already logged.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838446", "createdAt": "2020-10-10T22:20:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA2NjQzNg==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507066436", "createdAt": "2020-10-18T09:48:08Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODQ0Ng=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwMzE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoyNDoxMFrOHfi1iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoyNDoxMFrOHfi1iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODY2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n          \n          \n            \n                    if (config.maxEvents == null || config.maxEvents.compareTo(BigDecimal.ZERO) < 1) {", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838667", "createdAt": "2020-10-10T22:24:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwMzYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoyNDo1N1rOHfi1ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNjo1ODoxN1rOHflECA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODcyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @Nullable", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838723", "createdAt": "2020-10-10T22:24:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTE0NA==", "bodyText": "OK, doing locally", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875144", "createdAt": "2020-10-11T06:58:17Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODcyMw=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwNTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjoyNjo0NFrOHfi2aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNjo1ODowN1rOHflD_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODg5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            @Nullable", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502838891", "createdAt": "2020-10-10T22:26:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTEzNA==", "bodyText": "OK, doing locally", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875134", "createdAt": "2020-10-11T06:58:07Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODg5MQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwNzg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozMDozNlrOHfi3tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwNjo1NDo1MlrOHjibog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg==", "bodyText": "IllegalArgumentException is an unchecked exception, which are not meant to be cought. Is an exception needed at all here? Could you simply return and set the ThingStatus accordingly?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839222", "createdAt": "2020-10-10T22:30:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTQ3OA==", "bodyText": "I just did not want to reinvent the wheel and am catching the exception. Do you know a better one or should i create a own exception class for broken configs?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875478", "createdAt": "2020-10-11T07:01:53Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NjQ4Nw==", "bodyText": "Creating a custom exception would be a valid approach. But I'm wondering if an exception is needed at all here. Can't you simply return like in line 265? BTW you should set the ThingStatus accordingly in this line.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502966487", "createdAt": "2020-10-11T21:12:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyNjMzOA==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507026338", "createdAt": "2020-10-18T06:54:52Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTIyMg=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwODI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozMTowMlrOHfi34Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwNjo1NTozMFrOHjicDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI2NQ==", "bodyText": "See above. Remove logging and append the message to updateStatus().", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839265", "createdAt": "2020-10-10T22:31:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyNjQ0NA==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507026444", "createdAt": "2020-10-18T06:55:30Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI2NQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwODQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozMToxOFrOHfi38g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwNjo1NTowMFrOHjibxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI4Mg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839282", "createdAt": "2020-10-10T22:31:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAyNjM3Mw==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507026373", "createdAt": "2020-10-18T06:55:00Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTI4Mg=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTEwOTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozMjo0M1rOHfi4Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQxMDoyNToyM1rOHfmV9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTM5MA==", "bodyText": "You could inject the TimeZoneProvider to retrieve the timezone configured within openHAB. This may differ from the system time zone.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839390", "createdAt": "2020-10-10T22:32:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg5NjExOA==", "bodyText": "OK.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502896118", "createdAt": "2020-10-11T10:25:23Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTM5MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExMDA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozNDoxMlrOHfi4tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwNzo1MDo0NFrOHjix1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTQ3Ng==", "bodyText": "Please add an appropriate error reason to give the user a hint when debugging.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839476", "createdAt": "2020-10-10T22:34:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());\n+                switch (multiplicator) {\n+                    case WEEK:\n+                        refDT = refDT.with(ChronoField.DAY_OF_WEEK, 1);\n+                    case DAY:\n+                        refDT = refDT.with(ChronoField.HOUR_OF_DAY, 0);\n+                    case HOUR:\n+                        refDT = refDT.with(ChronoField.MINUTE_OF_HOUR, 0);\n+                    case MINUTE:\n+                        refDT = refDT.with(ChronoField.SECOND_OF_MINUTE, 0);\n+                }\n+                reference = refDT.toInstant();\n+            }\n+            Instant begin = Instant.EPOCH;\n+            Instant end = Instant.ofEpochMilli(Long.MAX_VALUE);\n+\n+            if (config.datetimeStart != null) {\n+                begin = reference.plusSeconds(config.datetimeStart.longValue() * multiplicator.getMultiplier());\n+            }\n+            if (config.datetimeEnd != null) {\n+                end = reference.plusSeconds(config.datetimeEnd.longValue() * multiplicator.getMultiplier());\n+            }\n+\n+            List<Event> results = cal.getFilteredEventsBetween(begin, end, filter, config.maxEvents.intValue());\n+            for (int position = 0; position < config.maxEvents.intValue(); position++) {\n+                ResultChannelSet channels = resultChannels.get(position);\n+                if (position < results.size()) {\n+                    Event result = results.get(position);\n+                    updateState(channels.titleChannel, new StringType(result.title));\n+                    updateState(channels.beginChannel, new DateTimeType(result.start.atZone(ZoneId.systemDefault())));\n+                    updateState(channels.endChannel, new DateTimeType(result.end.atZone(ZoneId.systemDefault())));\n+                } else {\n+                    updateState(channels.titleChannel, UnDefType.UNDEF);\n+                    updateState(channels.beginChannel, UnDefType.UNDEF);\n+                    updateState(channels.endChannel, UnDefType.UNDEF);\n+                }\n+            }\n+\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAzMjAyMg==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r507032022", "createdAt": "2020-10-18T07:50:44Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());\n+                switch (multiplicator) {\n+                    case WEEK:\n+                        refDT = refDT.with(ChronoField.DAY_OF_WEEK, 1);\n+                    case DAY:\n+                        refDT = refDT.with(ChronoField.HOUR_OF_DAY, 0);\n+                    case HOUR:\n+                        refDT = refDT.with(ChronoField.MINUTE_OF_HOUR, 0);\n+                    case MINUTE:\n+                        refDT = refDT.with(ChronoField.SECOND_OF_MINUTE, 0);\n+                }\n+                reference = refDT.toInstant();\n+            }\n+            Instant begin = Instant.EPOCH;\n+            Instant end = Instant.ofEpochMilli(Long.MAX_VALUE);\n+\n+            if (config.datetimeStart != null) {\n+                begin = reference.plusSeconds(config.datetimeStart.longValue() * multiplicator.getMultiplier());\n+            }\n+            if (config.datetimeEnd != null) {\n+                end = reference.plusSeconds(config.datetimeEnd.longValue() * multiplicator.getMultiplier());\n+            }\n+\n+            List<Event> results = cal.getFilteredEventsBetween(begin, end, filter, config.maxEvents.intValue());\n+            for (int position = 0; position < config.maxEvents.intValue(); position++) {\n+                ResultChannelSet channels = resultChannels.get(position);\n+                if (position < results.size()) {\n+                    Event result = results.get(position);\n+                    updateState(channels.titleChannel, new StringType(result.title));\n+                    updateState(channels.beginChannel, new DateTimeType(result.start.atZone(ZoneId.systemDefault())));\n+                    updateState(channels.endChannel, new DateTimeType(result.end.atZone(ZoneId.systemDefault())));\n+                } else {\n+                    updateState(channels.titleChannel, UnDefType.UNDEF);\n+                    updateState(channels.beginChannel, UnDefType.UNDEF);\n+                    updateState(channels.endChannel, UnDefType.UNDEF);\n+                }\n+            }\n+\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTQ3Ng=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExMDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozNDo1NlrOHfi5BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozNDo1NlrOHfi5BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTU1Ng==", "bodyText": "Syntactical sugar\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateFuture = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        updateStates();\n          \n          \n            \n                    }, refreshTime, refreshTime, TimeUnit.MINUTES);\n          \n          \n            \n                    updateFuture = scheduler.scheduleWithFixedDelay(this::updateStates, refreshTime, refreshTime, TimeUnit.MINUTES);", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839556", "createdAt": "2020-10-10T22:34:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/EventFilterHandler.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.icalendar.internal.handler;\n+\n+import static org.openhab.binding.icalendar.internal.ICalendarBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoField;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.icalendar.internal.config.EventFilterConfiguration;\n+import org.openhab.binding.icalendar.internal.handler.PullJob.CalendarUpdateListener;\n+import org.openhab.binding.icalendar.internal.logic.AbstractPresentableCalendar;\n+import org.openhab.binding.icalendar.internal.logic.Event;\n+import org.openhab.binding.icalendar.internal.logic.EventTextFilter;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelGroupUID;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.builder.ChannelBuilder;\n+import org.openhab.core.thing.binding.builder.ThingBuilder;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link EventFilterHandler} filters events from a calendar and presents them in a dynamic way.\n+ *\n+ * @author Michael Wodniok - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class EventFilterHandler extends BaseThingHandler implements CalendarUpdateListener {\n+\n+    private @Nullable EventFilterConfiguration configuration;\n+    private final Logger logger = LoggerFactory.getLogger(EventFilterHandler.class);\n+    private final List<ResultChannelSet> resultChannels;\n+    private @Nullable ScheduledFuture<?> updateFuture;\n+    private boolean initFinished;\n+\n+    public EventFilterHandler(Thing thing) {\n+        super(thing);\n+        resultChannels = new CopyOnWriteArrayList<>();\n+        initFinished = false;\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+            updateStates();\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            if (initFinished) {\n+                updateStates();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        @Nullable\n+        Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.warn(\"This thing requires a bridge configured to work.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final EventFilterConfiguration config = getConfigAs(EventFilterConfiguration.class);\n+        if (config.datetimeUnit == null && (config.datetimeEnd != null || config.datetimeStart != null)) {\n+            logger.warn(\"Start/End date-time is set but no unit. This will ignore the filter.\");\n+        }\n+        if (config.textEventField != null && config.textValueType == null) {\n+            logger.warn(\"Event field is set but not match type. This will ignore the filter.\");\n+        }\n+        configuration = config;\n+\n+        if (iCalendarBridge.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            return;\n+        } else {\n+            updateChannelSet(config);\n+            updateStates();\n+        }\n+        initFinished = true;\n+    }\n+\n+    @Override\n+    public void onCalendarUpdated() {\n+        updateStates();\n+    }\n+\n+    /**\n+     * Consists of a set of channels and their group for describing a filtered event. *\n+     */\n+    private class ResultChannelSet {\n+        ChannelGroupUID resultGroup;\n+        ChannelUID beginChannel;\n+        ChannelUID endChannel;\n+        ChannelUID titleChannel;\n+\n+        public ResultChannelSet(ChannelGroupUID group, ChannelUID begin, ChannelUID end, ChannelUID title) {\n+            resultGroup = group;\n+            beginChannel = begin;\n+            endChannel = end;\n+            titleChannel = title;\n+        }\n+    }\n+\n+    /**\n+     * Describes some fixed time factors for unit selection.\n+     */\n+    private enum TimeMultiplicator {\n+        MINUTE(60),\n+        HOUR(3600),\n+        DAY(86400),\n+        WEEK(604800);\n+\n+        private final int secondsPerUnit;\n+\n+        private TimeMultiplicator(int secondsPerUnit) {\n+            this.secondsPerUnit = secondsPerUnit;\n+        }\n+\n+        /**\n+         * Returns the count of seconds per unit.\n+         *\n+         * @return Seconds per unit.\n+         */\n+        public int getMultiplier() {\n+            return secondsPerUnit;\n+        }\n+    }\n+\n+    /**\n+     * Generates a list of channel sets according to the required amount.\n+     *\n+     * @param resultCount The required amount of results.\n+     */\n+    private void generateExpectedChannelList(int resultCount) {\n+        if (resultChannels.size() == resultCount) {\n+            return;\n+        }\n+        resultChannels.clear();\n+        for (int position = 0; position < resultCount; position++) {\n+            ChannelGroupUID currentGroup = new ChannelGroupUID(getThing().getUID(), RESULT_GROUP_ID_PREFIX + position);\n+            ResultChannelSet current = new ResultChannelSet(currentGroup, new ChannelUID(currentGroup, RESULT_BEGIN_ID),\n+                    new ChannelUID(currentGroup, RESULT_END_ID), new ChannelUID(currentGroup, RESULT_TITLE_ID));\n+            resultChannels.add(current);\n+        }\n+    }\n+\n+    /**\n+     * Checks existing channels, adds missing and removes extraneous channels from the Thing.\n+     *\n+     * @param config The validated Configuration of the Thing.\n+     */\n+    private void updateChannelSet(EventFilterConfiguration config) {\n+        @Nullable\n+        final ThingHandlerCallback handlerCallback = getCallback();\n+        if (handlerCallback == null) {\n+            return;\n+        }\n+\n+        final List<Channel> currentChannels = getThing().getChannels();\n+        final ThingBuilder thingBuilder = editThing();\n+        if (config.maxEvents == null || config.maxEvents.compareTo(new BigDecimal(0)) < 1) {\n+            thingBuilder.withoutChannels(currentChannels);\n+            updateThing(thingBuilder.build());\n+            return;\n+        }\n+        generateExpectedChannelList(config.maxEvents.intValue());\n+\n+        currentChannels.stream().filter((Channel current) -> {\n+            @Nullable\n+            String currentGroupId = current.getUID().getGroupId();\n+            if (currentGroupId == null) {\n+                return true;\n+            }\n+            for (ResultChannelSet channelSet : resultChannels) {\n+                if (channelSet.resultGroup.getId().contentEquals(currentGroupId)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }).forEach((Channel toDelete) -> {\n+            thingBuilder.withoutChannel(toDelete.getUID());\n+        });\n+\n+        resultChannels.stream().filter((ResultChannelSet current) -> {\n+            return (getThing().getChannelsOfGroup(current.resultGroup.toString()).size() == 0);\n+        }).forEach((ResultChannelSet current) -> {\n+            for (ChannelBuilder builder : handlerCallback.createChannelBuilders(current.resultGroup, GROUP_TYPE_UID)) {\n+                Channel currentChannel = builder.build();\n+                @Nullable\n+                Channel existingChannel = getThing().getChannel(currentChannel.getUID());\n+                if (existingChannel == null) {\n+                    thingBuilder.withChannel(currentChannel);\n+                }\n+            }\n+        });\n+\n+        updateThing(thingBuilder.build());\n+    }\n+\n+    /**\n+     * Updates all states and channels.\n+     */\n+    private void updateStates() {\n+        final Bridge iCalendarBridge = getBridge();\n+        if (iCalendarBridge == null) {\n+            logger.debug(\"Bridge not instantiated!\");\n+            return;\n+        }\n+        final ICalendarHandler iCalendarHandler = (ICalendarHandler) iCalendarBridge.getHandler();\n+        if (iCalendarHandler == null) {\n+            logger.debug(\"ICalendarHandler not instantiated!\");\n+            return;\n+        }\n+        final EventFilterConfiguration config = configuration;\n+        if (config == null) {\n+            logger.debug(\"Configuration not instantiated!\");\n+            return;\n+        }\n+        @Nullable\n+        final AbstractPresentableCalendar cal = iCalendarHandler.getRuntimeCalendar();\n+        if (cal != null) {\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            String textFilterValue = config.textEventValue;\n+            EventTextFilter filter = null;\n+            if (textFilterValue != null) {\n+                try {\n+                    if (config.textEventField == null || config.textValueType == null) {\n+                        throw new IllegalArgumentException(\"Config is broken.\");\n+                    }\n+                    EventTextFilter.Field textFilterField = EventTextFilter.Field.valueOf(config.textEventField);\n+                    EventTextFilter.Type textFilterType = EventTextFilter.Type.valueOf(config.textValueType);\n+\n+                    filter = new EventTextFilter(textFilterField, textFilterValue, textFilterType);\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"Text-filter settings are not set properly.\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                    return;\n+                }\n+            }\n+\n+            Instant reference = Instant.now();\n+            TimeMultiplicator multiplicator;\n+\n+            try {\n+                if (config.datetimeUnit == null) {\n+                    throw new IllegalArgumentException(\"Config is broken.\");\n+                }\n+                multiplicator = TimeMultiplicator.valueOf(config.datetimeUnit);\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Time-filter settings are not set properly.\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+                return;\n+            }\n+\n+            if (config.datetimeRound) {\n+                ZonedDateTime refDT = reference.atZone(ZoneId.systemDefault());\n+                switch (multiplicator) {\n+                    case WEEK:\n+                        refDT = refDT.with(ChronoField.DAY_OF_WEEK, 1);\n+                    case DAY:\n+                        refDT = refDT.with(ChronoField.HOUR_OF_DAY, 0);\n+                    case HOUR:\n+                        refDT = refDT.with(ChronoField.MINUTE_OF_HOUR, 0);\n+                    case MINUTE:\n+                        refDT = refDT.with(ChronoField.SECOND_OF_MINUTE, 0);\n+                }\n+                reference = refDT.toInstant();\n+            }\n+            Instant begin = Instant.EPOCH;\n+            Instant end = Instant.ofEpochMilli(Long.MAX_VALUE);\n+\n+            if (config.datetimeStart != null) {\n+                begin = reference.plusSeconds(config.datetimeStart.longValue() * multiplicator.getMultiplier());\n+            }\n+            if (config.datetimeEnd != null) {\n+                end = reference.plusSeconds(config.datetimeEnd.longValue() * multiplicator.getMultiplier());\n+            }\n+\n+            List<Event> results = cal.getFilteredEventsBetween(begin, end, filter, config.maxEvents.intValue());\n+            for (int position = 0; position < config.maxEvents.intValue(); position++) {\n+                ResultChannelSet channels = resultChannels.get(position);\n+                if (position < results.size()) {\n+                    Event result = results.get(position);\n+                    updateState(channels.titleChannel, new StringType(result.title));\n+                    updateState(channels.beginChannel, new DateTimeType(result.start.atZone(ZoneId.systemDefault())));\n+                    updateState(channels.endChannel, new DateTimeType(result.end.atZone(ZoneId.systemDefault())));\n+                } else {\n+                    updateState(channels.titleChannel, UnDefType.UNDEF);\n+                    updateState(channels.beginChannel, UnDefType.UNDEF);\n+                    updateState(channels.endChannel, UnDefType.UNDEF);\n+                }\n+            }\n+\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+        }\n+\n+        int refreshTime = DEFAULT_FILTER_REFRESH;\n+        if (config.refreshTime != null) {\n+            refreshTime = config.refreshTime.intValue();\n+        }\n+        ScheduledFuture<?> currentUpdateFuture = updateFuture;\n+        if (currentUpdateFuture != null) {\n+            currentUpdateFuture.cancel(true);\n+        }\n+        updateFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            updateStates();\n+        }, refreshTime, refreshTime, TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExMTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/ICalendarHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjozNTo1MVrOHfi5Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNzo0Mjo0M1rOHflT_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTYzNA==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502839634", "createdAt": "2020-10-10T22:35:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/ICalendarHandler.java", "diffHunk": "@@ -162,11 +164,29 @@ public void initialize() {\n     public void onCalendarUpdated() {\n         if (reloadCalendar()) {\n             updateStates();\n+            for (Thing childThing : getThing().getThings()) {\n+                ThingHandler handler = childThing.getHandler();\n+                if (handler instanceof CalendarUpdateListener) {\n+                    try {\n+                        ((CalendarUpdateListener) handler).onCalendarUpdated();\n+                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3OTIzMQ==", "bodyText": "I can't. This catch clause was added for resiliency against failures in other classes inside the callback. Other callbacks should not be affected if a callback fails.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502879231", "createdAt": "2020-10-11T07:42:43Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/handler/ICalendarHandler.java", "diffHunk": "@@ -162,11 +164,29 @@ public void initialize() {\n     public void onCalendarUpdated() {\n         if (reloadCalendar()) {\n             updateStates();\n+            for (Thing childThing : getThing().getThings()) {\n+                ThingHandler handler = childThing.getHandler();\n+                if (handler instanceof CalendarUpdateListener) {\n+                    try {\n+                        ((CalendarUpdateListener) handler).onCalendarUpdated();\n+                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTYzNA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExNDYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjo0MDo1MFrOHfi60w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDo0MTo1M1rOHnx7tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ==", "bodyText": "You could let Event implement Comparable and use Instant.compareTo(), instead of implementing your own compare method.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840019", "createdAt": "2020-10-10T22:40:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3OTYwOA==", "bodyText": "You are right in case the start of the event will stay the data events will be sorted after. I'm not sure, whether this case is enough for future.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502879608", "createdAt": "2020-10-11T07:46:05Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MDQwNQ==", "bodyText": "Sorry, I don't understand your comment.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511360405", "createdAt": "2020-10-24T09:24:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3NDYxNA==", "bodyText": "I thought here into future, as maybe the sorting could also be different. But implementing things partly is bad design, so i'm making Event Comparable.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511474614", "createdAt": "2020-10-24T14:41:53Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDAxOQ=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExNTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjo0MjowNVrOHfi7TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNjo1NzowMVrOHflDjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDE0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            @Nullable", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840140", "createdAt": "2020-10-10T22:42:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+\n+        return results.subList(0, (maximumCount > results.size() ? results.size() : maximumCount));\n+    }\n+\n+    /**\n+     * Finds events which begin in the given frame.\n+     *\n+     * @param frameBegin Begin of the frame where to search events.\n+     * @param frameEnd End of the time frame where to search events.\n+     * @return All events which begin in the time frame.\n+     */\n+    private List<VEventWPeriod> getVEventWPeriodsBetween(Instant frameBegin, Instant frameEnd) {\n+        final List<VEvent> positiveEvents = new ArrayList<>();\n+        final List<VEvent> negativeEvents = new ArrayList<>();\n+        classifyEvents(positiveEvents, negativeEvents);\n+\n+        final List<VEventWPeriod> eventList = new ArrayList<>();\n+        for (final VEvent positiveEvent : positiveEvents) {\n+            final DateIterator positiveBeginDates = getRecurredEventDateIterator(positiveEvent);\n+            positiveBeginDates.advanceTo(Date.from(frameBegin));\n+            while (positiveBeginDates.hasNext()) {\n+                final Instant begInst = positiveBeginDates.next().toInstant();\n+                if (begInst.isAfter(frameEnd)) {\n+                    break;\n+                }\n+                Duration duration = getEventLength(positiveEvent);\n+                if (duration == null) {\n+                    duration = Duration.ZERO;\n+                }\n+\n+                final VEventWPeriod resultingVEWP = new VEventWPeriod(positiveEvent, begInst, begInst.plus(duration));\n+                @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg3NTAyMg==", "bodyText": "OK, doing locally", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502875022", "createdAt": "2020-10-11T06:57:01Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendar.java", "diffHunk": "@@ -167,6 +176,113 @@ public boolean isEventPresent(Instant instant) {\n         return (this.getCurrentComponentWPeriod(instant) != null);\n     }\n \n+    @Override\n+    public List<Event> getFilteredEventsBetween(Instant begin, Instant end, @Nullable EventTextFilter filter,\n+            int maximumCount) {\n+        List<VEventWPeriod> candidates = this.getVEventWPeriodsBetween(begin, end);\n+        final List<Event> results = new ArrayList<>(candidates.size());\n+\n+        if (filter != null) {\n+            Pattern filterPattern;\n+            if (filter.type == Type.TEXT) {\n+                filterPattern = Pattern.compile(\".*\" + Pattern.quote(filter.value) + \".*\",\n+                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+            } else {\n+                filterPattern = Pattern.compile(filter.value);\n+            }\n+\n+            Class<? extends TextProperty> propertyClass;\n+            switch (filter.field) {\n+                case SUMMARY:\n+                    propertyClass = Summary.class;\n+                    break;\n+                case COMMENT:\n+                    propertyClass = Comment.class;\n+                    break;\n+                case CONTACT:\n+                    propertyClass = Contact.class;\n+                    break;\n+                case DESCRIPTION:\n+                    propertyClass = Description.class;\n+                    break;\n+                case LOCATION:\n+                    propertyClass = Location.class;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown Property to filter for.\");\n+            }\n+\n+            List<VEventWPeriod> filteredCandidates = candidates.stream().filter(current -> {\n+                List<? extends TextProperty> properties = current.vEvent.getProperties(propertyClass);\n+                for (TextProperty prop : properties) {\n+                    if (filterPattern.matcher(prop.getValue()).matches()) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }).collect(Collectors.toList());\n+            candidates = filteredCandidates;\n+        }\n+\n+        for (VEventWPeriod eventWPeriod : candidates) {\n+            results.add(eventWPeriod.toEvent());\n+        }\n+\n+        Collections.sort(results, (Event o1, Event o2) -> {\n+            if (o1.start.equals(o2.start)) {\n+                return 0;\n+            } else if (o1.start.isBefore(o2.start)) {\n+                return -1;\n+            } else {\n+                return 1;\n+            }\n+        });\n+\n+        return results.subList(0, (maximumCount > results.size() ? results.size() : maximumCount));\n+    }\n+\n+    /**\n+     * Finds events which begin in the given frame.\n+     *\n+     * @param frameBegin Begin of the frame where to search events.\n+     * @param frameEnd End of the time frame where to search events.\n+     * @return All events which begin in the time frame.\n+     */\n+    private List<VEventWPeriod> getVEventWPeriodsBetween(Instant frameBegin, Instant frameEnd) {\n+        final List<VEvent> positiveEvents = new ArrayList<>();\n+        final List<VEvent> negativeEvents = new ArrayList<>();\n+        classifyEvents(positiveEvents, negativeEvents);\n+\n+        final List<VEventWPeriod> eventList = new ArrayList<>();\n+        for (final VEvent positiveEvent : positiveEvents) {\n+            final DateIterator positiveBeginDates = getRecurredEventDateIterator(positiveEvent);\n+            positiveBeginDates.advanceTo(Date.from(frameBegin));\n+            while (positiveBeginDates.hasNext()) {\n+                final Instant begInst = positiveBeginDates.next().toInstant();\n+                if (begInst.isAfter(frameEnd)) {\n+                    break;\n+                }\n+                Duration duration = getEventLength(positiveEvent);\n+                if (duration == null) {\n+                    duration = Duration.ZERO;\n+                }\n+\n+                final VEventWPeriod resultingVEWP = new VEventWPeriod(positiveEvent, begInst, begInst.plus(duration));\n+                @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDE0MA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExNjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjo0NDozOFrOHfi70g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwODowMToxOVrOHflbsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDI3NA==", "bodyText": "Words in labels should be capitalized (except prepositions and so on). See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840274", "createdAt": "2020-10-10T22:44:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event filter</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4MTIwMw==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502881203", "createdAt": "2020-10-11T08:01:19Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event filter</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDI3NA=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExNzIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjo0NTowNFrOHfi8Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjo0NTowNFrOHfi8Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDMzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" groupName=\"general\">\n          \n          \n            \n            \t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" unit=\"min\" groupName=\"general\">", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840331", "createdAt": "2020-10-10T22:45:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event filter</label>\n+\t\t<description>Filtered Events from the calendar</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter-group name=\"general\">\n+\t\t\t\t<label>General filter options</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"datetime_based\">\n+\t\t\t\t<label>Date and Time based Filter</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"text_based\">\n+\t\t\t\t<label>Text based Filter</label>\n+\t\t\t</parameter-group>\n+\n+\t\t\t<parameter name=\"maxEvents\" type=\"integer\" min=\"0\" groupName=\"general\">\n+\t\t\t\t<label>maximum matches</label>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" groupName=\"general\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0OTExOTM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/test/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendarTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQyMjo0NzoxNVrOHfi89g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMToyMzoxM1rOHfqtNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDU2Ng==", "bodyText": "It's good practice to use one assert per test to see which test fails at the first view.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502840566", "createdAt": "2020-10-10T22:47:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/test/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendarTest.java", "diffHunk": "@@ -542,4 +542,47 @@ public void testCommandTagCode() {\n         assertNotNull(cmd7);\n         assertEquals(QuantityType.class, cmd7.getClass());\n     }\n+\n+    @SuppressWarnings(\"null\")\n+    @Test\n+    public void testGetFilteredEventsBetween() {\n+        Event[] expectedFilteredEvents1 = new Event[] {\n+                new Event(\"Test Series in UTC\", Instant.parse(\"2019-09-12T09:05:00Z\"),\n+                        Instant.parse(\"2019-09-12T09:10:00Z\"), \"\"),\n+                new Event(\"Test Event in UTC+2\", Instant.parse(\"2019-09-14T08:00:00Z\"),\n+                        Instant.parse(\"2019-09-14T09:00:00Z\"), \"\") };\n+        List<Event> realFilteredEvents1 = calendar.getFilteredEventsBetween(Instant.parse(\"2019-09-12T06:00:00Z\"),\n+                Instant.parse(\"2019-09-15T06:00:00Z\"), null, 3);\n+        assertArrayEquals(expectedFilteredEvents1, realFilteredEvents1.toArray(new Event[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4MTAwMQ==", "bodyText": "I do not agree generally. The tests are built currently on each consecutively as we have more context after each assert - to create tests with one assert per test this is not practical, please look into testIsEventPresent() which shows what i mean. Doing this test in the same way is just consequent.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502881001", "createdAt": "2020-10-11T07:59:30Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/test/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendarTest.java", "diffHunk": "@@ -542,4 +542,47 @@ public void testCommandTagCode() {\n         assertNotNull(cmd7);\n         assertEquals(QuantityType.class, cmd7.getClass());\n     }\n+\n+    @SuppressWarnings(\"null\")\n+    @Test\n+    public void testGetFilteredEventsBetween() {\n+        Event[] expectedFilteredEvents1 = new Event[] {\n+                new Event(\"Test Series in UTC\", Instant.parse(\"2019-09-12T09:05:00Z\"),\n+                        Instant.parse(\"2019-09-12T09:10:00Z\"), \"\"),\n+                new Event(\"Test Event in UTC+2\", Instant.parse(\"2019-09-14T08:00:00Z\"),\n+                        Instant.parse(\"2019-09-14T09:00:00Z\"), \"\") };\n+        List<Event> realFilteredEvents1 = calendar.getFilteredEventsBetween(Instant.parse(\"2019-09-12T06:00:00Z\"),\n+                Instant.parse(\"2019-09-15T06:00:00Z\"), null, 3);\n+        assertArrayEquals(expectedFilteredEvents1, realFilteredEvents1.toArray(new Event[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDU2Ng=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NzYwNQ==", "bodyText": "It looked for me that each expectedFilteredEvents* is independet from each other and the asserts could be invoked in arbitrary order. It was only a suggestion.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r502967605", "createdAt": "2020-10-11T21:23:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/test/java/org/openhab/binding/icalendar/internal/logic/BiweeklyPresentableCalendarTest.java", "diffHunk": "@@ -542,4 +542,47 @@ public void testCommandTagCode() {\n         assertNotNull(cmd7);\n         assertEquals(QuantityType.class, cmd7.getClass());\n     }\n+\n+    @SuppressWarnings(\"null\")\n+    @Test\n+    public void testGetFilteredEventsBetween() {\n+        Event[] expectedFilteredEvents1 = new Event[] {\n+                new Event(\"Test Series in UTC\", Instant.parse(\"2019-09-12T09:05:00Z\"),\n+                        Instant.parse(\"2019-09-12T09:10:00Z\"), \"\"),\n+                new Event(\"Test Event in UTC+2\", Instant.parse(\"2019-09-14T08:00:00Z\"),\n+                        Instant.parse(\"2019-09-14T09:00:00Z\"), \"\") };\n+        List<Event> realFilteredEvents1 = calendar.getFilteredEventsBetween(Instant.parse(\"2019-09-12T06:00:00Z\"),\n+                Instant.parse(\"2019-09-15T06:00:00Z\"), null, 3);\n+        assertArrayEquals(expectedFilteredEvents1, realFilteredEvents1.toArray(new Event[0]));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDU2Ng=="}, "originalCommit": {"oid": "8ce9198a9c41bf9b211d15609041e7d9be102036"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzMyNDMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOTowOToxNVrOHnqjxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOTowOToxNVrOHnqjxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1Mzc5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In version 3.0 `calendar` was changed from Thing to Bridge. You need to recreate calendars (or replace `Thing` by `Bridge` in your `.things` file).\n          \n          \n            \n            In OH3 `calendar` was changed from Thing to Bridge. You need to recreate calendars (or replace `Thing` by `Bridge` in your `.things` file).", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511353798", "createdAt": "2020-10-24T09:09:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/README.md", "diffHunk": "@@ -114,3 +165,7 @@ Command tags in a calendar event (in the case that configuration parameter `auth\n BEGIN:Calendar_Test_Switch:ON\n END:Calendar_Test_Switch:OFF\n ```\n+\n+## Breaking changes\n+\n+In version 3.0 `calendar` was changed from Thing to Bridge. You need to recreate calendars (or replace `Thing` by `Bridge` in your `.things` file).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzMyODQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToxMDo0MlrOHnqmUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToxMDo0MlrOHnqmUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM1NDQ1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return null;", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511354450", "createdAt": "2020-10-24T09:10:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/java/org/openhab/binding/icalendar/internal/ICalendarHandlerFactory.java", "diffHunk": "@@ -67,6 +80,17 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n         if (!supportsThingType(thingTypeUID)) {\n             return null;\n         }\n-        return new ICalendarHandler(thing, sharedHttpClient, eventPublisher);\n+        if (thingTypeUID.equals(THING_TYPE_CALENDAR)) {\n+            if (thing instanceof Bridge) {\n+                return new ICalendarHandler((Bridge) thing, sharedHttpClient, eventPublisher, tzProvider);\n+            } else {\n+                logger.warn(\n+                        \"The API of iCalendar has changed. You have to recreate the calendar according to the docs.\");\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzM2OTc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyNjo0MFrOHnrBHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDowMjoyNVrOHnxW2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MTMwOA==", "bodyText": "Did you test the default value in the UI? I guess this should be \"HOUR\".", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511361308", "createdAt": "2020-10-24T09:26:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of Result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of Result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of Result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event Filter</label>\n+\t\t<description>Filtered Events from the calendar</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter-group name=\"general\">\n+\t\t\t\t<label>General Filter Options</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"datetime_based\">\n+\t\t\t\t<label>Date and Time based Filter</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"text_based\">\n+\t\t\t\t<label>Text based Filter</label>\n+\t\t\t</parameter-group>\n+\n+\t\t\t<parameter name=\"maxEvents\" type=\"integer\" min=\"0\" groupName=\"general\">\n+\t\t\t\t<label>Maximum Matches</label>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" groupName=\"general\" unit=\"min\">\n+\t\t\t\t<label>Refresh Time</label>\n+\t\t\t\t<description>The frequency in minutes the channels get refreshed</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeUnit\" type=\"text\" groupName=\"datetime_based\">\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"MINUTE\">minute</option>\n+\t\t\t\t\t<option value=\"HOUR\">hour</option>\n+\t\t\t\t\t<option value=\"DAY\">day</option>\n+\t\t\t\t\t<option value=\"WEEK\">week</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>hour</default>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ2NTE3OQ==", "bodyText": "Yes, you are right, i've changed the constant after the last test. I'll fix it.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511465179", "createdAt": "2020-10-24T14:02:25Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of Result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of Result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of Result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event Filter</label>\n+\t\t<description>Filtered Events from the calendar</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter-group name=\"general\">\n+\t\t\t\t<label>General Filter Options</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"datetime_based\">\n+\t\t\t\t<label>Date and Time based Filter</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"text_based\">\n+\t\t\t\t<label>Text based Filter</label>\n+\t\t\t</parameter-group>\n+\n+\t\t\t<parameter name=\"maxEvents\" type=\"integer\" min=\"0\" groupName=\"general\">\n+\t\t\t\t<label>Maximum Matches</label>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" groupName=\"general\" unit=\"min\">\n+\t\t\t\t<label>Refresh Time</label>\n+\t\t\t\t<description>The frequency in minutes the channels get refreshed</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeUnit\" type=\"text\" groupName=\"datetime_based\">\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"MINUTE\">minute</option>\n+\t\t\t\t\t<option value=\"HOUR\">hour</option>\n+\t\t\t\t\t<option value=\"DAY\">day</option>\n+\t\t\t\t\t<option value=\"WEEK\">week</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>hour</default>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MTMwOA=="}, "originalCommit": {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzM3MTMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOToyNzoyMVrOHnrCAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDowMjozNlrOHnxXBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MTUzNw==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511361537", "createdAt": "2020-10-24T09:27:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of Result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of Result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of Result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event Filter</label>\n+\t\t<description>Filtered Events from the calendar</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter-group name=\"general\">\n+\t\t\t\t<label>General Filter Options</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"datetime_based\">\n+\t\t\t\t<label>Date and Time based Filter</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"text_based\">\n+\t\t\t\t<label>Text based Filter</label>\n+\t\t\t</parameter-group>\n+\n+\t\t\t<parameter name=\"maxEvents\" type=\"integer\" min=\"0\" groupName=\"general\">\n+\t\t\t\t<label>Maximum Matches</label>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" groupName=\"general\" unit=\"min\">\n+\t\t\t\t<label>Refresh Time</label>\n+\t\t\t\t<description>The frequency in minutes the channels get refreshed</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeUnit\" type=\"text\" groupName=\"datetime_based\">\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"MINUTE\">minute</option>\n+\t\t\t\t\t<option value=\"HOUR\">hour</option>\n+\t\t\t\t\t<option value=\"DAY\">day</option>\n+\t\t\t\t\t<option value=\"WEEK\">week</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>hour</default>\n+\t\t\t\t<label>Date or Time Unit for Start and End</label>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeStart\" type=\"integer\" groupName=\"datetime_based\">\n+\t\t\t\t<label>Start</label>\n+\t\t\t\t<description>Start date/time amount to find events relative to \"now\" (inclusive)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeEnd\" type=\"integer\" groupName=\"datetime_based\">\n+\t\t\t\t<label>End</label>\n+\t\t\t\t<description>End date/time amount to find events relative to \"now\" (exclusive)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeRound\" type=\"boolean\" groupName=\"datetime_based\">\n+\t\t\t\t<label>Round to Date/Time unit</label>\n+\t\t\t\t<description>Setting this will round start and end date/time to the unit down (e.g. if unit is day: start and end\n+\t\t\t\t\twill be rounded to 0:00 day time)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"textEventField\" type=\"text\" groupName=\"text_based\">\n+\t\t\t\t<label>Event Field</label>\n+\t\t\t\t<description>iCal field to match</description>\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"SUMMARY\">summary/subject</option>\n+\t\t\t\t\t<option value=\"DESCRIPTION\">description/content</option>\n+\t\t\t\t\t<option value=\"COMMENT\">comment</option>\n+\t\t\t\t\t<option value=\"CONTACT\">contact</option>\n+\t\t\t\t\t<option value=\"LOCATION\">location</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"textEventValue\" type=\"text\" groupName=\"text_based\">\n+\t\t\t\t<label>Event Value</label>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"textValueType\" type=\"text\" groupName=\"text_based\">\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"REGEX\">Regular Expression</option>\n+\t\t\t\t\t<option value=\"TEXT\">Text</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>text</default>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ2NTIyMg==", "bodyText": "As above.", "url": "https://github.com/openhab/openhab-addons/pull/8583#discussion_r511465222", "createdAt": "2020-10-24T14:02:36Z", "author": {"login": "daMihe"}, "path": "bundles/org.openhab.binding.icalendar/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -99,4 +99,113 @@\n \t\t<description>End of the next event in calendar</description>\n \t\t<state readOnly=\"true\"/>\n \t</channel-type>\n+\n+\t<channel-type id=\"result_start\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Start of Result</label>\n+\t\t<description>Start of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_end\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>End of Result</label>\n+\t\t<description>End of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"result_title\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Title of Result</label>\n+\t\t<description>Title of the found result in calendar</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-group-type id=\"result\">\n+\t\t<label>Result Event</label>\n+\t\t<description>A resulting event found by filter</description>\n+\t\t<channels>\n+\t\t\t<channel typeId=\"result_start\" id=\"begin\"/>\n+\t\t\t<channel typeId=\"result_end\" id=\"end\"/>\n+\t\t\t<channel typeId=\"result_title\" id=\"title\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\n+\t<thing-type id=\"eventfilter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"calendar\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Event Filter</label>\n+\t\t<description>Filtered Events from the calendar</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter-group name=\"general\">\n+\t\t\t\t<label>General Filter Options</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"datetime_based\">\n+\t\t\t\t<label>Date and Time based Filter</label>\n+\t\t\t</parameter-group>\n+\t\t\t<parameter-group name=\"text_based\">\n+\t\t\t\t<label>Text based Filter</label>\n+\t\t\t</parameter-group>\n+\n+\t\t\t<parameter name=\"maxEvents\" type=\"integer\" min=\"0\" groupName=\"general\">\n+\t\t\t\t<label>Maximum Matches</label>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshTime\" type=\"integer\" min=\"1\" groupName=\"general\" unit=\"min\">\n+\t\t\t\t<label>Refresh Time</label>\n+\t\t\t\t<description>The frequency in minutes the channels get refreshed</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>15</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeUnit\" type=\"text\" groupName=\"datetime_based\">\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"MINUTE\">minute</option>\n+\t\t\t\t\t<option value=\"HOUR\">hour</option>\n+\t\t\t\t\t<option value=\"DAY\">day</option>\n+\t\t\t\t\t<option value=\"WEEK\">week</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>hour</default>\n+\t\t\t\t<label>Date or Time Unit for Start and End</label>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeStart\" type=\"integer\" groupName=\"datetime_based\">\n+\t\t\t\t<label>Start</label>\n+\t\t\t\t<description>Start date/time amount to find events relative to \"now\" (inclusive)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeEnd\" type=\"integer\" groupName=\"datetime_based\">\n+\t\t\t\t<label>End</label>\n+\t\t\t\t<description>End date/time amount to find events relative to \"now\" (exclusive)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"datetimeRound\" type=\"boolean\" groupName=\"datetime_based\">\n+\t\t\t\t<label>Round to Date/Time unit</label>\n+\t\t\t\t<description>Setting this will round start and end date/time to the unit down (e.g. if unit is day: start and end\n+\t\t\t\t\twill be rounded to 0:00 day time)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"textEventField\" type=\"text\" groupName=\"text_based\">\n+\t\t\t\t<label>Event Field</label>\n+\t\t\t\t<description>iCal field to match</description>\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"SUMMARY\">summary/subject</option>\n+\t\t\t\t\t<option value=\"DESCRIPTION\">description/content</option>\n+\t\t\t\t\t<option value=\"COMMENT\">comment</option>\n+\t\t\t\t\t<option value=\"CONTACT\">contact</option>\n+\t\t\t\t\t<option value=\"LOCATION\">location</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"textEventValue\" type=\"text\" groupName=\"text_based\">\n+\t\t\t\t<label>Event Value</label>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"textValueType\" type=\"text\" groupName=\"text_based\">\n+\t\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"REGEX\">Regular Expression</option>\n+\t\t\t\t\t<option value=\"TEXT\">Text</option>\n+\t\t\t\t</options>\n+\t\t\t\t<default>text</default>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM2MTUzNw=="}, "originalCommit": {"oid": "4b5c42538bdb01bcd05135cb016b450a51885f0c"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4374, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}