{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDA2OTM5", "number": 6785, "title": "[openthermgateway] Initial contribution", "bodyText": "Signed-off-by: Arjen Korevaar a.korevaar@mephix.com\nInitial contribution of the OpenTherm Gateway binding.\nPlease see https://community.openhab.org/t/39160 for more details.", "createdAt": "2020-01-07T14:10:17Z", "url": "https://github.com/openhab/openhab-addons/pull/6785", "merged": true, "mergeCommit": {"oid": "da7b0549bd21e5a496050c1286909540b8d5f495"}, "closed": true, "closedAt": "2020-05-17T17:19:50Z", "author": {"login": "ArjenKorevaar"}, "timelineItems": {"totalCount": 53, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb65kUsAFqTM0MzgzNDU0MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABciOkiMgFqTQxMzE4MTY2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzODM0NTQw", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-343834540", "createdAt": "2020-01-16T11:07:02Z", "commit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "state": "DISMISSED", "comments": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMTowNzowMlrOFeVy8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMjo0MzoxMlrOFeYHFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1ODcwNA==", "bodyText": "Can you put all sentences on a single line. That makes review changes in the future easier.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367358704", "createdAt": "2020-01-16T11:07:02Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# OpenTherm Gateway binding\n+\n+This binding is used to integrate the OpenTherm Gateway into openHAB2. The OpenTherm Gateway is a module designed by Schelte Bron that is connected in between a boiler and a thermostat and communicates using the OpenTherm protocol.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1OTU5OA==", "bodyText": "Our current formatter wraps the feature file, but this is not correct. To avoid problems with feature files all tag information for a single tag needs to be on the same line.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <features name=\"org.openhab.binding.openthermgateway-${project.version}\"\n          \n          \n            \n            <features name=\"org.openhab.binding.openthermgateway-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n          \n      \n    \n    \n  \n\nSame for feature tag below.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367359598", "createdAt": "2020-01-16T11:09:27Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.openthermgateway-${project.version}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MDE1Mg==", "bodyText": "This is generally designed as a Set because that's more efficient in lookup. The list is used to check if a value is present.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367360152", "createdAt": "2020-01-16T11:10:51Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/OpenThermGatewayBindingConstants.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link OpenThermGatewayBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayBindingConstants {\n+\n+    private static final String BINDING_ID = \"openthermgateway\";\n+\n+    // List of all Thing Type UID's\n+    public static final ThingTypeUID MAIN_THING_TYPE = new ThingTypeUID(BINDING_ID, \"otgw\");\n+\n+    // List of all Channel id's\n+    public static final String CHANNEL_SEND_COMMAND = \"sendcommand\";\n+\n+    public static final String CHANNEL_OVERRIDE_SETPOINT_TEMPORARY = \"temperaturetemporary\";\n+    public static final String CHANNEL_OVERRIDE_SETPOINT_CONSTANT = \"temperatureconstant\";\n+    public static final String CHANNEL_OVERRIDE_DHW_SETPOINT = \"overridedhwsetpoint\";\n+    public static final String CHANNEL_ROOM_TEMPERATURE = \"roomtemp\";\n+    public static final String CHANNEL_ROOM_SETPOINT = \"roomsetpoint\";\n+    public static final String CHANNEL_FLOW_TEMPERATURE = \"flowtemp\";\n+    public static final String CHANNEL_RETURN_TEMPERATURE = \"returntemp\";\n+    public static final String CHANNEL_OUTSIDE_TEMPERATURE = \"outsidetemp\";\n+    public static final String CHANNEL_CENTRAL_HEATING_WATER_SETPOINT = \"controlsetpoint\";\n+    public static final String CHANNEL_CENTRAL_HEATING_WATER_PRESSURE = \"waterpressure\";\n+    public static final String CHANNEL_CENTRAL_HEATING_ENABLED = \"ch_enable\";\n+    public static final String CHANNEL_CENTRAL_HEATING_MODE = \"ch_mode\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_TEMPERATURE = \"dhwtemp\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_ENABLED = \"dhw_enable\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_MODE = \"dhw_mode\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_SETPOINT = \"tdhwset\";\n+    public static final String CHANNEL_FLAME = \"flame\";\n+    public static final String CHANNEL_RELATIVE_MODULATION_LEVEL = \"modulevel\";\n+    public static final String CHANNEL_MAXIMUM_MODULATION_LEVEL = \"maxrelmdulevel\";\n+    public static final String CHANNEL_FAULT = \"fault\";\n+    public static final String CHANNEL_SERVICEREQUEST = \"servicerequest\";\n+    public static final String CHANNEL_REMOTE_RESET = \"lockout-reset\";\n+    public static final String CHANNEL_LOW_WATER_PRESSURE = \"lowwaterpress\";\n+    public static final String CHANNEL_GAS_FLAME_FAULT = \"gasflamefault\";\n+    public static final String CHANNEL_AIR_PRESSURE_FAULT = \"airpressfault\";\n+    public static final String CHANNEL_WATER_OVER_TEMP = \"waterovtemp\";\n+    public static final String CHANNEL_OEM_FAULTCODE = \"oemfaultcode\";\n+\n+    public static final List<String> SUPPORTED_CHANNEL_IDS = Arrays.asList(CHANNEL_ROOM_TEMPERATURE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MTM5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<category>temperature</category>\n          \n          \n            \n            \t\t<category>Temperature</category>", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367361398", "createdAt": "2020-01-16T11:14:00Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"openthermgateway\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"roomtemp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Room temperature</label>\n+\t\t<description>Current sensed room temperature</description>\n+\t\t<category>temperature</category>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MjE0OQ==", "bodyText": "Format labels with uppercase characters for each word. There are exceptions, see https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367362149", "createdAt": "2020-01-16T11:15:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"openthermgateway\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"roomtemp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Room temperature</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MjUyMQ==", "bodyText": "Prefer to use UoM types. See https://www.openhab.org/docs/concepts/units-of-measurement.html#implementing-uom\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Temperature</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367362521", "createdAt": "2020-01-16T11:16:51Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/resources/ESH-INF/thing/channels.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"openthermgateway\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"roomtemp\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MzgyOQ==", "bodyText": "Enum convention should all be upper case, and/or use underscore:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Flags,\n          \n          \n            \n                FLAGS,", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367363829", "createdAt": "2020-01-16T11:20:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum DataType {\n+    Flags,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjM2NA==", "bodyText": "Use Java 8 notation:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            scheduler.schedule(new Runnable() {\n          \n          \n            \n            \n          \n          \n            \n                                @Override\n          \n          \n            \n                                public void run() {\n          \n          \n            \n                            scheduler.schedule(() -> {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367366364", "createdAt": "2020-01-16T11:26:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjU3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n          \n          \n            \n                            }, config.connectionRetryInterval, TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367366570", "createdAt": "2020-01-16T11:26:45Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3OTAzMQ==", "bodyText": "Only catch the specific Exception.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367379031", "createdAt": "2020-01-16T11:58:04Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String format, String arg) {\n+        String message = String.format(format, arg);\n+        log(loglevel, message);\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message, Throwable t) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message, t);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message, t);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message, t);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message, t);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message, t);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        try {\n+            disconnect();\n+\n+            logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+            explicitDisconnect = false;\n+\n+            connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+            new Thread(connector).start();\n+\n+            logger.info(\"OpenTherm Gateway connector started\");\n+\n+            return true;\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3OTU2Ng==", "bodyText": "Only log to error if it's a bug. If this exception happens you probably also want to inform the user by setting the thing offline with the exception message.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367379566", "createdAt": "2020-01-16T11:59:16Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String format, String arg) {\n+        String message = String.format(format, arg);\n+        log(loglevel, message);\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message, Throwable t) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message, t);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message, t);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message, t);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message, t);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message, t);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        try {\n+            disconnect();\n+\n+            logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+            explicitDisconnect = false;\n+\n+            connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+            new Thread(connector).start();\n+\n+            logger.info(\"OpenTherm Gateway connector started\");\n+\n+            return true;\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MDM3NA==", "bodyText": "Always log catched exceptions! Do you really need to catch the exception here? I've not seen it in other places, so you should probably remove the catch here.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367380374", "createdAt": "2020-01-16T12:01:30Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MDkxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (int i = 0; i < dataItems.length; i++) {\n          \n          \n            \n                        for (DataItem dataItem: dataItems) {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367380911", "createdAt": "2020-01-16T12:02:53Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MTU2NA==", "bodyText": "Remove this catch", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367381564", "createdAt": "2020-01-16T12:04:20Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MTcxNQ==", "bodyText": "Is this catch needed?", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367381715", "createdAt": "2020-01-16T12:04:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MjQ2NA==", "bodyText": "Don't compare string with !=. But you should check here on instanceof\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (command.toFullString() != \"REFRESH\") {\n          \n          \n            \n                        if (!command instanceof RefreshType) {\n          \n      \n    \n    \n  \n\nYou do need to handle the RefreshType command  by updating the channel with the known (or unknown) value.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367382464", "createdAt": "2020-01-16T12:06:34Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Mjk2Ng==", "bodyText": "Uppercase enum values:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Read,\n          \n          \n            \n                READ,", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367382966", "createdAt": "2020-01-16T12:08:03Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Msg.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum Msg {\n+    Read,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzA3NQ==", "bodyText": "Remove, see other comment.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383075", "createdAt": "2020-01-16T12:08:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayCallback.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface OpenThermGatewayCallback {\n+    public void connecting();\n+\n+    public void connected();\n+\n+    public void disconnected();\n+\n+    public void receiveMessage(Message message);\n+\n+    public void log(LogLevel loglevel, String message);\n+\n+    public void log(LogLevel loglevel, String format, String arg);\n+\n+    public void log(LogLevel loglevel, String format, Throwable t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzMxMw==", "bodyText": "Remove public on interface methods. It's not needed as interface methods are public by convention.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void connecting();\n          \n          \n            \n                void connecting();", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383313", "createdAt": "2020-01-16T12:09:02Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayCallback.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface OpenThermGatewayCallback {\n+    public void connecting();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzUxMQ==", "bodyText": "Remove public, see other comment.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383511", "createdAt": "2020-01-16T12:09:32Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayConnector.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface OpenThermGatewayConnector extends Runnable {\n+    public void sendCommand(GatewayCommand command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Mzc1NA==", "bodyText": "Remove immediate we don't set it on binding components.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.openthermgateway\")\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.openthermgateway\")", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383754", "createdAt": "2020-01-16T12:10:15Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayHandlerFactory.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.handler.OpenThermGatewayHandler;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link OpenThermGatewayHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.openthermgateway\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4NDI5OA==", "bodyText": "Use the timeunit in the variable name so it's easy to see what the unit is:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int COMMAND_RESPONSE_TIME = 100;\n          \n          \n            \n                private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n          \n      \n    \n    \n  \n\nSame for COMMAND_TIMEOUT", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367384298", "createdAt": "2020-01-16T12:11:34Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4NjU1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (int i = 0; i < dataItems.length; i++) {\n          \n          \n            \n                        for (DataItem dataItem: dataItems) {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367386554", "createdAt": "2020-01-16T12:17:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;\n+    private static final int COMMAND_TIMEOUT = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable Socket socket;\n+    private @Nullable BufferedReader reader;\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        try {\n+            callback.log(LogLevel.Info,\n+                    String.format(\"Connecting OpenThermGatewaySocketConnector to %s:%s\", this.ipaddress, this.port));\n+\n+            callback.connecting();\n+\n+            socket = new Socket();\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT);\n+            socket.setSoTimeout(COMMAND_TIMEOUT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            callback.log(LogLevel.Debug, \"OpenThermGatewaySocketConnector connected\");\n+\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+            // Set the OTGW to report every message it receives and transmits\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+            while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                @Nullable\n+                String message = reader.readLine();\n+\n+                if (message != null) {\n+                    handleMessage(message);\n+                } else {\n+                    callback.log(LogLevel.Info, \"Connection closed by OpenTherm Gateway\");\n+                    break;\n+                }\n+            }\n+\n+            callback.log(LogLevel.Debug, \"Stopping OpenThermGatewaySocketConnector\");\n+\n+        } catch (Exception e) {\n+            callback.log(LogLevel.Error, \"An error occured in OpenThermGatewaySocketConnector: %s\", e.getMessage());\n+        } finally {\n+\n+            if (writer != null) {\n+                writer.flush();\n+                writer.close();\n+            }\n+\n+            close(reader);\n+            close(writer);\n+\n+            connected = false;\n+\n+            callback.log(LogLevel.Debug, \"OpenThermGatewaySocketConnector disconnected\");\n+            callback.disconnected();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        callback.log(LogLevel.Debug, \"Stopping OpenThermGatewaySocketConnector\");\n+\n+        stopping = true;\n+\n+        close(socket);\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            callback.log(LogLevel.Debug, \"Sending message: %s\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);\n+        } else {\n+            callback.log(LogLevel.Debug,\n+                    \"Unable to send message: %s. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+            callback.log(LogLevel.Debug, String.format(\"Received command confirmation: %s: %s\", code, value));\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME) {\n+                callback.log(LogLevel.Debug,\n+                        String.format(\"Resending command: %s\", timeAndCommand.getValue().toFullString()));\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            callback.log(LogLevel.Debug, \"Received message: %s, (unknown)\", message);\n+            return;\n+        } else {\n+            callback.log(LogLevel.Debug, String.format(\"Received message: %s, %d %s %s\", message, msg.getID(),\n+                    msg.getCode(), msg.getMessageType().toString()));\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4ODI0NA==", "bodyText": "Uppercase enums:", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367388244", "createdAt": "2020-01-16T12:21:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/MessageType.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum MessageType {\n+    ReadData, // 000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTA2Nw==", "bodyText": "Don't compare strings with ==:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (other != null && this.getID() == other.getID() && (this.getCode() == \"R\" || this.getCode() == \"A\")) {\n          \n          \n            \n                    return other != null && this.getID() == other.getID() && (\"R\".equals(this.getCode()) || \"A\".equals(this.getCode()));\n          \n      \n    \n    \n  \n\nAnd just return the condition.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367389067", "createdAt": "2020-01-16T12:23:28Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;\n+    private MessageType messageType;\n+    private int id;\n+    private String data;\n+\n+    public String getCode() {\n+        return this.code;\n+    }\n+\n+    public MessageType getMessageType() {\n+        return messageType;\n+    }\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public @Nullable String getData(ByteType byteType) {\n+        if (this.data.length() == 4) {\n+            switch (byteType) {\n+                case HighByte:\n+                    return this.data.substring(0, 2);\n+                case LowByte:\n+                    return this.data.substring(2, 4);\n+                case Both:\n+                    return this.data;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean getBit(ByteType byteType, int pos) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            // First parse the hex value to an integer\n+            int parsed = Integer.parseInt(data, 16);\n+\n+            // Then right shift it pos positions so that the required bit is at the front\n+            // and then apply a bitmask of 00000001 (1)\n+            return ((parsed >> pos) & 1) == 1;\n+        }\n+\n+        return false;\n+    }\n+\n+    public int getUInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return Integer.parseInt(data, 16);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return parseSignedInteger(data);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public float getFloat() {\n+        // f8.8, two's complement\n+        @Nullable\n+        String data = getData(ByteType.Both);\n+\n+        if (data != null) {\n+            long value = Long.parseLong(data, 16);\n+\n+            // left padded with zeros\n+            String binary = String.format(\"%16s\", Long.toBinaryString(value)).replace(' ', '0');\n+\n+            if (binary.charAt(0) == '1') {\n+                // negative value\n+\n+                String inverted = invertBinary(binary);\n+\n+                value = Long.parseLong(inverted, 2);\n+                value = value + 1;\n+                value = value * -1;\n+            }\n+\n+            // divide by 2^8 = 256\n+            return (float) value / 256;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public boolean overrides(@Nullable Message other) {\n+        // If the message is a Request sent to the boiler or an Answer returned to the\n+        // thermostat, and it's ID is equal to the previous message, then this is an\n+        // override sent by the OpenTherm Gateway\n+        if (other != null && this.getID() == other.getID() && (this.getCode() == \"R\" || this.getCode() == \"A\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTU4MA==", "bodyText": "Remove TODO.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367389580", "createdAt": "2020-01-16T12:24:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;\n+    private MessageType messageType;\n+    private int id;\n+    private String data;\n+\n+    public String getCode() {\n+        return this.code;\n+    }\n+\n+    public MessageType getMessageType() {\n+        return messageType;\n+    }\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public @Nullable String getData(ByteType byteType) {\n+        if (this.data.length() == 4) {\n+            switch (byteType) {\n+                case HighByte:\n+                    return this.data.substring(0, 2);\n+                case LowByte:\n+                    return this.data.substring(2, 4);\n+                case Both:\n+                    return this.data;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean getBit(ByteType byteType, int pos) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            // First parse the hex value to an integer\n+            int parsed = Integer.parseInt(data, 16);\n+\n+            // Then right shift it pos positions so that the required bit is at the front\n+            // and then apply a bitmask of 00000001 (1)\n+            return ((parsed >> pos) & 1) == 1;\n+        }\n+\n+        return false;\n+    }\n+\n+    public int getUInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return Integer.parseInt(data, 16);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return parseSignedInteger(data);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public float getFloat() {\n+        // f8.8, two's complement\n+        @Nullable\n+        String data = getData(ByteType.Both);\n+\n+        if (data != null) {\n+            long value = Long.parseLong(data, 16);\n+\n+            // left padded with zeros\n+            String binary = String.format(\"%16s\", Long.toBinaryString(value)).replace(' ', '0');\n+\n+            if (binary.charAt(0) == '1') {\n+                // negative value\n+\n+                String inverted = invertBinary(binary);\n+\n+                value = Long.parseLong(inverted, 2);\n+                value = value + 1;\n+                value = value * -1;\n+            }\n+\n+            // divide by 2^8 = 256\n+            return (float) value / 256;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public boolean overrides(@Nullable Message other) {\n+        // If the message is a Request sent to the boiler or an Answer returned to the\n+        // thermostat, and it's ID is equal to the previous message, then this is an\n+        // override sent by the OpenTherm Gateway\n+        if (other != null && this.getID() == other.getID() && (this.getCode() == \"R\" || this.getCode() == \"A\")) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s - %s - %s\", this.code, this.id, this.data);\n+    }\n+\n+    public Message(String code, MessageType messageType, int id, String data) {\n+        this.code = code;\n+        this.messageType = messageType;\n+        this.id = id;\n+        this.data = data;\n+    }\n+\n+    public static @Nullable Message parse(String message) {\n+        if (message.matches(\"[TBRA]{1}[A-F0-9]{8}\")) {\n+\n+            // For now, only parse TBRA codes\n+            String code = message.substring(0, 1);\n+            MessageType messageType = getMessageType(message.substring(1, 3));\n+            int id = Integer.valueOf(message.substring(3, 5), 16);\n+            String data = message.substring(5);\n+\n+            return new Message(code, messageType, id, data);\n+        }\n+\n+        return null;\n+    }\n+\n+    private static MessageType getMessageType(String value) {\n+        // First parse the hex value to an integer\n+        int integer = Integer.parseInt(value, 16);\n+\n+        // Then right shift it 4 bits so that the message type bits are at the front\n+        int shifted = integer >> 4;\n+\n+        // Then mask it with 00000111 (7), so that we only get the first 3 bits,\n+        // effectively cutting off the parity bit.\n+        int cutoff = shifted & 7;\n+\n+        switch (cutoff) {\n+            case 0: // 000\n+                return MessageType.ReadData;\n+            case 1: // 001\n+                return MessageType.WriteData;\n+            case 2: // 010\n+                return MessageType.InvalidData;\n+            case 3: // 011\n+                return MessageType.Reserved;\n+            case 4: // 100\n+                return MessageType.ReadAck;\n+            case 5: // 101\n+                return MessageType.WriteAck;\n+            case 6: // 110\n+                return MessageType.DataInvalid;\n+            case 7: // 111\n+            default:\n+                return MessageType.UnknownDataId;\n+        }\n+    }\n+\n+    private int parseSignedInteger(String data) {\n+        // First parse the hex value to an unsigned integer value\n+        int result = Integer.parseInt(data, 16);\n+\n+        // TODO: more elegant way of determining the bitmask based on the parsed integer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTc4Ng==", "bodyText": "Remove this enum see other comment about logging.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367389786", "createdAt": "2020-01-16T12:25:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/LogLevel.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum LogLevel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDEwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((code == null || code == \"\") && message.length() > 2 && message.charAt(2) == '=') {\n          \n          \n            \n                    if ((code == null || code.isEmpty()) && message.length() > 2 && message.charAt(2) == '=') {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390107", "createdAt": "2020-01-16T12:26:10Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (int i = 0; i < validations.length; i++) {\n+            if (this.message.equals(validations[i])) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public static GatewayCommand parse(String code, String message) throws Exception {\n+        if ((code == null || code == \"\") && message.length() > 2 && message.charAt(2) == '=') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDM3OA==", "bodyText": "Can you make the thrown exception more specific or does a method actual throw Exception?", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390378", "createdAt": "2020-01-16T12:26:50Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (int i = 0; i < validations.length; i++) {\n+            if (this.message.equals(validations[i])) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public static GatewayCommand parse(String code, String message) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDU3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < validations.length; i++) {\n          \n          \n            \n                    for (String validation: validations) {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390576", "createdAt": "2020-01-16T12:27:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (int i = 0; i < validations.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDcwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this.validationSet == null || this.validationSet == \"\") {\n          \n          \n            \n                    if (this.validationSet == null || this.validationSet.isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390700", "createdAt": "2020-01-16T12:27:38Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDk5OA==", "bodyText": "It looks like the fields and methods in the class are not used?", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390998", "createdAt": "2020-01-16T12:28:25Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+    private int id;\n+    private DataItem[] dataItems;\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public void setID(int id) {\n+        this.id = id;\n+    }\n+\n+    public DataItem[] getDataItems() {\n+        return dataItems;\n+    }\n+\n+    public void setDataItem(DataItem[] dataItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTI2OQ==", "bodyText": "Uppercase enum, see other comment.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                HighByte,\n          \n          \n            \n                HIGH_BYTE,", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367391269", "createdAt": "2020-01-16T12:29:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/ByteType.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum ByteType {\n+    HighByte,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTY5Mg==", "bodyText": "This class doesn't seem to add much value. I suggest to remove it. OnOffType can be used as  OnOffType.from(value)", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367391692", "createdAt": "2020-01-16T12:30:19Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/TypeConverter.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+\n+/**\n+ * The {@link TypeConverter} is used to convert simple values to SmartHome types\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TypeConverter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MjE5Ng==", "bodyText": "Please remove this. Don't add custom logging features.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367392196", "createdAt": "2020-01-16T12:31:40Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String format, String arg) {\n+        String message = String.format(format, arg);\n+        log(loglevel, message);\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message, Throwable t) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message, t);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message, t);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message, t);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message, t);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message, t);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message);\n+                break;\n+            default:\n+                break;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5Mjc4Nw==", "bodyText": "Put @nullable annotations inline on fields:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private OpenThermGatewayConfiguration config;\n          \n          \n            \n                private @Nullable OpenThermGatewayConfiguration config;", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367392787", "createdAt": "2020-01-16T12:33:20Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NDE5NQ==", "bodyText": "Currently there are no channels that have a QuantityType so this check is not needed. However I would suggest to make some of the channels with unit UoM (see my other comment). In that case you can do this check. However you need to pass the correct unit to get the value of the command otherwise you might end up with a different unit you expect. For example if it's a temperature unit, but the command contains Fahrenheit you need to get the Celsius value probably. So you need to pass Celcius to get the double value.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367394195", "createdAt": "2020-01-16T12:36:47Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NTczNA==", "bodyText": "Can you catch the specific exception here or add RuntimException\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367395734", "createdAt": "2020-01-16T12:40:51Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;\n+    private static final int COMMAND_TIMEOUT = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable Socket socket;\n+    private @Nullable BufferedReader reader;\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        try {\n+            callback.log(LogLevel.Info,\n+                    String.format(\"Connecting OpenThermGatewaySocketConnector to %s:%s\", this.ipaddress, this.port));\n+\n+            callback.connecting();\n+\n+            socket = new Socket();\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT);\n+            socket.setSoTimeout(COMMAND_TIMEOUT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            callback.log(LogLevel.Debug, \"OpenThermGatewaySocketConnector connected\");\n+\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+            // Set the OTGW to report every message it receives and transmits\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+            while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                @Nullable\n+                String message = reader.readLine();\n+\n+                if (message != null) {\n+                    handleMessage(message);\n+                } else {\n+                    callback.log(LogLevel.Info, \"Connection closed by OpenTherm Gateway\");\n+                    break;\n+                }\n+            }\n+\n+            callback.log(LogLevel.Debug, \"Stopping OpenThermGatewaySocketConnector\");\n+\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NjYyOA==", "bodyText": "Use try-with-resources:\ntry (writer = new PrintWriter(socket.getOutputStream(), true);\n            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\nThen you don't have to call close.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367396628", "createdAt": "2020-01-16T12:43:12Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;\n+    private static final int COMMAND_TIMEOUT = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable Socket socket;\n+    private @Nullable BufferedReader reader;\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        try {\n+            callback.log(LogLevel.Info,\n+                    String.format(\"Connecting OpenThermGatewaySocketConnector to %s:%s\", this.ipaddress, this.port));\n+\n+            callback.connecting();\n+\n+            socket = new Socket();\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT);\n+            socket.setSoTimeout(COMMAND_TIMEOUT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7628cabf0067eac62ce763d8a3457d57685f7766"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjU0NzA1", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-344254705", "createdAt": "2020-01-16T22:18:17Z", "commit": {"oid": "f20e2e88fad33a6e12d8775a655bc1b7684505ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjoxODoxN1rOFepYLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjoxODoxN1rOFepYLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY3OTUzNA==", "bodyText": "This needs to be on the same line as the feature tag.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367679534", "createdAt": "2020-01-16T22:18:17Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.openthermgateway-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-openthermgateway\" description=\"OpenThermGateway Binding\"\n+\t\tversion=\"${project.version}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20e2e88fad33a6e12d8775a655bc1b7684505ac"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTYzOTg0", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-370563984", "createdAt": "2020-03-06T19:15:49Z", "commit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOToxNTo0OVrOFzERgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMDowMzoyNlrOFzF09A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MTcxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable private OpenThermGatewayConfiguration config;\n          \n          \n            \n                 private @Nullable OpenThermGatewayConfiguration config;", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389091715", "createdAt": "2020-03-06T19:15:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MTkxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable private OpenThermGatewayConnector connector;\n          \n          \n            \n                private @Nullable OpenThermGatewayConnector connector;", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389091912", "createdAt": "2020-03-06T19:16:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;\n+\n+    @Nullable private OpenThermGatewayConnector connector;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MjgyNQ==", "bodyText": "I would suggest add a description to your OFFLINE status updates so that users know what is going on", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389092825", "createdAt": "2020-03-06T19:17:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;\n+\n+    @Nullable private OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODg4OQ==", "bodyText": "Don't create unmanaged threads\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    new Thread(connector).start();\n          \n          \n            \n                    scheduler.execute(connector);", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389098889", "createdAt": "2020-03-06T19:30:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;\n+\n+    @Nullable private OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        disconnect();\n+\n+        logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+        explicitDisconnect = false;\n+\n+        connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+        new Thread(connector).start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5OTYyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }     \n          \n          \n            \n                    catch (IOException ex) {\n          \n          \n            \n                    } catch (IOException ex) {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389099628", "createdAt": "2020-03-06T19:32:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMDQ3Nw==", "bodyText": "please put all fields at the top of the class, also make it private if possible", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389110477", "createdAt": "2020-03-06T19:48:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMzQ1OQ==", "bodyText": "I would also flush the writer here to make sure the data gets sent", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389113459", "createdAt": "2020-03-06T19:55:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(), new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzE3Mg==", "bodyText": "So all this code is just for trace logging? If this code is only for logging then separate it out into its own method.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389117172", "createdAt": "2020-03-06T20:03:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(), new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(), msg.getMessageType().toString());\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(msg.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(msg.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(msg.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        state = new DecimalType(msg.getFloat());\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                logger.trace(\"  Data: {} {} {} {}\", dataItem.getID(), dataItem.getSubject(),\n+                    dataItem.getDataType().toString(), state == null ? \"\" : state.toString());\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjI5MDMw", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-374629030", "createdAt": "2020-03-13T21:26:51Z", "commit": {"oid": "d33464a4cd21f907708e5483463e3497bf2f3c3a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMToyNjo1MVrOF2To6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMTo0MjowNlrOF2UK2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ4OTE5NA==", "bodyText": "I'm pretty sure that a handler is disposed before it is removed. So I don't think this code is needed.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392489194", "createdAt": "2020-03-13T21:26:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d33464a4cd21f907708e5483463e3497bf2f3c3a"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MDc5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"OpenTherm Gateway connector started\");\n          \n          \n            \n                    logger.debug(\"OpenTherm Gateway connector started\");", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392490790", "createdAt": "2020-03-13T21:29:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        disconnect();\n+\n+        logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+        explicitDisconnect = false;\n+\n+        connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+\n+        Thread thread = new Thread(connector, \"OpenTherm Gateway Binding - socket listener thread\");\n+        thread.setDaemon(true);\n+        thread.start();\n+\n+        logger.info(\"OpenTherm Gateway connector started\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d33464a4cd21f907708e5483463e3497bf2f3c3a"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MTA4Ng==", "bodyText": "Please try to follow the openHab coding guidlines. Info level logging should generally not be touched by bindings, instead you should use debug or trace. Please go through the other parts of your code and change the logging levels accordingly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Starting OpenTherm Gateway connector\");\n          \n          \n            \n                    logger.debug(\"Starting OpenTherm Gateway connector\");", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392491086", "createdAt": "2020-03-13T21:30:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        disconnect();\n+\n+        logger.info(\"Starting OpenTherm Gateway connector\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d33464a4cd21f907708e5483463e3497bf2f3c3a"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5NTk4OA==", "bodyText": "why is this synchronized?", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392495988", "createdAt": "2020-03-13T21:38:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d33464a4cd21f907708e5483463e3497bf2f3c3a"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5Nzg4MA==", "bodyText": "How would callback be null here? Isn't callback a non-null field?", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392497880", "createdAt": "2020-03-13T21:42:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(), new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);\n+            writer.flush();\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(), msg.getMessageType().toString());\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(msg.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(msg.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(msg.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        state = new DecimalType(msg.getFloat());\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                logger.trace(\"  Data: {} {} {} {}\", dataItem.getID(), dataItem.getSubject(),\n+                    dataItem.getDataType().toString(), state == null ? \"\" : state.toString());\n+            }\n+        }\n+\n+        if (msg.getMessageType() == MessageType.READACK || msg.getMessageType() == MessageType.WRITEDATA) {\n+            receiveMessage(msg);\n+        }\n+    }\n+\n+    private void receiveMessage(Message message) {\n+        if (message != null && callback != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d33464a4cd21f907708e5483463e3497bf2f3c3a"}, "originalPosition": 206}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDQzNTQy", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-400443542", "createdAt": "2020-04-26T00:25:30Z", "commit": {"oid": "b0e3aae47d72c05e1555409743adb681ba3cc485"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMDoyNTozMFrOGL8UOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMDoyNjoxN1rOGL8U4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTczOA==", "bodyText": "Please move final fields above the non-final ones.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r415175738", "createdAt": "2020-04-26T00:25:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0e3aae47d72c05e1555409743adb681ba3cc485"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTkwNg==", "bodyText": "Can you make these final?", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r415175906", "createdAt": "2020-04-26T00:26:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0e3aae47d72c05e1555409743adb681ba3cc485"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjI4MDU3", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-405228057", "createdAt": "2020-05-04T18:12:42Z", "commit": {"oid": "72c5235f250106cb1957e92bf42fe74ec10b2e06"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxODoxMjo0MlrOGQMLdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxODozMjo0NVrOGQM6yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyOTk0MQ==", "bodyText": "Is \"\" a valid gateway code? If not maybe you should allow this method to return null instead.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419629941", "createdAt": "2020-05-04T18:12:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (conf != null && !explicitDisconnect && conf.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (conn != null && !connecting && !conn.isConnected()) {\n+                    connect();\n+                }\n+            }, conf.connectionRetryInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable\n+                        Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        if (conn != null && conn.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private boolean connect() {\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        disconnect();\n+\n+        if (conf != null) {\n+            logger.debug(\"Starting OpenTherm Gateway connector\");\n+\n+            explicitDisconnect = false;\n+\n+            connector = new OpenThermGatewaySocketConnector(this, conf.ipaddress, conf.port);\n+\n+            Thread thread = new Thread(connector, \"OpenTherm Gateway Binding - socket listener thread\");\n+            thread.setDaemon(true);\n+            thread.start();\n+\n+            logger.debug(\"OpenTherm Gateway connector started\");\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private void disconnect() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        if (conn != null) {\n+            if (conn.isConnected()) {\n+                logger.debug(\"Stopping OpenTherm Gateway connector\");\n+\n+                explicitDisconnect = true;\n+                conn.stop();\n+            }\n+\n+            connector = null;\n+        }\n+    }\n+\n+    private String getGatewayCodeFromChannel(String channel) throws IllegalArgumentException {\n+        switch (channel) {\n+            case OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_SETPOINT_TEMPORARY:\n+                return GatewayCommandCode.TemperatureTemporary;\n+            case OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_SETPOINT_CONSTANT:\n+                return GatewayCommandCode.TemperatureConstant;\n+            case OpenThermGatewayBindingConstants.CHANNEL_OUTSIDE_TEMPERATURE:\n+                return GatewayCommandCode.TemperatureOutside;\n+            case OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_DHW_SETPOINT:\n+                return GatewayCommandCode.SetpointWater;\n+            case OpenThermGatewayBindingConstants.CHANNEL_SEND_COMMAND:\n+                return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c5235f250106cb1957e92bf42fe74ec10b2e06"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzMDgwMw==", "bodyText": "Please put static fields at the top of the class", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419630803", "createdAt": "2020-05-04T18:14:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws IllegalArgumentException {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet.isEmpty()) {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (String validation : validations) {\n+            if (this.message.equals(validation)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public static GatewayCommand parse(String code, String message) throws IllegalArgumentException {\n+        if (code.isEmpty() && message.length() > 2 && message.charAt(2) == '=') {\n+            return parse(message.substring(0, 2), message.substring(3));\n+        }\n+\n+        if (code.length() == 2) {\n+            String codeUpperCase = code.toUpperCase();\n+\n+            if (supportedCommands.containsKey(codeUpperCase)) {\n+                String validateSet = supportedCommands.get(codeUpperCase);\n+\n+                if (validateSet == null) {\n+                    validateSet = \"\";\n+                }\n+\n+                return new GatewayCommand(codeUpperCase, message, validateSet);\n+            } else {\n+                throw new IllegalArgumentException(String.format(\"Unsupported gateway code '%s'\", code.toUpperCase()));\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\n+                String.format(\"Unable to parse gateway command with code '%s' and message '%s'\", code, message));\n+    }\n+\n+    private static final HashMap<String, @Nullable String> supportedCommands = getSupportedCommands();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c5235f250106cb1957e92bf42fe74ec10b2e06"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzOTE3NA==", "bodyText": "This code will never get called because you compare the time against the smallest value first.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419639174", "createdAt": "2020-05-04T18:28:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c5235f250106cb1957e92bf42fe74ec10b2e06"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjA1OQ==", "bodyText": "This field will be used by multiple threads, so make it thread-safe.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n          \n          \n            \n                private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419642059", "createdAt": "2020-05-04T18:32:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72c5235f250106cb1957e92bf42fe74ec10b2e06"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NzcxMDIy", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-406771022", "createdAt": "2020-05-06T16:12:45Z", "commit": {"oid": "a33f865e7aad7625f337fbb8f9f78f057f4d8180"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMDoxNzozOFrOGRp5pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDoxMDozN1rOGRttLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTQ3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                msg.getMessageType().toString());\n          \n          \n            \n                                msg.getMessageType());", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421165477", "createdAt": "2020-05-07T00:17:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            long responseTime = timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS;\n+            long timeoutTime = timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS;\n+\n+            if (currentTime > responseTime && currentTime <= timeoutTime) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (currentTime > timeoutTime) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(),\n+                    msg.getMessageType().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a33f865e7aad7625f337fbb8f9f78f057f4d8180"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTYyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    dataItem.getDataType().toString(), state == null ? \"\" : state.toString());\n          \n          \n            \n                                    dataItem.getDataType(), state == null ? \"\" : state);", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421165626", "createdAt": "2020-05-07T00:18:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            long responseTime = timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS;\n+            long timeoutTime = timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS;\n+\n+            if (currentTime > responseTime && currentTime <= timeoutTime) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (currentTime > timeoutTime) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(),\n+                    msg.getMessageType().toString());\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(msg.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(msg.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(msg.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        state = new DecimalType(msg.getFloat());\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                logger.trace(\"  Data: {} {} {} {}\", dataItem.getID(), dataItem.getSubject(),\n+                        dataItem.getDataType().toString(), state == null ? \"\" : state.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a33f865e7aad7625f337fbb8f9f78f057f4d8180"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNzgyMg==", "bodyText": "The writer is synchronized under the hood so you can't really split this up into two method calls. That said, you don't need to use printf for something this simple.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            wrtr.printf(\"%s\\r\\n\", msg);\n          \n          \n            \n                            wrtr.print(msg+\"\\r\\n\");", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421227822", "createdAt": "2020-05-07T04:10:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a33f865e7aad7625f337fbb8f9f78f057f4d8180"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Njc2MTcz", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-407676173", "createdAt": "2020-05-07T17:16:13Z", "commit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NjE3MjA2", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-408617206", "createdAt": "2020-05-09T06:20:35Z", "commit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNjoyMDozNlrOGS40ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNjo0NjowMFrOGS474g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODUwNg==", "bodyText": "Leave out the 2 of openHAB please check for other occurrences on the README as well.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422458506", "createdAt": "2020-05-09T06:20:36Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/README.md", "diffHunk": "@@ -0,0 +1,144 @@\n+# OpenTherm Gateway binding\n+\n+This binding is used to integrate the OpenTherm Gateway into openHAB2.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODU3Ng==", "bodyText": "Mine was too far from my openHAB instance I have it directly connected via MQTT now :-)\nNever mind, I didn't realize it was serial over TCP :-)", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422458576", "createdAt": "2020-05-09T06:21:30Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/README.md", "diffHunk": "@@ -0,0 +1,144 @@\n+# OpenTherm Gateway binding\n+\n+This binding is used to integrate the OpenTherm Gateway into openHAB2.\n+The OpenTherm Gateway is a module designed by Schelte Bron that is connected in between a boiler and a thermostat and communicates using the OpenTherm protocol.\n+\n+More information on the OpenTherm Gateway device can be found at http://otgw.tclcode.com/\n+\n+Comments on this binding can be submitted to the openHAB community topic at https://community.openhab.org/t/39160\n+\n+## Supported Things\n+\n+The OpenTherm Gateway binding currently only supports one thing, and that's the gateway itself.\n+\n+## Discovery\n+\n+The binding does not support auto discovery.\n+\n+## Binding Configuration\n+\n+The binding itself does not require any configuration.\n+\n+## Thing Configuration\n+\n+The binding is designed to support various ways of connecting to the OpenTherm Gateway device, but currently only supports a TCP socket connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODc4MQ==", "bodyText": "I personally would write this as kind of a pre-condition check so that the rest of the method does not need that much indentation:\nif (command instanceof RefreshType) {\n   return;\n}\n\n... rest of the code", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422458781", "createdAt": "2020-05-09T06:23:55Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTAwMg==", "bodyText": "Does connecting mean that is not connected? Or should it just be UKNOWN? The status which we talk about is the status of actual thing not of the connection.\nSo if you connected you know its ONLINE, if you fail to connect you can assume its OFFLINE or that there is some configuration error. But if you haven't tried you can nog know whether the thing is OFFLINE.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459002", "createdAt": "2020-05-09T06:26:46Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTA1Nw==", "bodyText": "See below", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459057", "createdAt": "2020-05-09T06:27:41Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTM1OQ==", "bodyText": "Is the normal String enough? If so please just pass the state. Otherways you will also call the toFullString when debug-levels do not apply.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459359", "createdAt": "2020-05-09T06:31:26Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (conf != null && !explicitDisconnect && conf.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (conn != null && !connecting && !conn.isConnected()) {\n+                    connect();\n+                }\n+            }, conf.connectionRetryInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable\n+                        Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTUxNw==", "bodyText": "It seems that a lot of these fields can be marked final I would always prefer to make class level fields explicitly final when possible.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459517", "createdAt": "2020-05-09T06:33:42Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItem.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItem {\n+    private int id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTU2MA==", "bodyText": "Please make sure that you document for all classes their purpose, see also https://www.openhab.org/docs/developer/guidelines.html#c-documentation", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459560", "createdAt": "2020-05-09T06:34:25Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItem.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTY3Nw==", "bodyText": "Please use the interface instead of the actual implementation for declarations and return values.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n          \n          \n            \n                public static final Map<Integer, DataItem[]> dataItemGroups = createDataItemGroups();", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459677", "createdAt": "2020-05-09T06:35:46Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTcyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static HashMap<Integer, DataItem[]> createDataItemGroups() {\n          \n          \n            \n                private static Map<Integer, DataItem[]> createDataItemGroups() {", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459722", "createdAt": "2020-05-09T06:36:21Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n+\n+    private static HashMap<Integer, DataItem[]> createDataItemGroups() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTczOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HashMap<Integer, DataItem[]> g = new HashMap<Integer, DataItem[]>();\n          \n          \n            \n                    Map<Integer, DataItem[]> g = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459738", "createdAt": "2020-05-09T06:36:35Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n+\n+    private static HashMap<Integer, DataItem[]> createDataItemGroups() {\n+        HashMap<Integer, DataItem[]> g = new HashMap<Integer, DataItem[]>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTc3Nw==", "bodyText": "Please use the diamond operator, ie replace the second occurrence of the same generic by <> please also check for other occurrences.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459777", "createdAt": "2020-05-09T06:37:15Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n+\n+    private static HashMap<Integer, DataItem[]> createDataItemGroups() {\n+        HashMap<Integer, DataItem[]> g = new HashMap<Integer, DataItem[]>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTczOA=="}, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTgxNQ==", "bodyText": "Please check for other occurrences", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459815", "createdAt": "2020-05-09T06:37:42Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private static final HashMap<String, @Nullable String> supportedCommands = getSupportedCommands();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTg3NQ==", "bodyText": "Consider marking these fields final", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459875", "createdAt": "2020-05-09T06:38:28Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private static final HashMap<String, @Nullable String> supportedCommands = getSupportedCommands();\n+\n+    private String code;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTkwMg==", "bodyText": "Please check others", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459902", "createdAt": "2020-05-09T06:38:53Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDAyMA==", "bodyText": "If this part of the code is used often it might make sense to compile a pattern once (and store as a static field) and re-use this every time, see also https://stackoverflow.com/a/2469275/3656774", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422460020", "createdAt": "2020-05-09T06:40:45Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;\n+    private MessageType messageType;\n+    private int id;\n+    private String data;\n+\n+    public String getCode() {\n+        return this.code;\n+    }\n+\n+    public MessageType getMessageType() {\n+        return messageType;\n+    }\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public @Nullable String getData(ByteType byteType) {\n+        if (this.data.length() == 4) {\n+            switch (byteType) {\n+                case HIGHBYTE:\n+                    return this.data.substring(0, 2);\n+                case LOWBYTE:\n+                    return this.data.substring(2, 4);\n+                case BOTH:\n+                    return this.data;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean getBit(ByteType byteType, int pos) {\n+        @Nullable String data = getData(byteType);\n+\n+        if (data != null) {\n+            // First parse the hex value to an integer\n+            int parsed = Integer.parseInt(data, 16);\n+\n+            // Then right shift it pos positions so that the required bit is at the front\n+            // and then apply a bitmask of 00000001 (1)\n+            return ((parsed >> pos) & 1) == 1;\n+        }\n+\n+        return false;\n+    }\n+\n+    public int getUInt(ByteType byteType) {\n+        @Nullable String data = getData(byteType);\n+\n+        if (data != null) {\n+            return Integer.parseInt(data, 16);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getInt(ByteType byteType) {\n+        @Nullable String data = getData(byteType);\n+\n+        if (data != null) {\n+            return parseSignedInteger(data);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public float getFloat() {\n+        // f8.8, two's complement\n+        @Nullable String data = getData(ByteType.BOTH);\n+\n+        if (data != null) {\n+            long value = Long.parseLong(data, 16);\n+\n+            // left padded with zeros\n+            String binary = String.format(\"%16s\", Long.toBinaryString(value)).replace(' ', '0');\n+\n+            if (binary.charAt(0) == '1') {\n+                // negative value\n+\n+                String inverted = invertBinary(binary);\n+\n+                value = Long.parseLong(inverted, 2);\n+                value = value + 1;\n+                value = value * -1;\n+            }\n+\n+            // divide by 2^8 = 256\n+            return (float) value / 256;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public boolean overrides(@Nullable Message other) {\n+        // If the message is a Request sent to the boiler or an Answer returned to the\n+        // thermostat, and it's ID is equal to the previous message, then this is an\n+        // override sent by the OpenTherm Gateway\n+        return other != null && this.getID() == other.getID() && (\"R\".equals(this.getCode()) || \"A\".equals(this.getCode()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s - %s - %s\", this.code, this.id, this.data);\n+    }\n+\n+    public Message(String code, MessageType messageType, int id, String data) {\n+        this.code = code;\n+        this.messageType = messageType;\n+        this.id = id;\n+        this.data = data;\n+    }\n+\n+    public static @Nullable Message parse(String message) {\n+        if (message.matches(\"[TBRA]{1}[A-F0-9]{8}\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDIzMw==", "bodyText": "You could consider the following to make the second boundary more explicit.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n          \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = 5_000;\n          \n      \n    \n    \n  \n\nOr even more explicit, however for such a small value both are optional.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n          \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = TimeUnit.SECONDS.toMillis(5);", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422460233", "createdAt": "2020-05-09T06:43:49Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDM4Ng==", "bodyText": "You don't have to call toString it will be called automatically, but only when the logging-level actually applies.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422460386", "createdAt": "2020-05-09T06:46:00Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.print(msg + \"\\r\\n\");\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            long responseTime = timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS;\n+            long timeoutTime = timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS;\n+\n+            if (currentTime > responseTime && currentTime <= timeoutTime) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103"}, "originalPosition": 165}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f4ff85ec82f7cd045cbc7afa5ad7d6c7dbceeb0", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/3f4ff85ec82f7cd045cbc7afa5ad7d6c7dbceeb0", "committedDate": "2020-05-17T11:44:43Z", "message": "Initial contribution\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbfa86beb01e2ed4acd7969cdbf0ea9d7d82f8ef", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/cbfa86beb01e2ed4acd7969cdbf0ea9d7d82f8ef", "committedDate": "2020-05-17T11:44:43Z", "message": "Update parent module version to 2.5.2-SNAPSHOT\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b1ede2a6450cf02d5e64592a847ca3662c3b53c", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/0b1ede2a6450cf02d5e64592a847ca3662c3b53c", "committedDate": "2020-05-17T11:44:43Z", "message": "Added openthermgateway\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f7cbc8efe2cbb8c78fd80474ef38769f8032a3d", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/1f7cbc8efe2cbb8c78fd80474ef38769f8032a3d", "committedDate": "2020-05-17T11:44:43Z", "message": "Review (#1)\n\n* Each sentence on a new line\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed newline added by code formatter\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Every word of label Uppercase\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed enums to uppercase\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed milliseconds to seconds\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed try catch on updating channel\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed for to foreach\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed public from interface methods\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed immediate\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Added MILLISECONDS to time interval statics\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed for to foreach\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Typo\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed == to equals on string comparison\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed TODO\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed == \"\" to isEmpty()\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed for to foreach\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed TypeConverter\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed newline after @Nullable\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21ba1500b317c036d39b160ba29578d05848a715", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/21ba1500b317c036d39b160ba29578d05848a715", "committedDate": "2020-05-17T11:44:43Z", "message": "Changed List to Set\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dd2016c926678c7d6b858a4347265a7583b36c4", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/2dd2016c926678c7d6b858a4347265a7583b36c4", "committedDate": "2020-05-17T11:44:43Z", "message": "Changed notation to start runnable\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc6b9387555d10202eb34ced0cd35e25564946f2", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/bc6b9387555d10202eb34ced0cd35e25564946f2", "committedDate": "2020-05-17T11:44:43Z", "message": "Removed (some occurences of) catching generic exceptions\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99dff96d2e1cf66082bd2067b209abec3cd7af06", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/99dff96d2e1cf66082bd2067b209abec3cd7af06", "committedDate": "2020-05-17T11:44:43Z", "message": "Removed some unused import statements\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6003d49c7acd8b937eb8b642417a2512738b94ff", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/6003d49c7acd8b937eb8b642417a2512738b94ff", "committedDate": "2020-05-17T11:44:44Z", "message": "Removed newline from feature.xml\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2e66bb9838bfc21ac4acf458c3b99391651ce63", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/e2e66bb9838bfc21ac4acf458c3b99391651ce63", "committedDate": "2020-05-17T11:44:44Z", "message": "Applies UoM to temperature and pressure channels\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d15bc601f60337e8f81e11c965632495ef8490c", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/5d15bc601f60337e8f81e11c965632495ef8490c", "committedDate": "2020-05-17T11:44:44Z", "message": "Changes to UoM\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2e1c958545549a866caa688f123d1fbe5e63a96", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/d2e1c958545549a866caa688f123d1fbe5e63a96", "committedDate": "2020-05-17T11:44:44Z", "message": "Removed logging callback and let connector log directly\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3a9b8067d301665a627dddb447ceb4e440a1c44", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/a3a9b8067d301665a627dddb447ceb4e440a1c44", "committedDate": "2020-05-17T11:44:44Z", "message": "Added tr-with-resources and removed throwing and catching generic exceptions\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7826ccfc22ab7175f0d30ae1df356b3960cf6fd4", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/7826ccfc22ab7175f0d30ae1df356b3960cf6fd4", "committedDate": "2020-05-17T11:44:44Z", "message": "Removed placeholder from logging string\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32ed6f49d518d700239461712b3b32ed1b81c86d", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/32ed6f49d518d700239461712b3b32ed1b81c86d", "committedDate": "2020-05-17T11:44:44Z", "message": "Removed unused attributes and setters from DataItem and DataItemGroup\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a2f1cf990563ba11bb610e479f9cf8569116e56", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/4a2f1cf990563ba11bb610e479f9cf8569116e56", "committedDate": "2020-05-17T11:44:44Z", "message": "Formatting\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40bcd2646c5e8bbd8da7bdfe228eecdc50630c0e", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/40bcd2646c5e8bbd8da7bdfe228eecdc50630c0e", "committedDate": "2020-05-17T11:44:44Z", "message": "Changed some log levels\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d25f0d72e398529efc062d193eaedceec95ed96", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/0d25f0d72e398529efc062d193eaedceec95ed96", "committedDate": "2020-05-17T11:44:44Z", "message": "Added explicit call to flush\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "535f5d1227450b96137c1ceed5d6bd4f373c7592", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/535f5d1227450b96137c1ceed5d6bd4f373c7592", "committedDate": "2020-05-17T11:44:44Z", "message": "Fixed some layout errors\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4d2bfd2fcb3b29dd05b246a2c84bbe1e9f216c8", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/f4d2bfd2fcb3b29dd05b246a2c84bbe1e9f216c8", "committedDate": "2020-05-17T11:44:44Z", "message": "Added description to ThingStatus offline\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f27de9d0833f113c5bdae57c5e9e60d356c6120e", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/f27de9d0833f113c5bdae57c5e9e60d356c6120e", "committedDate": "2020-05-17T11:44:44Z", "message": "Moved pendingCommands field to top and made private\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "940c0985b939261f81c772f677ea829a4b41a83a", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/940c0985b939261f81c772f677ea829a4b41a83a", "committedDate": "2020-05-17T11:44:45Z", "message": "Updated pom to 2.5.3\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d314b59d0c6708fadfd0576aa20eca3cce2e105", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/7d314b59d0c6708fadfd0576aa20eca3cce2e105", "committedDate": "2020-05-17T11:44:45Z", "message": "Named socket listener thread and set to daemon mode\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "550abf0f6ac5feafd97aba9a916d036e4aa5ead5", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/550abf0f6ac5feafd97aba9a916d036e4aa5ead5", "committedDate": "2020-05-17T11:44:45Z", "message": "Changed info to debug logging, removed synchronized\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "244fdbfbfefc89cd95747c83c529acf7a1d216aa", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/244fdbfbfefc89cd95747c83c529acf7a1d216aa", "committedDate": "2020-05-17T11:44:45Z", "message": "Updated pom.xml to 2.5.5-SNAPSHOT\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9303b87ad1b3fbf8d599a7133ade75cae35a04f0", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/9303b87ad1b3fbf8d599a7133ade75cae35a04f0", "committedDate": "2020-05-17T11:44:45Z", "message": "Made variables final and moved them above non-final\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7a9ef7fbfbb0b88ede6d3c8a464b084a66e65e6", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/f7a9ef7fbfbb0b88ede6d3c8a464b084a66e65e6", "committedDate": "2020-05-17T11:44:45Z", "message": "Fixed potential null warnings\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37e483f0f41134d570904cf9b8da312f76faf2fb", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/37e483f0f41134d570904cf9b8da312f76faf2fb", "committedDate": "2020-05-17T11:44:45Z", "message": "Moved static field to top of the class\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e84b7d1ec8a5b0a782b25f8c3101d85355823c3e", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/e84b7d1ec8a5b0a782b25f8c3101d85355823c3e", "committedDate": "2020-05-17T11:44:45Z", "message": "Return null instead of empty string\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45441bad99587a2089460d5faca9a49686f5051c", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/45441bad99587a2089460d5faca9a49686f5051c", "committedDate": "2020-05-17T11:44:46Z", "message": "Changed check on resend and timeout commands\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e493f47fd02a581b2acc5eb23bbb188eaecd196e", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/e493f47fd02a581b2acc5eb23bbb188eaecd196e", "committedDate": "2020-05-17T11:44:46Z", "message": "Made pendingCommands hashmap thread-safe\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16a5c94678bf41760ea84ef9232f728c75fb2954", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/16a5c94678bf41760ea84ef9232f728c75fb2954", "committedDate": "2020-05-17T11:44:46Z", "message": "Removed explicit calls to toString()\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d11097e996d6815e85de94ae28a50a7e61b53386", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/d11097e996d6815e85de94ae28a50a7e61b53386", "committedDate": "2020-05-17T11:44:46Z", "message": "Changed printf() to print()\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa2be59b68ac09304a41aa72882ca2ff15e28129", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/aa2be59b68ac09304a41aa72882ca2ff15e28129", "committedDate": "2020-05-17T11:44:46Z", "message": "Changed to use interface instead of implementation\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d785df55f12efb62d88d8c6971ab54bda4f57e", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/76d785df55f12efb62d88d8c6971ab54bda4f57e", "committedDate": "2020-05-17T11:44:46Z", "message": "Changed readme\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36f8a910cccfa07c24bd2fe36fc529bde9432502", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/36f8a910cccfa07c24bd2fe36fc529bde9432502", "committedDate": "2020-05-17T11:44:46Z", "message": "Precompile matching pattern\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7f77d72c7cf2073b87d1122331c5e0ca97dad26", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/f7f77d72c7cf2073b87d1122331c5e0ca97dad26", "committedDate": "2020-05-17T11:44:46Z", "message": "Added JavaDoc\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "766a0e5159df21696dedf42c4c1f437fd19112e2", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/766a0e5159df21696dedf42c4c1f437fd19112e2", "committedDate": "2020-05-17T11:44:46Z", "message": "Changed OFFLINE to UNKNOWN status upon connecting\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2f002c5f4d5d6d717c8a9ba7ee71088663e4478", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/f2f002c5f4d5d6d717c8a9ba7ee71088663e4478", "committedDate": "2020-05-17T11:44:46Z", "message": "Removed toFullString() to prevent unnecessary calls depending on loglevel\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b58f2ac460fdeade42b65b3858f15510c3bce7b1", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/b58f2ac460fdeade42b65b3858f15510c3bce7b1", "committedDate": "2020-05-17T11:46:18Z", "message": "Changed parent version to 2.5.6\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTU0MzY3", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-413154367", "createdAt": "2020-05-17T11:48:14Z", "commit": {"oid": "4f6c35c546d6445e2c197e5f3d839f738aea8341"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxMTo1MDoxN1rOGWgXTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxMjo0MTo0NFrOGWgqYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjEwOA==", "bodyText": "This status might not be correct, because it's about the binding status being disconnected instead of the thing being OFFLINE.\nAlso, it is indirectly called from the dispose which will also be called when updating configuration, so better leave this one out and replace it by some way to update status when IOException are caught.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426252108", "createdAt": "2020-05-17T11:50:17Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b58f2ac460fdeade42b65b3858f15510c3bce7b1"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjQwMw==", "bodyText": "This is location where can you be sure that the device is ONLINE, if you are unsure that the status is currently sufficiently synchronized this could be the location to mark the thing ONLINE.", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426252403", "createdAt": "2020-05-17T11:53:33Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (conf != null && !explicitDisconnect && conf.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (conn != null && !connecting && !conn.isConnected()) {\n+                    connect();\n+                }\n+            }, conf.connectionRetryInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b58f2ac460fdeade42b65b3858f15510c3bce7b1"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Njk5NQ==", "bodyText": "I would expect an update of status from this IOException because now disconnect is called but the proper details of the problem are lacking. See also: https://www.openhab.org/docs/developer/guidelines.html#f-logging\n\nIn general bindings should NOT log to error/warn if e.g. connections are dropped - this is considered to be an external problem and from a system perspective to be a normal and expected situation. The correct way to inform users about such events is to update the Thing status accordingl", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426256995", "createdAt": "2020-05-17T12:41:44Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b58f2ac460fdeade42b65b3858f15510c3bce7b1"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8822e46eb435f89bdd4f1b31fdf79d2a7227cb42", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/8822e46eb435f89bdd4f1b31fdf79d2a7227cb42", "committedDate": "2020-05-17T15:28:49Z", "message": "Changed Thing status updates\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb1bb1de0e9d893eb1c7a23660f3d56a9eec9849", "author": {"user": {"login": "ArjenKorevaar", "name": "Arjen Korevaar"}}, "url": "https://github.com/openhab/openhab-addons/commit/eb1bb1de0e9d893eb1c7a23660f3d56a9eec9849", "committedDate": "2020-05-17T16:41:09Z", "message": "Revert \"Changed Thing status updates\"\n\nThis reverts commit 8822e46eb435f89bdd4f1b31fdf79d2a7227cb42.\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTgxNjY2", "url": "https://github.com/openhab/openhab-addons/pull/6785#pullrequestreview-413181666", "createdAt": "2020-05-17T17:18:05Z", "commit": {"oid": "eb1bb1de0e9d893eb1c7a23660f3d56a9eec9849"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1570, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}