{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5Mjg5ODgw", "number": 8851, "reviewThreads": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDozMToyNVrOE0Ibgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDoxODoyMlrOE5NMTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDk5NTIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDozMToyNVrOHrt_TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDozMToyNVrOHrt_TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNDMwMQ==", "bodyText": "Please start each sentence on a new line. This makes reviewing later changes much easier.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515604301", "createdAt": "2020-11-01T10:31:25Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,137 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. The binding does not support any particular serial protocols", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDk5NTg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDozMjowNlrOHrt_mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDozMjowNlrOHrt_mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNDM3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            by performing a patterm match on the received data. For example, a Serial Device could be configured to represent a temperature sensor.\n          \n          \n            \n            by performing a pattern match on the received data. For example, a Serial Device could be configured to represent a temperature sensor.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515604377", "createdAt": "2020-11-01T10:32:06Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,137 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. The binding does not support any particular serial protocols\n+and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. Sending a command to this channel\n+sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. The serial port\n+may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. Usually such devices can be indentified \n+by performing a patterm match on the received data. For example, a Serial Device could be configured to represent a temperature sensor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAwMDE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDozNzo1NVrOHruBqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzoxMzo1MVrOHsN59g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNDkwNw==", "bodyText": "Why not use system.trigger? I think there is no use for the payload, if it's always PRESSED", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515604907", "createdAt": "2020-11-01T10:37:55Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,137 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. The binding does not support any particular serial protocols\n+and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. Sending a command to this channel\n+sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. The serial port\n+may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. Usually such devices can be indentified \n+by performing a patterm match on the received data. For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port.                                                                                                                                    |\n+| binary   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. \"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"                                                                            |\n+| data     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEyNzIyMg==", "bodyText": "I'm under the impression that you need to use system.rawbutton if you want to use profiles such as rawbutton-toggle-switch.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r516127222", "createdAt": "2020-11-02T17:13:51Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,137 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. The binding does not support any particular serial protocols\n+and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. Sending a command to this channel\n+sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. The serial port\n+may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. Usually such devices can be indentified \n+by performing a patterm match on the received data. For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port.                                                                                                                                    |\n+| binary   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. \"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"                                                                            |\n+| data     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNDkwNw=="}, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAwMjQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDo0MDo0OFrOHruC0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDo0MDo0OFrOHruC0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNTIwMA==", "bodyText": "Regarding the parameters, can you have a look at the MQTT generic binding and the new HTTP binding (#8521)? They use the same parameter names and it would be very convenient for the user if serial (which is similar in the provided functionality) would use them, too.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515605200", "createdAt": "2020-11-01T10:40:48Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,137 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. The binding does not support any particular serial protocols\n+and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. Sending a command to this channel\n+sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. The serial port\n+may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. Usually such devices can be indentified \n+by performing a patterm match on the received data. For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port.                                                                                                                                    |\n+| binary   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. \"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"                                                                            |\n+| data     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |\n+\n+\n+The channels supported by the `serialDevice` are:\n+\n+| Channel Type  | Type             | Description                                                                                              |\n+|---------------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string        | String           | Channel for receiving string based commands. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can optionally be formatted and transformed before sending to the device. |\n+| number        | Number           | Channel for receiving number based commands. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can optionally be formatted and transformed before sending to the device. |\n+| dimmer        | Dimmer           | Channel for receiving percentage based commands, e.g. from a Dimmer. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can optionally be formatted and transformed before sending to the device. |\n+| switch        | Switch           | Channel for receiving commands from a Switch. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the ON and OFF commands. |\n+| rollershutter | Rollershutter    | Channel for receiving commands from a Rollershutter. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the UP, DOWN and STOP commands. |\n+\n+The configuration for the `serialBridge` channels consists of the following parameters:\n+\n+| Parameter        | Description                                                                            | Supported Channels |\n+|------------------|----------------------------------------------------------------------------------------|--------------------|\n+| transform        | Transform used to convert device data to channel state, e.g. REGEX(.*?STATE=(.*?);.*)  | string, number, dimmer, switch, rollershutter |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAwNDIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/SerialHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDo0MzoxOFrOHruDvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMDo0MzoxOFrOHruDvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNTQzOA==", "bodyText": "Please use constructor injection (see e.g. https://github.com/openhab/openhab-addons/blob/main/bundles/org.openhab.binding.snmp/src/main/java/org/openhab/binding/snmp/internal/SnmpHandlerFactory.java how to do that).", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515605438", "createdAt": "2020-11-01T10:43:18Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/SerialHandlerFactory.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.THING_TYPE_BRIDGE;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.THING_TYPE_DEVICE;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.handler.SerialBridgeHandler;\n+import org.openhab.binding.serial.internal.handler.SerialDeviceHandler;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link SerialHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.serial\", service = ThingHandlerFactory.class)\n+public class SerialHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Set.of(THING_TYPE_BRIDGE, THING_TYPE_DEVICE);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAxNzQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowMDo0M1rOHruKLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowMDo0M1rOHruKLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzA4Ng==", "bodyText": "Same here.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607086", "createdAt": "2020-11-01T11:00:43Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+\n+/**\n+ * Class describing the serial bridge user configuration\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfiguration {\n+    /**\n+     * Serial port name\n+     */\n+    public @Nullable String serialPort;\n+\n+    /**\n+     * Serial port baud rate\n+     */\n+    public int baudRate = 9600;\n+\n+    /**\n+     * Serial port data bits\n+     */\n+    public int dataBits = 8;\n+\n+    /**\n+     * Serial port parity\n+     */\n+    public String parity = \"N\";\n+\n+    /**\n+     * Serial port stop bits\n+     */\n+    public String stopBits = \"1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAxOTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowMzowNVrOHruK_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDo0ODowOFrOHupICQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzI5Mw==", "bodyText": "You could use an enum for that (NONE, EVEN, ODD, MARK, SPACE).", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607293", "createdAt": "2020-11-01T11:03:05Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+\n+/**\n+ * Class describing the serial bridge user configuration\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfiguration {\n+    /**\n+     * Serial port name\n+     */\n+    public @Nullable String serialPort;\n+\n+    /**\n+     * Serial port baud rate\n+     */\n+    public int baudRate = 9600;\n+\n+    /**\n+     * Serial port data bits\n+     */\n+    public int dataBits = 8;\n+\n+    /**\n+     * Serial port parity\n+     */\n+    public String parity = \"N\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1MzE0MQ==", "bodyText": "Are you suggesting changing parity to be an enum rather than a string?\nHow would you handle a user setting an invalid value in the config? I've tried it and you get a an IllegalArgumentException thrown from ConfigMapper.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515653141", "createdAt": "2020-11-01T18:10:11Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+\n+/**\n+ * Class describing the serial bridge user configuration\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfiguration {\n+    /**\n+     * Serial port name\n+     */\n+    public @Nullable String serialPort;\n+\n+    /**\n+     * Serial port baud rate\n+     */\n+    public int baudRate = 9600;\n+\n+    /**\n+     * Serial port data bits\n+     */\n+    public int dataBits = 8;\n+\n+    /**\n+     * Serial port parity\n+     */\n+    public String parity = \"N\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzI5Mw=="}, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3MDM0NQ==", "bodyText": "But that's up to the user if he/she configures wrong values. Your code is much simpler and less error prone if you use the enum.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r518670345", "createdAt": "2020-11-06T10:48:08Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+\n+/**\n+ * Class describing the serial bridge user configuration\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfiguration {\n+    /**\n+     * Serial port name\n+     */\n+    public @Nullable String serialPort;\n+\n+    /**\n+     * Serial port baud rate\n+     */\n+    public int baudRate = 9600;\n+\n+    /**\n+     * Serial port data bits\n+     */\n+    public int dataBits = 8;\n+\n+    /**\n+     * Serial port parity\n+     */\n+    public String parity = \"N\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzI5Mw=="}, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAyMTAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowNToxM1rOHruL5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowNToxM1rOHruL5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzUyNg==", "bodyText": "Unfortunately this is not possible anymore. You could workaround that by assigning a new SerialBridgeConfiguration object.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607526", "createdAt": "2020-11-01T11:05:13Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAyMTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowNTozMFrOHruL-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowNTozMFrOHruL-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzU0Nw==", "bodyText": "Change to @Nullable", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607547", "createdAt": "2020-11-01T11:05:30Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAyMTUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowNTo1N1rOHruMJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTowNTo1N1rOHruMJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwNzU4OA==", "bodyText": "Either assign a default charset or change to @Nullable.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515607588", "createdAt": "2020-11-01T11:05:57Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @NonNullByDefault({}) Charset charset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTAyNjczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMToxMzoxNlrOHruOog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxODoxMjowOVrOHrw-5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwODIyNg==", "bodyText": "You could refactor the receiving and processing to a new method (receiveAndProcess). Then schedule a call to that method here. Instead of a do-while, check if data is available, read that and then schedule a call to the same method after reading with a delay of 100ms. If no data is available, do the processing (l.212-224). Then Thread.sleep can be avoided.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515608226", "createdAt": "2020-11-01T11:13:16Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @NonNullByDefault({}) Charset charset;\n+\n+    private @Nullable String data;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset == null) {\n+                charset = Charset.defaultCharset();\n+            } else {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            serialPort = portId.open(getThing().getUID().toString(), 2000);\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits, config.getStopBitsAsInt(),\n+                    config.getParityAsInt());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            return;\n+        }\n+\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                final StringBuilder sb = new StringBuilder();\n+                final byte[] readBuffer = new byte[20];\n+                try {\n+                    do {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1Mjg2NA==", "bodyText": "Is the sleep that much of an issue?\nI've refactored it and it appears to work, but now I'm concerned about 2 threads being involved and missing data. In my refactored code serialEvent checks if there's a ScheduledFuture active and does nothing. The assumption here is that receiveAndProcess will read in the data, but there's a risk that we are in the processing bit of receiveAndProcess and we won't do any more reads until we get another callback from serialEvent.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515652864", "createdAt": "2020-11-01T18:07:27Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @NonNullByDefault({}) Charset charset;\n+\n+    private @Nullable String data;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset == null) {\n+                charset = Charset.defaultCharset();\n+            } else {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            serialPort = portId.open(getThing().getUID().toString(), 2000);\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits, config.getStopBitsAsInt(),\n+                    config.getParityAsInt());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            return;\n+        }\n+\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                final StringBuilder sb = new StringBuilder();\n+                final byte[] readBuffer = new byte[20];\n+                try {\n+                    do {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwODIyNg=="}, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1MzM1MA==", "bodyText": "You could create a AtomicBoolean serialProcessing, set it when you first call the read-method and unset it after you stopped reading. That makes sure it's never called twice. The problem with Thread.sleep is when you have (e.g. five) com-ports reading, it'll sleep all threads in the thread-pool.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515653350", "createdAt": "2020-11-01T18:12:09Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfiguration config;\n+\n+    private final SerialPortManager serialPortManager;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @NonNullByDefault({}) Charset charset;\n+\n+    private @Nullable String data;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset == null) {\n+                charset = Charset.defaultCharset();\n+            } else {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            serialPort = portId.open(getThing().getUID().toString(), 2000);\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits, config.getStopBitsAsInt(),\n+                    config.getParityAsInt());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            return;\n+        }\n+\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                final StringBuilder sb = new StringBuilder();\n+                final byte[] readBuffer = new byte[20];\n+                try {\n+                    do {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYwODIyNg=="}, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTA0NTc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTozNjo1M1rOHruXvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTozNjo1M1rOHruXvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMDU1OA==", "bodyText": "Pass the bundleContext from the handler factory when instantiating the handler.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515610558", "createdAt": "2020-11-01T11:36:53Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            if (channels.containsKey(channelUID)) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        final String data = channels.get(channelUID).mapCommand(command);\n+                        if (data != null) {\n+                            handler.writeString(data);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        final BundleContext bundleContext = FrameworkUtil.getBundle(SerialDeviceHandler.class).getBundleContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTA2NTY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo1OTo1NFrOHruhaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo1OTo1NFrOHruhaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzAzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (channels.containsKey(channelUID)) {\n          \n          \n            \n                        final String state = channels.get(channelUID).transformData(data);\n          \n          \n            \n            \n          \n          \n            \n                        if (state != null) {\n          \n          \n            \n                            updateState(channelUID, new StringType(state));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    Channel channel = channels.get(channelUID);\n          \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        final String state = channel.transformData(data);\n          \n          \n            \n            \n          \n          \n            \n                        if (state != null) {\n          \n          \n            \n                            updateState(channelUID, new StringType(state));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nAvoid null warning.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r515613032", "createdAt": "2020-11-01T11:59:54Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.FrameworkUtil;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            if (channels.containsKey(channelUID)) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        final String data = channels.get(channelUID).mapCommand(command);\n+                        if (data != null) {\n+                            handler.writeString(data);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        final BundleContext bundleContext = FrameworkUtil.getBundle(SerialDeviceHandler.class).getBundleContext();\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    DeviceChannel deviceChannel = DeviceChannelFactory.createDeviceChannel(bundleContext, channelConfig,\n+                            type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }\n+\n+    /**\n+     * Return the bridge status.\n+     */\n+    private ThingStatusInfo getBridgeStatus() {\n+        final Bridge b = getBridge();\n+        if (b != null) {\n+            return b.getStatusInfo();\n+        } else {\n+            return new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, null);\n+        }\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final ChannelUID channelUID) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelUID)) {\n+            return;\n+        }\n+\n+        if (channels.containsKey(channelUID)) {\n+            final String state = channels.get(channelUID).transformData(data);\n+\n+            if (state != null) {\n+                updateState(channelUID, new StringType(state));\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb95f3380eb99f21f8f7a0850ad9e310eef24118"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTAyOTM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTowMjo1OVrOHupsZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTowMjo1OVrOHupsZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3OTY1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable String transformData(final @Nullable String data) {\n          \n          \n            \n                    return data != null ? transform.apply(data).orElse(null) : null;\n          \n          \n            \n                }\n          \n          \n            \n                public Optional<String> transformData(final String data) {\n          \n          \n            \n                    return transform.apply(data);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\n(see below)", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r518679654", "createdAt": "2020-11-06T11:02:59Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data or the orginal data if no mapping found\n+     */\n+    public @Nullable String mapCommand(final Command command) {\n+        String data = formatCommand(command);\n+\n+        data = transformCommand(data);\n+\n+        logger.debug(\"Mapped command is '{}'\", data);\n+\n+        return data;\n+    }\n+\n+    /**\n+     * Transform the data using the configured transform\n+     * \n+     * @param data the data to transform\n+     * @return the transformed data is the transform produced a result otherwise null.\n+     */\n+    public @Nullable String transformData(final @Nullable String data) {\n+        return data != null ? transform.apply(data).orElse(null) : null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451bcd026efd63ab68f55c600a70acf970312e85"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTAzNzg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTowNTozNlrOHupxtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTowNTozNlrOHupxtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY4MTAxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        final String state = channel.transformData(data);\n          \n          \n            \n            \n          \n          \n            \n                        if (state != null) {\n          \n          \n            \n                            updateState(channelUID, new StringType(state));\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value));\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nYou have a null-check in l.169, so requiring non-null for the parameter should be ok. I think the same applies to mapCommand, please check that.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r518681014", "createdAt": "2020-11-06T11:05:36Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        final String data = channel.mapCommand(command);\n+                        if (data != null) {\n+                            handler.writeString(data);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }\n+\n+    /**\n+     * Return the bridge status.\n+     */\n+    private ThingStatusInfo getBridgeStatus() {\n+        final Bridge b = getBridge();\n+        if (b != null) {\n+            return b.getStatusInfo();\n+        } else {\n+            return new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, null);\n+        }\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final ChannelUID channelUID) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelUID)) {\n+            return;\n+        }\n+\n+        final DeviceChannel channel = channels.get(channelUID);\n+        if (channel != null) {\n+            final String state = channel.transformData(data);\n+\n+            if (state != null) {\n+                updateState(channelUID, new StringType(state));\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "451bcd026efd63ab68f55c600a70acf970312e85"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE1NDQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0MjowNFrOHvYoQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0MjowNFrOHvYoQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0ODY0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n          \n          \n            \n            | `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n          \n      \n    \n    \n  \n\nAlso for other channel types", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519448641", "createdAt": "2020-11-08T16:42:04Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE1NDkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0Mjo0OVrOHvYofw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0Mjo0OVrOHvYofw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0ODcwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | descreaseValue | Send this value when receiving a DECREASE command | dimmer |\n          \n          \n            \n            | decreaseValue | Send this value when receiving a DECREASE command | dimmer |", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519448703", "createdAt": "2020-11-08T16:42:49Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| binary   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. \"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\" |\n+| data     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |\n+\n+\n+The channels supported by the `serialDevice` are:\n+\n+| Channel Type  | Type             | Description                                                                                              |\n+|---------------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string | String | Channel for receiving string based commands. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can be formatted and transformed before sending to the device. |\n+| number | Number | Channel for receiving number based commands. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can be formatted and transformed before sending to the device. |\n+| dimmer | Dimmer | Channel for receiving commands from a Dimmer. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the ON, OFF, INCREASE and DECREASE commands. |\n+| switch | Switch | Channel for receiving commands from a Switch. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the ON and OFF commands. |\n+| rollershutter | Rollershutter | Channel for receiving commands from a Rollershutter. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the UP, DOWN and STOP commands. |\n+\n+The configuration for the `serialBridge` channels consists of the following parameters:\n+\n+| Parameter        | Description                                                                            | Supported Channels |\n+|------------------|----------------------------------------------------------------------------------------|--------------------|\n+| stateTransformation | One or more transformation (concatenated with `\u2229`) used to convert device data to channel state, e.g. REGEX:.*?STATE=(.*?);.* | string, number, dimmer, switch, rollershutter |\n+| commandTransformation | One or more transformation (concatenated with `\u2229`) used to convert command to device data, e.g. JS:device.js | string, number, dimmer, switch, rollershutter |\n+| commandFormat | Format string applied to the command before transform, e.g. ID=671;COMMAND=%s | string, number, dimmer, rollershutter |\n+| onValue | Send this value when receiving an ON command | switch, dimmer |\n+| offValue | Send this value when receiving an OFF command | switch, dimmer |\n+| increaseValue | Send this value when receiving an INCREASE command | dimmer |\n+| descreaseValue | Send this value when receiving a DECREASE command | dimmer |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE1NTM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0MzoxM1rOHvYouA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0MzoxM1rOHvYouA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0ODc2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | stateTransformation | One or more transformation (concatenated with `\u2229`) used to convert device data to channel state, e.g. REGEX:.*?STATE=(.*?);.* | string, number, dimmer, switch, rollershutter |\n          \n          \n            \n            | `stateTransformation` | One or more transformation (concatenated with `\u2229`) used to convert device data to channel state, e.g. `REGEX:.*?STATE=(.*?);.*` | string, number, dimmer, switch, rollershutter |", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519448760", "createdAt": "2020-11-08T16:43:13Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| binary   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. \"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\" |\n+| data     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |\n+\n+\n+The channels supported by the `serialDevice` are:\n+\n+| Channel Type  | Type             | Description                                                                                              |\n+|---------------|------------------|----------------------------------------------------------------------------------------------------------|\n+| string | String | Channel for receiving string based commands. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can be formatted and transformed before sending to the device. |\n+| number | Number | Channel for receiving number based commands. The channel can be configured to apply a transform on the received data to convert to the channel state. Commands received by the channel can be formatted and transformed before sending to the device. |\n+| dimmer | Dimmer | Channel for receiving commands from a Dimmer. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the ON, OFF, INCREASE and DECREASE commands. |\n+| switch | Switch | Channel for receiving commands from a Switch. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the ON and OFF commands. |\n+| rollershutter | Rollershutter | Channel for receiving commands from a Rollershutter. The channel can be configured to apply a transform on the received data to convert to the channel state. The channel can be configured to apply a simple mapping for the UP, DOWN and STOP commands. |\n+\n+The configuration for the `serialBridge` channels consists of the following parameters:\n+\n+| Parameter        | Description                                                                            | Supported Channels |\n+|------------------|----------------------------------------------------------------------------------------|--------------------|\n+| stateTransformation | One or more transformation (concatenated with `\u2229`) used to convert device data to channel state, e.g. REGEX:.*?STATE=(.*?);.* | string, number, dimmer, switch, rollershutter |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE1ODQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0NjoxMlrOHvYqQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0NjoxMlrOHvYqQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTE1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ValueTransformation transform;\n          \n          \n            \n                private final ValueTransformation stateTransform;", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449155", "createdAt": "2020-11-08T16:46:12Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2MDM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0ODozN1rOHvYrPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODowODozNFrOHwpFxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTQwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result);\n          \n      \n    \n    \n  \n\nOptional.toString always contains the value", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449407", "createdAt": "2020-11-08T16:48:37Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data if the mapping produced a result.\n+     */\n+    public Optional<String> mapCommand(final Command command) {\n+        final Optional<String> result = transformCommand(formatCommand(command));\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2NjkxOQ==", "bodyText": "For cases when there is no value the result of just passing in the optional gives:\nMapped command is 'Optional.empty' which I don't think is as clear as  Mapped command is 'null'", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r520766919", "createdAt": "2020-11-10T18:08:34Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data if the mapping produced a result.\n+     */\n+    public Optional<String> mapCommand(final Command command) {\n+        final Optional<String> result = transformCommand(formatCommand(command));\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTQwNw=="}, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2MDYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0OTowMVrOHvYrYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo0OTowMVrOHvYrYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTQ0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Optional<String> transformData(final String data) {\n          \n          \n            \n                public Optional<String> transformState(final String data) {", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449441", "createdAt": "2020-11-08T16:49:01Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DeviceChannel.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformation;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DeviceChannel} is the abstract class for handling a channel. Provides\n+ * the ability to transform the device data into the channel state.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class DeviceChannel {\n+    protected final Logger logger = LoggerFactory.getLogger(DeviceChannel.class);\n+\n+    protected final ChannelConfig config;\n+\n+    private final ValueTransformation transform;\n+    private final ValueTransformation commandTransform;\n+\n+    protected DeviceChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        this.config = config;\n+        transform = valueTransformationProvider.getValueTransformation(config.stateTransformation);\n+        commandTransform = valueTransformationProvider.getValueTransformation(config.commandTransformation);\n+    }\n+\n+    /**\n+     * Map the supplied command into the data to send to the device by\n+     * applying a format followed by a transform.\n+     * \n+     * @param command the command to map\n+     * @return the mapped data if the mapping produced a result.\n+     */\n+    public Optional<String> mapCommand(final Command command) {\n+        final Optional<String> result = transformCommand(formatCommand(command));\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Transform the data using the configured transform\n+     * \n+     * @param data the data to transform\n+     * @return the transformed data if the transform produced a result.\n+     */\n+    public Optional<String> transformData(final String data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2MjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/RollershutterChannel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1MDo1OVrOHvYsdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1MDo1OVrOHvYsdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTcxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result);", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449718", "createdAt": "2020-11-08T16:50:59Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/RollershutterChannel.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StopMoveType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link RollershutterChannel} channel provides mappings for the UP, DOWN and STOP commands\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RollershutterChannel extends DeviceChannel {\n+\n+    public RollershutterChannel(final ValueTransformationProvider valueTransformationProvider,\n+            final ChannelConfig config) {\n+        super(valueTransformationProvider, config);\n+    }\n+\n+    @Override\n+    public Optional<String> mapCommand(final Command command) {\n+        String data;\n+\n+        final String upValue = config.upValue;\n+        final String downValue = config.downValue;\n+        final String stopValue = config.stopValue;\n+\n+        if (command instanceof UpDownType) {\n+            if (upValue != null && UpDownType.UP.equals(command)) {\n+                data = upValue;\n+            } else if (downValue != null && UpDownType.DOWN.equals(command)) {\n+                data = downValue;\n+            } else {\n+                data = command.toFullString();\n+            }\n+        } else if (command instanceof StopMoveType) {\n+            if (stopValue != null && StopMoveType.STOP.equals(command)) {\n+                data = stopValue;\n+            } else {\n+                data = command.toFullString();\n+            }\n+        } else {\n+            data = formatCommand(command);\n+        }\n+\n+        final Optional<String> result = transformCommand(data);\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2MzEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/SwitchChannel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1MToyMlrOHvYsow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1MToyMlrOHvYsow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTc2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                    logger.debug(\"Mapped command is '{}'\", result.);", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449763", "createdAt": "2020-11-08T16:51:22Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/SwitchChannel.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link SwitchChannel} channel provides mappings for the ON and OFF commands\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SwitchChannel extends DeviceChannel {\n+\n+    public SwitchChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        super(valueTransformationProvider, config);\n+    }\n+\n+    @Override\n+    public Optional<String> mapCommand(final Command command) {\n+        String data;\n+\n+        final String onValue = config.onValue;\n+        final String offValue = config.offValue;\n+\n+        if (onValue != null && OnOffType.ON.equals(command)) {\n+            data = onValue;\n+        } else if (offValue != null && OnOffType.OFF.equals(command)) {\n+            data = offValue;\n+        } else {\n+            data = command.toFullString();\n+        }\n+\n+        final Optional<String> result = transformCommand(data);\n+\n+        logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2NDI1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DimmerChannel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1Mjo0NVrOHvYtPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1Mjo0NVrOHvYtPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0OTkxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Mapped command is '{}'\", result.orElse(null));\n          \n          \n            \n                        logger.debug(\"Mapped command is '{}'\", result);", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519449918", "createdAt": "2020-11-08T16:52:45Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/channel/DimmerChannel.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.channel;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link DimmerChannel} channel applies a format followed by a transform.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DimmerChannel extends SwitchChannel {\n+\n+    public DimmerChannel(final ValueTransformationProvider valueTransformationProvider, final ChannelConfig config) {\n+        super(valueTransformationProvider, config);\n+    }\n+\n+    @Override\n+    public Optional<String> mapCommand(final Command command) {\n+        Optional<String> result;\n+\n+        if (command instanceof OnOffType) {\n+            result = super.mapCommand(command);\n+        } else {\n+            String data;\n+\n+            final String increaseValue = config.increaseValue;\n+            final String decreaseValue = config.decreaseValue;\n+\n+            if (command instanceof IncreaseDecreaseType) {\n+                if (increaseValue != null && IncreaseDecreaseType.INCREASE.equals(command)) {\n+                    data = increaseValue;\n+                } else if (decreaseValue != null && IncreaseDecreaseType.DECREASE.equals(command)) {\n+                    data = decreaseValue;\n+                } else {\n+                    data = command.toFullString();\n+                }\n+            } else {\n+                data = formatCommand(command);\n+            }\n+\n+            result = transformCommand(data);\n+\n+            logger.debug(\"Mapped command is '{}'\", result.orElse(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2NjgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1NTo0MlrOHvYumw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxMTowOFrOHvZPLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDI2Nw==", "bodyText": "Wouldnt it be possible to remove the data field and pass result as a parameter to refresh? That's much more thread-safe.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519450267", "createdAt": "2020-11-08T16:55:42Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.util.Parity;\n+import org.openhab.binding.serial.internal.util.StopBits;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private SerialBridgeConfiguration config = new SerialBridgeConfiguration();\n+\n+    private final SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private Charset charset = Charset.defaultCharset();\n+\n+    private @Nullable String data;\n+\n+    private final AtomicBoolean readerActive = new AtomicBoolean(false);\n+    private @Nullable ScheduledFuture<?> reader;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset != null) {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            final SerialPort serialPort = portId.open(getThing().getUID().toString(), 2000);\n+            this.serialPort = serialPort;\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits,\n+                    StopBits.fromConfig(config.stopBits).getSerialPortValue(),\n+                    Parity.fromConfig(config.parity).getSerialPortValue());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final SerialPort serialPort = this.serialPort;\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            this.serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        readerActive.set(false);\n+        final ScheduledFuture<?> reader = this.reader;\n+        if (reader != null) {\n+            reader.cancel(false);\n+            this.reader = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                if (readerActive.compareAndSet(false, true)) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(new StringBuilder(), true), 0,\n+                            TimeUnit.MILLISECONDS);\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Sends a string to the serial port.\n+     *\n+     * @param string the string to send\n+     */\n+    public void writeString(final String string) {\n+        writeString(string, false);\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final String channelId) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelId)) {\n+            return;\n+        }\n+\n+        switch (channelId) {\n+            case STRING_CHANNEL:\n+                updateState(channelId, new StringType(data));\n+                break;\n+            case BINARY_CHANNEL:\n+                final StringBuilder sb = new StringBuilder(\"data:\");\n+                sb.append(RawType.DEFAULT_MIME_TYPE).append(\";base64,\")\n+                        .append(Base64.getEncoder().encodeToString(data.getBytes(charset)));\n+                updateState(channelId, new StringType(sb.toString()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Read from the serial port and process the data\n+     * \n+     * @param sb the string builder to receive the data\n+     * @param firstAttempt indicates if this is the first read attempt without waiting\n+     */\n+    private void receiveAndProcess(final StringBuilder sb, final boolean firstAttempt) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            readerActive.set(false);\n+            return;\n+        }\n+\n+        try {\n+            if (firstAttempt || inputStream.available() > 0) {\n+                final byte[] readBuffer = new byte[20];\n+\n+                // read data from serial device\n+                while (inputStream.available() > 0) {\n+                    final int bytes = inputStream.read(readBuffer);\n+                    sb.append(new String(readBuffer, 0, bytes, charset));\n+                }\n+\n+                // Add wait states around reading the stream, so that interrupted transmissions\n+                // are merged\n+                if (readerActive.get()) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(sb, false), 100, TimeUnit.MILLISECONDS);\n+                }\n+\n+            } else {\n+                final String result = sb.toString();\n+                data = result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1NjQwNA==", "bodyText": "I'm using the data field to have access to the last received data to handle a refresh command. If I don't have the data field I can ignore the refresh command?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519456404", "createdAt": "2020-11-08T17:49:38Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.util.Parity;\n+import org.openhab.binding.serial.internal.util.StopBits;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private SerialBridgeConfiguration config = new SerialBridgeConfiguration();\n+\n+    private final SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private Charset charset = Charset.defaultCharset();\n+\n+    private @Nullable String data;\n+\n+    private final AtomicBoolean readerActive = new AtomicBoolean(false);\n+    private @Nullable ScheduledFuture<?> reader;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset != null) {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            final SerialPort serialPort = portId.open(getThing().getUID().toString(), 2000);\n+            this.serialPort = serialPort;\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits,\n+                    StopBits.fromConfig(config.stopBits).getSerialPortValue(),\n+                    Parity.fromConfig(config.parity).getSerialPortValue());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final SerialPort serialPort = this.serialPort;\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            this.serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        readerActive.set(false);\n+        final ScheduledFuture<?> reader = this.reader;\n+        if (reader != null) {\n+            reader.cancel(false);\n+            this.reader = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                if (readerActive.compareAndSet(false, true)) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(new StringBuilder(), true), 0,\n+                            TimeUnit.MILLISECONDS);\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Sends a string to the serial port.\n+     *\n+     * @param string the string to send\n+     */\n+    public void writeString(final String string) {\n+        writeString(string, false);\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final String channelId) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelId)) {\n+            return;\n+        }\n+\n+        switch (channelId) {\n+            case STRING_CHANNEL:\n+                updateState(channelId, new StringType(data));\n+                break;\n+            case BINARY_CHANNEL:\n+                final StringBuilder sb = new StringBuilder(\"data:\");\n+                sb.append(RawType.DEFAULT_MIME_TYPE).append(\";base64,\")\n+                        .append(Base64.getEncoder().encodeToString(data.getBytes(charset)));\n+                updateState(channelId, new StringType(sb.toString()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Read from the serial port and process the data\n+     * \n+     * @param sb the string builder to receive the data\n+     * @param firstAttempt indicates if this is the first read attempt without waiting\n+     */\n+    private void receiveAndProcess(final StringBuilder sb, final boolean firstAttempt) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            readerActive.set(false);\n+            return;\n+        }\n+\n+        try {\n+            if (firstAttempt || inputStream.available() > 0) {\n+                final byte[] readBuffer = new byte[20];\n+\n+                // read data from serial device\n+                while (inputStream.available() > 0) {\n+                    final int bytes = inputStream.read(readBuffer);\n+                    sb.append(new String(readBuffer, 0, bytes, charset));\n+                }\n+\n+                // Add wait states around reading the stream, so that interrupted transmissions\n+                // are merged\n+                if (readerActive.get()) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(sb, false), 100, TimeUnit.MILLISECONDS);\n+                }\n+\n+            } else {\n+                final String result = sb.toString();\n+                data = result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDI2Nw=="}, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1ODYwNg==", "bodyText": "Good point. I would suggest to use the parameter nevertheless and store it in the field additionally. You can then use that to pass it when REFRESH is called.\nThis of course means that you must keep a refresh method in the ThingHandler below. I have edited my suggestions there. You could do something similar here.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519458606", "createdAt": "2020-11-08T18:11:08Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.util.Parity;\n+import org.openhab.binding.serial.internal.util.StopBits;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private SerialBridgeConfiguration config = new SerialBridgeConfiguration();\n+\n+    private final SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private Charset charset = Charset.defaultCharset();\n+\n+    private @Nullable String data;\n+\n+    private final AtomicBoolean readerActive = new AtomicBoolean(false);\n+    private @Nullable ScheduledFuture<?> reader;\n+\n+    public SerialBridgeHandler(final Bridge bridge, final SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID.getId());\n+        } else {\n+            switch (channelUID.getId()) {\n+                case STRING_CHANNEL:\n+                    writeString(command.toFullString(), false);\n+                    break;\n+                case BINARY_CHANNEL:\n+                    writeString(command.toFullString(), true);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SerialBridgeConfiguration.class);\n+\n+        try {\n+            if (config.charset != null) {\n+                charset = Charset.forName(config.charset);\n+            }\n+            logger.debug(\"Serial port '{}' charset '{}' set\", config.serialPort, charset);\n+        } catch (final IllegalCharsetNameException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Invalid charset\");\n+            return;\n+        }\n+\n+        final String port = config.serialPort;\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set\");\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        final SerialPortIdentifier portId = serialPortManager.getIdentifier(port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known\");\n+            return;\n+        }\n+\n+        // initialize serial port\n+        try {\n+            final SerialPort serialPort = portId.open(getThing().getUID().toString(), 2000);\n+            this.serialPort = serialPort;\n+\n+            serialPort.setSerialPortParams(config.baudRate, config.dataBits,\n+                    StopBits.fromConfig(config.stopBits).getSerialPortValue(),\n+                    Parity.fromConfig(config.parity).getSerialPortValue());\n+\n+            serialPort.addEventListener(this);\n+\n+            // activate the DATA_AVAILABLE notifier\n+            serialPort.notifyOnDataAvailable(true);\n+            inputStream = serialPort.getInputStream();\n+            outputStream = serialPort.getOutputStream();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error\");\n+        } catch (final PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use\");\n+        } catch (final TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port\");\n+        } catch (final UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unsupported port parameters: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final SerialPort serialPort = this.serialPort;\n+        if (serialPort != null) {\n+            serialPort.removeEventListener();\n+            serialPort.close();\n+            this.serialPort = null;\n+        }\n+\n+        final InputStream inputStream = this.inputStream;\n+        if (inputStream != null) {\n+            try {\n+                inputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the input stream: {}\", e.getMessage());\n+            }\n+            this.inputStream = null;\n+        }\n+\n+        final OutputStream outputStream = this.outputStream;\n+        if (outputStream != null) {\n+            try {\n+                outputStream.close();\n+            } catch (final IOException e) {\n+                logger.debug(\"Error while closing the output stream: {}\", e.getMessage());\n+            }\n+            this.outputStream = null;\n+        }\n+\n+        readerActive.set(false);\n+        final ScheduledFuture<?> reader = this.reader;\n+        if (reader != null) {\n+            reader.cancel(false);\n+            this.reader = null;\n+        }\n+\n+        data = null;\n+    }\n+\n+    @Override\n+    public void serialEvent(final SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                if (readerActive.compareAndSet(false, true)) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(new StringBuilder(), true), 0,\n+                            TimeUnit.MILLISECONDS);\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Sends a string to the serial port.\n+     *\n+     * @param string the string to send\n+     */\n+    public void writeString(final String string) {\n+        writeString(string, false);\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final String channelId) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelId)) {\n+            return;\n+        }\n+\n+        switch (channelId) {\n+            case STRING_CHANNEL:\n+                updateState(channelId, new StringType(data));\n+                break;\n+            case BINARY_CHANNEL:\n+                final StringBuilder sb = new StringBuilder(\"data:\");\n+                sb.append(RawType.DEFAULT_MIME_TYPE).append(\";base64,\")\n+                        .append(Base64.getEncoder().encodeToString(data.getBytes(charset)));\n+                updateState(channelId, new StringType(sb.toString()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Read from the serial port and process the data\n+     * \n+     * @param sb the string builder to receive the data\n+     * @param firstAttempt indicates if this is the first read attempt without waiting\n+     */\n+    private void receiveAndProcess(final StringBuilder sb, final boolean firstAttempt) {\n+        final InputStream inputStream = this.inputStream;\n+\n+        if (inputStream == null) {\n+            readerActive.set(false);\n+            return;\n+        }\n+\n+        try {\n+            if (firstAttempt || inputStream.available() > 0) {\n+                final byte[] readBuffer = new byte[20];\n+\n+                // read data from serial device\n+                while (inputStream.available() > 0) {\n+                    final int bytes = inputStream.read(readBuffer);\n+                    sb.append(new String(readBuffer, 0, bytes, charset));\n+                }\n+\n+                // Add wait states around reading the stream, so that interrupted transmissions\n+                // are merged\n+                if (readerActive.get()) {\n+                    reader = scheduler.schedule(() -> receiveAndProcess(sb, false), 100, TimeUnit.MILLISECONDS);\n+                }\n+\n+            } else {\n+                final String result = sb.toString();\n+                data = result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDI2Nw=="}, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE2ODUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1NzoxOFrOHvYvYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1NzoxOFrOHvYvYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDQ2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) Pattern devicePattern;\n          \n          \n            \n                private @Nullable Pattern devicePattern;\n          \n      \n    \n    \n  \n\nunfortunately the decision was to use that only for injected OSGi-services.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519450467", "createdAt": "2020-11-08T16:57:18Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE3MDc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1OTo0OFrOHvYwgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNjo1OTo0OFrOHvYwgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MDc1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void handleData(final String data) {\n          \n          \n            \n                    if (devicePattern.matcher(data).matches()) {\n          \n          \n            \n                        this.data = data;\n          \n          \n            \n                        channels.keySet().forEach(this::refresh);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                public void handleData(final String data) {\n          \n          \n            \n                    if (devicePattern.matcher(data).matches()) {\n          \n          \n            \n                        channels.forEach((channelUID, channel) -> refresh(channelUID, channel, value));\n          \n          \n            \n                        this.lastValue = value;\n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519450752", "createdAt": "2020-11-08T16:59:48Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE4NTc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNzoxNjowOVrOHvY4Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNzoxNjowOVrOHvY4Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1MjY3OQ==", "bodyText": "can be removed if you provide no options", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519452679", "createdAt": "2020-11-08T17:16:09Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,247 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"serial\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<bridge-type id=\"serialBridge\">\n+\t\t<label>Serial Bridge</label>\n+\t\t<description>Serial port which can send and receive data</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"string\" typeId=\"stringData\"/>\n+\t\t\t<channel id=\"binary\" typeId=\"binaryData\"/>\n+\t\t\t<channel id=\"data\" typeId=\"system.rawbutton\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<limitToOptions>false</limitToOptions>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjE4NjUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNzoxNzowMFrOHvY4Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxNzoxNzowMFrOHvY4Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1Mjc3NA==", "bodyText": "see above", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519452774", "createdAt": "2020-11-08T17:17:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,247 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"serial\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<bridge-type id=\"serialBridge\">\n+\t\t<label>Serial Bridge</label>\n+\t\t<description>Serial port which can send and receive data</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"string\" typeId=\"stringData\"/>\n+\t\t\t<channel id=\"binary\" typeId=\"binaryData\"/>\n+\t\t\t<channel id=\"data\" typeId=\"system.rawbutton\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<limitToOptions>false</limitToOptions>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"baudRate\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Baud Rate</label>\n+\t\t\t\t<description>Set the baud rate</description>\n+\t\t\t\t<default>9600</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"4800\">4800</option>\n+\t\t\t\t\t<option value=\"9600\">9600</option>\n+\t\t\t\t\t<option value=\"19200\">19200</option>\n+\t\t\t\t\t<option value=\"38400\">38400</option>\n+\t\t\t\t\t<option value=\"57600\">57600</option>\n+\t\t\t\t\t<option value=\"115200\">115200</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"dataBits\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Data Bits</label>\n+\t\t\t\t<description>Set the data bits</description>\n+\t\t\t\t<default>8</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"5\">5</option>\n+\t\t\t\t\t<option value=\"6\">6</option>\n+\t\t\t\t\t<option value=\"7\">7</option>\n+\t\t\t\t\t<option value=\"8\">8</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"parity\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Parity</label>\n+\t\t\t\t<description>Set the parity</description>\n+\t\t\t\t<default>N</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"N\">N(one)</option>\n+\t\t\t\t\t<option value=\"O\">O(dd)</option>\n+\t\t\t\t\t<option value=\"E\">E(even)</option>\n+\t\t\t\t\t<option value=\"M\">M(ark)</option>\n+\t\t\t\t\t<option value=\"S\">S(pace)</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"stopBits\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Stop Bits</label>\n+\t\t\t\t<description>Set the stop bits</description>\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"1\">1</option>\n+\t\t\t\t\t<option value=\"1.5\">1.5</option>\n+\t\t\t\t\t<option value=\"2\">2</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"charset\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Charset</label>\n+\t\t\t\t<description>The charset to use for converting between bytes and string (e.g. UTF-8, ISO-8859-1)</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<thing-type id=\"serialDevice\" extensible=\"string, number, dimmer, switch, rollershutter\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serialBridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Serial Device</label>\n+\t\t<description>Represents a device</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"patternMatch\" type=\"text\">\n+\t\t\t\t<label>Patern Match</label>\n+\t\t\t\t<context>pattern-match</context>\n+\t\t\t\t<limitToOptions>false</limitToOptions>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjIzMzczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxMTozMVrOHvZPWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxMTozMVrOHvZPWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1ODY1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable String data;\n          \n          \n            \n                private @Nullable String lastValue;", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519458651", "createdAt": "2020-11-08T18:11:31Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjIzNDg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxMzoxMVrOHvZP7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxMzoxMVrOHvZP7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1ODc5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof RefreshType) {\n          \n          \n            \n                        refresh(channelUID);\n          \n          \n            \n                    } else {\n          \n          \n            \n                    if (command instanceof RefreshType) {\n          \n          \n            \n                        DeviceChannel channel = channels.get(channelUID);\n          \n          \n            \n                        String lastValue = this,lastValue;\n          \n          \n            \n                        if (channel != null) {\n          \n          \n            \n                            refresh(channelUID, channel, lastValue);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519458797", "createdAt": "2020-11-08T18:13:11Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjIzNzQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxNjowMFrOHvZRIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQxODoxNjowMFrOHvZRIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ1OTEwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void refresh(final ChannelUID channelUID) {\n          \n          \n            \n                    final String data = this.data;\n          \n          \n            \n            \n          \n          \n            \n                    if (data == null || !isLinked(channelUID)) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    final DeviceChannel channel = channels.get(channelUID);\n          \n          \n            \n                    if (channel != null) {\n          \n          \n            \n                        channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value)));\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void refresh(ChannelUID channelUID, DeviceChannel channel, @Nullable String value) {\n          \n          \n            \n                    if (isLinked(channelUID) && value != null) {\n          \n          \n            \n                        channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value)));\n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r519459106", "createdAt": "2020-11-08T18:16:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @NonNullByDefault({}) Pattern devicePattern;\n+\n+    private @Nullable String data;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            refresh(channelUID);\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        data = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        if (devicePattern.matcher(data).matches()) {\n+            this.data = data;\n+            channels.keySet().forEach(this::refresh);\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }\n+\n+    /**\n+     * Return the bridge status.\n+     */\n+    private ThingStatusInfo getBridgeStatus() {\n+        final Bridge b = getBridge();\n+        if (b != null) {\n+            return b.getStatusInfo();\n+        } else {\n+            return new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, null);\n+        }\n+    }\n+\n+    /**\n+     * Refreshes the channel with the last received data\n+     *\n+     * @param channelId the channel to refresh\n+     */\n+    private void refresh(final ChannelUID channelUID) {\n+        final String data = this.data;\n+\n+        if (data == null || !isLinked(channelUID)) {\n+            return;\n+        }\n+\n+        final DeviceChannel channel = channels.get(channelUID);\n+        if (channel != null) {\n+            channel.transformData(data).ifPresent(value -> updateState(channelUID, new StringType(value)));\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b89e69f874e0282c544d6aba870f1f02623e9ab7"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDE4MjU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxOTo1Njo0NVrOHzii4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxOTo1Njo0NVrOHzii4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTQwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Usually such devices can be indentified by performing a pattern match on the received data. \n          \n          \n            \n            Usually such devices can be identified by performing a pattern match on the received data.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523805408", "createdAt": "2020-11-15T19:56:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDE4NTQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/README.md", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxOTo1OTo1NFrOHzikPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODoyMzo0MFrOH0pSzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng==", "bodyText": "What's the purpose of this Channel?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523805756", "createdAt": "2020-11-15T19:59:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkzMzk0Mw==", "bodyText": "This was to provide some sort of replacement for the v1 \"switch\" channel which would just toggle ON/OFF when data was received.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523933943", "createdAt": "2020-11-16T07:11:47Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk0MDQ5OA==", "bodyText": "Is there any use case for it? Rules can be triggered event-based on Item/Channel state changes.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523940498", "createdAt": "2020-11-16T07:30:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI5OTM3MQ==", "bodyText": "Shall I remove that channel since it just duplicates what the SerialButton binding does?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524299371", "createdAt": "2020-11-16T14:18:05Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkxOTU5NA==", "bodyText": "If I see correctly, the Serial Button binding triggers when DTR or so is raised by a switch/contact and your Channel triggers when data is available. As the Channel's functionality is redundant to the event based framework, I'd remove it.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524919594", "createdAt": "2020-11-17T06:53:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyNjM2OQ==", "bodyText": "Unless I've missed something it's behaving exactly as the SerialButton binding, i.e. triggering based on the SerialPortEvent.DATA_AVAILABLE event.\nSo it's redundant in the sense that there is already a binding to provide that functionality, but it means some users may have to replace the use of one binding with two.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524926369", "createdAt": "2020-11-17T07:11:38Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyOTM4OA==", "bodyText": "If I see correctly, the Serial Button binding triggers also when RI/CTS is raised, not (only) when data is available. I think that's a difference to your binding and not a redundancy.\nMy point is that OH already provides the ability to react on a state change of a Channel/Item via rules. So, it's not necessary to have a dedicated Switch that changes when a Channel has been updated. Or do I miss something?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524929388", "createdAt": "2020-11-17T07:19:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk1OTY5NQ==", "bodyText": "There's a simple use case of using the trigger channel with the toggle profile to hook it up to a switch without the need of a rule.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524959695", "createdAt": "2020-11-17T08:14:55Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk2NDU1OA==", "bodyText": "I wasn't aware of that profile. You convinced me.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524964558", "createdAt": "2020-11-17T08:23:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/README.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# Serial Binding\n+\n+The Serial binding allows openHAB to communicate over serial ports attached to the openHAB server.\n+\n+The binding allows data to be sent and received from a serial port. \n+The binding does not support any particular serial protocols and simply reads what is available and sends what is provided.\n+\n+The binding can be used to communicate with simple serial devices for which a dedicated openHAB binding does not exist.\n+\n+## Overview\n+\n+The Serial binding represents a serial port as a bridge thing and data matching defined patterns as things connected to the bridge.\n+\n+### Serial Bridge\n+\n+A Serial Bridge thing (`serialBridge`) represents a single serial port.\n+\n+The bridge supports a String channel which is set to the currently received data from the serial port. \n+Sending a command to this channel sends the command as a string to the serial port.\n+\n+The bridge also supports a String channel which encodes the received data as the string representation of a RawType to handle data that is \n+not supported by the REST interface. \n+A command sent to this channel will only be sent to the serial port if it is encoded as the string representation of a RawType.\n+\n+A trigger channel is also provided which triggers when data is received.\n+\n+### Serial Device\n+\n+A Serial Device thing (`serialDevice`) can be used to represent data matching a defined pattern as a device. \n+The serial port may be providing data for many different devices/sensors, such as a temperature sensor or a doorbell. \n+Usually such devices can be indentified by performing a pattern match on the received data. \n+For example, a Serial Device could be configured to represent a temperature sensor.\n+\n+The thing will only update its channels if the received data matches the defined pattern. \n+\n+The thing supports generic String and Number channels which can apply a transform on the received data to set the channel state. \n+Commands sent to the channels can be formatted and transformed before being sent to the device.\n+\n+The thing also supports Switch and Rollershutter channels which provide simple mappings for the ON, OFF, UP, DOWN and STOP commands.\n+\n+When using a Serial Device the expectation is that the received data for each device is terminated by a line break.\n+\n+## Thing Configuration\n+\n+The configuration for the `serialBridge` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| serialPort          | The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1) (mandatory)                           |\n+| baudRate            | Set the baud rate. Valid values: 4800, 9600, 19200, 38400, 57600, 115200 (default 9600)                |\n+| dataBits            | Set the data bits. Valid values: 5, 6, 7, 8 (default 8)                                                |\n+| parity              | Set the parity. Valid values: N(one), O(dd), E(even), M(ark), S(pace) (default N)                      |\n+| stopBits            | Set the stop bits. Valid values: 1, 1.5, 2 (default 1)                                                 |\n+| charset             | The charset to use for converting between bytes and string (e.g. UTF-8,ISO-8859-1)                     |\n+\n+The configuration for the `serialDevice` consists of the following parameters:\n+\n+| Parameter           | Description                                                                                            |\n+|---------------------|--------------------------------------------------------------------------------------------------------|\n+| patternMatch        | Regular expression used to identify device from received data (must match the whole line) (mandatory)  |\n+\n+## Channels\n+\n+The channels supported by the `serialBridge` are:\n+\n+| Channel  | Type             | Description                                                                                              |\n+|----------|------------------|----------------------------------------------------------------------------------------------------------|\n+| `string`   | String           | Channel for sending/receiving data as a string to/from the serial port. The channel will update its state to a StringType that is the data received from the serial port. A command sent to this channel will be sent out as data through the serial port. |\n+| `binary`   | String           | Channel for sending/receiving data in Base64 format to/from the serial port. The channel will update its state to a StringType which is the string representation of a RawType that contains the data received from the serial port. A command sent to this channel must be encoded as the string representation of a RawType, e.g. `\"data:application/octet-stream;base64 MjA7MDU7Q3Jlc3RhO0lEPTI4MDE7VEVNUD0yNTtIVU09NTU7QkFUPU9LOwo=\"` |\n+| `data`     | system.rawbutton | Trigger which emits `PRESSED` events (no `RELEASED` events) whenever data is available on the serial port                                                                                                                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNTc1Ng=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDE5NDI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDowNzozNlrOHzioRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDowNzozNlrOHzioRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNjc5MA==", "bodyText": "To have the same behavior across all platforms and configurations, I'd use a static charset here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Charset charset = Charset.defaultCharset();\n          \n          \n            \n                private Charset charset = StandardCharsets.UTF_8;", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523806790", "createdAt": "2020-11-15T20:07:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.BINARY_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.STRING_CHANNEL;\n+import static org.openhab.binding.serial.internal.SerialBindingConstants.TRIGGER_CHANNEL;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Base64;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.util.Parity;\n+import org.openhab.binding.serial.internal.util.StopBits;\n+import org.openhab.core.io.transport.serial.PortInUseException;\n+import org.openhab.core.io.transport.serial.SerialPort;\n+import org.openhab.core.io.transport.serial.SerialPortEvent;\n+import org.openhab.core.io.transport.serial.SerialPortEventListener;\n+import org.openhab.core.io.transport.serial.SerialPortIdentifier;\n+import org.openhab.core.io.transport.serial.SerialPortManager;\n+import org.openhab.core.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.CommonTriggerEvents;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SerialBridgeHandler} is responsible for handling commands, which\n+ * are sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends BaseBridgeHandler implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private SerialBridgeConfiguration config = new SerialBridgeConfiguration();\n+\n+    private final SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private Charset charset = Charset.defaultCharset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDIwMDg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDoxNDozNVrOHzireQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDo0NDowNVrOHzi5Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzYwOQ==", "bodyText": "Why is the bridge status updated when the thing has been initialized?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523807609", "createdAt": "2020-11-15T20:14:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTA3NA==", "bodyText": "In fact this sets the thing status depending on the bridge status by calling bridgeStatusChanged with the current bridge status. The other option would be to duplicate the code from bridgeStatusChanged here.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523811074", "createdAt": "2020-11-15T20:44:05Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzYwOQ=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDIwMjMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDoxNTo1M1rOHzisHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODo0N1rOHzxGvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg==", "bodyText": "The BaseThingHandler sets the Thing states accordingly when the bridge status changes. Is this method necessary?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523807772", "createdAt": "2020-11-15T20:15:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        lastValue = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        final Pattern devicePattern = this.devicePattern;\n+\n+        if (devicePattern != null && devicePattern.matcher(data).matches()) {\n+            channels.forEach((channelUID, channel) -> refresh(channelUID, channel, data));\n+            this.lastValue = data;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkzNDcxNA==", "bodyText": "This is preventing the thing from going online if there is a thing level configuration error.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523934714", "createdAt": "2020-11-16T07:14:26Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        lastValue = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        final Pattern devicePattern = this.devicePattern;\n+\n+        if (devicePattern != null && devicePattern.matcher(data).matches()) {\n+            channels.forEach((channelUID, channel) -> refresh(channelUID, channel, data));\n+            this.lastValue = data;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk0Mzg4Nw==", "bodyText": "I understood that the Thing should be online when there's no configuration error and the Bridge is online.\nThis behavior can be achieved by using the framework. You can set the Thing status to ONLINE when there is no configuration error. Then, the framework takes care, that the Thing is only online when the Bridge is.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523943887", "createdAt": "2020-11-16T07:39:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        lastValue = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        final Pattern devicePattern = this.devicePattern;\n+\n+        if (devicePattern != null && devicePattern.matcher(data).matches()) {\n+            channels.forEach((channelUID, channel) -> refresh(channelUID, channel, data));\n+            this.lastValue = data;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjEyNg==", "bodyText": "It seems the framework only takes care of it if you explicitly check the bridge status and don't put the thing online if the bridge is offline. The framework allows you to set the thing online even though the bridge is offline. I'll make that change since its cleaner not overriding bridgeStatusChanged.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524002126", "createdAt": "2020-11-16T09:11:16Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        lastValue = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        final Pattern devicePattern = this.devicePattern;\n+\n+        if (devicePattern != null && devicePattern.matcher(data).matches()) {\n+            channels.forEach((channelUID, channel) -> refresh(channelUID, channel, data));\n+            this.lastValue = data;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0Mzk2NA==", "bodyText": "From my knowledge the Thing doesn't go online when the bridge is offline, although if the binding sets it explicitly to online. But I'm open for conviction.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r524043964", "createdAt": "2020-11-16T09:48:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/java/org/openhab/binding/serial/internal/handler/SerialDeviceHandler.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.serial.internal.handler;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.serial.internal.channel.ChannelConfig;\n+import org.openhab.binding.serial.internal.channel.DeviceChannel;\n+import org.openhab.binding.serial.internal.channel.DeviceChannelFactory;\n+import org.openhab.binding.serial.internal.transform.ValueTransformationProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.type.ChannelTypeUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+/**\n+ * The {@link SerialDeviceHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Mike Major - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialDeviceHandler extends BaseThingHandler {\n+\n+    private final ValueTransformationProvider valueTransformationProvider;\n+\n+    private @Nullable Pattern devicePattern;\n+\n+    private @Nullable String lastValue;\n+\n+    private final Map<ChannelUID, DeviceChannel> channels = new HashMap<>();\n+\n+    public SerialDeviceHandler(final Thing thing, final ValueTransformationProvider valueTransformationProvider) {\n+        super(thing);\n+        this.valueTransformationProvider = valueTransformationProvider;\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            final String lastValue = this.lastValue;\n+\n+            if (lastValue != null) {\n+                final DeviceChannel channel = channels.get(channelUID);\n+                if (channel != null) {\n+                    refresh(channelUID, channel, lastValue);\n+                }\n+            }\n+        } else {\n+            final DeviceChannel channel = channels.get(channelUID);\n+            if (channel != null) {\n+                final Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    final SerialBridgeHandler handler = (SerialBridgeHandler) bridge.getHandler();\n+                    if (handler != null) {\n+                        channel.mapCommand(command).ifPresent(value -> handler.writeString(value));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final SerialDeviceConfiguration config = getConfigAs(SerialDeviceConfiguration.class);\n+\n+        try {\n+            devicePattern = Pattern.compile(config.patternMatch);\n+        } catch (final PatternSyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid device pattern: \" + e.getMessage());\n+            return;\n+        }\n+\n+        for (final Channel c : getThing().getChannels()) {\n+            final ChannelTypeUID type = c.getChannelTypeUID();\n+            if (type != null) {\n+                final ChannelConfig channelConfig = c.getConfiguration().as(ChannelConfig.class);\n+                try {\n+                    final DeviceChannel deviceChannel = DeviceChannelFactory\n+                            .createDeviceChannel(valueTransformationProvider, channelConfig, type.getId());\n+                    if (deviceChannel != null) {\n+                        channels.put(c.getUID(), deviceChannel);\n+                    }\n+                } catch (final IllegalArgumentException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configuration error for channel \" + c.getUID().getId() + \": \" + e.getMessage());\n+                    return;\n+                }\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        bridgeStatusChanged(getBridgeStatus());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        channels.clear();\n+        lastValue = null;\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Handle a line of data received from the bridge\n+     *\n+     * @param data the line of data\n+     */\n+    public void handleData(final String data) {\n+        final Pattern devicePattern = this.devicePattern;\n+\n+        if (devicePattern != null && devicePattern.matcher(data).matches()) {\n+            channels.forEach((channelUID, channel) -> refresh(channelUID, channel, data));\n+            this.lastValue = data;\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(final ThingStatusInfo bridgeStatusInfo) {\n+        if (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+            return;\n+        }\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE && getThing().getStatus() == ThingStatus.UNKNOWN) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            return;\n+        }\n+\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwNzc3Mg=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDIwNDI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQyMDoxODoyMlrOHzitKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoyNDo1M1rOH09nIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwODA0MA==", "bodyText": "I think the brackets are not necessary.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t<option value=\"N\">N(one)</option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"N\">None</option>", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523808040", "createdAt": "2020-11-15T20:18:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,245 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"serial\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<bridge-type id=\"serialBridge\">\n+\t\t<label>Serial Bridge</label>\n+\t\t<description>Serial port which can send and receive data</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"string\" typeId=\"stringData\"/>\n+\t\t\t<channel id=\"binary\" typeId=\"binaryData\"/>\n+\t\t\t<channel id=\"data\" typeId=\"system.rawbutton\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"baudRate\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Baud Rate</label>\n+\t\t\t\t<description>Set the baud rate</description>\n+\t\t\t\t<default>9600</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"4800\">4800</option>\n+\t\t\t\t\t<option value=\"9600\">9600</option>\n+\t\t\t\t\t<option value=\"19200\">19200</option>\n+\t\t\t\t\t<option value=\"38400\">38400</option>\n+\t\t\t\t\t<option value=\"57600\">57600</option>\n+\t\t\t\t\t<option value=\"115200\">115200</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"dataBits\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Data Bits</label>\n+\t\t\t\t<description>Set the data bits</description>\n+\t\t\t\t<default>8</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"5\">5</option>\n+\t\t\t\t\t<option value=\"6\">6</option>\n+\t\t\t\t\t<option value=\"7\">7</option>\n+\t\t\t\t\t<option value=\"8\">8</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"parity\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Parity</label>\n+\t\t\t\t<description>Set the parity</description>\n+\t\t\t\t<default>N</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"N\">N(one)</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDk3MQ==", "bodyText": "I thought about that, too. But: Usually the settings are given as 8N1 or 7E0, only one letter. And it's probably more intuitive for less experienced users to have it with the brackets.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r523810971", "createdAt": "2020-11-15T20:42:50Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,245 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"serial\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<bridge-type id=\"serialBridge\">\n+\t\t<label>Serial Bridge</label>\n+\t\t<description>Serial port which can send and receive data</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"string\" typeId=\"stringData\"/>\n+\t\t\t<channel id=\"binary\" typeId=\"binaryData\"/>\n+\t\t\t<channel id=\"data\" typeId=\"system.rawbutton\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"baudRate\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Baud Rate</label>\n+\t\t\t\t<description>Set the baud rate</description>\n+\t\t\t\t<default>9600</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"4800\">4800</option>\n+\t\t\t\t\t<option value=\"9600\">9600</option>\n+\t\t\t\t\t<option value=\"19200\">19200</option>\n+\t\t\t\t\t<option value=\"38400\">38400</option>\n+\t\t\t\t\t<option value=\"57600\">57600</option>\n+\t\t\t\t\t<option value=\"115200\">115200</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"dataBits\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Data Bits</label>\n+\t\t\t\t<description>Set the data bits</description>\n+\t\t\t\t<default>8</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"5\">5</option>\n+\t\t\t\t\t<option value=\"6\">6</option>\n+\t\t\t\t\t<option value=\"7\">7</option>\n+\t\t\t\t\t<option value=\"8\">8</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"parity\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Parity</label>\n+\t\t\t\t<description>Set the parity</description>\n+\t\t\t\t<default>N</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"N\">N(one)</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwODA0MA=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5NjYxMA==", "bodyText": "The use of brackets was copied from the DSMR binding.  Do you want me to keep the brackets or remove them?", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r525096610", "createdAt": "2020-11-17T11:52:55Z", "author": {"login": "MikeJMajor"}, "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,245 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"serial\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<bridge-type id=\"serialBridge\">\n+\t\t<label>Serial Bridge</label>\n+\t\t<description>Serial port which can send and receive data</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"string\" typeId=\"stringData\"/>\n+\t\t\t<channel id=\"binary\" typeId=\"binaryData\"/>\n+\t\t\t<channel id=\"data\" typeId=\"system.rawbutton\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"baudRate\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Baud Rate</label>\n+\t\t\t\t<description>Set the baud rate</description>\n+\t\t\t\t<default>9600</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"4800\">4800</option>\n+\t\t\t\t\t<option value=\"9600\">9600</option>\n+\t\t\t\t\t<option value=\"19200\">19200</option>\n+\t\t\t\t\t<option value=\"38400\">38400</option>\n+\t\t\t\t\t<option value=\"57600\">57600</option>\n+\t\t\t\t\t<option value=\"115200\">115200</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"dataBits\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Data Bits</label>\n+\t\t\t\t<description>Set the data bits</description>\n+\t\t\t\t<default>8</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"5\">5</option>\n+\t\t\t\t\t<option value=\"6\">6</option>\n+\t\t\t\t\t<option value=\"7\">7</option>\n+\t\t\t\t\t<option value=\"8\">8</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"parity\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Parity</label>\n+\t\t\t\t<description>Set the parity</description>\n+\t\t\t\t<default>N</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"N\">N(one)</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwODA0MA=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI5NzQ0Mw==", "bodyText": "It's not that important. You can keep them.", "url": "https://github.com/openhab/openhab-addons/pull/8851#discussion_r525297443", "createdAt": "2020-11-17T16:24:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.serial/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,245 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"serial\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Thing Types -->\n+\t<bridge-type id=\"serialBridge\">\n+\t\t<label>Serial Bridge</label>\n+\t\t<description>Serial port which can send and receive data</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"string\" typeId=\"stringData\"/>\n+\t\t\t<channel id=\"binary\" typeId=\"binaryData\"/>\n+\t\t\t<channel id=\"data\" typeId=\"system.rawbutton\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<description>The serial port to use (e.g. Linux: /dev/ttyUSB0, Windows: COM1)</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"baudRate\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Baud Rate</label>\n+\t\t\t\t<description>Set the baud rate</description>\n+\t\t\t\t<default>9600</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"4800\">4800</option>\n+\t\t\t\t\t<option value=\"9600\">9600</option>\n+\t\t\t\t\t<option value=\"19200\">19200</option>\n+\t\t\t\t\t<option value=\"38400\">38400</option>\n+\t\t\t\t\t<option value=\"57600\">57600</option>\n+\t\t\t\t\t<option value=\"115200\">115200</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"dataBits\" type=\"integer\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Data Bits</label>\n+\t\t\t\t<description>Set the data bits</description>\n+\t\t\t\t<default>8</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"5\">5</option>\n+\t\t\t\t\t<option value=\"6\">6</option>\n+\t\t\t\t\t<option value=\"7\">7</option>\n+\t\t\t\t\t<option value=\"8\">8</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"parity\" type=\"text\">\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Parity</label>\n+\t\t\t\t<description>Set the parity</description>\n+\t\t\t\t<default>N</default>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"N\">N(one)</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwODA0MA=="}, "originalCommit": {"oid": "ced376cd67d3f5529e1317783162c5410ac0d47b"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4140, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}