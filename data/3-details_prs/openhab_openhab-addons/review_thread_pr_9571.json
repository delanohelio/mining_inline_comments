{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2Mjk0MDg1", "number": 9571, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNjoyMjozMVrOFJsL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NjoyOFrOFJ0Wzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzA1NDU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/resources/OH-INF/thing/roku.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwNjoyMjozMVrOIMH4XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNToyNjoxNlrOIMRyRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU4Mjk0MA==", "bodyText": "You have multiple channels that have the same label. This causes an issue in OH3 as the label is what is used when you auto create the items using 'create equipement from thing' feature. Each label should be short and unique.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549582940", "createdAt": "2020-12-29T06:22:31Z", "author": {"login": "Skinah"}, "path": "bundles/org.openhab.binding.roku/src/main/resources/OH-INF/thing/roku.xml", "diffHunk": "@@ -0,0 +1,192 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"roku\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Roku Player Thing -->\n+\t<thing-type id=\"roku_player\">\n+\t\t<label>Roku</label>\n+\t\t<description>\n+\t\t\tA Roku Streaming Media Player\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"activeApp\" typeId=\"activeApp\"/>\n+\t\t\t<channel id=\"button\" typeId=\"button\"/>\n+\t\t\t<channel id=\"playMode\" typeId=\"playMode\"/>\n+\t\t\t<channel id=\"timeElapsed\" typeId=\"timeElapsed\"/>\n+\t\t\t<channel id=\"timeTotal\" typeId=\"timeTotal\"/>\n+\t\t</channels>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Model Name\">unknown</property>\n+\t\t\t<property name=\"Model Number\">unknown</property>\n+\t\t\t<property name=\"Device Location\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Device Id\">unknown</property>\n+\t\t\t<property name=\"Software Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<representation-property>uuid</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Roku device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Port for the ECP Connector of the Roku device</description>\n+\t\t\t\t<default>8060</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"10\" required=\"false\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Seconds</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Roku TV Thing -->\n+\t<thing-type id=\"roku_tv\">\n+\t\t<label>Roku TV</label>\n+\t\t<description>\n+\t\t\tA Roku Streaming Media TV\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"activeApp\" typeId=\"activeApp\"/>\n+\t\t\t<channel id=\"button\" typeId=\"buttonTv\"/>\n+\t\t\t<channel id=\"playMode\" typeId=\"playMode\"/>\n+\t\t\t<channel id=\"timeElapsed\" typeId=\"timeElapsed\"/>\n+\t\t\t<channel id=\"timeTotal\" typeId=\"timeTotal\"/>\n+\t\t</channels>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Model Name\">unknown</property>\n+\t\t\t<property name=\"Model Number\">unknown</property>\n+\t\t\t<property name=\"Device Location\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Device Id\">unknown</property>\n+\t\t\t<property name=\"Software Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<representation-property>uuid</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Roku TV</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Port for the ECP Connector of the Roku TV</description>\n+\t\t\t\t<default>8060</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"10\" required=\"false\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Seconds</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"button\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Button</label>\n+\t\t<description>A Remote Button Press to Send to the Roku</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"Home\">Home</option>\n+\t\t\t\t<option value=\"Rev\">Reverse</option>\n+\t\t\t\t<option value=\"Fwd\">Forward</option>\n+\t\t\t\t<option value=\"Play\">Play</option>\n+\t\t\t\t<option value=\"Select\">Select</option>\n+\t\t\t\t<option value=\"Left\">Left</option>\n+\t\t\t\t<option value=\"Right\">Right</option>\n+\t\t\t\t<option value=\"Down\">Down</option>\n+\t\t\t\t<option value=\"Up\">Up</option>\n+\t\t\t\t<option value=\"Back\">Back</option>\n+\t\t\t\t<option value=\"InstantReplay\">Instant Replay</option>\n+\t\t\t\t<option value=\"Info\">Info</option>\n+\t\t\t\t<option value=\"Backspace\">Backspace</option>\n+\t\t\t\t<option value=\"Search\">Search</option>\n+\t\t\t\t<option value=\"Enter\">Enter</option>\n+\t\t\t\t<option value=\"FindRemote\">Find Remote</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonTv\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Button</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc0NTIyMg==", "bodyText": "You have multiple channels that have the same label. This causes an issue in OH3 as the label is what is used when you auto create the items using 'create equipment from thing' feature. Each label should be short and unique.\n\nThis was by design. One is used on standalone Roku things, the other is used on Roku TV things. The buttonTv channel adds additional button presets that only apply to TVs.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549745222", "createdAt": "2020-12-29T15:26:16Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.roku/src/main/resources/OH-INF/thing/roku.xml", "diffHunk": "@@ -0,0 +1,192 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"roku\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Roku Player Thing -->\n+\t<thing-type id=\"roku_player\">\n+\t\t<label>Roku</label>\n+\t\t<description>\n+\t\t\tA Roku Streaming Media Player\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"activeApp\" typeId=\"activeApp\"/>\n+\t\t\t<channel id=\"button\" typeId=\"button\"/>\n+\t\t\t<channel id=\"playMode\" typeId=\"playMode\"/>\n+\t\t\t<channel id=\"timeElapsed\" typeId=\"timeElapsed\"/>\n+\t\t\t<channel id=\"timeTotal\" typeId=\"timeTotal\"/>\n+\t\t</channels>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Model Name\">unknown</property>\n+\t\t\t<property name=\"Model Number\">unknown</property>\n+\t\t\t<property name=\"Device Location\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Device Id\">unknown</property>\n+\t\t\t<property name=\"Software Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<representation-property>uuid</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Roku device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Port for the ECP Connector of the Roku device</description>\n+\t\t\t\t<default>8060</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"10\" required=\"false\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Seconds</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Roku TV Thing -->\n+\t<thing-type id=\"roku_tv\">\n+\t\t<label>Roku TV</label>\n+\t\t<description>\n+\t\t\tA Roku Streaming Media TV\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"activeApp\" typeId=\"activeApp\"/>\n+\t\t\t<channel id=\"button\" typeId=\"buttonTv\"/>\n+\t\t\t<channel id=\"playMode\" typeId=\"playMode\"/>\n+\t\t\t<channel id=\"timeElapsed\" typeId=\"timeElapsed\"/>\n+\t\t\t<channel id=\"timeTotal\" typeId=\"timeTotal\"/>\n+\t\t</channels>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Model Name\">unknown</property>\n+\t\t\t<property name=\"Model Number\">unknown</property>\n+\t\t\t<property name=\"Device Location\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Device Id\">unknown</property>\n+\t\t\t<property name=\"Software Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<representation-property>uuid</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Roku TV</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Port for the ECP Connector of the Roku TV</description>\n+\t\t\t\t<default>8060</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"10\" required=\"false\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Seconds</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"button\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Button</label>\n+\t\t<description>A Remote Button Press to Send to the Roku</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"Home\">Home</option>\n+\t\t\t\t<option value=\"Rev\">Reverse</option>\n+\t\t\t\t<option value=\"Fwd\">Forward</option>\n+\t\t\t\t<option value=\"Play\">Play</option>\n+\t\t\t\t<option value=\"Select\">Select</option>\n+\t\t\t\t<option value=\"Left\">Left</option>\n+\t\t\t\t<option value=\"Right\">Right</option>\n+\t\t\t\t<option value=\"Down\">Down</option>\n+\t\t\t\t<option value=\"Up\">Up</option>\n+\t\t\t\t<option value=\"Back\">Back</option>\n+\t\t\t\t<option value=\"InstantReplay\">Instant Replay</option>\n+\t\t\t\t<option value=\"Info\">Info</option>\n+\t\t\t\t<option value=\"Backspace\">Backspace</option>\n+\t\t\t\t<option value=\"Search\">Search</option>\n+\t\t\t\t<option value=\"Enter\">Enter</option>\n+\t\t\t\t<option value=\"FindRemote\">Find Remote</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"buttonTv\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Remote Button</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU4Mjk0MA=="}, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzYzODQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMTowODoxNFrOIMM3gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMDoyNjozOFrOIMa_DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NDY0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (host != null && !host.equals(EMPTY)) {\n          \n          \n            \n                    if (!EMPTY.equals(host)) {", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549664642", "createdAt": "2020-12-29T11:08:14Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NTk0OA==", "bodyText": "This is needed for the NonNullByDefault check passing host into RokuCommunicator on line 86", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549895948", "createdAt": "2020-12-30T00:26:38Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NDY0Mg=="}, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzY0NzI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxMjo1M1rOIMM8aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxMjo1M1rOIMM8aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NTg5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (config.refresh >= 10)\n          \n          \n            \n                        refreshInterval = config.refresh;\n          \n          \n            \n                    if (config.refresh >= 10) {\n          \n          \n            \n                        refreshInterval = config.refresh;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549665899", "createdAt": "2020-12-29T11:12:53Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzY1MjkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxNTo0M1rOIMM_lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxNTo0M1rOIMM_lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NjcwOQ==", "bodyText": "It's not needed to call .toString() as that is done automatically.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Unsupported refresh command: {}\", command.toString());\n          \n          \n            \n                        logger.debug(\"Unsupported refresh command: {}\", command);\n          \n      \n    \n    \n  \n\nSame comment applies to all other occurrences.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549666709", "createdAt": "2020-12-29T11:15:43Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {\n+                        logger.debug(\"Unable to retrieve Roku media-player info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+                }\n+            };\n+            this.refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update list of apps installed on the the Roku\n+     */\n+    private void startAppListRefresh() {\n+        ScheduledFuture<?> appListJob = this.appListJob;\n+        if (appListJob == null || appListJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        List<App> appList = communicator.getAppList();\n+\n+                        List<StateOption> appListOptions = new ArrayList<>();\n+                        // Roku Home will be selected in the drop-down any time an app is not running.\n+                        appListOptions.add(new StateOption(ROKU_HOME_ID, ROKU_HOME));\n+\n+                        appList.forEach(app -> {\n+                            appListOptions.add(new StateOption(app.getId(), app.getValue()));\n+                        });\n+\n+                        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), ACTIVE_APP),\n+                                appListOptions);\n+\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku installed app-list. Exception: {}\", e.getMessage(), e);\n+                    }\n+                }\n+            };\n+            this.appListJob = scheduler.scheduleWithFixedDelay(runnable, 10, 600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+\n+        ScheduledFuture<?> appListJob = this.appListJob;\n+        if (appListJob != null) {\n+            appListJob.cancel(true);\n+            this.appListJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Unsupported refresh command: {}\", command.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzY1NjI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxNzowNVrOIMNBSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxNzowNVrOIMNBSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzE0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (device.isTv())\n          \n          \n            \n                            thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n          \n          \n            \n                        if (device.isTv()) {\n          \n          \n            \n                            thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549667147", "createdAt": "2020-12-29T11:17:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    host = value;\n+                    Matcher matchIp = IP_HOST_PATTERN.matcher(value);\n+                    if (matchIp.find()) {\n+                        host = matchIp.group(1);\n+                        port = Integer.parseInt(matchIp.group(2));\n+                    }\n+                    break;\n+                case \"usn\":\n+                    Matcher matchUid = USN_PATTERN.matcher(value);\n+                    if (matchUid.find()) {\n+                        uuid = matchUid.group(2);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        if (host == null || port == -1 || uuid == null) {\n+            logger.debug(\"Bad Format from Roku, received data was: {}\", response);\n+            return;\n+        } else {\n+            logger.debug(\"Found Roku, uuid: {} host: {}\", uuid, host);\n+        }\n+\n+        uuid = uuid.replace(\":\", \"\").toLowerCase();\n+\n+        ThingUID thingUid = new ThingUID(THING_TYPE_ROKU_PLAYER, uuid);\n+\n+        // Try to query the device using discovered host and port to get extended device info\n+        try {\n+            RokuCommunicator communicator = new RokuCommunicator(httpClient, host, port);\n+            DeviceInfo device = communicator.getDeviceInfo();\n+            label = device.getModelName() + \" \" + device.getModelNumber();\n+            if (device.isTv())\n+                thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzY1ODUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxODoxN1rOIMNCkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMDoyOTozOFrOIMbBhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzQ3NA==", "bodyText": "If the RokuHttpException happens does it make sense to continue here and add the thing to discovery results? or should that code be placed with the try-catch?", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549667474", "createdAt": "2020-12-29T11:18:17Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    host = value;\n+                    Matcher matchIp = IP_HOST_PATTERN.matcher(value);\n+                    if (matchIp.find()) {\n+                        host = matchIp.group(1);\n+                        port = Integer.parseInt(matchIp.group(2));\n+                    }\n+                    break;\n+                case \"usn\":\n+                    Matcher matchUid = USN_PATTERN.matcher(value);\n+                    if (matchUid.find()) {\n+                        uuid = matchUid.group(2);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        if (host == null || port == -1 || uuid == null) {\n+            logger.debug(\"Bad Format from Roku, received data was: {}\", response);\n+            return;\n+        } else {\n+            logger.debug(\"Found Roku, uuid: {} host: {}\", uuid, host);\n+        }\n+\n+        uuid = uuid.replace(\":\", \"\").toLowerCase();\n+\n+        ThingUID thingUid = new ThingUID(THING_TYPE_ROKU_PLAYER, uuid);\n+\n+        // Try to query the device using discovered host and port to get extended device info\n+        try {\n+            RokuCommunicator communicator = new RokuCommunicator(httpClient, host, port);\n+            DeviceInfo device = communicator.getDeviceInfo();\n+            label = device.getModelName() + \" \" + device.getModelNumber();\n+            if (device.isTv())\n+                thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(PROPERTY_UUID)\n+                .withProperty(PROPERTY_UUID, uuid).withProperty(PROPERTY_HOST_NAME, host)\n+                .withProperty(PROPERTY_PORT, port).build();\n+        this.thingDiscovered(result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NjU4MA==", "bodyText": "At this point there is enough information to create the thing. This call being caught here only enhances the result. I would like to leave it as-is just in case the call to retrieve the extended info stops working due to a device firmware update or similar issue.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549896580", "createdAt": "2020-12-30T00:29:38Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    host = value;\n+                    Matcher matchIp = IP_HOST_PATTERN.matcher(value);\n+                    if (matchIp.find()) {\n+                        host = matchIp.group(1);\n+                        port = Integer.parseInt(matchIp.group(2));\n+                    }\n+                    break;\n+                case \"usn\":\n+                    Matcher matchUid = USN_PATTERN.matcher(value);\n+                    if (matchUid.find()) {\n+                        uuid = matchUid.group(2);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        if (host == null || port == -1 || uuid == null) {\n+            logger.debug(\"Bad Format from Roku, received data was: {}\", response);\n+            return;\n+        } else {\n+            logger.debug(\"Found Roku, uuid: {} host: {}\", uuid, host);\n+        }\n+\n+        uuid = uuid.replace(\":\", \"\").toLowerCase();\n+\n+        ThingUID thingUid = new ThingUID(THING_TYPE_ROKU_PLAYER, uuid);\n+\n+        // Try to query the device using discovered host and port to get extended device info\n+        try {\n+            RokuCommunicator communicator = new RokuCommunicator(httpClient, host, port);\n+            DeviceInfo device = communicator.getDeviceInfo();\n+            label = device.getModelName() + \" \" + device.getModelNumber();\n+            if (device.isTv())\n+                thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(PROPERTY_UUID)\n+                .withProperty(PROPERTY_UUID, uuid).withProperty(PROPERTY_HOST_NAME, host)\n+                .withProperty(PROPERTY_PORT, port).build();\n+        this.thingDiscovered(result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzQ3NA=="}, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzY2MTcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMToxOTo1OVrOIMNEXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMDozMTowNVrOIMbCdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzkzNA==", "bodyText": "With quantity type it's not necessarily needed to convert. So you can pass it as it and just give it the right unit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n          \n          \n            \n                                                new QuantityType<>(Integer.parseInt(position), API_MILLISECONDS_UNIT));", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549667934", "createdAt": "2020-12-29T11:19:59Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NjgyMw==", "bodyText": "I did not think that the user needs millisecond precision in the elapsed time of the show they are watching.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549896823", "createdAt": "2020-12-30T00:31:05Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzkzNA=="}, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM2NDY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozNDowN1rOIMTQQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozNDowN1rOIMTQQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2OTI4MA==", "bodyText": "You can also put this into a method and than pass that method the scheduler with this::<method name>", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549769280", "createdAt": "2020-12-29T16:34:07Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {\n+                        logger.debug(\"Unable to retrieve Roku media-player info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+                }\n+            };\n+            this.refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update list of apps installed on the the Roku\n+     */\n+    private void startAppListRefresh() {\n+        ScheduledFuture<?> appListJob = this.appListJob;\n+        if (appListJob == null || appListJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        List<App> appList = communicator.getAppList();\n+\n+                        List<StateOption> appListOptions = new ArrayList<>();\n+                        // Roku Home will be selected in the drop-down any time an app is not running.\n+                        appListOptions.add(new StateOption(ROKU_HOME_ID, ROKU_HOME));\n+\n+                        appList.forEach(app -> {\n+                            appListOptions.add(new StateOption(app.getId(), app.getValue()));\n+                        });\n+\n+                        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), ACTIVE_APP),\n+                                appListOptions);\n+\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku installed app-list. Exception: {}\", e.getMessage(), e);\n+                    }\n+                }\n+            };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM3MTk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozNzowNlrOIMTURg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMDozMzo0NVrOIMbD0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDMxMA==", "bodyText": "By having 1 exception for all you might miss updating channels. Because if it fails on the first channel set, the other channels are not set. Also if only 1 fails on NumberFormatException should the thing go offline?", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549770310", "createdAt": "2020-12-29T16:37:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NzE3MQ==", "bodyText": "I looked at this again and removed the NumberFormatException from the catch. The code already removes non-numeric characters and checks for empty string before doing parseInt(). Catching NumberFormatException was redundant.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549897171", "createdAt": "2020-12-30T00:33:45Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDMxMA=="}, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM3NDk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/resources/OH-INF/thing/roku.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjozODoyMlrOIMTV6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMDozNToxNFrOIMbEhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDcyOA==", "bodyText": "You can also use a config reference. So you don't have to repeat the config in both things.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549770728", "createdAt": "2020-12-29T16:38:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/resources/OH-INF/thing/roku.xml", "diffHunk": "@@ -0,0 +1,192 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"roku\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Roku Player Thing -->\n+\t<thing-type id=\"roku_player\">\n+\t\t<label>Roku</label>\n+\t\t<description>\n+\t\t\tA Roku Streaming Media Player\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"activeApp\" typeId=\"activeApp\"/>\n+\t\t\t<channel id=\"button\" typeId=\"button\"/>\n+\t\t\t<channel id=\"playMode\" typeId=\"playMode\"/>\n+\t\t\t<channel id=\"timeElapsed\" typeId=\"timeElapsed\"/>\n+\t\t\t<channel id=\"timeTotal\" typeId=\"timeTotal\"/>\n+\t\t</channels>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Model Name\">unknown</property>\n+\t\t\t<property name=\"Model Number\">unknown</property>\n+\t\t\t<property name=\"Device Location\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Device Id\">unknown</property>\n+\t\t\t<property name=\"Software Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<representation-property>uuid</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Roku device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Port for the ECP Connector of the Roku device</description>\n+\t\t\t\t<default>8060</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"10\" required=\"false\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Seconds</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NzM1MQ==", "bodyText": "Changed to use a config reference. I had done this to be able to tweak the labels for standalone devices vs. TV.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549897351", "createdAt": "2020-12-30T00:35:14Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.roku/src/main/resources/OH-INF/thing/roku.xml", "diffHunk": "@@ -0,0 +1,192 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"roku\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Roku Player Thing -->\n+\t<thing-type id=\"roku_player\">\n+\t\t<label>Roku</label>\n+\t\t<description>\n+\t\t\tA Roku Streaming Media Player\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"activeApp\" typeId=\"activeApp\"/>\n+\t\t\t<channel id=\"button\" typeId=\"button\"/>\n+\t\t\t<channel id=\"playMode\" typeId=\"playMode\"/>\n+\t\t\t<channel id=\"timeElapsed\" typeId=\"timeElapsed\"/>\n+\t\t\t<channel id=\"timeTotal\" typeId=\"timeTotal\"/>\n+\t\t</channels>\n+\n+\t\t<properties>\n+\t\t\t<property name=\"Model Name\">unknown</property>\n+\t\t\t<property name=\"Model Number\">unknown</property>\n+\t\t\t<property name=\"Device Location\">unknown</property>\n+\t\t\t<property name=\"Serial Number\">unknown</property>\n+\t\t\t<property name=\"Device Id\">unknown</property>\n+\t\t\t<property name=\"Software Version\">unknown</property>\n+\t\t</properties>\n+\n+\t\t<representation-property>uuid</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Roku device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"port\" type=\"integer\" min=\"1\" max=\"65535\" required=\"true\">\n+\t\t\t\t<label>Port</label>\n+\t\t\t\t<description>Port for the ECP Connector of the Roku device</description>\n+\t\t\t\t<default>8060</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"10\" required=\"false\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Seconds</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<unitLabel>s</unitLabel>\n+\t\t\t</parameter>\n+\t\t</config-description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDcyOA=="}, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM4MTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0MTowOFrOIMTZaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0MTowOFrOIMTZaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTYyNA==", "bodyText": "If you put the DatagramSocket into a try-with-resources you can omit all the calls to close.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            DatagramSocket socket = sendDiscoveryBroacast(ni);\n          \n          \n            \n                            if (socket != null) {\n          \n          \n            \n                                scanResposesForKeywords(socket);\n          \n          \n            \n                            }\n          \n          \n            \n                            try (DatagramSocket socket = sendDiscoveryBroacast(ni)) {\n          \n          \n            \n                                if (socket != null) {\n          \n          \n            \n                                    scanResposesForKeywords(socket);\n          \n          \n            \n                                }\n          \n          \n            \n                            }", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549771624", "createdAt": "2020-12-29T16:41:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM4Mzc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0MjoyMVrOIMTa1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0MjoyMVrOIMTa1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTk5MA==", "bodyText": "Same here with try-with-resources:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Scanner scanner = new Scanner(response);\n          \n          \n            \n                    try (Scanner scanner = new Scanner(response)) {\n          \n      \n    \n    \n  \n\nand remove the call to close below.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549771990", "createdAt": "2020-12-29T16:42:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM5MTcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NTo1NVrOIMTfFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NTo1NVrOIMTfFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MzA3OA==", "bodyText": "This seems a bit overkill. Because socketTimeout will never be true. Because if it's made true the method will call return. So you can remove this variable and simply make it a while(true)) loop.", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549773078", "createdAt": "2020-12-29T16:45:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1ODM5MzEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NjoyOFrOIMTfzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjo0NjoyOFrOIMTfzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MzI2Mg==", "bodyText": "Do you need a new byte block here? or can you reuse it by putting it above the do-while loop?", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549773262", "createdAt": "2020-12-29T16:46:28Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14"}, "originalPosition": 175}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3559, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}